(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Aims = {}));
})(this, (function (exports) { 'use strict';

    const parseApproachName = name => {
      // L(eft), C(entre), R(ight), T(true North) are the possible runway designators (ARINC424)
      // If there are multiple procedures for the same type of approach, an alphanumeric suffix is added to their names (last subpattern)
      // We are a little more lenient than ARINC424 in an effort to match non-perfect navdata, so we allow dashes, spaces, or nothing before the suffix
      const match = name.trim().match(/^(ILS|LOC|RNAV|NDB|VOR|GPS) (RW)?([0-9]{1,2}[LCRT]?)([\s-]*([A-Z0-9]))?$/);
      if (!match) {
        return undefined;
      }
      return {
        type: match[1],
        runway: match[3],
        designator: match[5]
      };
    };

    /**
     *
     * @param name approach name from the nav database
     * @returns max 9 digit name in the format <approach type><runway with leading zero><option -designator><spaces if needed>
     */
    const normaliseApproachName = name => {
      const appr = parseApproachName(name);
      if (!appr) {
        return name;
      }
      const runway = Avionics.Utils.formatRunway(appr.runway);
      const suffix = appr.designator ? "".concat(runway.length > 2 ? '' : '-').concat(appr.designator) : '';
      return "".concat(appr.type.replace('RNAV', 'RNV')).concat(runway).concat(suffix);
    };

    function ownKeys$2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
          _defineProperty$2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty$2(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }

    /**
     * Allows interacting with the persistent storage
     */
    class NXDataStore {
      static get listener() {
        if (this.mListener === undefined) {
          this.mListener = RegisterViewListener('JS_LISTENER_SIMVARS', null, true);
        }
        return this.mListener;
      }

      /**
       * Reads a value from persistent storage
       * @param key The property key
       * @param defaultVal The default value if the property is not set
       */

      static get(key, defaultVal) {
        const val = GetStoredData("B77HS_".concat(key));
        // GetStoredData returns null on error, or empty string for keys that don't exist (why isn't that an error??)
        // We could use SearchStoredData, but that spams the console with every key (somebody left their debug print in)
        if (val === null || val.length === 0) {
          return defaultVal;
        }
        return val;
      }

      /**
       * Sets a value in persistent storage
       *
       * @param key The property key
       * @param val The value to assign to the property
       */
      static set(key, val) {
        SetStoredData("B77HS_".concat(key), val);
        this.listener.triggerToAllSubscribers('B77HS_NXDATASTORE_UPDATE', key, val);
      }
      static subscribe(key, callback) {
        return Coherent.on('B77HS_NXDATASTORE_UPDATE', (updatedKey, value) => {
          if (key === '*' || key === updatedKey) {
            callback(updatedKey, value);
          }
        }).clear;
      }
      static getAndSubscribe(key, callback, defaultVal) {
        callback(key, NXDataStore.get(key, defaultVal));
        return NXDataStore.subscribe(key, callback);
      }
    }
    _defineProperty$2(NXDataStore, "mListener", void 0);

    // Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
    // SPDX-License-Identifier: MIT

    let AirportClass;
    (function (AirportClass) {
      AirportClass[AirportClass["Unknown"] = 0] = "Unknown";
      AirportClass[AirportClass["Normal"] = 1] = "Normal";
      AirportClass[AirportClass["SoftUnknown"] = 2] = "SoftUnknown";
      AirportClass[AirportClass["Seaplane"] = 3] = "Seaplane";
      AirportClass[AirportClass["Heliport"] = 4] = "Heliport";
      AirportClass[AirportClass["Private"] = 5] = "Private";
    })(AirportClass || (AirportClass = {}));
    let AirportPrivateType;
    (function (AirportPrivateType) {
      AirportPrivateType[AirportPrivateType["Unknown"] = 0] = "Unknown";
      AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
      AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
      AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
    })(AirportPrivateType || (AirportPrivateType = {}));
    let AirspaceType;
    (function (AirspaceType) {
      AirspaceType[AirspaceType["None"] = 0] = "None";
      AirspaceType[AirspaceType["Center"] = 1] = "Center";
      AirspaceType[AirspaceType["ClassA"] = 2] = "ClassA";
      AirspaceType[AirspaceType["ClassB"] = 3] = "ClassB";
      AirspaceType[AirspaceType["ClassC"] = 4] = "ClassC";
      AirspaceType[AirspaceType["ClassD"] = 5] = "ClassD";
      AirspaceType[AirspaceType["ClassE"] = 6] = "ClassE";
      AirspaceType[AirspaceType["ClassF"] = 7] = "ClassF";
      AirspaceType[AirspaceType["ClassG"] = 8] = "ClassG";
      AirspaceType[AirspaceType["Tower"] = 9] = "Tower";
      AirspaceType[AirspaceType["Clearance"] = 10] = "Clearance";
      AirspaceType[AirspaceType["Ground"] = 11] = "Ground";
      AirspaceType[AirspaceType["Departure"] = 12] = "Departure";
      AirspaceType[AirspaceType["Approach"] = 13] = "Approach";
      AirspaceType[AirspaceType["MOA"] = 14] = "MOA";
      AirspaceType[AirspaceType["Restricted"] = 15] = "Restricted";
      AirspaceType[AirspaceType["Prohibited"] = 16] = "Prohibited";
      AirspaceType[AirspaceType["Warning"] = 17] = "Warning";
      AirspaceType[AirspaceType["Alert"] = 18] = "Alert";
      AirspaceType[AirspaceType["Danger"] = 19] = "Danger";
      AirspaceType[AirspaceType["NationalPark"] = 20] = "NationalPark";
      AirspaceType[AirspaceType["ModeC"] = 21] = "ModeC";
      AirspaceType[AirspaceType["Radar"] = 22] = "Radar";
      AirspaceType[AirspaceType["Training"] = 23] = "Training";
    })(AirspaceType || (AirspaceType = {}));
    let AltitudeDescriptor; // V, Alt1 is procedure alt for step-down, Alt2 is at alt for vertical path angle
    // X, not supported
    // Y, not supported
    (function (AltitudeDescriptor) {
      AltitudeDescriptor[AltitudeDescriptor["Empty"] = 0] = "Empty";
      AltitudeDescriptor[AltitudeDescriptor["At"] = 1] = "At";
      AltitudeDescriptor[AltitudeDescriptor["AtOrAbove"] = 2] = "AtOrAbove";
      AltitudeDescriptor[AltitudeDescriptor["AtOrBelow"] = 3] = "AtOrBelow";
      AltitudeDescriptor[AltitudeDescriptor["Between"] = 4] = "Between";
      AltitudeDescriptor[AltitudeDescriptor["C"] = 5] = "C";
      AltitudeDescriptor[AltitudeDescriptor["G"] = 6] = "G";
      AltitudeDescriptor[AltitudeDescriptor["H"] = 7] = "H";
      AltitudeDescriptor[AltitudeDescriptor["I"] = 8] = "I";
      AltitudeDescriptor[AltitudeDescriptor["J"] = 9] = "J";
      AltitudeDescriptor[AltitudeDescriptor["V"] = 10] = "V";
    })(AltitudeDescriptor || (AltitudeDescriptor = {}));
    let FixTypeFlags;
    (function (FixTypeFlags) {
      FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
      FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
      FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
      FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
      FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    })(FixTypeFlags || (FixTypeFlags = {}));
    let FrequencyType;

    // ARINC424 names
    (function (FrequencyType) {
      FrequencyType[FrequencyType["None"] = 0] = "None";
      FrequencyType[FrequencyType["ATIS"] = 1] = "ATIS";
      FrequencyType[FrequencyType["Multicom"] = 2] = "Multicom";
      FrequencyType[FrequencyType["Unicom"] = 3] = "Unicom";
      FrequencyType[FrequencyType["CTAF"] = 4] = "CTAF";
      FrequencyType[FrequencyType["Ground"] = 5] = "Ground";
      FrequencyType[FrequencyType["Tower"] = 6] = "Tower";
      FrequencyType[FrequencyType["Clearance"] = 7] = "Clearance";
      FrequencyType[FrequencyType["Approach"] = 8] = "Approach";
      FrequencyType[FrequencyType["Departure"] = 9] = "Departure";
      FrequencyType[FrequencyType["Center"] = 10] = "Center";
      FrequencyType[FrequencyType["FSS"] = 11] = "FSS";
      FrequencyType[FrequencyType["AWOS"] = 12] = "AWOS";
      FrequencyType[FrequencyType["ASOS"] = 13] = "ASOS";
      FrequencyType[FrequencyType["ClearancePreTaxi"] = 14] = "ClearancePreTaxi";
      FrequencyType[FrequencyType["RemoteDeliveryClearance"] = 15] = "RemoteDeliveryClearance";
    })(FrequencyType || (FrequencyType = {}));
    let LegType; // Heading to a VOR radial
    (function (LegType) {
      LegType[LegType["Unknown"] = 0] = "Unknown";
      LegType[LegType["AF"] = 1] = "AF";
      LegType[LegType["CA"] = 2] = "CA";
      LegType[LegType["CD"] = 3] = "CD";
      LegType[LegType["CF"] = 4] = "CF";
      LegType[LegType["CI"] = 5] = "CI";
      LegType[LegType["CR"] = 6] = "CR";
      LegType[LegType["DF"] = 7] = "DF";
      LegType[LegType["FA"] = 8] = "FA";
      LegType[LegType["FC"] = 9] = "FC";
      LegType[LegType["FD"] = 10] = "FD";
      LegType[LegType["FM"] = 11] = "FM";
      LegType[LegType["HA"] = 12] = "HA";
      LegType[LegType["HF"] = 13] = "HF";
      LegType[LegType["HM"] = 14] = "HM";
      LegType[LegType["IF"] = 15] = "IF";
      LegType[LegType["PI"] = 16] = "PI";
      LegType[LegType["RF"] = 17] = "RF";
      LegType[LegType["TF"] = 18] = "TF";
      LegType[LegType["VA"] = 19] = "VA";
      LegType[LegType["VD"] = 20] = "VD";
      LegType[LegType["VI"] = 21] = "VI";
      LegType[LegType["VM"] = 22] = "VM";
      LegType[LegType["VR"] = 23] = "VR";
    })(LegType || (LegType = {}));
    let NdbType; // > 200 W ?
    (function (NdbType) {
      NdbType[NdbType["CompassLocator"] = 0] = "CompassLocator";
      NdbType[NdbType["MH"] = 1] = "MH";
      NdbType[NdbType["H"] = 2] = "H";
      NdbType[NdbType["HH"] = 3] = "HH";
    })(NdbType || (NdbType = {}));
    let NearestSearchType;
    (function (NearestSearchType) {
      NearestSearchType[NearestSearchType["None"] = 0] = "None";
      NearestSearchType[NearestSearchType["Airport"] = 1] = "Airport";
      NearestSearchType[NearestSearchType["Intersection"] = 2] = "Intersection";
      NearestSearchType[NearestSearchType["Vor"] = 3] = "Vor";
      NearestSearchType[NearestSearchType["Ndb"] = 4] = "Ndb";
      NearestSearchType[NearestSearchType["Boundary"] = 5] = "Boundary";
    })(NearestSearchType || (NearestSearchType = {}));
    let RnavTypeFlags;
    (function (RnavTypeFlags) {
      RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
      RnavTypeFlags[RnavTypeFlags["Lnav"] = 1] = "Lnav";
      RnavTypeFlags[RnavTypeFlags["LnavVnav"] = 2] = "LnavVnav";
      RnavTypeFlags[RnavTypeFlags["Lp"] = 4] = "Lp";
      RnavTypeFlags[RnavTypeFlags["Lpv"] = 8] = "Lpv";
    })(RnavTypeFlags || (RnavTypeFlags = {}));
    let RouteType; // B, both
    (function (RouteType) {
      RouteType[RouteType["None"] = 0] = "None";
      RouteType[RouteType["LowLevel"] = 1] = "LowLevel";
      RouteType[RouteType["HighLevel"] = 2] = "HighLevel";
      RouteType[RouteType["All"] = 3] = "All";
    })(RouteType || (RouteType = {}));
    let RunwayDesignatorChar;
    (function (RunwayDesignatorChar) {
      RunwayDesignatorChar[RunwayDesignatorChar["L"] = 1] = "L";
      RunwayDesignatorChar[RunwayDesignatorChar["R"] = 2] = "R";
      RunwayDesignatorChar[RunwayDesignatorChar["C"] = 3] = "C";
      RunwayDesignatorChar[RunwayDesignatorChar["W"] = 4] = "W";
      RunwayDesignatorChar[RunwayDesignatorChar["A"] = 5] = "A";
      RunwayDesignatorChar[RunwayDesignatorChar["B"] = 6] = "B";
    })(RunwayDesignatorChar || (RunwayDesignatorChar = {}));
    let RunwayLighting;
    (function (RunwayLighting) {
      RunwayLighting[RunwayLighting["Unknown"] = 0] = "Unknown";
      RunwayLighting[RunwayLighting["None"] = 1] = "None";
      RunwayLighting[RunwayLighting["PartTime"] = 2] = "PartTime";
      RunwayLighting[RunwayLighting["FullTime"] = 3] = "FullTime";
      RunwayLighting[RunwayLighting["Frequency"] = 4] = "Frequency";
    })(RunwayLighting || (RunwayLighting = {}));
    let RunwaySurface;
    (function (RunwaySurface) {
      RunwaySurface[RunwaySurface["Concrete"] = 0] = "Concrete";
      RunwaySurface[RunwaySurface["Grass"] = 1] = "Grass";
      RunwaySurface[RunwaySurface["WaterFsx"] = 2] = "WaterFsx";
      RunwaySurface[RunwaySurface["GrassBumpy"] = 3] = "GrassBumpy";
      RunwaySurface[RunwaySurface["Asphalt"] = 4] = "Asphalt";
      RunwaySurface[RunwaySurface["ShortGrass"] = 5] = "ShortGrass";
      RunwaySurface[RunwaySurface["LongGrass"] = 6] = "LongGrass";
      RunwaySurface[RunwaySurface["HardTurf"] = 7] = "HardTurf";
      RunwaySurface[RunwaySurface["Snow"] = 8] = "Snow";
      RunwaySurface[RunwaySurface["Ice"] = 9] = "Ice";
      RunwaySurface[RunwaySurface["Urban"] = 10] = "Urban";
      RunwaySurface[RunwaySurface["Forest"] = 11] = "Forest";
      RunwaySurface[RunwaySurface["Dirt"] = 12] = "Dirt";
      RunwaySurface[RunwaySurface["Coral"] = 13] = "Coral";
      RunwaySurface[RunwaySurface["Gravel"] = 14] = "Gravel";
      RunwaySurface[RunwaySurface["OilTreated"] = 15] = "OilTreated";
      RunwaySurface[RunwaySurface["SteelMats"] = 16] = "SteelMats";
      RunwaySurface[RunwaySurface["Bituminous"] = 17] = "Bituminous";
      RunwaySurface[RunwaySurface["Brick"] = 18] = "Brick";
      RunwaySurface[RunwaySurface["Macadam"] = 19] = "Macadam";
      RunwaySurface[RunwaySurface["Planks"] = 20] = "Planks";
      RunwaySurface[RunwaySurface["Sand"] = 21] = "Sand";
      RunwaySurface[RunwaySurface["Shale"] = 22] = "Shale";
      RunwaySurface[RunwaySurface["Tarmac"] = 23] = "Tarmac";
      RunwaySurface[RunwaySurface["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
      RunwaySurface[RunwaySurface["Ocean"] = 26] = "Ocean";
      RunwaySurface[RunwaySurface["Water"] = 27] = "Water";
      RunwaySurface[RunwaySurface["Pond"] = 28] = "Pond";
      RunwaySurface[RunwaySurface["Lake"] = 29] = "Lake";
      RunwaySurface[RunwaySurface["River"] = 30] = "River";
      RunwaySurface[RunwaySurface["WasterWater"] = 31] = "WasterWater";
      RunwaySurface[RunwaySurface["Paint"] = 32] = "Paint";
    })(RunwaySurface || (RunwaySurface = {}));
    let TurnDirection;
    (function (TurnDirection) {
      TurnDirection[TurnDirection["Unknown"] = 0] = "Unknown";
      TurnDirection[TurnDirection["Left"] = 1] = "Left";
      TurnDirection[TurnDirection["Right"] = 2] = "Right";
      TurnDirection[TurnDirection["Either"] = 3] = "Either";
    })(TurnDirection || (TurnDirection = {}));
    let VorClass;
    (function (VorClass) {
      VorClass[VorClass["Unknown"] = 0] = "Unknown";
      VorClass[VorClass["Terminal"] = 1] = "Terminal";
      VorClass[VorClass["LowAltitude"] = 2] = "LowAltitude";
      VorClass[VorClass["HighAlttitude"] = 3] = "HighAlttitude";
      VorClass[VorClass["ILS"] = 4] = "ILS";
      VorClass[VorClass["VOT"] = 5] = "VOT";
    })(VorClass || (VorClass = {}));
    let VorType;
    (function (VorType) {
      VorType[VorType["Unknown"] = 0] = "Unknown";
      VorType[VorType["VOR"] = 1] = "VOR";
      VorType[VorType["VORDME"] = 2] = "VORDME";
      VorType[VorType["DME"] = 3] = "DME";
      VorType[VorType["TACAN"] = 4] = "TACAN";
      VorType[VorType["VORTAC"] = 5] = "VORTAC";
      VorType[VorType["ILS"] = 6] = "ILS";
      VorType[VorType["VOT"] = 7] = "VOT";
    })(VorType || (VorType = {}));

    // Copyright (c) 2021-2022 FlyByWire Simulations
    // Copyright (c) 2021-2022 Synaptic Simulations
    //
    // SPDX-License-Identifier: GPL-3.0

    const LnavConfig = {
      /* ========== PATHGEN CONFIG ========== */

      /**
       * The minimum TAS we ever compute guidables with
       */
      DEFAULT_MIN_PREDICTED_TAS: 160,
      /**
       * Coefficient applied to all transition turn radii
       */
      TURN_RADIUS_FACTOR: 1.0,
      /**
       * The number of transitions to compute after the active leg (-1: no limit, compute all transitions)
       */
      NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE: -1,
      /* ========== false INFO ========== */

      /**
       * Whether to print geometry generation / update debug info
       */
      DEBUG_GEOMETRY: false,
      /**
       * Whether to use the L:A32NX_DEBUG_TAS and L:A32NX_DEBUG_GS LVar for prediction speeds
       */
      DEBUG_USE_SPEED_LVARS: false,
      /**
       * Whether to force the drawing of course reversal (hold, proc turn) vectors at any point in the path
       */
      DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS: false,
      /**
       * Whether to print guidance debug information on the ND
       */
      DEBUG_GUIDANCE: false,
      /**
       * Whether to print guidable recomputation info
       */
      DEBUG_GUIDABLE_RECOMPUTATION: false,
      /**
       * Whether to draw path debug points and print them out
       */
      DEBUG_PREDICTED_PATH: false,
      /**
       * Whether to print SVG path generation debug info
       */
      DEBUG_PATH_DRAWING: false,
      /**
       * Whether to print FMS timing information
       */
      DEBUG_PERF: false,
      /**
       * Whether to save the flight plan to local storage (keeps flight plan over instrument reload)
       */
      DEBUG_SAVE_FPLN_LOCAL_STORAGE: false
    };

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    /**
     * Information about the current direct-to procedures in the flight plan.
     */
    class DirectTo {
      constructor() {
        _defineProperty$2(this, "waypointIsInFlightPlan", false);
        _defineProperty$2(this, "isActive", false);
        _defineProperty$2(this, "waypoint", void 0);
        _defineProperty$2(this, "planWaypointIndex", 0);
        _defineProperty$2(this, "interceptPoints", void 0);
        _defineProperty$2(this, "currentWaypointIndex", 0);
        _defineProperty$2(this, "segments", void 0);
      }
    }

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * A segment of a flight plan.
     */
    class FlightPlanSegment {
      /**
      * Creates a new FlightPlanSegment.
      * @param type The type of the flight plan segment.
      * @param offset The offset within the original flight plan that
      * the segment starts at.
      * @param waypoints The waypoints in the flight plan segment.
      */
      constructor(type, offset, waypoints) {
        this.type = type;
        this.offset = offset;
        this.waypoints = waypoints;
        this.type = type;
        this.offset = offset;
        this.waypoints = waypoints;
      }

      /** An empty flight plan segment. */
    }

    /** Types of flight plan segments. */
    _defineProperty$2(FlightPlanSegment, "Empty", new FlightPlanSegment(-1, -1, []));
    let SegmentType;
    (function (SegmentType) {
      SegmentType[SegmentType["Origin"] = 0] = "Origin";
      SegmentType[SegmentType["Departure"] = 1] = "Departure";
      SegmentType[SegmentType["Enroute"] = 2] = "Enroute";
      SegmentType[SegmentType["Arrival"] = 3] = "Arrival";
      SegmentType[SegmentType["Approach"] = 4] = "Approach";
      SegmentType[SegmentType["Missed"] = 5] = "Missed";
      SegmentType[SegmentType["Destination"] = 6] = "Destination";
    })(SegmentType || (SegmentType = {}));

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    /**
     * Methods for interacting with the FS9GPS subsystem.
     */
    class GPS {
      /**
      * Clears the FS9GPS flight plan.
      */
      static async clearPlan() {
        const totalGpsWaypoints = SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointsNumber', 'number');
        for (let i = 0; i < totalGpsWaypoints; i++) {
          // Always remove waypoint 0 here, which shifts the rest of the waypoints down one
          GPS.deleteWaypoint(0).catch(console.error);
        }
      }

      /**
      * Adds a waypoint to the FS9GPS flight plan by ICAO designation.
      * @param icao The MSFS ICAO to add to the flight plan.
      * @param index The index of the waypoint to add in the flight plan.
      */
      static async addIcaoWaypoint(icao, index) {
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointICAO', 'string', icao).catch(console.error);
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanAddWaypoint', 'number', index).catch(console.error);
      }

      /**
      * Adds a user waypoint to the FS9GPS flight plan.
      * @param lat The latitude of the user waypoint.
      * @param lon The longitude of the user waypoint.
      * @param index The index of the waypoint to add in the flight plan.
      * @param ident The ident of the waypoint.
      */
      static async addUserWaypoint(lat, lon, index, ident) {
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointLatitude', 'degrees', lat).catch(console.error);
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointLongitude', 'degrees', lon).catch(console.error);
        if (ident) {
          await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointIdent', 'string', ident).catch(console.error);
        }
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanAddWaypoint', 'number', index).catch(console.error);
      }

      /**
      * Deletes a waypoint from the FS9GPS flight plan.
      * @param index The index of the waypoint in the flight plan to delete.
      */
      static async deleteWaypoint(index) {
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanDeleteWaypoint', 'number', index).catch(console.error);
      }

      /**
      * Sets the active FS9GPS waypoint.
      * @param {Number} index The index of the waypoint to set active.
      */
      static async setActiveWaypoint(index) {
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanActiveWaypoint', 'number', index).catch(console.error);
      }

      /**
      * Gets the active FS9GPS waypoint.
      */
      static getActiveWaypoint() {
        return SimVar.GetSimVarValue('C:fs9gps:FlightPlanActiveWaypoint', 'number');
      }

      /**
      * Logs the current FS9GPS flight plan.
      */
      static async logCurrentPlan() {
        const waypointIdents = [];
        const totalGpsWaypoints = SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointsNumber', 'number');
        for (let i = 0; i < totalGpsWaypoints; i++) {
          SimVar.SetSimVarValue('C:fs9gps:FlightPlanWaypointIndex', 'number', i);
          waypointIdents.push(SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointIdent', 'string'));
        }
        console.log("GPS Plan: ".concat(waypointIdents.join(' ')));
      }
    }

    //  Copyright (c) 2021 FlyByWire Simulations
    //  SPDX-License-Identifier: GPL-3.0

    let HoldType;
    (function (HoldType) {
      HoldType[HoldType["Computed"] = 0] = "Computed";
      HoldType[HoldType["Database"] = 1] = "Database";
      HoldType[HoldType["Pilot"] = 2] = "Pilot";
    })(HoldType || (HoldType = {}));

    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }

    var DEFAULT_CONFIG = {
      // minimum relative difference between two compared values,
      // used by all comparison functions
      epsilon: 1e-12,
      // type of default matrix output. Choose 'matrix' (default) or 'array'
      matrix: 'Matrix',
      // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
      number: 'number',
      // number of significant digits in BigNumbers
      precision: 64,
      // predictable output type of functions. When true, output type depends only
      // on the input types. When false (default), output type can vary depending
      // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
      // predictable is false, and returns `NaN` when true.
      predictable: false,
      // random seed for seeded pseudo random number generation
      // null = randomly seed
      randomSeed: null
    };

    // type checks for all known types
    //
    // note that:
    //
    // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
    //   instanceof cannot be used because that would not allow to pass data from
    //   one instance of math.js to another since each has it's own instance of Unit.
    // - check the `isUnit` property via the constructor, so there will be no
    //   matches for "fake" instances like plain objects with a property `isUnit`.
    //   That is important for security reasons.
    // - It must not be possible to override the type checks used internally,
    //   for security reasons, so these functions are not exposed in the expression
    //   parser.
    function isNumber(x) {
      return typeof x === 'number';
    }
    function isBigNumber(x) {
      if (!x || typeof x !== 'object' || typeof x.constructor !== 'function') {
        return false;
      }
      if (x.isBigNumber === true && typeof x.constructor.prototype === 'object' && x.constructor.prototype.isBigNumber === true) {
        return true;
      }
      if (typeof x.constructor.isDecimal === 'function' && x.constructor.isDecimal(x) === true) {
        return true;
      }
      return false;
    }
    function isComplex(x) {
      return x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true || false;
    }
    function isFraction(x) {
      return x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true || false;
    }
    function isUnit(x) {
      return x && x.constructor.prototype.isUnit === true || false;
    }
    function isString(x) {
      return typeof x === 'string';
    }
    var isArray = Array.isArray;
    function isMatrix(x) {
      return x && x.constructor.prototype.isMatrix === true || false;
    }
    /**
     * Test whether a value is a collection: an Array or Matrix
     * @param {*} x
     * @returns {boolean} isCollection
     */

    function isCollection(x) {
      return Array.isArray(x) || isMatrix(x);
    }
    function isDenseMatrix(x) {
      return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
    }
    function isSparseMatrix(x) {
      return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
    }
    function isRange(x) {
      return x && x.constructor.prototype.isRange === true || false;
    }
    function isIndex(x) {
      return x && x.constructor.prototype.isIndex === true || false;
    }
    function isBoolean(x) {
      return typeof x === 'boolean';
    }
    function isResultSet(x) {
      return x && x.constructor.prototype.isResultSet === true || false;
    }
    function isHelp(x) {
      return x && x.constructor.prototype.isHelp === true || false;
    }
    function isFunction(x) {
      return typeof x === 'function';
    }
    function isDate(x) {
      return x instanceof Date;
    }
    function isRegExp(x) {
      return x instanceof RegExp;
    }
    function isObject(x) {
      return !!(x && typeof x === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));
    }
    function isNull(x) {
      return x === null;
    }
    function isUndefined(x) {
      return x === undefined;
    }
    function isAccessorNode(x) {
      return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isArrayNode(x) {
      return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isAssignmentNode(x) {
      return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isBlockNode(x) {
      return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isConditionalNode(x) {
      return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isConstantNode(x) {
      return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isFunctionAssignmentNode(x) {
      return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isFunctionNode(x) {
      return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isIndexNode(x) {
      return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isNode(x) {
      return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isObjectNode(x) {
      return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isOperatorNode(x) {
      return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isParenthesisNode(x) {
      return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isRangeNode(x) {
      return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isSymbolNode(x) {
      return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
    }
    function isChain(x) {
      return x && x.constructor.prototype.isChain === true || false;
    }
    function typeOf(x) {
      var t = typeof x;
      if (t === 'object') {
        // JavaScript types
        if (x === null) return 'null';
        if (Array.isArray(x)) return 'Array';
        if (x instanceof Date) return 'Date';
        if (x instanceof RegExp) return 'RegExp'; // math.js types

        if (isBigNumber(x)) return 'BigNumber';
        if (isComplex(x)) return 'Complex';
        if (isFraction(x)) return 'Fraction';
        if (isMatrix(x)) return 'Matrix';
        if (isUnit(x)) return 'Unit';
        if (isIndex(x)) return 'Index';
        if (isRange(x)) return 'Range';
        if (isResultSet(x)) return 'ResultSet';
        if (isNode(x)) return x.type;
        if (isChain(x)) return 'Chain';
        if (isHelp(x)) return 'Help';
        return 'Object';
      }
      if (t === 'function') return 'Function';
      return t; // can be 'string', 'number', 'boolean', ...
    }

    /**
     * Clone an object
     *
     *     clone(x)
     *
     * Can clone any primitive type, array, and object.
     * If x has a function clone, this function will be invoked to clone the object.
     *
     * @param {*} x
     * @return {*} clone
     */

    function clone$1(x) {
      var type = typeof x; // immutable primitive types

      if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {
        return x;
      } // use clone function of the object when available

      if (typeof x.clone === 'function') {
        return x.clone();
      } // array

      if (Array.isArray(x)) {
        return x.map(function (value) {
          return clone$1(value);
        });
      }
      if (x instanceof Date) return new Date(x.valueOf());
      if (isBigNumber(x)) return x; // bignumbers are immutable

      if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp
      // object

      return mapObject(x, clone$1);
    }
    /**
     * Apply map to all properties of an object
     * @param {Object} object
     * @param {function} callback
     * @return {Object} Returns a copy of the object with mapped properties
     */

    function mapObject(object, callback) {
      var clone = {};
      for (var key in object) {
        if (hasOwnProperty(object, key)) {
          clone[key] = callback(object[key]);
        }
      }
      return clone;
    }
    /**
     * Extend object a with the properties of object b
     * @param {Object} a
     * @param {Object} b
     * @return {Object} a
     */

    function extend(a, b) {
      for (var prop in b) {
        if (hasOwnProperty(b, prop)) {
          a[prop] = b[prop];
        }
      }
      return a;
    }
    /**
     * Deep test equality of all fields in two pairs of arrays or objects.
     * Compares values and functions strictly (ie. 2 is not the same as '2').
     * @param {Array | Object} a
     * @param {Array | Object} b
     * @returns {boolean}
     */

    function deepStrictEqual(a, b) {
      var prop, i, len;
      if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (i = 0, len = a.length; i < len; i++) {
          if (!deepStrictEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      } else if (typeof a === 'function') {
        return a === b;
      } else if (a instanceof Object) {
        if (Array.isArray(b) || !(b instanceof Object)) {
          return false;
        }
        for (prop in a) {
          // noinspection JSUnfilteredForInLoop
          if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
            return false;
          }
        }
        for (prop in b) {
          // noinspection JSUnfilteredForInLoop
          if (!(prop in a)) {
            return false;
          }
        }
        return true;
      } else {
        return a === b;
      }
    }
    /**
     * A safe hasOwnProperty
     * @param {Object} object
     * @param {string} property
     */

    function hasOwnProperty(object, property) {
      return object && Object.hasOwnProperty.call(object, property);
    }
    /**
     * Shallow version of pick, creating an object composed of the picked object properties
     * but not for nested properties
     * @param {Object} object
     * @param {string[]} properties
     * @return {Object}
     */

    function pickShallow(object, properties) {
      var copy = {};
      for (var i = 0; i < properties.length; i++) {
        var key = properties[i];
        var value = object[key];
        if (value !== undefined) {
          copy[key] = value;
        }
      }
      return copy;
    }

    var MATRIX_OPTIONS = ['Matrix', 'Array']; // valid values for option matrix

    var NUMBER_OPTIONS = ['number', 'BigNumber', 'Fraction']; // valid values for option number

    var config$1 = function config(options) {
      if (options) {
        throw new Error('The global config is readonly. \n' + 'Please create a mathjs instance if you want to change the default configuration. \n' + 'Example:\n' + '\n' + '  import { create, all } from \'mathjs\';\n' + '  const mathjs = create(all);\n' + '  mathjs.config({ number: \'BigNumber\' });\n');
      }
      return Object.freeze(DEFAULT_CONFIG);
    };
    _extends(config$1, DEFAULT_CONFIG, {
      MATRIX_OPTIONS,
      NUMBER_OPTIONS
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var typedFunctionExports = {};
    var typedFunction$1 = {
      get exports(){ return typedFunctionExports; },
      set exports(v){ typedFunctionExports = v; },
    };

    /**
     * typed-function
     *
     * Type checking for JavaScript functions
     *
     * https://github.com/josdejong/typed-function
     */
    (function (module, exports) {

      (function (root, factory) {
        {
          // OldNode. Does not work with strict CommonJS, but
          // only CommonJS-like environments that support module.exports,
          // like OldNode.
          module.exports = factory();
        }
      })(commonjsGlobal, function () {
        function ok() {
          return true;
        }
        function notOk() {
          return false;
        }
        function undef() {
          return undefined;
        }

        /**
         * @typedef {{
         *   params: Param[],
         *   fn: function
         * }} Signature
         *
         * @typedef {{
         *   types: Type[],
         *   restParam: boolean
         * }} Param
         *
         * @typedef {{
         *   name: string,
         *   typeIndex: number,
         *   test: function,
         *   conversion?: ConversionDef,
         *   conversionIndex: number,
         * }} Type
         *
         * @typedef {{
         *   from: string,
         *   to: string,
         *   convert: function (*) : *
         * }} ConversionDef
         *
         * @typedef {{
         *   name: string,
         *   test: function(*) : boolean
         * }} TypeDef
         */

        // create a new instance of typed-function
        function create() {
          // data type tests
          var _types = [{
            name: 'number',
            test: function (x) {
              return typeof x === 'number';
            }
          }, {
            name: 'string',
            test: function (x) {
              return typeof x === 'string';
            }
          }, {
            name: 'boolean',
            test: function (x) {
              return typeof x === 'boolean';
            }
          }, {
            name: 'Function',
            test: function (x) {
              return typeof x === 'function';
            }
          }, {
            name: 'Array',
            test: Array.isArray
          }, {
            name: 'Date',
            test: function (x) {
              return x instanceof Date;
            }
          }, {
            name: 'RegExp',
            test: function (x) {
              return x instanceof RegExp;
            }
          }, {
            name: 'Object',
            test: function (x) {
              return typeof x === 'object' && x !== null && x.constructor === Object;
            }
          }, {
            name: 'null',
            test: function (x) {
              return x === null;
            }
          }, {
            name: 'undefined',
            test: function (x) {
              return x === undefined;
            }
          }];
          var anyType = {
            name: 'any',
            test: ok
          };

          // types which need to be ignored
          var _ignore = [];

          // type conversions
          var _conversions = [];

          // This is a temporary object, will be replaced with a typed function at the end
          var typed = {
            types: _types,
            conversions: _conversions,
            ignore: _ignore
          };

          /**
           * Find the test function for a type
           * @param {String} typeName
           * @return {TypeDef} Returns the type definition when found,
           *                    Throws a TypeError otherwise
           */
          function findTypeByName(typeName) {
            var entry = findInArray(typed.types, function (entry) {
              return entry.name === typeName;
            });
            if (entry) {
              return entry;
            }
            if (typeName === 'any') {
              // special baked-in case 'any'
              return anyType;
            }
            var hint = findInArray(typed.types, function (entry) {
              return entry.name.toLowerCase() === typeName.toLowerCase();
            });
            throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ''));
          }

          /**
           * Find the index of a type definition. Handles special case 'any'
           * @param {TypeDef} type
           * @return {number}
           */
          function findTypeIndex(type) {
            if (type === anyType) {
              return 999;
            }
            return typed.types.indexOf(type);
          }

          /**
           * Find a type that matches a value.
           * @param {*} value
           * @return {string} Returns the name of the first type for which
           *                  the type test matches the value.
           */
          function findTypeName(value) {
            var entry = findInArray(typed.types, function (entry) {
              return entry.test(value);
            });
            if (entry) {
              return entry.name;
            }
            throw new TypeError('Value has unknown type. Value: ' + value);
          }

          /**
           * Find a specific signature from a (composed) typed function, for example:
           *
           *   typed.find(fn, ['number', 'string'])
           *   typed.find(fn, 'number, string')
           *
           * Function find only only works for exact matches.
           *
           * @param {Function} fn                   A typed-function
           * @param {string | string[]} signature   Signature to be found, can be
           *                                        an array or a comma separated string.
           * @return {Function}                     Returns the matching signature, or
           *                                        throws an error when no signature
           *                                        is found.
           */
          function find(fn, signature) {
            if (!fn.signatures) {
              throw new TypeError('Function is no typed-function');
            }

            // normalize input
            var arr;
            if (typeof signature === 'string') {
              arr = signature.split(',');
              for (var i = 0; i < arr.length; i++) {
                arr[i] = arr[i].trim();
              }
            } else if (Array.isArray(signature)) {
              arr = signature;
            } else {
              throw new TypeError('String array or a comma separated string expected');
            }
            var str = arr.join(',');

            // find an exact match
            var match = fn.signatures[str];
            if (match) {
              return match;
            }

            // TODO: extend find to match non-exact signatures

            throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
          }

          /**
           * Convert a given value to another data type.
           * @param {*} value
           * @param {string} type
           */
          function convert(value, type) {
            var from = findTypeName(value);

            // check conversion is needed
            if (type === from) {
              return value;
            }
            for (var i = 0; i < typed.conversions.length; i++) {
              var conversion = typed.conversions[i];
              if (conversion.from === from && conversion.to === type) {
                return conversion.convert(value);
              }
            }
            throw new Error('Cannot convert from ' + from + ' to ' + type);
          }

          /**
           * Stringify parameters in a normalized way
           * @param {Param[]} params
           * @return {string}
           */
          function stringifyParams(params) {
            return params.map(function (param) {
              var typeNames = param.types.map(getTypeName);
              return (param.restParam ? '...' : '') + typeNames.join('|');
            }).join(',');
          }

          /**
           * Parse a parameter, like "...number | boolean"
           * @param {string} param
           * @param {ConversionDef[]} conversions
           * @return {Param} param
           */
          function parseParam(param, conversions) {
            var restParam = param.indexOf('...') === 0;
            var types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';
            var typeNames = types.split('|').map(trim).filter(notEmpty).filter(notIgnore);
            var matchingConversions = filterConversions(conversions, typeNames);
            var exactTypes = typeNames.map(function (typeName) {
              var type = findTypeByName(typeName);
              return {
                name: typeName,
                typeIndex: findTypeIndex(type),
                test: type.test,
                conversion: null,
                conversionIndex: -1
              };
            });
            var convertibleTypes = matchingConversions.map(function (conversion) {
              var type = findTypeByName(conversion.from);
              return {
                name: conversion.from,
                typeIndex: findTypeIndex(type),
                test: type.test,
                conversion: conversion,
                conversionIndex: conversions.indexOf(conversion)
              };
            });
            return {
              types: exactTypes.concat(convertibleTypes),
              restParam: restParam
            };
          }

          /**
           * Parse a signature with comma separated parameters,
           * like "number | boolean, ...string"
           * @param {string} signature
           * @param {function} fn
           * @param {ConversionDef[]} conversions
           * @return {Signature | null} signature
           */
          function parseSignature(signature, fn, conversions) {
            var params = [];
            if (signature.trim() !== '') {
              params = signature.split(',').map(trim).map(function (param, index, array) {
                var parsedParam = parseParam(param, conversions);
                if (parsedParam.restParam && index !== array.length - 1) {
                  throw new SyntaxError('Unexpected rest parameter "' + param + '": ' + 'only allowed for the last parameter');
                }
                return parsedParam;
              });
            }
            if (params.some(isInvalidParam)) {
              // invalid signature: at least one parameter has no types
              // (they may have been filtered)
              return null;
            }
            return {
              params: params,
              fn: fn
            };
          }

          /**
           * Test whether a set of params contains a restParam
           * @param {Param[]} params
           * @return {boolean} Returns true when the last parameter is a restParam
           */
          function hasRestParam(params) {
            var param = last(params);
            return param ? param.restParam : false;
          }

          /**
           * Test whether a parameter contains conversions
           * @param {Param} param
           * @return {boolean} Returns true when at least one of the parameters
           *                   contains a conversion.
           */
          function hasConversions(param) {
            return param.types.some(function (type) {
              return type.conversion != null;
            });
          }

          /**
           * Create a type test for a single parameter, which can have one or multiple
           * types.
           * @param {Param} param
           * @return {function(x: *) : boolean} Returns a test function
           */
          function compileTest(param) {
            if (!param || param.types.length === 0) {
              // nothing to do
              return ok;
            } else if (param.types.length === 1) {
              return findTypeByName(param.types[0].name).test;
            } else if (param.types.length === 2) {
              var test0 = findTypeByName(param.types[0].name).test;
              var test1 = findTypeByName(param.types[1].name).test;
              return function or(x) {
                return test0(x) || test1(x);
              };
            } else {
              // param.types.length > 2
              var tests = param.types.map(function (type) {
                return findTypeByName(type.name).test;
              });
              return function or(x) {
                for (var i = 0; i < tests.length; i++) {
                  if (tests[i](x)) {
                    return true;
                  }
                }
                return false;
              };
            }
          }

          /**
           * Create a test for all parameters of a signature
           * @param {Param[]} params
           * @return {function(args: Array<*>) : boolean}
           */
          function compileTests(params) {
            var tests, test0, test1;
            if (hasRestParam(params)) {
              // variable arguments like '...number'
              tests = initial(params).map(compileTest);
              var varIndex = tests.length;
              var lastTest = compileTest(last(params));
              var testRestParam = function (args) {
                for (var i = varIndex; i < args.length; i++) {
                  if (!lastTest(args[i])) {
                    return false;
                  }
                }
                return true;
              };
              return function testArgs(args) {
                for (var i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return testRestParam(args) && args.length >= varIndex + 1;
              };
            } else {
              // no variable arguments
              if (params.length === 0) {
                return function testArgs(args) {
                  return args.length === 0;
                };
              } else if (params.length === 1) {
                test0 = compileTest(params[0]);
                return function testArgs(args) {
                  return test0(args[0]) && args.length === 1;
                };
              } else if (params.length === 2) {
                test0 = compileTest(params[0]);
                test1 = compileTest(params[1]);
                return function testArgs(args) {
                  return test0(args[0]) && test1(args[1]) && args.length === 2;
                };
              } else {
                // arguments.length > 2
                tests = params.map(compileTest);
                return function testArgs(args) {
                  for (var i = 0; i < tests.length; i++) {
                    if (!tests[i](args[i])) {
                      return false;
                    }
                  }
                  return args.length === tests.length;
                };
              }
            }
          }

          /**
           * Find the parameter at a specific index of a signature.
           * Handles rest parameters.
           * @param {Signature} signature
           * @param {number} index
           * @return {Param | null} Returns the matching parameter when found,
           *                        null otherwise.
           */
          function getParamAtIndex(signature, index) {
            return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;
          }

          /**
           * Get all type names of a parameter
           * @param {Signature} signature
           * @param {number} index
           * @param {boolean} excludeConversions
           * @return {string[]} Returns an array with type names
           */
          function getExpectedTypeNames(signature, index, excludeConversions) {
            var param = getParamAtIndex(signature, index);
            var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
            return types.map(getTypeName);
          }

          /**
           * Returns the name of a type
           * @param {Type} type
           * @return {string} Returns the type name
           */
          function getTypeName(type) {
            return type.name;
          }

          /**
           * Test whether a type is an exact type or conversion
           * @param {Type} type
           * @return {boolean} Returns true when
           */
          function isExactType(type) {
            return type.conversion === null || type.conversion === undefined;
          }

          /**
           * Helper function for creating error messages: create an array with
           * all available types on a specific argument index.
           * @param {Signature[]} signatures
           * @param {number} index
           * @return {string[]} Returns an array with available types
           */
          function mergeExpectedParams(signatures, index) {
            var typeNames = uniq(flatMap(signatures, function (signature) {
              return getExpectedTypeNames(signature, index, false);
            }));
            return typeNames.indexOf('any') !== -1 ? ['any'] : typeNames;
          }

          /**
           * Create
           * @param {string} name             The name of the function
           * @param {array.<*>} args          The actual arguments passed to the function
           * @param {Signature[]} signatures  A list with available signatures
           * @return {TypeError} Returns a type error with additional data
           *                     attached to it in the property `data`
           */
          function createError(name, args, signatures) {
            var err, expected;
            var _name = name || 'unnamed';

            // test for wrong type at some index
            var matchingSignatures = signatures;
            var index;
            for (index = 0; index < args.length; index++) {
              var nextMatchingDefs = matchingSignatures.filter(function (signature) {
                var test = compileTest(getParamAtIndex(signature, index));
                return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);
              });
              if (nextMatchingDefs.length === 0) {
                // no matching signatures anymore, throw error "wrong type"
                expected = mergeExpectedParams(matchingSignatures, index);
                if (expected.length > 0) {
                  var actualType = findTypeName(args[index]);
                  err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')');
                  err.data = {
                    category: 'wrongType',
                    fn: _name,
                    index: index,
                    actual: actualType,
                    expected: expected
                  };
                  return err;
                }
              } else {
                matchingSignatures = nextMatchingDefs;
              }
            }

            // test for too few arguments
            var lengths = matchingSignatures.map(function (signature) {
              return hasRestParam(signature.params) ? Infinity : signature.params.length;
            });
            if (args.length < Math.min.apply(null, lengths)) {
              expected = mergeExpectedParams(matchingSignatures, index);
              err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');
              err.data = {
                category: 'tooFewArgs',
                fn: _name,
                index: args.length,
                expected: expected
              };
              return err;
            }

            // test for too many arguments
            var maxLength = Math.max.apply(null, lengths);
            if (args.length > maxLength) {
              err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');
              err.data = {
                category: 'tooManyArgs',
                fn: _name,
                index: args.length,
                expectedLength: maxLength
              };
              return err;
            }
            err = new TypeError('Arguments of type "' + args.join(', ') + '" do not match any of the defined signatures of function ' + _name + '.');
            err.data = {
              category: 'mismatch',
              actual: args.map(findTypeName)
            };
            return err;
          }

          /**
           * Find the lowest index of all exact types of a parameter (no conversions)
           * @param {Param} param
           * @return {number} Returns the index of the lowest type in typed.types
           */
          function getLowestTypeIndex(param) {
            var min = 999;
            for (var i = 0; i < param.types.length; i++) {
              if (isExactType(param.types[i])) {
                min = Math.min(min, param.types[i].typeIndex);
              }
            }
            return min;
          }

          /**
           * Find the lowest index of the conversion of all types of the parameter
           * having a conversion
           * @param {Param} param
           * @return {number} Returns the lowest index of the conversions of this type
           */
          function getLowestConversionIndex(param) {
            var min = 999;
            for (var i = 0; i < param.types.length; i++) {
              if (!isExactType(param.types[i])) {
                min = Math.min(min, param.types[i].conversionIndex);
              }
            }
            return min;
          }

          /**
           * Compare two params
           * @param {Param} param1
           * @param {Param} param2
           * @return {number} returns a negative number when param1 must get a lower
           *                  index than param2, a positive number when the opposite,
           *                  or zero when both are equal
           */
          function compareParams(param1, param2) {
            var c;

            // compare having a rest parameter or not
            c = param1.restParam - param2.restParam;
            if (c !== 0) {
              return c;
            }

            // compare having conversions or not
            c = hasConversions(param1) - hasConversions(param2);
            if (c !== 0) {
              return c;
            }

            // compare the index of the types
            c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
            if (c !== 0) {
              return c;
            }

            // compare the index of any conversion
            return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
          }

          /**
           * Compare two signatures
           * @param {Signature} signature1
           * @param {Signature} signature2
           * @return {number} returns a negative number when param1 must get a lower
           *                  index than param2, a positive number when the opposite,
           *                  or zero when both are equal
           */
          function compareSignatures(signature1, signature2) {
            var len = Math.min(signature1.params.length, signature2.params.length);
            var i;
            var c;

            // compare whether the params have conversions at all or not
            c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
            if (c !== 0) {
              return c;
            }

            // next compare whether the params have conversions one by one
            for (i = 0; i < len; i++) {
              c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
              if (c !== 0) {
                return c;
              }
            }

            // compare the types of the params one by one
            for (i = 0; i < len; i++) {
              c = compareParams(signature1.params[i], signature2.params[i]);
              if (c !== 0) {
                return c;
              }
            }

            // compare the number of params
            return signature1.params.length - signature2.params.length;
          }

          /**
           * Get params containing all types that can be converted to the defined types.
           *
           * @param {ConversionDef[]} conversions
           * @param {string[]} typeNames
           * @return {ConversionDef[]} Returns the conversions that are available
           *                        for every type (if any)
           */
          function filterConversions(conversions, typeNames) {
            var matches = {};
            conversions.forEach(function (conversion) {
              if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
                matches[conversion.from] = conversion;
              }
            });
            return Object.keys(matches).map(function (from) {
              return matches[from];
            });
          }

          /**
           * Preprocess arguments before calling the original function:
           * - if needed convert the parameters
           * - in case of rest parameters, move the rest parameters into an Array
           * @param {Param[]} params
           * @param {function} fn
           * @return {function} Returns a wrapped function
           */
          function compileArgsPreprocessing(params, fn) {
            var fnConvert = fn;

            // TODO: can we make this wrapper function smarter/simpler?

            if (params.some(hasConversions)) {
              var restParam = hasRestParam(params);
              var compiledConversions = params.map(compileArgConversion);
              fnConvert = function convertArgs() {
                var args = [];
                var last = restParam ? arguments.length - 1 : arguments.length;
                for (var i = 0; i < last; i++) {
                  args[i] = compiledConversions[i](arguments[i]);
                }
                if (restParam) {
                  args[last] = arguments[last].map(compiledConversions[last]);
                }
                return fn.apply(this, args);
              };
            }
            var fnPreprocess = fnConvert;
            if (hasRestParam(params)) {
              var offset = params.length - 1;
              fnPreprocess = function preprocessRestParams() {
                return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
              };
            }
            return fnPreprocess;
          }

          /**
           * Compile conversion for a parameter to the right type
           * @param {Param} param
           * @return {function} Returns the wrapped function that will convert arguments
           *
           */
          function compileArgConversion(param) {
            var test0, test1, conversion0, conversion1;
            var tests = [];
            var conversions = [];
            param.types.forEach(function (type) {
              if (type.conversion) {
                tests.push(findTypeByName(type.conversion.from).test);
                conversions.push(type.conversion.convert);
              }
            });

            // create optimized conversion functions depending on the number of conversions
            switch (conversions.length) {
              case 0:
                return function convertArg(arg) {
                  return arg;
                };
              case 1:
                test0 = tests[0];
                conversion0 = conversions[0];
                return function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  return arg;
                };
              case 2:
                test0 = tests[0];
                test1 = tests[1];
                conversion0 = conversions[0];
                conversion1 = conversions[1];
                return function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  if (test1(arg)) {
                    return conversion1(arg);
                  }
                  return arg;
                };
              default:
                return function convertArg(arg) {
                  for (var i = 0; i < conversions.length; i++) {
                    if (tests[i](arg)) {
                      return conversions[i](arg);
                    }
                  }
                  return arg;
                };
            }
          }

          /**
           * Convert an array with signatures into a map with signatures,
           * where signatures with union types are split into separate signatures
           *
           * Throws an error when there are conflicting types
           *
           * @param {Signature[]} signatures
           * @return {Object.<string, function>}  Returns a map with signatures
           *                                      as key and the original function
           *                                      of this signature as value.
           */
          function createSignaturesMap(signatures) {
            var signaturesMap = {};
            signatures.forEach(function (signature) {
              if (!signature.params.some(hasConversions)) {
                splitParams(signature.params, true).forEach(function (params) {
                  signaturesMap[stringifyParams(params)] = signature.fn;
                });
              }
            });
            return signaturesMap;
          }

          /**
           * Split params with union types in to separate params.
           *
           * For example:
           *
           *     splitParams([['Array', 'Object'], ['string', 'RegExp'])
           *     // returns:
           *     // [
           *     //   ['Array', 'string'],
           *     //   ['Array', 'RegExp'],
           *     //   ['Object', 'string'],
           *     //   ['Object', 'RegExp']
           *     // ]
           *
           * @param {Param[]} params
           * @param {boolean} ignoreConversionTypes
           * @return {Param[]}
           */
          function splitParams(params, ignoreConversionTypes) {
            function _splitParams(params, index, types) {
              if (index < params.length) {
                var param = params[index];
                var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
                var typeGroups;
                if (param.restParam) {
                  // split the types of a rest parameter in two:
                  // one with only exact types, and one with exact types and conversions
                  var exactTypes = filteredTypes.filter(isExactType);
                  typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];
                } else {
                  // split all the types of a regular parameter into one type per group
                  typeGroups = filteredTypes.map(function (type) {
                    return [type];
                  });
                }

                // recurse over the groups with types
                return flatMap(typeGroups, function (typeGroup) {
                  return _splitParams(params, index + 1, types.concat([typeGroup]));
                });
              } else {
                // we've reached the end of the parameters. Now build a new Param
                var splittedParams = types.map(function (type, typeIndex) {
                  return {
                    types: type,
                    restParam: typeIndex === params.length - 1 && hasRestParam(params)
                  };
                });
                return [splittedParams];
              }
            }
            return _splitParams(params, 0, []);
          }

          /**
           * Test whether two signatures have a conflicting signature
           * @param {Signature} signature1
           * @param {Signature} signature2
           * @return {boolean} Returns true when the signatures conflict, false otherwise.
           */
          function hasConflictingParams(signature1, signature2) {
            var ii = Math.max(signature1.params.length, signature2.params.length);
            for (var i = 0; i < ii; i++) {
              var typesNames1 = getExpectedTypeNames(signature1, i, true);
              var typesNames2 = getExpectedTypeNames(signature2, i, true);
              if (!hasOverlap(typesNames1, typesNames2)) {
                return false;
              }
            }
            var len1 = signature1.params.length;
            var len2 = signature2.params.length;
            var restParam1 = hasRestParam(signature1.params);
            var restParam2 = hasRestParam(signature2.params);
            return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
          }

          /**
           * Create a typed function
           * @param {String} name               The name for the typed function
           * @param {Object.<string, function>} signaturesMap
           *                                    An object with one or
           *                                    multiple signatures as key, and the
           *                                    function corresponding to the
           *                                    signature as value.
           * @return {function}  Returns the created typed function.
           */
          function createTypedFunction(name, signaturesMap) {
            if (Object.keys(signaturesMap).length === 0) {
              throw new SyntaxError('No signatures provided');
            }

            // parse the signatures, and check for conflicts
            var parsedSignatures = [];
            Object.keys(signaturesMap).map(function (signature) {
              return parseSignature(signature, signaturesMap[signature], typed.conversions);
            }).filter(notNull).forEach(function (parsedSignature) {
              // check whether this parameter conflicts with already parsed signatures
              var conflictingSignature = findInArray(parsedSignatures, function (s) {
                return hasConflictingParams(s, parsedSignature);
              });
              if (conflictingSignature) {
                throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
              }
              parsedSignatures.push(parsedSignature);
            });

            // split and filter the types of the signatures, and then order them
            var signatures = flatMap(parsedSignatures, function (parsedSignature) {
              var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
              return params.map(function (params) {
                return {
                  params: params,
                  fn: parsedSignature.fn
                };
              });
            }).filter(notNull);
            signatures.sort(compareSignatures);

            // we create a highly optimized checks for the first couple of signatures with max 2 arguments
            var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
            var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
            var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
            var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
            var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
            var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
            var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;

            // compile the tests
            var tests = signatures.map(function (signature) {
              return compileTests(signature.params);
            });
            var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
            var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
            var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
            var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
            var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
            var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
            var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
            var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
            var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
            var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
            var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
            var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;

            // compile the functions
            var fns = signatures.map(function (signature) {
              return compileArgsPreprocessing(signature.params, signature.fn);
            });
            var fn0 = ok0 ? fns[0] : undef;
            var fn1 = ok1 ? fns[1] : undef;
            var fn2 = ok2 ? fns[2] : undef;
            var fn3 = ok3 ? fns[3] : undef;
            var fn4 = ok4 ? fns[4] : undef;
            var fn5 = ok5 ? fns[5] : undef;
            var len0 = ok0 ? signatures[0].params.length : -1;
            var len1 = ok1 ? signatures[1].params.length : -1;
            var len2 = ok2 ? signatures[2].params.length : -1;
            var len3 = ok3 ? signatures[3].params.length : -1;
            var len4 = ok4 ? signatures[4].params.length : -1;
            var len5 = ok5 ? signatures[5].params.length : -1;

            // simple and generic, but also slow
            var iStart = allOk ? 6 : 0;
            var iEnd = signatures.length;
            var generic = function generic() {

              for (var i = iStart; i < iEnd; i++) {
                if (tests[i](arguments)) {
                  return fns[i].apply(this, arguments);
                }
              }
              return typed.onMismatch(name, arguments, signatures);
            };

            // create the typed function
            // fast, specialized version. Falls back to the slower, generic one if needed
            var fn = function fn(arg0, arg1) {

              if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
                return fn0.apply(fn, arguments);
              }
              if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
                return fn1.apply(fn, arguments);
              }
              if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
                return fn2.apply(fn, arguments);
              }
              if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
                return fn3.apply(fn, arguments);
              }
              if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
                return fn4.apply(fn, arguments);
              }
              if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
                return fn5.apply(fn, arguments);
              }
              return generic.apply(fn, arguments);
            };

            // attach name the typed function
            try {
              Object.defineProperty(fn, 'name', {
                value: name
              });
            } catch (err) {
              // old browsers do not support Object.defineProperty and some don't support setting the name property
              // the function name is not essential for the functioning, it's mostly useful for debugging,
              // so it's fine to have unnamed functions.
            }

            // attach signatures to the function
            fn.signatures = createSignaturesMap(signatures);
            return fn;
          }

          /**
           * Action to take on mismatch
           * @param {string} name      Name of function that was attempted to be called
           * @param {Array} args       Actual arguments to the call
           * @param {Array} signatures Known signatures of the named typed-function
           */
          function _onMismatch(name, args, signatures) {
            throw createError(name, args, signatures);
          }

          /**
           * Test whether a type should be NOT be ignored
           * @param {string} typeName
           * @return {boolean}
           */
          function notIgnore(typeName) {
            return typed.ignore.indexOf(typeName) === -1;
          }

          /**
           * trim a string
           * @param {string} str
           * @return {string}
           */
          function trim(str) {
            return str.trim();
          }

          /**
           * Test whether a string is not empty
           * @param {string} str
           * @return {boolean}
           */
          function notEmpty(str) {
            return !!str;
          }

          /**
           * test whether a value is not strict equal to null
           * @param {*} value
           * @return {boolean}
           */
          function notNull(value) {
            return value !== null;
          }

          /**
           * Test whether a parameter has no types defined
           * @param {Param} param
           * @return {boolean}
           */
          function isInvalidParam(param) {
            return param.types.length === 0;
          }

          /**
           * Return all but the last items of an array
           * @param {Array} arr
           * @return {Array}
           */
          function initial(arr) {
            return arr.slice(0, arr.length - 1);
          }

          /**
           * return the last item of an array
           * @param {Array} arr
           * @return {*}
           */
          function last(arr) {
            return arr[arr.length - 1];
          }

          /**
           * Slice an array or function Arguments
           * @param {Array | Arguments | IArguments} arr
           * @param {number} start
           * @param {number} [end]
           * @return {Array}
           */
          function slice(arr, start, end) {
            return Array.prototype.slice.call(arr, start, end);
          }

          /**
           * Test whether an array contains some item
           * @param {Array} array
           * @param {*} item
           * @return {boolean} Returns true if array contains item, false if not.
           */
          function contains(array, item) {
            return array.indexOf(item) !== -1;
          }

          /**
           * Test whether two arrays have overlapping items
           * @param {Array} array1
           * @param {Array} array2
           * @return {boolean} Returns true when at least one item exists in both arrays
           */
          function hasOverlap(array1, array2) {
            for (var i = 0; i < array1.length; i++) {
              if (contains(array2, array1[i])) {
                return true;
              }
            }
            return false;
          }

          /**
           * Return the first item from an array for which test(arr[i]) returns true
           * @param {Array} arr
           * @param {function} test
           * @return {* | undefined} Returns the first matching item
           *                         or undefined when there is no match
           */
          function findInArray(arr, test) {
            for (var i = 0; i < arr.length; i++) {
              if (test(arr[i])) {
                return arr[i];
              }
            }
            return undefined;
          }

          /**
           * Filter unique items of an array with strings
           * @param {string[]} arr
           * @return {string[]}
           */
          function uniq(arr) {
            var entries = {};
            for (var i = 0; i < arr.length; i++) {
              entries[arr[i]] = true;
            }
            return Object.keys(entries);
          }

          /**
           * Flat map the result invoking a callback for every item in an array.
           * https://gist.github.com/samgiles/762ee337dff48623e729
           * @param {Array} arr
           * @param {function} callback
           * @return {Array}
           */
          function flatMap(arr, callback) {
            return Array.prototype.concat.apply([], arr.map(callback));
          }

          /**
           * Retrieve the function name from a set of typed functions,
           * and check whether the name of all functions match (if given)
           * @param {function[]} fns
           */
          function getName(fns) {
            var name = '';
            for (var i = 0; i < fns.length; i++) {
              var fn = fns[i];

              // check whether the names are the same when defined
              if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {
                if (name === '') {
                  name = fn.name;
                } else if (name !== fn.name) {
                  var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
                  err.data = {
                    actual: fn.name,
                    expected: name
                  };
                  throw err;
                }
              }
            }
            return name;
          }

          // extract and merge all signatures of a list with typed functions
          function extractSignatures(fns) {
            var err;
            var signaturesMap = {};
            function validateUnique(_signature, _fn) {
              if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
                err = new Error('Signature "' + _signature + '" is defined twice');
                err.data = {
                  signature: _signature
                };
                throw err;
                // else: both signatures point to the same function, that's fine
              }
            }

            for (var i = 0; i < fns.length; i++) {
              var fn = fns[i];

              // test whether this is a typed-function
              if (typeof fn.signatures === 'object') {
                // merge the signatures
                for (var signature in fn.signatures) {
                  if (fn.signatures.hasOwnProperty(signature)) {
                    validateUnique(signature, fn.signatures[signature]);
                    signaturesMap[signature] = fn.signatures[signature];
                  }
                }
              } else if (typeof fn.signature === 'string') {
                validateUnique(fn.signature, fn);
                signaturesMap[fn.signature] = fn;
              } else {
                err = new TypeError('Function is no typed-function (index: ' + i + ')');
                err.data = {
                  index: i
                };
                throw err;
              }
            }
            return signaturesMap;
          }
          typed = createTypedFunction('typed', {
            'string, Object': createTypedFunction,
            'Object': function (signaturesMap) {
              // find existing name
              var fns = [];
              for (var signature in signaturesMap) {
                if (signaturesMap.hasOwnProperty(signature)) {
                  fns.push(signaturesMap[signature]);
                }
              }
              var name = getName(fns);
              return createTypedFunction(name, signaturesMap);
            },
            '...Function': function (fns) {
              return createTypedFunction(getName(fns), extractSignatures(fns));
            },
            'string, ...Function': function (name, fns) {
              return createTypedFunction(name, extractSignatures(fns));
            }
          });
          typed.create = create;
          typed.types = _types;
          typed.conversions = _conversions;
          typed.ignore = _ignore;
          typed.onMismatch = _onMismatch;
          typed.throwMismatchError = _onMismatch;
          typed.createError = createError;
          typed.convert = convert;
          typed.find = find;

          /**
           * add a type
           * @param {{name: string, test: function}} type
           * @param {boolean} [beforeObjectTest=true]
           *                          If true, the new test will be inserted before
           *                          the test with name 'Object' (if any), since
           *                          tests for Object match Array and classes too.
           */
          typed.addType = function (type, beforeObjectTest) {
            if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
              throw new TypeError('Object with properties {name: string, test: function} expected');
            }
            if (beforeObjectTest !== false) {
              for (var i = 0; i < typed.types.length; i++) {
                if (typed.types[i].name === 'Object') {
                  typed.types.splice(i, 0, type);
                  return;
                }
              }
            }
            typed.types.push(type);
          };

          // add a conversion
          typed.addConversion = function (conversion) {
            if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {
              throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
            }
            typed.conversions.push(conversion);
          };
          return typed;
        }
        return create();
      });
    })(typedFunction$1);
    var typedFunction = typedFunctionExports;

    /**
     * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue
     */

    /**
     * Check if a number is integer
     * @param {number | boolean} value
     * @return {boolean} isInteger
     */

    function isInteger(value) {
      if (typeof value === 'boolean') {
        return true;
      }
      return isFinite(value) ? value === Math.round(value) : false;
    }
    /**
     * Calculate the sign of a number
     * @param {number} x
     * @returns {number}
     */

    var sign$2 = Math.sign || function (x) {
      if (x > 0) {
        return 1;
      } else if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    };
    /**
     * Formats a number in a given base
     * @param {number} n
     * @param {number} base
     * @param {number} size
     * @returns {string}
     */

    function formatNumberToBase(n, base, size) {
      var prefixes = {
        2: '0b',
        8: '0o',
        16: '0x'
      };
      var prefix = prefixes[base];
      var suffix = '';
      if (size) {
        if (size < 1) {
          throw new Error('size must be in greater than 0');
        }
        if (!isInteger(size)) {
          throw new Error('size must be an integer');
        }
        if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
          throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
        }
        if (!isInteger(n)) {
          throw new Error('Value must be an integer');
        }
        if (n < 0) {
          n = n + 2 ** size;
        }
        suffix = "i".concat(size);
      }
      var sign = '';
      if (n < 0) {
        n = -n;
        sign = '-';
      }
      return "".concat(sign).concat(prefix).concat(n.toString(base)).concat(suffix);
    }
    /**
     * Convert a number to a formatted string representation.
     *
     * Syntax:
     *
     *    format(value)
     *    format(value, options)
     *    format(value, precision)
     *    format(value, fn)
     *
     * Where:
     *
     *    {number} value   The value to be formatted
     *    {Object} options An object with formatting options. Available options:
     *                     {string} notation
     *                         Number notation. Choose from:
     *                         'fixed'          Always use regular number notation.
     *                                          For example '123.40' and '14000000'
     *                         'exponential'    Always use exponential notation.
     *                                          For example '1.234e+2' and '1.4e+7'
     *                         'engineering'    Always use engineering notation.
     *                                          For example '123.4e+0' and '14.0e+6'
     *                         'auto' (default) Regular number notation for numbers
     *                                          having an absolute value between
     *                                          `lowerExp` and `upperExp` bounds, and
     *                                          uses exponential notation elsewhere.
     *                                          Lower bound is included, upper bound
     *                                          is excluded.
     *                                          For example '123.4' and '1.4e7'.
     *                         'bin', 'oct, or
     *                         'hex'            Format the number using binary, octal,
     *                                          or hexadecimal notation.
     *                                          For example '0b1101' and '0x10fe'.
     *                     {number} wordSize    The word size in bits to use for formatting
     *                                          in binary, octal, or hexadecimal notation.
     *                                          To be used only with 'bin', 'oct', or 'hex'
     *                                          values for 'notation' option. When this option
     *                                          is defined the value is formatted as a signed
     *                                          twos complement integer of the given word size
     *                                          and the size suffix is appended to the output.
     *                                          For example
     *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
     *                                          Default value is undefined.
     *                     {number} precision   A number between 0 and 16 to round
     *                                          the digits of the number.
     *                                          In case of notations 'exponential',
     *                                          'engineering', and 'auto',
     *                                          `precision` defines the total
     *                                          number of significant digits returned.
     *                                          In case of notation 'fixed',
     *                                          `precision` defines the number of
     *                                          significant digits after the decimal
     *                                          point.
     *                                          `precision` is undefined by default,
     *                                          not rounding any digits.
     *                     {number} lowerExp    Exponent determining the lower boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `-3`.
     *                     {number} upperExp    Exponent determining the upper boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `5`.
     *    {Function} fn    A custom formatting function. Can be used to override the
     *                     built-in notations. Function `fn` is called with `value` as
     *                     parameter and must return a string. Is useful for example to
     *                     format all values inside a matrix in a particular way.
     *
     * Examples:
     *
     *    format(6.4)                                        // '6.4'
     *    format(1240000)                                    // '1.24e6'
     *    format(1/3)                                        // '0.3333333333333333'
     *    format(1/3, 3)                                     // '0.333'
     *    format(21385, 2)                                   // '21000'
     *    format(12.071, {notation: 'fixed'})                // '12'
     *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'
     *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'
     *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'
     *
     * @param {number} value
     * @param {Object | Function | number} [options]
     * @return {string} str The formatted value
     */

    function format$2(value, options) {
      if (typeof options === 'function') {
        // handle format(value, fn)
        return options(value);
      } // handle special cases

      if (value === Infinity) {
        return 'Infinity';
      } else if (value === -Infinity) {
        return '-Infinity';
      } else if (isNaN(value)) {
        return 'NaN';
      } // default values for options

      var notation = 'auto';
      var precision;
      var wordSize;
      if (options) {
        // determine notation from options
        if (options.notation) {
          notation = options.notation;
        } // determine precision from options

        if (isNumber(options)) {
          precision = options;
        } else if (isNumber(options.precision)) {
          precision = options.precision;
        }
        if (options.wordSize) {
          wordSize = options.wordSize;
          if (typeof wordSize !== 'number') {
            throw new Error('Option "wordSize" must be a number');
          }
        }
      } // handle the various notations

      switch (notation) {
        case 'fixed':
          return toFixed$1(value, precision);
        case 'exponential':
          return toExponential$1(value, precision);
        case 'engineering':
          return toEngineering$1(value, precision);
        case 'bin':
          return formatNumberToBase(value, 2, wordSize);
        case 'oct':
          return formatNumberToBase(value, 8, wordSize);
        case 'hex':
          return formatNumberToBase(value, 16, wordSize);
        case 'auto':
          // remove trailing zeros after the decimal point
          return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function () {
            var digits = arguments[2];
            var e = arguments[4];
            return digits !== '.' ? digits + e : e;
          });
        default:
          throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
      }
    }
    /**
     * Split a number into sign, coefficients, and exponent
     * @param {number | string} value
     * @return {SplitValue}
     *              Returns an object containing sign, coefficients, and exponent
     */

    function splitNumber(value) {
      // parse the input value
      var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
      if (!match) {
        throw new SyntaxError('Invalid number ' + value);
      }
      var sign = match[1];
      var digits = match[2];
      var exponent = parseFloat(match[4] || '0');
      var dot = digits.indexOf('.');
      exponent += dot !== -1 ? dot - 1 : digits.length - 1;
      var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)
      .replace(/^0*/, function (zeros) {
        // remove leading zeros, add their count to the exponent
        exponent -= zeros.length;
        return '';
      }).replace(/0*$/, '') // remove trailing zeros
      .split('').map(function (d) {
        return parseInt(d);
      });
      if (coefficients.length === 0) {
        coefficients.push(0);
        exponent++;
      }
      return {
        sign,
        coefficients,
        exponent
      };
    }
    /**
     * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
     * @param {number | string} value
     * @param {number} [precision]        Optional number of significant figures to return.
     */

    function toEngineering$1(value, precision) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value);
      }
      var split = splitNumber(value);
      var rounded = roundDigits(split, precision);
      var e = rounded.exponent;
      var c = rounded.coefficients; // find nearest lower multiple of 3 for exponent

      var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
      if (isNumber(precision)) {
        // add zeroes to give correct sig figs
        while (precision > c.length || e - newExp + 1 > c.length) {
          c.push(0);
        }
      } else {
        // concatenate coefficients with necessary zeros
        // add zeros if necessary (for example: 1e+8 -> 100e+6)
        var missingZeros = Math.abs(e - newExp) - (c.length - 1);
        for (var i = 0; i < missingZeros; i++) {
          c.push(0);
        }
      } // find difference in exponents

      var expDiff = Math.abs(e - newExp);
      var decimalIdx = 1; // push decimal index over by expDiff times

      while (expDiff > 0) {
        decimalIdx++;
        expDiff--;
      } // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
      // otherwise concat with the rest of the coefficients

      var decimals = c.slice(decimalIdx).join('');
      var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';
      var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
      return rounded.sign + str;
    }
    /**
     * Format a number with fixed notation.
     * @param {number | string} value
     * @param {number} [precision=undefined]  Optional number of decimals after the
     *                                        decimal point. null by default.
     */

    function toFixed$1(value, precision) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value);
      }
      var splitValue = splitNumber(value);
      var rounded = typeof precision === 'number' ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
      var c = rounded.coefficients;
      var p = rounded.exponent + 1; // exponent may have changed
      // append zeros if needed

      var pp = p + (precision || 0);
      if (c.length < pp) {
        c = c.concat(zeros$1(pp - c.length));
      } // prepend zeros if needed

      if (p < 0) {
        c = zeros$1(-p + 1).concat(c);
        p = 1;
      } // insert a dot if needed

      if (p < c.length) {
        c.splice(p, 0, p === 0 ? '0.' : '.');
      }
      return rounded.sign + c.join('');
    }
    /**
     * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
     * @param {number | string} value
     * @param {number} [precision]  Number of digits in formatted output.
     *                              If not provided, the maximum available digits
     *                              is used.
     */

    function toExponential$1(value, precision) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value);
      } // round if needed, else create a clone

      var split = splitNumber(value);
      var rounded = precision ? roundDigits(split, precision) : split;
      var c = rounded.coefficients;
      var e = rounded.exponent; // append zeros if needed

      if (c.length < precision) {
        c = c.concat(zeros$1(precision - c.length));
      } // format as `C.CCCe+EEE` or `C.CCCe-EEE`

      var first = c.shift();
      return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;
    }
    /**
     * Format a number with a certain precision
     * @param {number | string} value
     * @param {number} [precision=undefined] Optional number of digits.
     * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]
     *                                       By default:
     *                                         lowerExp = -3 (incl)
     *                                         upper = +5 (excl)
     * @return {string}
     */

    function toPrecision(value, precision, options) {
      if (isNaN(value) || !isFinite(value)) {
        return String(value);
      } // determine lower and upper bound for exponential notation.

      var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
      var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
      var split = splitNumber(value);
      var rounded = precision ? roundDigits(split, precision) : split;
      if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
        // exponential notation
        return toExponential$1(value, precision);
      } else {
        var c = rounded.coefficients;
        var e = rounded.exponent; // append trailing zeros

        if (c.length < precision) {
          c = c.concat(zeros$1(precision - c.length));
        } // append trailing zeros
        // TODO: simplify the next statement

        c = c.concat(zeros$1(e - c.length + 1 + (c.length < precision ? precision - c.length : 0))); // prepend zeros

        c = zeros$1(-e).concat(c);
        var dot = e > 0 ? e : 0;
        if (dot < c.length - 1) {
          c.splice(dot + 1, 0, '.');
        }
        return rounded.sign + c.join('');
      }
    }
    /**
     * Round the number of digits of a number *
     * @param {SplitValue} split       A value split with .splitNumber(value)
     * @param {number} precision  A positive integer
     * @return {SplitValue}
     *              Returns an object containing sign, coefficients, and exponent
     *              with rounded digits
     */

    function roundDigits(split, precision) {
      // create a clone
      var rounded = {
        sign: split.sign,
        coefficients: split.coefficients,
        exponent: split.exponent
      };
      var c = rounded.coefficients; // prepend zeros if needed

      while (precision <= 0) {
        c.unshift(0);
        rounded.exponent++;
        precision++;
      }
      if (c.length > precision) {
        var removed = c.splice(precision, c.length - precision);
        if (removed[0] >= 5) {
          var i = precision - 1;
          c[i]++;
          while (c[i] === 10) {
            c.pop();
            if (i === 0) {
              c.unshift(0);
              rounded.exponent++;
              i++;
            }
            i--;
            c[i]++;
          }
        }
      }
      return rounded;
    }
    /**
     * Create an array filled with zeros.
     * @param {number} length
     * @return {Array}
     */

    function zeros$1(length) {
      var arr = [];
      for (var i = 0; i < length; i++) {
        arr.push(0);
      }
      return arr;
    }
    /**
     * Count the number of significant digits of a number.
     *
     * For example:
     *   2.34 returns 3
     *   0.0034 returns 2
     *   120.5e+30 returns 4
     *
     * @param {number} value
     * @return {number} digits   Number of significant digits
     */

    function digits(value) {
      return value.toExponential().replace(/e.*$/, '') // remove exponential notation
      .replace(/^0\.?0*|\./, '') // remove decimal point and leading zeros
      .length;
    }
    /**
     * Minimum number added to one that makes the result different than one
     */

    var DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;
    /**
     * Compares two floating point numbers.
     * @param {number} x          First value to compare
     * @param {number} y          Second value to compare
     * @param {number} [epsilon]  The maximum relative difference between x and y
     *                            If epsilon is undefined or null, the function will
     *                            test whether x and y are exactly equal.
     * @return {boolean} whether the two numbers are nearly equal
    */

    function nearlyEqual$1(x, y, epsilon) {
      // if epsilon is null or undefined, test whether x and y are exactly equal
      if (epsilon === null || epsilon === undefined) {
        return x === y;
      }
      if (x === y) {
        return true;
      } // NaN

      if (isNaN(x) || isNaN(y)) {
        return false;
      } // at this point x and y should be finite

      if (isFinite(x) && isFinite(y)) {
        // check numbers are very close, needed when comparing numbers near zero
        var diff = Math.abs(x - y);
        if (diff < DBL_EPSILON) {
          return true;
        } else {
          // use relative error
          return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
        }
      } // Infinite and Number or negative Infinite and positive Infinite cases

      return false;
    }

    /**
     * Formats a BigNumber in a given base
     * @param {BigNumber} n
     * @param {number} base
     * @param {number} size
     * @returns {string}
     */

    function formatBigNumberToBase(n, base, size) {
      var BigNumberCtor = n.constructor;
      var big2 = new BigNumberCtor(2);
      var suffix = '';
      if (size) {
        if (size < 1) {
          throw new Error('size must be in greater than 0');
        }
        if (!isInteger(size)) {
          throw new Error('size must be an integer');
        }
        if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
          throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
        }
        if (!n.isInteger()) {
          throw new Error('Value must be an integer');
        }
        if (n.lessThan(0)) {
          n = n.add(big2.pow(size));
        }
        suffix = "i".concat(size);
      }
      switch (base) {
        case 2:
          return "".concat(n.toBinary()).concat(suffix);
        case 8:
          return "".concat(n.toOctal()).concat(suffix);
        case 16:
          return "".concat(n.toHexadecimal()).concat(suffix);
        default:
          throw new Error("Base ".concat(base, " not supported "));
      }
    }
    /**
     * Convert a BigNumber to a formatted string representation.
     *
     * Syntax:
     *
     *    format(value)
     *    format(value, options)
     *    format(value, precision)
     *    format(value, fn)
     *
     * Where:
     *
     *    {number} value   The value to be formatted
     *    {Object} options An object with formatting options. Available options:
     *                     {string} notation
     *                         Number notation. Choose from:
     *                         'fixed'          Always use regular number notation.
     *                                          For example '123.40' and '14000000'
     *                         'exponential'    Always use exponential notation.
     *                                          For example '1.234e+2' and '1.4e+7'
     *                         'auto' (default) Regular number notation for numbers
     *                                          having an absolute value between
     *                                          `lower` and `upper` bounds, and uses
     *                                          exponential notation elsewhere.
     *                                          Lower bound is included, upper bound
     *                                          is excluded.
     *                                          For example '123.4' and '1.4e7'.
     *                         'bin', 'oct, or
     *                         'hex'            Format the number using binary, octal,
     *                                          or hexadecimal notation.
     *                                          For example '0b1101' and '0x10fe'.
     *                     {number} wordSize    The word size in bits to use for formatting
     *                                          in binary, octal, or hexadecimal notation.
     *                                          To be used only with 'bin', 'oct', or 'hex'
     *                                          values for 'notation' option. When this option
     *                                          is defined the value is formatted as a signed
     *                                          twos complement integer of the given word size
     *                                          and the size suffix is appended to the output.
     *                                          For example
     *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
     *                                          Default value is undefined.
     *                     {number} precision   A number between 0 and 16 to round
     *                                          the digits of the number.
     *                                          In case of notations 'exponential',
     *                                          'engineering', and 'auto',
     *                                          `precision` defines the total
     *                                          number of significant digits returned.
     *                                          In case of notation 'fixed',
     *                                          `precision` defines the number of
     *                                          significant digits after the decimal
     *                                          point.
     *                                          `precision` is undefined by default.
     *                     {number} lowerExp    Exponent determining the lower boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `-3`.
     *                     {number} upperExp    Exponent determining the upper boundary
     *                                          for formatting a value with an exponent
     *                                          when `notation='auto`.
     *                                          Default value is `5`.
     *    {Function} fn    A custom formatting function. Can be used to override the
     *                     built-in notations. Function `fn` is called with `value` as
     *                     parameter and must return a string. Is useful for example to
     *                     format all values inside a matrix in a particular way.
     *
     * Examples:
     *
     *    format(6.4)                                        // '6.4'
     *    format(1240000)                                    // '1.24e6'
     *    format(1/3)                                        // '0.3333333333333333'
     *    format(1/3, 3)                                     // '0.333'
     *    format(21385, 2)                                   // '21000'
     *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'
     *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'
     *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'
     *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'
     *
     * @param {BigNumber} value
     * @param {Object | Function | number} [options]
     * @return {string} str The formatted value
     */

    function format$1(value, options) {
      if (typeof options === 'function') {
        // handle format(value, fn)
        return options(value);
      } // handle special cases

      if (!value.isFinite()) {
        return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';
      } // default values for options

      var notation = 'auto';
      var precision;
      var wordSize;
      if (options !== undefined) {
        // determine notation from options
        if (options.notation) {
          notation = options.notation;
        } // determine precision from options

        if (typeof options === 'number') {
          precision = options;
        } else if (options.precision) {
          precision = options.precision;
        }
        if (options.wordSize) {
          wordSize = options.wordSize;
          if (typeof wordSize !== 'number') {
            throw new Error('Option "wordSize" must be a number');
          }
        }
      } // handle the various notations

      switch (notation) {
        case 'fixed':
          return toFixed(value, precision);
        case 'exponential':
          return toExponential(value, precision);
        case 'engineering':
          return toEngineering(value, precision);
        case 'bin':
          return formatBigNumberToBase(value, 2, wordSize);
        case 'oct':
          return formatBigNumberToBase(value, 8, wordSize);
        case 'hex':
          return formatBigNumberToBase(value, 16, wordSize);
        case 'auto':
          {
            // determine lower and upper bound for exponential notation.
            // TODO: implement support for upper and lower to be BigNumbers themselves
            var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
            var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5; // handle special case zero

            if (value.isZero()) return '0'; // determine whether or not to output exponential notation

            var str;
            var rounded = value.toSignificantDigits(precision);
            var exp = rounded.e;
            if (exp >= lowerExp && exp < upperExp) {
              // normal number notation
              str = rounded.toFixed();
            } else {
              // exponential notation
              str = toExponential(value, precision);
            } // remove trailing zeros after the decimal point

            return str.replace(/((\.\d*?)(0+))($|e)/, function () {
              var digits = arguments[2];
              var e = arguments[4];
              return digits !== '.' ? digits + e : e;
            });
          }
        default:
          throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
      }
    }
    /**
     * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
     * @param {BigNumber | string} value
     * @param {number} [precision]        Optional number of significant figures to return.
     */

    function toEngineering(value, precision) {
      // find nearest lower multiple of 3 for exponent
      var e = value.e;
      var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3; // find difference in exponents, and calculate the value without exponent

      var valueWithoutExp = value.mul(Math.pow(10, -newExp));
      var valueStr = valueWithoutExp.toPrecision(precision);
      if (valueStr.indexOf('e') !== -1) {
        valueStr = valueWithoutExp.toString();
      }
      return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
    }
    /**
     * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
     * @param {BigNumber} value
     * @param {number} [precision]  Number of digits in formatted output.
     *                              If not provided, the maximum available digits
     *                              is used.
     * @returns {string} str
     */

    function toExponential(value, precision) {
      if (precision !== undefined) {
        return value.toExponential(precision - 1); // Note the offset of one
      } else {
        return value.toExponential();
      }
    }
    /**
     * Format a number with fixed notation.
     * @param {BigNumber} value
     * @param {number} [precision=undefined] Optional number of decimals after the
     *                                       decimal point. Undefined by default.
     */

    function toFixed(value, precision) {
      return value.toFixed(precision);
    }

    /**
     * Format a value of any type into a string.
     *
     * Usage:
     *     math.format(value)
     *     math.format(value, precision)
     *     math.format(value, options)
     *
     * When value is a function:
     *
     * - When the function has a property `syntax`, it returns this
     *   syntax description.
     * - In other cases, a string `'function'` is returned.
     *
     * When `value` is an Object:
     *
     * - When the object contains a property `format` being a function, this
     *   function is invoked as `value.format(options)` and the result is returned.
     * - When the object has its own `toString` method, this method is invoked
     *   and the result is returned.
     * - In other cases the function will loop over all object properties and
     *   return JSON object notation like '{"a": 2, "b": 3}'.
     *
     * Example usage:
     *     math.format(2/7)                // '0.2857142857142857'
     *     math.format(math.pi, 3)         // '3.14'
     *     math.format(new Complex(2, 3))  // '2 + 3i'
     *     math.format('hello')            // '"hello"'
     *
     * @param {*} value             Value to be stringified
     * @param {Object | number | Function} [options]
     *     Formatting options. See src/utils/number.js:format for a
     *     description of the available options controlling number output.
     *     This generic "format" also supports the option property `truncate: NN`
     *     giving the maximum number NN of characters to return (if there would
     *     have been more, they are deleted and replaced by an ellipsis).
     * @return {string} str
     */

    function format(value, options) {
      var result = _format(value, options);
      if (options && typeof options === 'object' && 'truncate' in options && result.length > options.truncate) {
        return result.substring(0, options.truncate - 3) + '...';
      }
      return result;
    }
    function _format(value, options) {
      if (typeof value === 'number') {
        return format$2(value, options);
      }
      if (isBigNumber(value)) {
        return format$1(value, options);
      } // note: we use unsafe duck-typing here to check for Fractions, this is
      // ok here since we're only invoking toString or concatenating its values

      if (looksLikeFraction(value)) {
        if (!options || options.fraction !== 'decimal') {
          // output as ratio, like '1/3'
          return value.s * value.n + '/' + value.d;
        } else {
          // output as decimal, like '0.(3)'
          return value.toString();
        }
      }
      if (Array.isArray(value)) {
        return formatArray(value, options);
      }
      if (isString(value)) {
        return '"' + value + '"';
      }
      if (typeof value === 'function') {
        return value.syntax ? String(value.syntax) : 'function';
      }
      if (value && typeof value === 'object') {
        if (typeof value.format === 'function') {
          return value.format(options);
        } else if (value && value.toString(options) !== {}.toString()) {
          // this object has a non-native toString method, use that one
          return value.toString(options);
        } else {
          var entries = Object.keys(value).map(key => {
            return '"' + key + '": ' + format(value[key], options);
          });
          return '{' + entries.join(', ') + '}';
        }
      }
      return String(value);
    }
    /**
     * Recursively format an n-dimensional matrix
     * Example output: "[[1, 2], [3, 4]]"
     * @param {Array} array
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */

    function formatArray(array, options) {
      if (Array.isArray(array)) {
        var str = '[';
        var len = array.length;
        for (var i = 0; i < len; i++) {
          if (i !== 0) {
            str += ', ';
          }
          str += formatArray(array[i], options);
        }
        str += ']';
        return str;
      } else {
        return format(array, options);
      }
    }
    /**
     * Check whether a value looks like a Fraction (unsafe duck-type check)
     * @param {*} value
     * @return {boolean}
     */

    function looksLikeFraction(value) {
      return value && typeof value === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;
    }

    /**
     * Create a range error with the message:
     *     'Dimension mismatch (<actual size> != <expected size>)'
     * @param {number | number[]} actual        The actual size
     * @param {number | number[]} expected      The expected size
     * @param {string} [relation='!=']          Optional relation between actual
     *                                          and expected size: '!=', '<', etc.
     * @extends RangeError
     */
    function DimensionError(actual, expected, relation) {
      if (!(this instanceof DimensionError)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
      this.actual = actual;
      this.expected = expected;
      this.relation = relation;
      this.message = 'Dimension mismatch (' + (Array.isArray(actual) ? '[' + actual.join(', ') + ']' : actual) + ' ' + (this.relation || '!=') + ' ' + (Array.isArray(expected) ? '[' + expected.join(', ') + ']' : expected) + ')';
      this.stack = new Error().stack;
    }
    DimensionError.prototype = new RangeError();
    DimensionError.prototype.constructor = RangeError;
    DimensionError.prototype.name = 'DimensionError';
    DimensionError.prototype.isDimensionError = true;

    /**
     * Create a range error with the message:
     *     'Index out of range (index < min)'
     *     'Index out of range (index < max)'
     *
     * @param {number} index     The actual index
     * @param {number} [min=0]   Minimum index (included)
     * @param {number} [max]     Maximum index (excluded)
     * @extends RangeError
     */
    function IndexError(index, min, max) {
      if (!(this instanceof IndexError)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
      this.index = index;
      if (arguments.length < 3) {
        this.min = 0;
        this.max = min;
      } else {
        this.min = min;
        this.max = max;
      }
      if (this.min !== undefined && this.index < this.min) {
        this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
      } else if (this.max !== undefined && this.index >= this.max) {
        this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
      } else {
        this.message = 'Index out of range (' + this.index + ')';
      }
      this.stack = new Error().stack;
    }
    IndexError.prototype = new RangeError();
    IndexError.prototype.constructor = RangeError;
    IndexError.prototype.name = 'IndexError';
    IndexError.prototype.isIndexError = true;

    /**
     * Calculate the size of a multi dimensional array.
     * This function checks the size of the first entry, it does not validate
     * whether all dimensions match. (use function `validate` for that)
     * @param {Array} x
     * @Return {Number[]} size
     */

    function arraySize(x) {
      var s = [];
      while (Array.isArray(x)) {
        s.push(x.length);
        x = x[0];
      }
      return s;
    }
    /**
     * Recursively validate whether each element in a multi dimensional array
     * has a size corresponding to the provided size array.
     * @param {Array} array    Array to be validated
     * @param {number[]} size  Array with the size of each dimension
     * @param {number} dim   Current dimension
     * @throws DimensionError
     * @private
     */

    function _validate(array, size, dim) {
      var i;
      var len = array.length;
      if (len !== size[dim]) {
        throw new DimensionError(len, size[dim]);
      }
      if (dim < size.length - 1) {
        // recursively validate each child array
        var dimNext = dim + 1;
        for (i = 0; i < len; i++) {
          var child = array[i];
          if (!Array.isArray(child)) {
            throw new DimensionError(size.length - 1, size.length, '<');
          }
          _validate(array[i], size, dimNext);
        }
      } else {
        // last dimension. none of the childs may be an array
        for (i = 0; i < len; i++) {
          if (Array.isArray(array[i])) {
            throw new DimensionError(size.length + 1, size.length, '>');
          }
        }
      }
    }
    /**
     * Validate whether each element in a multi dimensional array has
     * a size corresponding to the provided size array.
     * @param {Array} array    Array to be validated
     * @param {number[]} size  Array with the size of each dimension
     * @throws DimensionError
     */

    function validate(array, size) {
      var isScalar = size.length === 0;
      if (isScalar) {
        // scalar
        if (Array.isArray(array)) {
          throw new DimensionError(array.length, 0);
        }
      } else {
        // array
        _validate(array, size, 0);
      }
    }
    /**
     * Test whether index is an integer number with index >= 0 and index < length
     * when length is provided
     * @param {number} index    Zero-based index
     * @param {number} [length] Length of the array
     */

    function validateIndex(index, length) {
      if (!isNumber(index) || !isInteger(index)) {
        throw new TypeError('Index must be an integer (value: ' + index + ')');
      }
      if (index < 0 || typeof length === 'number' && index >= length) {
        throw new IndexError(index, length);
      }
    }
    /**
     * Resize a multi dimensional array. The resized array is returned.
     * @param {Array} array         Array to be resized
     * @param {Array.<number>} size Array with the size of each dimension
     * @param {*} [defaultValue=0]  Value to be filled in in new entries,
     *                              zero by default. Specify for example `null`,
     *                              to clearly see entries that are not explicitly
     *                              set.
     * @return {Array} array         The resized array
     */

    function resize(array, size, defaultValue) {
      // TODO: add support for scalars, having size=[] ?
      // check the type of the arguments
      if (!Array.isArray(array) || !Array.isArray(size)) {
        throw new TypeError('Array expected');
      }
      if (size.length === 0) {
        throw new Error('Resizing to scalar is not supported');
      } // check whether size contains positive integers

      size.forEach(function (value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');
        }
      }); // recursively resize the array

      var _defaultValue = defaultValue !== undefined ? defaultValue : 0;
      _resize(array, size, 0, _defaultValue);
      return array;
    }
    /**
     * Recursively resize a multi dimensional array
     * @param {Array} array         Array to be resized
     * @param {number[]} size       Array with the size of each dimension
     * @param {number} dim          Current dimension
     * @param {*} [defaultValue]    Value to be filled in in new entries,
     *                              undefined by default.
     * @private
     */

    function _resize(array, size, dim, defaultValue) {
      var i;
      var elem;
      var oldLen = array.length;
      var newLen = size[dim];
      var minLen = Math.min(oldLen, newLen); // apply new length

      array.length = newLen;
      if (dim < size.length - 1) {
        // non-last dimension
        var dimNext = dim + 1; // resize existing child arrays

        for (i = 0; i < minLen; i++) {
          // resize child array
          elem = array[i];
          if (!Array.isArray(elem)) {
            elem = [elem]; // add a dimension

            array[i] = elem;
          }
          _resize(elem, size, dimNext, defaultValue);
        } // create new child arrays

        for (i = minLen; i < newLen; i++) {
          // get child array
          elem = [];
          array[i] = elem; // resize new child array

          _resize(elem, size, dimNext, defaultValue);
        }
      } else {
        // last dimension
        // remove dimensions of existing values
        for (i = 0; i < minLen; i++) {
          while (Array.isArray(array[i])) {
            array[i] = array[i][0];
          }
        } // fill new elements with the default value

        for (i = minLen; i < newLen; i++) {
          array[i] = defaultValue;
        }
      }
    }
    /**
     * Re-shape a multi dimensional array to fit the specified dimensions
     * @param {Array} array           Array to be reshaped
     * @param {Array.<number>} sizes  List of sizes for each dimension
     * @returns {Array}               Array whose data has been formatted to fit the
     *                                specified dimensions
     *
     * @throws {DimensionError}       If the product of the new dimension sizes does
     *                                not equal that of the old ones
     */

    function reshape(array, sizes) {
      var flatArray = flatten$1(array);
      var currentLength = flatArray.length;
      if (!Array.isArray(array) || !Array.isArray(sizes)) {
        throw new TypeError('Array expected');
      }
      if (sizes.length === 0) {
        throw new DimensionError(0, currentLength, '!=');
      }
      sizes = processSizesWildcard(sizes, currentLength);
      var newLength = product(sizes);
      if (currentLength !== newLength) {
        throw new DimensionError(newLength, currentLength, '!=');
      }
      try {
        return _reshape(flatArray, sizes);
      } catch (e) {
        if (e instanceof DimensionError) {
          throw new DimensionError(newLength, currentLength, '!=');
        }
        throw e;
      }
    }
    /**
     * Replaces the wildcard -1 in the sizes array.
     * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.
     * @param {number} currentLength  Number of elements in the array.
     * @throws {Error}                If more than one wildcard or unable to replace it.
     * @returns {Array.<number>}      The sizes array with wildcard replaced.
     */

    function processSizesWildcard(sizes, currentLength) {
      var newLength = product(sizes);
      var processedSizes = sizes.slice();
      var WILDCARD = -1;
      var wildCardIndex = sizes.indexOf(WILDCARD);
      var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
      if (isMoreThanOneWildcard) {
        throw new Error('More than one wildcard in sizes');
      }
      var hasWildcard = wildCardIndex >= 0;
      var canReplaceWildcard = currentLength % newLength === 0;
      if (hasWildcard) {
        if (canReplaceWildcard) {
          processedSizes[wildCardIndex] = -currentLength / newLength;
        } else {
          throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);
        }
      }
      return processedSizes;
    }
    /**
     * Computes the product of all array elements.
     * @param {Array<number>} array Array of factors
     * @returns {number}            Product of all elements
     */

    function product(array) {
      return array.reduce((prev, curr) => prev * curr, 1);
    }
    /**
     * Iteratively re-shape a multi dimensional array to fit the specified dimensions
     * @param {Array} array           Array to be reshaped
     * @param {Array.<number>} sizes  List of sizes for each dimension
     * @returns {Array}               Array whose data has been formatted to fit the
     *                                specified dimensions
     */

    function _reshape(array, sizes) {
      // testing if there are enough elements for the requested shape
      var tmpArray = array;
      var tmpArray2; // for each dimensions starting by the last one and ignoring the first one

      for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
        var size = sizes[sizeIndex];
        tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size

        var length = tmpArray.length / size;
        for (var i = 0; i < length; i++) {
          tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
        } // set it as the new tmpArray for the next loop turn or for return

        tmpArray = tmpArray2;
      }
      return tmpArray;
    }
    /**
     * Squeeze a multi dimensional array
     * @param {Array} array
     * @param {Array} [size]
     * @returns {Array} returns the array itself
     */

    function squeeze(array, size) {
      var s = size || arraySize(array); // squeeze outer dimensions

      while (Array.isArray(array) && array.length === 1) {
        array = array[0];
        s.shift();
      } // find the first dimension to be squeezed

      var dims = s.length;
      while (s[dims - 1] === 1) {
        dims--;
      } // squeeze inner dimensions

      if (dims < s.length) {
        array = _squeeze(array, dims, 0);
        s.length = dims;
      }
      return array;
    }
    /**
     * Recursively squeeze a multi dimensional array
     * @param {Array} array
     * @param {number} dims Required number of dimensions
     * @param {number} dim  Current dimension
     * @returns {Array | *} Returns the squeezed array
     * @private
     */

    function _squeeze(array, dims, dim) {
      var i, ii;
      if (dim < dims) {
        var next = dim + 1;
        for (i = 0, ii = array.length; i < ii; i++) {
          array[i] = _squeeze(array[i], dims, next);
        }
      } else {
        while (Array.isArray(array)) {
          array = array[0];
        }
      }
      return array;
    }
    /**
     * Unsqueeze a multi dimensional array: add dimensions when missing
     *
     * Paramter `size` will be mutated to match the new, unqueezed matrix size.
     *
     * @param {Array} array
     * @param {number} dims       Desired number of dimensions of the array
     * @param {number} [outer]    Number of outer dimensions to be added
     * @param {Array} [size] Current size of array.
     * @returns {Array} returns the array itself
     * @private
     */

    function unsqueeze(array, dims, outer, size) {
      var s = size || arraySize(array); // unsqueeze outer dimensions

      if (outer) {
        for (var i = 0; i < outer; i++) {
          array = [array];
          s.unshift(1);
        }
      } // unsqueeze inner dimensions

      array = _unsqueeze(array, dims, 0);
      while (s.length < dims) {
        s.push(1);
      }
      return array;
    }
    /**
     * Recursively unsqueeze a multi dimensional array
     * @param {Array} array
     * @param {number} dims Required number of dimensions
     * @param {number} dim  Current dimension
     * @returns {Array | *} Returns the squeezed array
     * @private
     */

    function _unsqueeze(array, dims, dim) {
      var i, ii;
      if (Array.isArray(array)) {
        var next = dim + 1;
        for (i = 0, ii = array.length; i < ii; i++) {
          array[i] = _unsqueeze(array[i], dims, next);
        }
      } else {
        for (var d = dim; d < dims; d++) {
          array = [array];
        }
      }
      return array;
    }
    /**
     * Flatten a multi dimensional array, put all elements in a one dimensional
     * array
     * @param {Array} array   A multi dimensional array
     * @return {Array}        The flattened array (1 dimensional)
     */

    function flatten$1(array) {
      if (!Array.isArray(array)) {
        // if not an array, return as is
        return array;
      }
      var flat = [];
      array.forEach(function callback(value) {
        if (Array.isArray(value)) {
          value.forEach(callback); // traverse through sub-arrays recursively
        } else {
          flat.push(value);
        }
      });
      return flat;
    }
    /**
     * Check the datatype of a given object
     * This is a low level implementation that should only be used by
     * parent Matrix classes such as SparseMatrix or DenseMatrix
     * This method does not validate Array Matrix shape
     * @param {Array} array
     * @param {function} typeOf   Callback function to use to determine the type of a value
     * @return {string}
     */

    function getArrayDataType(array, typeOf) {
      var type; // to hold type info

      var length = 0; // to hold length value to ensure it has consistent sizes

      for (var i = 0; i < array.length; i++) {
        var item = array[i];
        var isArray = Array.isArray(item); // Saving the target matrix row size

        if (i === 0 && isArray) {
          length = item.length;
        } // If the current item is an array but the length does not equal the targetVectorSize

        if (isArray && item.length !== length) {
          return undefined;
        }
        var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array
        : typeOf(item);
        if (type === undefined) {
          type = itemType; // first item
        } else if (type !== itemType) {
          return 'mixed';
        } else ;
      }
      return type;
    }

    /**
     * Create a factory function, which can be used to inject dependencies.
     *
     * The created functions are memoized, a consecutive call of the factory
     * with the exact same inputs will return the same function instance.
     * The memoized cache is exposed on `factory.cache` and can be cleared
     * if needed.
     *
     * Example:
     *
     *     const name = 'log'
     *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']
     *
     *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {
     *       // ... create the function log here and return it
     *     }
     *
     * @param {string} name           Name of the function to be created
     * @param {string[]} dependencies The names of all required dependencies
     * @param {function} create       Callback function called with an object with all dependencies
     * @param {Object} [meta]         Optional object with meta information that will be attached
     *                                to the created factory function as property `meta`.
     * @returns {function}
     */

    function factory(name, dependencies, create, meta) {
      function assertAndCreate(scope) {
        // we only pass the requested dependencies to the factory function
        // to prevent functions to rely on dependencies that are not explicitly
        // requested.
        var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));
        assertDependencies(name, dependencies, scope);
        return create(deps);
      }
      assertAndCreate.isFactory = true;
      assertAndCreate.fn = name;
      assertAndCreate.dependencies = dependencies.slice().sort();
      if (meta) {
        assertAndCreate.meta = meta;
      }
      return assertAndCreate;
    }
    /**
     * Assert that all dependencies of a list with dependencies are available in the provided scope.
     *
     * Will throw an exception when there are dependencies missing.
     *
     * @param {string} name   Name for the function to be created. Used to generate a useful error message
     * @param {string[]} dependencies
     * @param {Object} scope
     */

    function assertDependencies(name, dependencies, scope) {
      var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals
      .every(dependency => scope[dependency] !== undefined);
      if (!allDefined) {
        var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined); // TODO: create a custom error class for this, a MathjsError or something like that

        throw new Error("Cannot create function \"".concat(name, "\", ") + "some dependencies are missing: ".concat(missingDependencies.map(d => "\"".concat(d, "\"")).join(', '), "."));
      }
    }
    function isOptionalDependency(dependency) {
      return dependency && dependency[0] === '?';
    }
    function stripOptionalNotation(dependency) {
      return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;
    }

    /**
     * Get a property of a plain object
     * Throws an error in case the object is not a plain object or the
     * property is not defined on the object itself
     * @param {Object} object
     * @param {string} prop
     * @return {*} Returns the property value when safe
     */

    function getSafeProperty(object, prop) {
      // only allow getting safe properties of a plain object
      if (isPlainObject(object) && isSafeProperty(object, prop)) {
        return object[prop];
      }
      if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {
        throw new Error('Cannot access method "' + prop + '" as a property');
      }
      throw new Error('No access to property "' + prop + '"');
    }
    /**
     * Set a property on a plain object.
     * Throws an error in case the object is not a plain object or the
     * property would override an inherited property like .constructor or .toString
     * @param {Object} object
     * @param {string} prop
     * @param {*} value
     * @return {*} Returns the value
     */
    // TODO: merge this function into access.js?

    function setSafeProperty(object, prop, value) {
      // only allow setting safe properties of a plain object
      if (isPlainObject(object) && isSafeProperty(object, prop)) {
        object[prop] = value;
        return value;
      }
      throw new Error('No access to property "' + prop + '"');
    }
    function hasSafeProperty(object, prop) {
      return prop in object;
    }
    /**
     * Test whether a property is safe to use for an object.
     * For example .toString and .constructor are not safe
     * @param {string} prop
     * @return {boolean} Returns true when safe
     */

    function isSafeProperty(object, prop) {
      if (!object || typeof object !== 'object') {
        return false;
      } // SAFE: whitelisted
      // e.g length

      if (hasOwnProperty(safeNativeProperties, prop)) {
        return true;
      } // UNSAFE: inherited from Object prototype
      // e.g constructor

      if (prop in Object.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Object.prototype is a root object
        return false;
      } // UNSAFE: inherited from Function prototype
      // e.g call, apply

      if (prop in Function.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Function.prototype is a root object
        return false;
      }
      return true;
    }
    /**
     * Check whether a method is safe.
     * Throws an error when that's not the case (for example for `constructor`).
     * @param {Object} object
     * @param {string} method
     * @return {boolean} Returns true when safe, false otherwise
     */

    function isSafeMethod(object, method) {
      if (object === null || object === undefined || typeof object[method] !== 'function') {
        return false;
      } // UNSAFE: ghosted
      // e.g overridden toString
      // Note that IE10 doesn't support __proto__ and we can't do this check there.

      if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
        return false;
      } // SAFE: whitelisted
      // e.g toString

      if (hasOwnProperty(safeNativeMethods, method)) {
        return true;
      } // UNSAFE: inherited from Object prototype
      // e.g constructor

      if (method in Object.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Object.prototype is a root object
        return false;
      } // UNSAFE: inherited from Function prototype
      // e.g call, apply

      if (method in Function.prototype) {
        // 'in' is used instead of hasOwnProperty for nodejs v0.10
        // which is inconsistent on root prototypes. It is safe
        // here because Function.prototype is a root object
        return false;
      }
      return true;
    }
    function isPlainObject(object) {
      return typeof object === 'object' && object && object.constructor === Object;
    }
    var safeNativeProperties = {
      length: true,
      name: true
    };
    var safeNativeMethods = {
      toString: true,
      valueOf: true,
      toLocaleString: true
    };

    /**
     * A map facade on a bare object.
     *
     * The small number of methods needed to implement a scope,
     * forwarding on to the SafeProperty functions. Over time, the codebase
     * will stop using this method, as all objects will be Maps, rather than
     * more security prone objects.
     */

    class ObjectWrappingMap {
      constructor(object) {
        this.wrappedObject = object;
      }
      keys() {
        return Object.keys(this.wrappedObject);
      }
      get(key) {
        return getSafeProperty(this.wrappedObject, key);
      }
      set(key, value) {
        setSafeProperty(this.wrappedObject, key, value);
        return this;
      }
      has(key) {
        return hasSafeProperty(this.wrappedObject, key);
      }
    }
    /**
     * Returns `true` if the passed object appears to be a Map (i.e. duck typing).
     *
     * Methods looked for are `get`, `set`, `keys` and `has`.
     *
     * @param {Map | object} object
     * @returns
     */

    function isMap(object) {
      // We can use the fast instanceof, or a slower duck typing check.
      // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.
      if (!object) {
        return false;
      }
      return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';
    }

    /**
     * Create a typed-function which checks the types of the arguments and
     * can match them against multiple provided signatures. The typed-function
     * automatically converts inputs in order to find a matching signature.
     * Typed functions throw informative errors in case of wrong input arguments.
     *
     * See the library [typed-function](https://github.com/josdejong/typed-function)
     * for detailed documentation.
     *
     * Syntax:
     *
     *     math.typed(name, signatures) : function
     *     math.typed(signatures) : function
     *
     * Examples:
     *
     *     // create a typed function with multiple types per argument (type union)
     *     const fn2 = typed({
     *       'number | boolean': function (b) {
     *         return 'b is a number or boolean'
     *       },
     *       'string, number | boolean': function (a, b) {
     *         return 'a is a string, b is a number or boolean'
     *       }
     *     })
     *
     *     // create a typed function with an any type argument
     *     const log = typed({
     *       'string, any': function (event, data) {
     *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))
     *       }
     *     })
     *
     * @param {string} [name]                          Optional name for the typed-function
     * @param {Object<string, function>} signatures   Object with one or multiple function signatures
     * @returns {function} The created typed-function.
     */

    var _createTyped2 = function _createTyped() {
      // initially, return the original instance of typed-function
      // consecutively, return a new instance from typed.create.
      _createTyped2 = typedFunction.create;
      return typedFunction;
    };
    var dependencies$14 = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];
    /**
     * Factory function for creating a new typed instance
     * @param {Object} dependencies   Object with data types like Complex and BigNumber
     * @returns {Function}
     */

    var createTyped = /* #__PURE__ */factory('typed', dependencies$14, function createTyped(_ref) {
      var {
        BigNumber,
        Complex,
        DenseMatrix,
        Fraction
      } = _ref;

      // TODO: typed-function must be able to silently ignore signatures with unknown data types
      // get a new instance of typed-function
      var typed = _createTyped2(); // define all types. The order of the types determines in which order function
      // arguments are type-checked (so for performance it's important to put the
      // most used types first).

      typed.types = [{
        name: 'number',
        test: isNumber
      }, {
        name: 'Complex',
        test: isComplex
      }, {
        name: 'BigNumber',
        test: isBigNumber
      }, {
        name: 'Fraction',
        test: isFraction
      }, {
        name: 'Unit',
        test: isUnit
      }, {
        name: 'string',
        test: isString
      }, {
        name: 'Chain',
        test: isChain
      }, {
        name: 'Array',
        test: isArray
      }, {
        name: 'Matrix',
        test: isMatrix
      }, {
        name: 'DenseMatrix',
        test: isDenseMatrix
      }, {
        name: 'SparseMatrix',
        test: isSparseMatrix
      }, {
        name: 'Range',
        test: isRange
      }, {
        name: 'Index',
        test: isIndex
      }, {
        name: 'boolean',
        test: isBoolean
      }, {
        name: 'ResultSet',
        test: isResultSet
      }, {
        name: 'Help',
        test: isHelp
      }, {
        name: 'function',
        test: isFunction
      }, {
        name: 'Date',
        test: isDate
      }, {
        name: 'RegExp',
        test: isRegExp
      }, {
        name: 'null',
        test: isNull
      }, {
        name: 'undefined',
        test: isUndefined
      }, {
        name: 'AccessorNode',
        test: isAccessorNode
      }, {
        name: 'ArrayNode',
        test: isArrayNode
      }, {
        name: 'AssignmentNode',
        test: isAssignmentNode
      }, {
        name: 'BlockNode',
        test: isBlockNode
      }, {
        name: 'ConditionalNode',
        test: isConditionalNode
      }, {
        name: 'ConstantNode',
        test: isConstantNode
      }, {
        name: 'FunctionNode',
        test: isFunctionNode
      }, {
        name: 'FunctionAssignmentNode',
        test: isFunctionAssignmentNode
      }, {
        name: 'IndexNode',
        test: isIndexNode
      }, {
        name: 'Node',
        test: isNode
      }, {
        name: 'ObjectNode',
        test: isObjectNode
      }, {
        name: 'OperatorNode',
        test: isOperatorNode
      }, {
        name: 'ParenthesisNode',
        test: isParenthesisNode
      }, {
        name: 'RangeNode',
        test: isRangeNode
      }, {
        name: 'SymbolNode',
        test: isSymbolNode
      }, {
        name: 'Map',
        test: isMap
      }, {
        name: 'Object',
        test: isObject
      } // order 'Object' last, it matches on other classes too
      ];

      typed.conversions = [{
        from: 'number',
        to: 'BigNumber',
        convert: function convert(x) {
          if (!BigNumber) {
            throwNoBignumber(x);
          } // note: conversion from number to BigNumber can fail if x has >15 digits

          if (digits(x) > 15) {
            throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');
          }
          return new BigNumber(x);
        }
      }, {
        from: 'number',
        to: 'Complex',
        convert: function convert(x) {
          if (!Complex) {
            throwNoComplex(x);
          }
          return new Complex(x, 0);
        }
      }, {
        from: 'number',
        to: 'string',
        convert: function convert(x) {
          return x + '';
        }
      }, {
        from: 'BigNumber',
        to: 'Complex',
        convert: function convert(x) {
          if (!Complex) {
            throwNoComplex(x);
          }
          return new Complex(x.toNumber(), 0);
        }
      }, {
        from: 'Fraction',
        to: 'BigNumber',
        convert: function convert(x) {
          throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
        }
      }, {
        from: 'Fraction',
        to: 'Complex',
        convert: function convert(x) {
          if (!Complex) {
            throwNoComplex(x);
          }
          return new Complex(x.valueOf(), 0);
        }
      }, {
        from: 'number',
        to: 'Fraction',
        convert: function convert(x) {
          if (!Fraction) {
            throwNoFraction(x);
          }
          var f = new Fraction(x);
          if (f.valueOf() !== x) {
            throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');
          }
          return f;
        }
      }, {
        // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
        //  from: 'Fraction',
        //  to: 'number',
        //  convert: function (x) {
        //    return x.valueOf()
        //  }
        // }, {
        from: 'string',
        to: 'number',
        convert: function convert(x) {
          var n = Number(x);
          if (isNaN(n)) {
            throw new Error('Cannot convert "' + x + '" to a number');
          }
          return n;
        }
      }, {
        from: 'string',
        to: 'BigNumber',
        convert: function convert(x) {
          if (!BigNumber) {
            throwNoBignumber(x);
          }
          try {
            return new BigNumber(x);
          } catch (err) {
            throw new Error('Cannot convert "' + x + '" to BigNumber');
          }
        }
      }, {
        from: 'string',
        to: 'Fraction',
        convert: function convert(x) {
          if (!Fraction) {
            throwNoFraction(x);
          }
          try {
            return new Fraction(x);
          } catch (err) {
            throw new Error('Cannot convert "' + x + '" to Fraction');
          }
        }
      }, {
        from: 'string',
        to: 'Complex',
        convert: function convert(x) {
          if (!Complex) {
            throwNoComplex(x);
          }
          try {
            return new Complex(x);
          } catch (err) {
            throw new Error('Cannot convert "' + x + '" to Complex');
          }
        }
      }, {
        from: 'boolean',
        to: 'number',
        convert: function convert(x) {
          return +x;
        }
      }, {
        from: 'boolean',
        to: 'BigNumber',
        convert: function convert(x) {
          if (!BigNumber) {
            throwNoBignumber(x);
          }
          return new BigNumber(+x);
        }
      }, {
        from: 'boolean',
        to: 'Fraction',
        convert: function convert(x) {
          if (!Fraction) {
            throwNoFraction(x);
          }
          return new Fraction(+x);
        }
      }, {
        from: 'boolean',
        to: 'string',
        convert: function convert(x) {
          return String(x);
        }
      }, {
        from: 'Array',
        to: 'Matrix',
        convert: function convert(array) {
          if (!DenseMatrix) {
            throwNoMatrix();
          }
          return new DenseMatrix(array);
        }
      }, {
        from: 'Matrix',
        to: 'Array',
        convert: function convert(matrix) {
          return matrix.valueOf();
        }
      }];
      return typed;
    });
    function throwNoBignumber(x) {
      throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
    }
    function throwNoComplex(x) {
      throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
    }
    function throwNoMatrix() {
      throw new Error('Cannot convert array into a Matrix: no class \'DenseMatrix\' provided');
    }
    function throwNoFraction(x) {
      throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
    }

    /*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     */


    // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


      // The maximum exponent magnitude.
      // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
    var EXP_LIMIT = 9e15,                      // 0 to 9e15

      // The limit on the value of `precision`, and on the value of the first argument to
      // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
      MAX_DIGITS = 1e9,                        // 0 to 1e9

      // Base conversion alphabet.
      NUMERALS = '0123456789abcdef',

      // The natural logarithm of 10 (1025 digits).
      LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

      // Pi (1025 digits).
      PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


      // The initial configuration properties of the Decimal constructor.
      DEFAULTS = {

        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.

        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,                         // 1 to MAX_DIGITS

        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,                           // 0 to 8

        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,                             // 0 to 9

        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,                          // 0 to -EXP_LIMIT

        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos:  21,                         // 0 to EXP_LIMIT

        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false                          // true/false
      },


    // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


      inexact, quadrant,
      external = true,

      decimalError = '[DecimalError] ',
      invalidArgument = decimalError + 'Invalid argument: ',
      precisionLimitExceeded = decimalError + 'Precision limit exceeded',
      cryptoUnavailable = decimalError + 'crypto unavailable',
      tag = '[object Decimal]',

      mathfloor = Math.floor,
      mathpow = Math.pow,

      isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
      isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
      isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
      isDecimal$2 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

      BASE = 1e7,
      LOG_BASE = 7,
      MAX_SAFE_INTEGER = 9007199254740991,

      LN10_PRECISION = LN10.length - 1,
      PI_PRECISION = PI.length - 1,

      // Decimal.prototype object
      P = { toStringTag: tag };


    // Decimal prototype methods


    /*
     *  absoluteValue             abs
     *  ceil
     *  clampedTo                 clamp
     *  comparedTo                cmp
     *  cosine                    cos
     *  cubeRoot                  cbrt
     *  decimalPlaces             dp
     *  dividedBy                 div
     *  dividedToIntegerBy        divToInt
     *  equals                    eq
     *  floor
     *  greaterThan               gt
     *  greaterThanOrEqualTo      gte
     *  hyperbolicCosine          cosh
     *  hyperbolicSine            sinh
     *  hyperbolicTangent         tanh
     *  inverseCosine             acos
     *  inverseHyperbolicCosine   acosh
     *  inverseHyperbolicSine     asinh
     *  inverseHyperbolicTangent  atanh
     *  inverseSine               asin
     *  inverseTangent            atan
     *  isFinite
     *  isInteger                 isInt
     *  isNaN
     *  isNegative                isNeg
     *  isPositive                isPos
     *  isZero
     *  lessThan                  lt
     *  lessThanOrEqualTo         lte
     *  logarithm                 log
     *  [maximum]                 [max]
     *  [minimum]                 [min]
     *  minus                     sub
     *  modulo                    mod
     *  naturalExponential        exp
     *  naturalLogarithm          ln
     *  negated                   neg
     *  plus                      add
     *  precision                 sd
     *  round
     *  sine                      sin
     *  squareRoot                sqrt
     *  tangent                   tan
     *  times                     mul
     *  toBinary
     *  toDecimalPlaces           toDP
     *  toExponential
     *  toFixed
     *  toFraction
     *  toHexadecimal             toHex
     *  toNearest
     *  toNumber
     *  toOctal
     *  toPower                   pow
     *  toPrecision
     *  toSignificantDigits       toSD
     *  toString
     *  truncated                 trunc
     *  valueOf                   toJSON
     */


    /*
     * Return a new Decimal whose value is the absolute value of this Decimal.
     *
     */
    P.absoluteValue = P.abs = function () {
      var x = new this.constructor(this);
      if (x.s < 0) x.s = 1;
      return finalise(x);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
     * direction of positive Infinity.
     *
     */
    P.ceil = function () {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal clamped to the range
     * delineated by `min` and `max`.
     *
     * min {number|string|Decimal}
     * max {number|string|Decimal}
     *
     */
    P.clampedTo = P.clamp = function (min, max) {
      var k,
        x = this,
        Ctor = x.constructor;
      min = new Ctor(min);
      max = new Ctor(max);
      if (!min.s || !max.s) return new Ctor(NaN);
      if (min.gt(max)) throw Error(invalidArgument + max);
      k = x.cmp(min);
      return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
    };


    /*
     * Return
     *   1    if the value of this Decimal is greater than the value of `y`,
     *  -1    if the value of this Decimal is less than the value of `y`,
     *   0    if they have the same value,
     *   NaN  if the value of either Decimal is NaN.
     *
     */
    P.comparedTo = P.cmp = function (y) {
      var i, j, xdL, ydL,
        x = this,
        xd = x.d,
        yd = (y = new x.constructor(y)).d,
        xs = x.s,
        ys = y.s;

      // Either NaN or ±Infinity?
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }

      // Either zero?
      if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

      // Signs differ?
      if (xs !== ys) return xs;

      // Compare exponents.
      if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

      xdL = xd.length;
      ydL = yd.length;

      // Compare digit by digit.
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }

      // Compare lengths.
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };


    /*
     * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * cos(0)         = 1
     * cos(-0)        = 1
     * cos(Infinity)  = NaN
     * cos(-Infinity) = NaN
     * cos(NaN)       = NaN
     *
     */
    P.cosine = P.cos = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.d) return new Ctor(NaN);

      // cos(0) = cos(-0) = 1
      if (!x.d[0]) return new Ctor(1);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;

      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };


    /*
     *
     * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     *  cbrt(0)  =  0
     *  cbrt(-0) = -0
     *  cbrt(1)  =  1
     *  cbrt(-1) = -1
     *  cbrt(N)  =  N
     *  cbrt(-I) = -I
     *  cbrt(I)  =  I
     *
     * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
     *
     */
    P.cubeRoot = P.cbrt = function () {
      var e, m, n, r, rep, s, sd, t, t3, t3plusx,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      external = false;

      // Initial estimate.
      s = x.s * mathpow(x.s * x, 1 / 3);

       // Math.cbrt underflow/overflow?
       // Pass x to Math.pow as integer, then adjust the exponent of the result.
      if (!s || Math.abs(s) == 1 / 0) {
        n = digitsToString(x.d);
        e = x.e;

        // Adjust n exponent so it is a multiple of 3 away from x exponent.
        if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
        s = mathpow(n, 1 / 3);

        // Rarely, e may be one less than the result exponent value.
        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new Ctor(n);
        r.s = x.s;
      } else {
        r = new Ctor(s.toString());
      }

      sd = (e = Ctor.precision) + 3;

      // Halley's method.
      // TODO? Compare Newton's method.
      for (;;) {
        t = r;
        t3 = t.times(t).times(t);
        t3plusx = t3.plus(x);
        r = divide$1(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

        // TODO? Replace with for-loop and checkRoundingDigits.
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
          // , i.e. approaching a rounding boundary, continue the iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the exact result as the
            // nines may infinitely repeat.
            if (!rep) {
              finalise(t, e + 1, 0);

              if (t.times(t).times(t).eq(x)) {
                r = t;
                break;
              }
            }

            sd += 4;
            rep = 1;
          } else {

            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
            // If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              finalise(r, e + 1, 1);
              m = !r.times(r).times(r).eq(x);
            }

            break;
          }
        }
      }

      external = true;

      return finalise(r, e, Ctor.rounding, m);
    };


    /*
     * Return the number of decimal places of the value of this Decimal.
     *
     */
    P.decimalPlaces = P.dp = function () {
      var w,
        d = this.d,
        n = NaN;

      if (d) {
        w = d.length - 1;
        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

        // Subtract the number of trailing zeros of the last word.
        w = d[w];
        if (w) for (; w % 10 == 0; w /= 10) n--;
        if (n < 0) n = 0;
      }

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.dividedBy = P.div = function (y) {
      return divide$1(this, new this.constructor(y));
    };


    /*
     * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
     * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.dividedToIntegerBy = P.divToInt = function (y) {
      var x = this,
        Ctor = x.constructor;
      return finalise(divide$1(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };


    /*
     * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
     *
     */
    P.equals = P.eq = function (y) {
      return this.cmp(y) === 0;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
     * direction of negative Infinity.
     *
     */
    P.floor = function () {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };


    /*
     * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
     * false.
     *
     */
    P.greaterThan = P.gt = function (y) {
      return this.cmp(y) > 0;
    };


    /*
     * Return true if the value of this Decimal is greater than or equal to the value of `y`,
     * otherwise return false.
     *
     */
    P.greaterThanOrEqualTo = P.gte = function (y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };


    /*
     * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [1, Infinity]
     *
     * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
     *
     * cosh(0)         = 1
     * cosh(-0)        = 1
     * cosh(Infinity)  = Infinity
     * cosh(-Infinity) = Infinity
     * cosh(NaN)       = NaN
     *
     *  x        time taken (ms)   result
     * 1000      9                 9.8503555700852349694e+433
     * 10000     25                4.4034091128314607936e+4342
     * 100000    171               1.4033316802130615897e+43429
     * 1000000   3817              1.5166076984010437725e+434294
     * 10000000  abandoned after 2 minute wait
     *
     * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
     *
     */
    P.hyperbolicCosine = P.cosh = function () {
      var k, n, pr, rm, len,
        x = this,
        Ctor = x.constructor,
        one = new Ctor(1);

      if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero()) return one;

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;

      // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
      // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

      // Estimate the optimum number of times to use the argument reduction.
      // TODO? Estimation reused from cosine() and may not be optimal here.
      if (len < 32) {
        k = Math.ceil(len / 3);
        n = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n = '2.3283064365386962890625e-10';
      }

      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

      // Reverse argument reduction
      var cosh2_x,
        i = k,
        d8 = new Ctor(8);
      for (; i--;) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }

      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };


    /*
     * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
     *
     * sinh(0)         = 0
     * sinh(-0)        = -0
     * sinh(Infinity)  = Infinity
     * sinh(-Infinity) = -Infinity
     * sinh(NaN)       = NaN
     *
     * x        time taken (ms)
     * 10       2 ms
     * 100      5 ms
     * 1000     14 ms
     * 10000    82 ms
     * 100000   886 ms            1.4033316802130615897e+43429
     * 200000   2613 ms
     * 300000   5407 ms
     * 400000   8824 ms
     * 500000   13026 ms          8.7080643612718084129e+217146
     * 1000000  48543 ms
     *
     * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
     *
     */
    P.hyperbolicSine = P.sinh = function () {
      var k, pr, rm, len,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;

      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {

        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
        // 3 multiplications and 1 addition

        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
        // 4 multiplications and 2 additions

        // Estimate the optimum number of times to use the argument reduction.
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;

        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);

        // Reverse argument reduction
        var sinh2_x,
          d5 = new Ctor(5),
          d16 = new Ctor(16),
          d20 = new Ctor(20);
        for (; k--;) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(x, pr, rm, true);
    };


    /*
     * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * tanh(x) = sinh(x) / cosh(x)
     *
     * tanh(0)         = 0
     * tanh(-0)        = -0
     * tanh(Infinity)  = 1
     * tanh(-Infinity) = -1
     * tanh(NaN)       = NaN
     *
     */
    P.hyperbolicTangent = P.tanh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(x.s);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;

      return divide$1(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };


    /*
     * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
     * this Decimal.
     *
     * Domain: [-1, 1]
     * Range: [0, pi]
     *
     * acos(x) = pi/2 - asin(x)
     *
     * acos(0)       = pi/2
     * acos(-0)      = pi/2
     * acos(1)       = 0
     * acos(-1)      = pi
     * acos(1/2)     = pi/3
     * acos(-1/2)    = 2*pi/3
     * acos(|x| > 1) = NaN
     * acos(NaN)     = NaN
     *
     */
    P.inverseCosine = P.acos = function () {
      var halfPi,
        x = this,
        Ctor = x.constructor,
        k = x.abs().cmp(1),
        pr = Ctor.precision,
        rm = Ctor.rounding;

      if (k !== -1) {
        return k === 0
          // |x| is 1
          ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
          // |x| > 1 or x is NaN
          : new Ctor(NaN);
      }

      if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

      // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

      Ctor.precision = pr + 6;
      Ctor.rounding = 1;

      x = x.asin();
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return halfPi.minus(x);
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
     * value of this Decimal.
     *
     * Domain: [1, Infinity]
     * Range: [0, Infinity]
     *
     * acosh(x) = ln(x + sqrt(x^2 - 1))
     *
     * acosh(x < 1)     = NaN
     * acosh(NaN)       = NaN
     * acosh(Infinity)  = Infinity
     * acosh(-Infinity) = NaN
     * acosh(0)         = NaN
     * acosh(-0)        = NaN
     * acosh(1)         = 0
     * acosh(-1)        = NaN
     *
     */
    P.inverseHyperbolicCosine = P.acosh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;

      x = x.times(x).minus(1).sqrt().plus(x);

      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.ln();
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
     * of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * asinh(x) = ln(x + sqrt(x^2 + 1))
     *
     * asinh(NaN)       = NaN
     * asinh(Infinity)  = Infinity
     * asinh(-Infinity) = -Infinity
     * asinh(0)         = 0
     * asinh(-0)        = -0
     *
     */
    P.inverseHyperbolicSine = P.asinh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;

      x = x.times(x).plus(1).sqrt().plus(x);

      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.ln();
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
     * value of this Decimal.
     *
     * Domain: [-1, 1]
     * Range: [-Infinity, Infinity]
     *
     * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
     *
     * atanh(|x| > 1)   = NaN
     * atanh(NaN)       = NaN
     * atanh(Infinity)  = NaN
     * atanh(-Infinity) = NaN
     * atanh(0)         = 0
     * atanh(-0)        = -0
     * atanh(1)         = Infinity
     * atanh(-1)        = -Infinity
     *
     */
    P.inverseHyperbolicTangent = P.atanh = function () {
      var pr, rm, wpr, xsd,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();

      if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

      Ctor.precision = wpr = xsd - x.e;

      x = divide$1(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

      Ctor.precision = pr + 4;
      Ctor.rounding = 1;

      x = x.ln();

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.times(0.5);
    };


    /*
     * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi/2, pi/2]
     *
     * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
     *
     * asin(0)       = 0
     * asin(-0)      = -0
     * asin(1/2)     = pi/6
     * asin(-1/2)    = -pi/6
     * asin(1)       = pi/2
     * asin(-1)      = -pi/2
     * asin(|x| > 1) = NaN
     * asin(NaN)     = NaN
     *
     * TODO? Compare performance of Taylor series.
     *
     */
    P.inverseSine = P.asin = function () {
      var halfPi, k,
        pr, rm,
        x = this,
        Ctor = x.constructor;

      if (x.isZero()) return new Ctor(x);

      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;

      if (k !== -1) {

        // |x| is 1
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }

        // |x| > 1 or x is NaN
        return new Ctor(NaN);
      }

      // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

      Ctor.precision = pr + 6;
      Ctor.rounding = 1;

      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.times(2);
    };


    /*
     * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
     * of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi/2, pi/2]
     *
     * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
     *
     * atan(0)         = 0
     * atan(-0)        = -0
     * atan(1)         = pi/4
     * atan(-1)        = -pi/4
     * atan(Infinity)  = pi/2
     * atan(-Infinity) = -pi/2
     * atan(NaN)       = NaN
     *
     */
    P.inverseTangent = P.atan = function () {
      var i, j, k, n, px, t, r, wpr, x2,
        x = this,
        Ctor = x.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding;

      if (!x.isFinite()) {
        if (!x.s) return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.5);
          r.s = x.s;
          return r;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.25);
        r.s = x.s;
        return r;
      }

      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;

      // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

      // Argument reduction
      // Ensure |x| < 0.42
      // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

      k = Math.min(28, wpr / LOG_BASE + 2 | 0);

      for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

      external = false;

      j = Math.ceil(wpr / LOG_BASE);
      n = 1;
      x2 = x.times(x);
      r = new Ctor(x);
      px = x;

      // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
      for (; i !== -1;) {
        px = px.times(x2);
        t = r.minus(px.div(n += 2));

        px = px.times(x2);
        r = t.plus(px.div(n += 2));

        if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
      }

      if (k) r = r.times(2 << (k - 1));

      external = true;

      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
    };


    /*
     * Return true if the value of this Decimal is a finite number, otherwise return false.
     *
     */
    P.isFinite = function () {
      return !!this.d;
    };


    /*
     * Return true if the value of this Decimal is an integer, otherwise return false.
     *
     */
    P.isInteger = P.isInt = function () {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };


    /*
     * Return true if the value of this Decimal is NaN, otherwise return false.
     *
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this Decimal is negative, otherwise return false.
     *
     */
    P.isNegative = P.isNeg = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this Decimal is positive, otherwise return false.
     *
     */
    P.isPositive = P.isPos = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this Decimal is 0 or -0, otherwise return false.
     *
     */
    P.isZero = function () {
      return !!this.d && this.d[0] === 0;
    };


    /*
     * Return true if the value of this Decimal is less than `y`, otherwise return false.
     *
     */
    P.lessThan = P.lt = function (y) {
      return this.cmp(y) < 0;
    };


    /*
     * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
     *
     */
    P.lessThanOrEqualTo = P.lte = function (y) {
      return this.cmp(y) < 1;
    };


    /*
     * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * If no base is specified, return log[10](arg).
     *
     * log[base](arg) = ln(arg) / ln(base)
     *
     * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
     * otherwise:
     *
     * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
     * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
     * between the result and the correctly rounded result will be one ulp (unit in the last place).
     *
     * log[-b](a)       = NaN
     * log[0](a)        = NaN
     * log[1](a)        = NaN
     * log[NaN](a)      = NaN
     * log[Infinity](a) = NaN
     * log[b](0)        = -Infinity
     * log[b](-0)       = -Infinity
     * log[b](-a)       = NaN
     * log[b](1)        = 0
     * log[b](Infinity) = Infinity
     * log[b](NaN)      = NaN
     *
     * [base] {number|string|Decimal} The base of the logarithm.
     *
     */
    P.logarithm = P.log = function (base) {
      var isBase10, d, denominator, k, inf, num, sd, r,
        arg = this,
        Ctor = arg.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding,
        guard = 5;

      // Default base is 10.
      if (base == null) {
        base = new Ctor(10);
        isBase10 = true;
      } else {
        base = new Ctor(base);
        d = base.d;

        // Return NaN if base is negative, or non-finite, or is 0 or 1.
        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

        isBase10 = base.eq(10);
      }

      d = arg.d;

      // Is arg negative, non-finite, 0 or 1?
      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
      }

      // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
      // integer power of 10.
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0;) k /= 10;
          inf = k !== 1;
        }
      }

      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

      // The result will have 5 rounding digits.
      r = divide$1(num, denominator, sd, 1);

      // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
      // calculate 10 further digits.
      //
      // If the result is known to have an infinite decimal expansion, repeat this until it is clear
      // that the result is above or below the boundary. Otherwise, if after calculating the 10
      // further digits, the last 14 are nines, round up and assume the result is exact.
      // Also assume the result is exact if the last 14 are zero.
      //
      // Example of a result that will be incorrectly rounded:
      // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
      // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
      // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
      // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
      // place is still 2.6.
      if (checkRoundingDigits(r.d, k = pr, rm)) {

        do {
          sd += 10;
          num = naturalLogarithm(arg, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
          r = divide$1(num, denominator, sd, 1);

          if (!inf) {

            // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }

            break;
          }
        } while (checkRoundingDigits(r.d, k += 10, rm));
      }

      external = true;

      return finalise(r, pr, rm);
    };


    /*
     * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
     *
     * arguments {number|string|Decimal}
     *
    P.max = function () {
      Array.prototype.push.call(arguments, this);
      return maxOrMin(this.constructor, arguments, 'lt');
    };
     */


    /*
     * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
     *
     * arguments {number|string|Decimal}
     *
    P.min = function () {
      Array.prototype.push.call(arguments, this);
      return maxOrMin(this.constructor, arguments, 'gt');
    };
     */


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.minus = P.sub = function (y) {
      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // If either is not finite...
      if (!x.d || !y.d) {

        // Return NaN if either is NaN.
        if (!x.s || !y.s) y = new Ctor(NaN);

        // Return y negated if x is finite and y is ±Infinity.
        else if (x.d) y.s = -y.s;

        // Return x if y is finite and x is ±Infinity.
        // Return x if both are ±Infinity with different signs.
        // Return NaN if both are ±Infinity with the same sign.
        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

        return y;
      }

      // If signs differ...
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }

      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;

      // If either is zero...
      if (!xd[0] || !yd[0]) {

        // Return y negated if x is zero and y is non-zero.
        if (yd[0]) y.s = -y.s;

        // Return x if y is zero and x is non-zero.
        else if (xd[0]) y = new Ctor(x);

        // Return zero if both are zero.
        // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
        else return new Ctor(rm === 3 ? -0 : 0);

        return external ? finalise(y, pr, rm) : y;
      }

      // x and y are finite, non-zero numbers with the same sign.

      // Calculate base 1e7 exponents.
      e = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);

      xd = xd.slice();
      k = xe - e;

      // If base 1e7 exponents differ...
      if (k) {
        xLTy = k < 0;

        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e = xe;
          len = xd.length;
        }

        // Numbers with massively different exponents would result in a very high number of
        // zeros needing to be prepended, but this can be avoided while still ensuring correct
        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

        if (k > i) {
          k = i;
          d.length = 1;
        }

        // Prepend zeros to equalise exponents.
        d.reverse();
        for (i = k; i--;) d.push(0);
        d.reverse();

      // Base 1e7 exponents equal.
      } else {

        // Check digits to determine which is the bigger number.

        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy) len = i;

        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }

        k = 0;
      }

      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }

      len = xd.length;

      // Append zeros to `xd` if shorter.
      // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
      for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

      // Subtract yd from xd.
      for (i = yd.length; i > k;) {

        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }

        xd[i] -= yd[i];
      }

      // Remove trailing zeros.
      for (; xd[--len] === 0;) xd.pop();

      // Remove leading zeros and adjust exponent accordingly.
      for (; xd[0] === 0; xd.shift()) --e;

      // Zero?
      if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

      y.d = xd;
      y.e = getBase10Exponent(xd, e);

      return external ? finalise(y, pr, rm) : y;
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * The result depends on the modulo mode.
     *
     */
    P.modulo = P.mod = function (y) {
      var q,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
      if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

      // Return x if y is ±Infinity or x is ±0.
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }

      // Prevent rounding of intermediate calculations.
      external = false;

      if (Ctor.modulo == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // result = x - q * y    where  0 <= result < abs(y)
        q = divide$1(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide$1(x, y, 0, Ctor.modulo, 1);
      }

      q = q.times(y);

      external = true;

      return x.minus(q);
    };


    /*
     * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
     * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.naturalExponential = P.exp = function () {
      return naturalExponential(this);
    };


    /*
     * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
     * rounded to `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.naturalLogarithm = P.ln = function () {
      return naturalLogarithm(this);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
     * -1.
     *
     */
    P.negated = P.neg = function () {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.plus = P.add = function (y) {
      var carry, d, e, i, k, len, pr, rm, xd, yd,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // If either is not finite...
      if (!x.d || !y.d) {

        // Return NaN if either is NaN.
        if (!x.s || !y.s) y = new Ctor(NaN);

        // Return x if y is finite and x is ±Infinity.
        // Return x if both are ±Infinity with the same sign.
        // Return NaN if both are ±Infinity with different signs.
        // Return y if x is finite and y is ±Infinity.
        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

        return y;
      }

       // If signs differ...
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }

      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;

      // If either is zero...
      if (!xd[0] || !yd[0]) {

        // Return x if y is zero.
        // Return y if y is non-zero.
        if (!yd[0]) y = new Ctor(x);

        return external ? finalise(y, pr, rm) : y;
      }

      // x and y are finite, non-zero numbers with the same sign.

      // Calculate base 1e7 exponents.
      k = mathfloor(x.e / LOG_BASE);
      e = mathfloor(y.e / LOG_BASE);

      xd = xd.slice();
      i = k - e;

      // If base 1e7 exponents differ...
      if (i) {

        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e = k;
          len = xd.length;
        }

        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;

        if (i > len) {
          i = len;
          d.length = 1;
        }

        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
        d.reverse();
        for (; i--;) d.push(0);
        d.reverse();
      }

      len = xd.length;
      i = yd.length;

      // If yd is longer than xd, swap xd and yd so xd points to the longer array.
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }

      // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
      for (carry = 0; i;) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }

      if (carry) {
        xd.unshift(carry);
        ++e;
      }

      // Remove trailing zeros.
      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      for (len = xd.length; xd[--len] == 0;) xd.pop();

      y.d = xd;
      y.e = getBase10Exponent(xd, e);

      return external ? finalise(y, pr, rm) : y;
    };


    /*
     * Return the number of significant digits of the value of this Decimal.
     *
     * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
     *
     */
    P.precision = P.sd = function (z) {
      var k,
        x = this;

      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k) k = x.e + 1;
      } else {
        k = NaN;
      }

      return k;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
     * rounding mode `rounding`.
     *
     */
    P.round = function () {
      var x = this,
        Ctor = x.constructor;

      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };


    /*
     * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * sin(x) = x - x^3/3! + x^5/5! - ...
     *
     * sin(0)         = 0
     * sin(-0)        = -0
     * sin(Infinity)  = NaN
     * sin(-Infinity) = NaN
     * sin(NaN)       = NaN
     *
     */
    P.sine = P.sin = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;

      x = sine(Ctor, toLessThanHalfPi(Ctor, x));

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };


    /*
     * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     *  sqrt(-n) =  N
     *  sqrt(N)  =  N
     *  sqrt(-I) =  N
     *  sqrt(I)  =  I
     *  sqrt(0)  =  0
     *  sqrt(-0) = -0
     *
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, sd, r, rep, t,
        x = this,
        d = x.d,
        e = x.e,
        s = x.s,
        Ctor = x.constructor;

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !d || !d[0]) {
        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }

      external = false;

      // Initial estimate.
      s = Math.sqrt(+x);

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(d);

        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }

      sd = (e = Ctor.precision) + 3;

      // Newton-Raphson iteration.
      for (;;) {
        t = r;
        r = t.plus(divide$1(x, t, sd + 2, 1)).times(0.5);

        // TODO? Replace with for-loop and checkRoundingDigits.
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
          // 4999, i.e. approaching a rounding boundary, continue the iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the exact result as the
            // nines may infinitely repeat.
            if (!rep) {
              finalise(t, e + 1, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            sd += 4;
            rep = 1;
          } else {

            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
            // If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              finalise(r, e + 1, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }

      external = true;

      return finalise(r, e, Ctor.rounding, m);
    };


    /*
     * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * tan(0)         = 0
     * tan(-0)        = -0
     * tan(Infinity)  = NaN
     * tan(-Infinity) = NaN
     * tan(NaN)       = NaN
     *
     */
    P.tangent = P.tan = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;

      x = x.sin();
      x.s = 1;
      x = divide$1(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     */
    P.times = P.mul = function (y) {
      var carry, e, i, k, r, rL, t, xdL, ydL,
        x = this,
        Ctor = x.constructor,
        xd = x.d,
        yd = (y = new Ctor(y)).d;

      y.s *= x.s;

       // If either is NaN, ±Infinity or ±0...
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

          // Return NaN if either is NaN.
          // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
          ? NaN

          // Return ±Infinity if either is ±Infinity.
          // Return ±0 if either is ±0.
          : !xd || !yd ? y.s / 0 : y.s * 0);
      }

      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;

      // Ensure xd points to the longer array.
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }

      // Initialise the result array with zeros.
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--;) r.push(0);

      // Multiply!
      for (i = ydL; --i >= 0;) {
        carry = 0;
        for (k = xdL + i; k > i;) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }

        r[k] = (r[k] + carry) % BASE | 0;
      }

      // Remove trailing zeros.
      for (; !r[--rL];) r.pop();

      if (carry) ++e;
      else r.shift();

      y.d = r;
      y.e = getBase10Exponent(r, e);

      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };


    /*
     * Return a string representing the value of this Decimal in base 2, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toBinary = function (sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
     * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
     *
     * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toDecimalPlaces = P.toDP = function (dp, rm) {
      var x = this,
        Ctor = x.constructor;

      x = new Ctor(x);
      if (dp === void 0) return x;

      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      return finalise(x, dp + x.e + 1, rm);
    };


    /*
     * Return a string representing the value of this Decimal in exponential notation rounded to
     * `dp` fixed decimal places using rounding mode `rounding`.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toExponential = function (dp, rm) {
      var str,
        x = this,
        Ctor = x.constructor;

      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a string representing the value of this Decimal in normal (fixed-point) notation to
     * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
     * omitted.
     *
     * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
     * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
     * (-0).toFixed(3) is '0.000'.
     * (-0.5).toFixed(0) is '-0'.
     *
     */
    P.toFixed = function (dp, rm) {
      var str, y,
        x = this,
        Ctor = x.constructor;

      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }

      // To determine whether to add the minus sign look at the value before it was rounded,
      // i.e. look at `x` rather than `y`.
      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return an array representing the value of this Decimal as a simple fraction with an integer
     * numerator and an integer denominator.
     *
     * The denominator will be a positive non-zero value less than or equal to the specified maximum
     * denominator. If a maximum denominator is not specified, the denominator will be the lowest
     * value necessary to represent the number exactly.
     *
     * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
     *
     */
    P.toFraction = function (maxD) {
      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
        x = this,
        xd = x.d,
        Ctor = x.constructor;

      if (!xd) return new Ctor(x);

      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);

      d = new Ctor(d1);
      e = d.e = getPrecision(xd) - x.e - 1;
      k = e % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

      if (maxD == null) {

        // d is 10**e, the minimum max-denominator needed.
        maxD = e > 0 ? d : n1;
      } else {
        n = new Ctor(maxD);
        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
        maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
      }

      external = false;
      n = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e = xd.length * LOG_BASE * 2;

      for (;;)  {
        q = divide$1(n, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1) break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n.minus(q.times(d2));
        n = d2;
      }

      d2 = divide$1(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;

      // Determine which fraction is closer to x, n0/d0 or n1/d1?
      r = divide$1(n1, d1, e, 1).minus(x).abs().cmp(divide$1(n0, d0, e, 1).minus(x).abs()) < 1
          ? [n1, d1] : [n0, d0];

      Ctor.precision = pr;
      external = true;

      return r;
    };


    /*
     * Return a string representing the value of this Decimal in base 16, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toHexadecimal = P.toHex = function (sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };


    /*
     * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
     * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
     *
     * The return value will always have the same sign as this Decimal, unless either this Decimal
     * or `y` is NaN, in which case the return value will be also be NaN.
     *
     * The return value is not affected by the value of `precision`.
     *
     * y {number|string|Decimal} The magnitude to round to a multiple of.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toNearest() rounding mode not an integer: {rm}'
     * 'toNearest() rounding mode out of range: {rm}'
     *
     */
    P.toNearest = function (y, rm) {
      var x = this,
        Ctor = x.constructor;

      x = new Ctor(x);

      if (y == null) {

        // If x is not finite, return x.
        if (!x.d) return x;

        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }

        // If x is not finite, return x if y is not NaN, else NaN.
        if (!x.d) return y.s ? x : y;

        // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
        if (!y.d) {
          if (y.s) y.s = x.s;
          return y;
        }
      }

      // If y is not zero, calculate the nearest multiple of y to x.
      if (y.d[0]) {
        external = false;
        x = divide$1(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);

      // If y is zero, return zero with the sign of x.
      } else {
        y.s = x.s;
        x = y;
      }

      return x;
    };


    /*
     * Return the value of this Decimal converted to a number primitive.
     * Zero keeps its sign.
     *
     */
    P.toNumber = function () {
      return +this;
    };


    /*
     * Return a string representing the value of this Decimal in base 8, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toOctal = function (sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
     * to `precision` significant digits using rounding mode `rounding`.
     *
     * ECMAScript compliant.
     *
     *   pow(x, NaN)                           = NaN
     *   pow(x, ±0)                            = 1

     *   pow(NaN, non-zero)                    = NaN
     *   pow(abs(x) > 1, +Infinity)            = +Infinity
     *   pow(abs(x) > 1, -Infinity)            = +0
     *   pow(abs(x) == 1, ±Infinity)           = NaN
     *   pow(abs(x) < 1, +Infinity)            = +0
     *   pow(abs(x) < 1, -Infinity)            = +Infinity
     *   pow(+Infinity, y > 0)                 = +Infinity
     *   pow(+Infinity, y < 0)                 = +0
     *   pow(-Infinity, odd integer > 0)       = -Infinity
     *   pow(-Infinity, even integer > 0)      = +Infinity
     *   pow(-Infinity, odd integer < 0)       = -0
     *   pow(-Infinity, even integer < 0)      = +0
     *   pow(+0, y > 0)                        = +0
     *   pow(+0, y < 0)                        = +Infinity
     *   pow(-0, odd integer > 0)              = -0
     *   pow(-0, even integer > 0)             = +0
     *   pow(-0, odd integer < 0)              = -Infinity
     *   pow(-0, even integer < 0)             = +Infinity
     *   pow(finite x < 0, finite non-integer) = NaN
     *
     * For non-integer or very large exponents pow(x, y) is calculated using
     *
     *   x^y = exp(y*ln(x))
     *
     * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
     * probability of an incorrectly rounded result
     * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
     * i.e. 1 in 250,000,000,000,000
     *
     * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
     *
     * y {number|string|Decimal} The power to which to raise this Decimal.
     *
     */
    P.toPower = P.pow = function (y) {
      var e, k, pr, r, rm, s,
        x = this,
        Ctor = x.constructor,
        yn = +(y = new Ctor(y));

      // Either ±Infinity, NaN or ±0?
      if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

      x = new Ctor(x);

      if (x.eq(1)) return x;

      pr = Ctor.precision;
      rm = Ctor.rounding;

      if (y.eq(1)) return finalise(x, pr, rm);

      // y exponent
      e = mathfloor(y.e / LOG_BASE);

      // If y is a small integer use the 'exponentiation by squaring' algorithm.
      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
      }

      s = x.s;

      // if x is negative
      if (s < 0) {

        // if y is not an integer
        if (e < y.d.length - 1) return new Ctor(NaN);

        // Result is positive if x is negative and the last digit of integer y is even.
        if ((y.d[e] & 1) == 0) s = 1;

        // if x.eq(-1)
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s;
          return x;
        }
      }

      // Estimate result exponent.
      // x^y = 10^e,  where e = y * log10(x)
      // log10(x) = log10(x_significand) + x_exponent
      // log10(x_significand) = ln(x_significand) / ln(10)
      k = mathpow(+x, yn);
      e = k == 0 || !isFinite(k)
        ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
        : new Ctor(k + '').e;

      // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

      // Overflow/underflow?
      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

      external = false;
      Ctor.rounding = x.s = 1;

      // Estimate the extra guard digits needed to ensure five correct rounding digits from
      // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
      // new Decimal(2.32456).pow('2087987436534566.46411')
      // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
      k = Math.min(12, (e + '').length);

      // r = x^y = exp(y*ln(x))
      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

      // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
      if (r.d) {

        // Truncate to the required precision plus five rounding digits.
        r = finalise(r, pr + 5, 1);

        // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
        // the result.
        if (checkRoundingDigits(r.d, pr, rm)) {
          e = pr + 10;

          // Truncate to the increased precision plus five rounding digits.
          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

          // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
        }
      }

      r.s = s;
      external = true;
      Ctor.rounding = rm;

      return finalise(r, pr, rm);
    };


    /*
     * Return a string representing the value of this Decimal rounded to `sd` significant digits
     * using rounding mode `rounding`.
     *
     * Return exponential notation if `sd` is less than the number of digits necessary to represent
     * the integer part of the value in normal notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toPrecision = function (sd, rm) {
      var str,
        x = this,
        Ctor = x.constructor;

      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
     * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
     * omitted.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toSD() digits out of range: {sd}'
     * 'toSD() digits not an integer: {sd}'
     * 'toSD() rounding mode not an integer: {rm}'
     * 'toSD() rounding mode out of range: {rm}'
     *
     */
    P.toSignificantDigits = P.toSD = function (sd, rm) {
      var x = this,
        Ctor = x.constructor;

      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      }

      return finalise(new Ctor(x), sd, rm);
    };


    /*
     * Return a string representing the value of this Decimal.
     *
     * Return exponential notation if this Decimal has a positive exponent equal to or greater than
     * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
     *
     */
    P.toString = function () {
      var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
     *
     */
    P.truncated = P.trunc = function () {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };


    /*
     * Return a string representing the value of this Decimal.
     * Unlike `toString`, negative zero will include the minus sign.
     *
     */
    P.valueOf = P.toJSON = function () {
      var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

      return x.isNeg() ? '-' + str : str;
    };


    // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


    /*
     *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
     *                           finiteToString, naturalExponential, naturalLogarithm
     *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
     *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
     *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
     *  convertBase              toStringBinary, parseOther
     *  cos                      P.cos
     *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
     *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
     *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
     *                           taylorSeries, atan2, parseOther
     *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
     *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
     *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
     *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
     *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
     *                           P.truncated, divide, getLn10, getPi, naturalExponential,
     *                           naturalLogarithm, ceil, floor, round, trunc
     *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
     *                           toStringBinary
     *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
     *  getLn10                  P.logarithm, naturalLogarithm
     *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
     *  getPrecision             P.precision, P.toFraction
     *  getZeroString            digitsToString, finiteToString
     *  intPow                   P.toPower, parseOther
     *  isOdd                    toLessThanHalfPi
     *  maxOrMin                 max, min
     *  naturalExponential       P.naturalExponential, P.toPower
     *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
     *                           P.toPower, naturalExponential
     *  nonFiniteToString        finiteToString, toStringBinary
     *  parseDecimal             Decimal
     *  parseOther               Decimal
     *  sin                      P.sin
     *  taylorSeries             P.cosh, P.sinh, cos, sin
     *  toLessThanHalfPi         P.cos, P.sin
     *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
     *  truncate                 intPow
     *
     *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
     *                           naturalLogarithm, config, parseOther, random, Decimal
     */


    function digitsToString(d) {
      var i, k, ws,
        indexOfLastWord = d.length - 1,
        str = '',
        w = d[0];

      if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + '';
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
          str += ws;
        }

        w = d[i];
        ws = w + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
      } else if (w === 0) {
        return '0';
      }

      // Remove trailing zeros of last w.
      for (; w % 10 === 0;) w /= 10;

      return str + w;
    }


    function checkInt32(i, min, max) {
      if (i !== ~~i || i < min || i > max) {
        throw Error(invalidArgument + i);
      }
    }


    /*
     * Check 5 rounding digits if `repeating` is null, 4 otherwise.
     * `repeating == null` if caller is `log` or `pow`,
     * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
     */
    function checkRoundingDigits(d, i, rm, repeating) {
      var di, k, r, rd;

      // Get the length of the first word of the array d.
      for (k = d[0]; k >= 10; k /= 10) --i;

      // Is the rounding digit in the first word of d?
      if (--i < 0) {
        i += LOG_BASE;
        di = 0;
      } else {
        di = Math.ceil((i + 1) / LOG_BASE);
        i %= LOG_BASE;
      }

      // i is the index (0 - 6) of the rounding digit.
      // E.g. if within the word 3487563 the first rounding digit is 5,
      // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
      k = mathpow(10, LOG_BASE - i);
      rd = d[di] % k | 0;

      if (repeating == null) {
        if (i < 3) {
          if (i == 0) rd = rd / 100 | 0;
          else if (i == 1) rd = rd / 10 | 0;
          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
        } else {
          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
            (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
              (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
        }
      } else {
        if (i < 4) {
          if (i == 0) rd = rd / 1000 | 0;
          else if (i == 1) rd = rd / 100 | 0;
          else if (i == 2) rd = rd / 10 | 0;
          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
        } else {
          r = ((repeating || rm < 4) && rd + 1 == k ||
          (!repeating && rm > 3) && rd + 1 == k / 2) &&
            (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
        }
      }

      return r;
    }


    // Convert string of `baseIn` to an array of numbers of `baseOut`.
    // Eg. convertBase('255', 10, 16) returns [15, 15].
    // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
    function convertBase(str, baseIn, baseOut) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        strL = str.length;

      for (; i < strL;) {
        for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
        arr[0] += NUMERALS.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] === void 0) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    }


    /*
     * cos(x) = 1 - x^2/2! + x^4/4! - ...
     * |x| < pi/2
     *
     */
    function cosine(Ctor, x) {
      var k, len, y;

      if (x.isZero()) return x;

      // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
      // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

      // Estimate the optimum number of times to use the argument reduction.
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        y = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        y = '2.3283064365386962890625e-10';
      }

      Ctor.precision += k;

      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

      // Reverse argument reduction
      for (var i = k; i--;) {
        var cos2x = x.times(x);
        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
      }

      Ctor.precision -= k;

      return x;
    }


    /*
     * Perform division in the specified base.
     */
    var divide$1 = (function () {

      // Assumes non-zero x and k, and hence non-zero result.
      function multiplyInteger(x, k, base) {
        var temp,
          carry = 0,
          i = x.length;

        for (x = x.slice(); i--;) {
          temp = x[i] * k + carry;
          x[i] = temp % base | 0;
          carry = temp / base | 0;
        }

        if (carry) x.unshift(carry);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, r;

        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return r;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1;) a.shift();
      }

      return function (x, y, pr, rm, dp, base) {
        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
          yL, yz,
          Ctor = x.constructor,
          sign = x.s == y.s ? 1 : -1,
          xd = x.d,
          yd = y.d;

        // Either NaN, Infinity or 0?
        if (!xd || !xd[0] || !yd || !yd[0]) {

          return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

            // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
        }

        if (base) {
          logBase = 1;
          e = x.e - y.e;
        } else {
          base = BASE;
          logBase = LOG_BASE;
          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }

        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign);
        qd = q.d = [];

        // Result exponent may be one less than e.
        // The digit array of a Decimal from toStringBinary may have trailing zeros.
        for (i = 0; yd[i] == (xd[i] || 0); i++);

        if (yd[i] > (xd[i] || 0)) e--;

        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }

        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {

          // Convert precision in number of base 10 digits to base 1e7 digits.
          sd = sd / logBase + 2 | 0;
          i = 0;

          // divisor < 1e7
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;

            // k is the carry.
            for (; (i < xL || k) && sd--; i++) {
              t = k * base + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }

            more = k || i < xL;

          // divisor >= 1e7
          } else {

            // Normalise xd and yd so highest order digit of yd is >= base/2
            k = base / (yd[0] + 1) | 0;

            if (k > 1) {
              yd = multiplyInteger(yd, k, base);
              xd = multiplyInteger(xd, k, base);
              yL = yd.length;
              xL = xd.length;
            }

            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;

            // Add zeros to make remainder as long as divisor.
            for (; remL < yL;) rem[remL++] = 0;

            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];

            if (yd[1] >= base / 2) ++yd0;

            do {
              k = 0;

              // Compare divisor and remainder.
              cmp = compare(yd, rem, yL, remL);

              // If divisor < remainder.
              if (cmp < 0) {

                // Calculate trial digit, k.
                rem0 = rem[0];
                if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                // k will be how many times the divisor goes into the current remainder.
                k = rem0 / yd0 | 0;

                //  Algorithm:
                //  1. product = divisor * trial digit (k)
                //  2. if product > remainder: product -= divisor, k--
                //  3. remainder -= product
                //  4. if product was < remainder at 2:
                //    5. compare new remainder and divisor
                //    6. If remainder > divisor: remainder -= divisor, k++

                if (k > 1) {
                  if (k >= base) k = base - 1;

                  // product = divisor * trial digit.
                  prod = multiplyInteger(yd, k, base);
                  prodL = prod.length;
                  remL = rem.length;

                  // Compare product and remainder.
                  cmp = compare(prod, rem, prodL, remL);

                  // product > remainder.
                  if (cmp == 1) {
                    k--;

                    // Subtract divisor from product.
                    subtract(prod, yL < prodL ? yz : yd, prodL, base);
                  }
                } else {

                  // cmp is -1.
                  // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                  // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                  if (k == 0) cmp = k = 1;
                  prod = yd.slice();
                }

                prodL = prod.length;
                if (prodL < remL) prod.unshift(0);

                // Subtract product from remainder.
                subtract(rem, prod, remL, base);

                // If product was < previous remainder.
                if (cmp == -1) {
                  remL = rem.length;

                  // Compare divisor and new remainder.
                  cmp = compare(yd, rem, yL, remL);

                  // If divisor < new remainder, subtract divisor from remainder.
                  if (cmp < 1) {
                    k++;

                    // Subtract divisor from remainder.
                    subtract(rem, yL < remL ? yz : yd, remL, base);
                  }
                }

                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }    // if cmp === 1, k will be 0

              // Add the next digit, k, to the result array.
              qd[i++] = k;

              // Update the remainder.
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }

            } while ((xi++ < xL || rem[0] !== void 0) && sd--);

            more = rem[0] !== void 0;
          }

          // Leading zero?
          if (!qd[0]) qd.shift();
        }

        // logBase is 1 when divide is being used for base conversion.
        if (logBase == 1) {
          q.e = e;
          inexact = more;
        } else {

          // To calculate q.e, first get the number of digits of qd[0].
          for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
          q.e = i + e * logBase - 1;

          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }

        return q;
      };
    })();


    /*
     * Round `x` to `sd` significant digits using rounding mode `rm`.
     * Check for over/under-flow.
     */
     function finalise(x, sd, rm, isTruncated) {
      var digits, i, j, k, rd, roundUp, w, xd, xdi,
        Ctor = x.constructor;

      // Don't round if sd is null or undefined.
      out: if (sd != null) {
        xd = x.d;

        // Infinity/NaN.
        if (!xd) return x;

        // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
        // w: the word of xd containing rd, a base 1e7 number.
        // xdi: the index of w within xd.
        // digits: the number of digits of w.
        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
        // they had leading zeros)
        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

        // Get the length of the first word of the digits array xd.
        for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
        i = sd - digits;

        // Is the rounding digit in the first word of xd?
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];

          // Get the rounding digit at index j of w.
          rd = w / mathpow(10, digits - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {

              // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
              for (; k++ <= xdi;) xd.push(0);
              w = rd = 0;
              digits = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w = k = xd[xdi];

            // Get the number of digits of w.
            for (digits = 1; k >= 10; k /= 10) digits++;

            // Get the index of rd within w.
            i %= LOG_BASE;

            // Get the index of rd within w, adjusted for leading zeros.
            // The number of leading zeros of w is given by LOG_BASE - digits.
            j = i - LOG_BASE + digits;

            // Get the rounding digit at index j of w.
            rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
          }
        }

        // Are there any non-zero digits after the rounding digit?
        isTruncated = isTruncated || sd < 0 ||
          xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

        // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
        // will give 714.

        roundUp = rm < 4
          ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
          : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
              rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {

            // Convert sd to decimal places.
            sd -= x.e + 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {

            // Zero.
            xd[0] = x.e = 0;
          }

          return x;
        }

        // Remove excess digits.
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);

          // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of w.
          xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
        }

        if (roundUp) {
          for (;;) {

            // Is the digit to be rounded up in the first word of xd?
            if (xdi == 0) {

              // i will be the length of xd[0] before k is added.
              for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10) k++;

              // if i != k the length has increased.
              if (i != k) {
                x.e++;
                if (xd[0] == BASE) xd[0] = 1;
              }

              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE) break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }

        // Remove trailing zeros.
        for (i = xd.length; xd[--i] === 0;) xd.pop();
      }

      if (external) {

        // Overflow?
        if (x.e > Ctor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < Ctor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // Ctor.underflow = true;
        } // else Ctor.underflow = false;
      }

      return x;
    }


    function finiteToString(x, isExp, sd) {
      if (!x.isFinite()) return nonFiniteToString(x);
      var k,
        e = x.e,
        str = digitsToString(x.d),
        len = str.length;

      if (isExp) {
        if (sd && (k = sd - len) > 0) {
          str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
          str = str.charAt(0) + '.' + str.slice(1);
        }

        str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
      } else if (e < 0) {
        str = '0.' + getZeroString(-e - 1) + str;
        if (sd && (k = sd - len) > 0) str += getZeroString(k);
      } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
      } else {
        if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
        if (sd && (k = sd - len) > 0) {
          if (e + 1 === len) str += '.';
          str += getZeroString(k);
        }
      }

      return str;
    }


    // Calculate the base 10 exponent from the base 1e7 exponent.
    function getBase10Exponent(digits, e) {
      var w = digits[0];

      // Add the number of digits of the first word of the digits array.
      for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
      return e;
    }


    function getLn10(Ctor, sd, pr) {
      if (sd > LN10_PRECISION) {

        // Reset global state in case the exception is caught.
        external = true;
        if (pr) Ctor.precision = pr;
        throw Error(precisionLimitExceeded);
      }
      return finalise(new Ctor(LN10), sd, 1, true);
    }


    function getPi(Ctor, sd, rm) {
      if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
      return finalise(new Ctor(PI), sd, rm, true);
    }


    function getPrecision(digits) {
      var w = digits.length - 1,
        len = w * LOG_BASE + 1;

      w = digits[w];

      // If non-zero...
      if (w) {

        // Subtract the number of trailing zeros of the last word.
        for (; w % 10 == 0; w /= 10) len--;

        // Add the number of digits of the first word.
        for (w = digits[0]; w >= 10; w /= 10) len++;
      }

      return len;
    }


    function getZeroString(k) {
      var zs = '';
      for (; k--;) zs += '0';
      return zs;
    }


    /*
     * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
     * integer of type number.
     *
     * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
     *
     */
    function intPow(Ctor, x, n, pr) {
      var isTruncated,
        r = new Ctor(1),

        // Max n of 9007199254740991 takes 53 loop iterations.
        // Maximum digits array length; leaves [28, 34] guard digits.
        k = Math.ceil(pr / LOG_BASE + 4);

      external = false;

      for (;;) {
        if (n % 2) {
          r = r.times(x);
          if (truncate(r.d, k)) isTruncated = true;
        }

        n = mathfloor(n / 2);
        if (n === 0) {

          // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
          n = r.d.length - 1;
          if (isTruncated && r.d[n] === 0) ++r.d[n];
          break;
        }

        x = x.times(x);
        truncate(x.d, k);
      }

      external = true;

      return r;
    }


    function isOdd(n) {
      return n.d[n.d.length - 1] & 1;
    }


    /*
     * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
     */
    function maxOrMin(Ctor, args, ltgt) {
      var y,
        x = new Ctor(args[0]),
        i = 0;

      for (; ++i < args.length;) {
        y = new Ctor(args[i]);
        if (!y.s) {
          x = y;
          break;
        } else if (x[ltgt](y)) {
          x = y;
        }
      }

      return x;
    }


    /*
     * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
     * digits.
     *
     * Taylor/Maclaurin series.
     *
     * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
     *
     * Argument reduction:
     *   Repeat x = x / 32, k += 5, until |x| < 0.1
     *   exp(x) = exp(x / 2^k)^(2^k)
     *
     * Previously, the argument was initially reduced by
     * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
     * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
     * found to be slower than just dividing repeatedly by 32 as above.
     *
     * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
     * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
     * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
     *
     *  exp(Infinity)  = Infinity
     *  exp(-Infinity) = 0
     *  exp(NaN)       = NaN
     *  exp(±0)        = 1
     *
     *  exp(x) is non-terminating for any finite, non-zero x.
     *
     *  The result will always be correctly rounded.
     *
     */
    function naturalExponential(x, sd) {
      var denominator, guard, j, pow, sum, t, wpr,
        rep = 0,
        i = 0,
        k = 0,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision;

      // 0/NaN/Infinity?
      if (!x.d || !x.d[0] || x.e > 17) {

        return new Ctor(x.d
          ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
          : x.s ? x.s < 0 ? 0 : x : 0 / 0);
      }

      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }

      t = new Ctor(0.03125);

      // while abs(x) >= 0.1
      while (x.e > -2) {

        // x = x / 2^5
        x = x.times(t);
        k += 5;
      }

      // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
      // necessary to ensure the first 4 rounding digits are correct.
      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow = sum = new Ctor(1);
      Ctor.precision = wpr;

      for (;;) {
        pow = finalise(pow.times(x), wpr, 1);
        denominator = denominator.times(++i);
        t = sum.plus(divide$1(pow, denominator, wpr, 1));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          j = k;
          while (j--) sum = finalise(sum.times(sum), wpr, 1);

          // Check to see if the first 4 rounding digits are [49]999.
          // If so, repeat the summation with a higher precision, otherwise
          // e.g. with precision: 18, rounding: 1
          // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
          // `wpr - guard` is the index of first rounding digit.
          if (sd == null) {

            if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += 10;
              denominator = pow = t = new Ctor(1);
              i = 0;
              rep++;
            } else {
              return finalise(sum, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum;
          }
        }

        sum = t;
      }
    }


    /*
     * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
     * digits.
     *
     *  ln(-n)        = NaN
     *  ln(0)         = -Infinity
     *  ln(-0)        = -Infinity
     *  ln(1)         = 0
     *  ln(Infinity)  = Infinity
     *  ln(-Infinity) = NaN
     *  ln(NaN)       = NaN
     *
     *  ln(n) (n != 1) is non-terminating.
     *
     */
    function naturalLogarithm(y, sd) {
      var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
        n = 1,
        guard = 10,
        x = y,
        xd = x.d,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision;

      // Is x negative or Infinity, NaN, 0 or 1?
      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
      }

      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }

      Ctor.precision = wpr += guard;
      c = digitsToString(xd);
      c0 = c.charAt(0);

      if (Math.abs(e = x.e) < 1.5e15) {

        // Argument reduction.
        // The series converges faster the closer the argument is to 1, so using
        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
        // later be divided by this number, then separate out the power of 10 using
        // ln(a*10^b) = ln(a) + b*ln(10).

        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
        // max n is 6 (gives 0.7 - 1.3)
        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
          x = x.times(y);
          c = digitsToString(x.d);
          c0 = c.charAt(0);
          n++;
        }

        e = x.e;

        if (c0 > 1) {
          x = new Ctor('0.' + c);
          e++;
        } else {
          x = new Ctor(c0 + '.' + c.slice(1));
        }
      } else {

        // The argument reduction method above may result in overflow if the argument y is a massive
        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
        // function using ln(x*10^e) = ln(x) + e*ln(10).
        t = getLn10(Ctor, wpr + 2, pr).times(e + '');
        x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
        Ctor.precision = pr;

        return sd == null ? finalise(x, pr, rm, external = true) : x;
      }

      // x1 is x reduced to a value near 1.
      x1 = x;

      // Taylor series.
      // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
      // where x = (y - 1)/(y + 1)    (|x| < 1)
      sum = numerator = x = divide$1(x.minus(1), x.plus(1), wpr, 1);
      x2 = finalise(x.times(x), wpr, 1);
      denominator = 3;

      for (;;) {
        numerator = finalise(numerator.times(x2), wpr, 1);
        t = sum.plus(divide$1(numerator, new Ctor(denominator), wpr, 1));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          sum = sum.times(2);

          // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
          // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
          if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
          sum = divide$1(sum, new Ctor(n), wpr, 1);

          // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
          // been repeated previously) and the first 4 rounding digits 9999?
          // If so, restart the summation with a higher precision, otherwise
          // e.g. with precision: 12, rounding: 1
          // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
          // `wpr - guard` is the index of first rounding digit.
          if (sd == null) {
            if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += guard;
              t = numerator = x = divide$1(x1.minus(1), x1.plus(1), wpr, 1);
              x2 = finalise(x.times(x), wpr, 1);
              denominator = rep = 1;
            } else {
              return finalise(sum, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum;
          }
        }

        sum = t;
        denominator += 2;
      }
    }


    // ±Infinity, NaN.
    function nonFiniteToString(x) {
      // Unsigned.
      return String(x.s * x.s / 0);
    }


    /*
     * Parse the value of a new Decimal `x` from string `str`.
     */
    function parseDecimal(x, str) {
      var e, i, len;

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

      // Exponential form?
      if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {

        // Integer.
        e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
      str = str.slice(i, len);

      if (str) {
        len -= i;
        x.e = e = e - i - 1;
        x.d = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first word of the digits array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;

        if (i < len) {
          if (i) x.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }

        for (; i--;) str += '0';
        x.d.push(+str);

        if (external) {

          // Overflow?
          if (x.e > x.constructor.maxE) {

            // Infinity.
            x.d = null;
            x.e = NaN;

          // Underflow?
          } else if (x.e < x.constructor.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
            // x.constructor.underflow = true;
          } // else x.constructor.underflow = false;
        }
      } else {

        // Zero.
        x.e = 0;
        x.d = [0];
      }

      return x;
    }


    /*
     * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
     */
    function parseOther(x, str) {
      var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

      if (str.indexOf('_') > -1) {
        str = str.replace(/(\d)_(?=\d)/g, '$1');
        if (isDecimal$2.test(str)) return parseDecimal(x, str);
      } else if (str === 'Infinity' || str === 'NaN') {
        if (!+str) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return x;
      }

      if (isHex.test(str))  {
        base = 16;
        str = str.toLowerCase();
      } else if (isBinary.test(str))  {
        base = 2;
      } else if (isOctal.test(str))  {
        base = 8;
      } else {
        throw Error(invalidArgument + str);
      }

      // Is there a binary exponent part?
      i = str.search(/p/i);

      if (i > 0) {
        p = +str.slice(i + 1);
        str = str.substring(2, i);
      } else {
        str = str.slice(2);
      }

      // Convert `str` as an integer then divide the result by `base` raised to a power such that the
      // fraction part will be restored.
      i = str.indexOf('.');
      isFloat = i >= 0;
      Ctor = x.constructor;

      if (isFloat) {
        str = str.replace('.', '');
        len = str.length;
        i = len - i;

        // log[10](16) = 1.2041... , log[10](88) = 1.9444....
        divisor = intPow(Ctor, new Ctor(base), i, i * 2);
      }

      xd = convertBase(str, base, BASE);
      xe = xd.length - 1;

      // Remove trailing zeros.
      for (i = xe; xd[i] === 0; --i) xd.pop();
      if (i < 0) return new Ctor(x.s * 0);
      x.e = getBase10Exponent(xd, xe);
      x.d = xd;
      external = false;

      // At what precision to perform the division to ensure exact conversion?
      // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
      // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
      // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
      // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
      // Therefore using 4 * the number of digits of str will always be enough.
      if (isFloat) x = divide$1(x, divisor, len * 4);

      // Multiply by the binary exponent part if present.
      if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
      external = true;

      return x;
    }


    /*
     * sin(x) = x - x^3/3! + x^5/5! - ...
     * |x| < pi/2
     *
     */
    function sine(Ctor, x) {
      var k,
        len = x.d.length;

      if (len < 3) {
        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
      }

      // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
      // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
      // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x);

      // Reverse argument reduction
      var sin2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sin2_x = x.times(x);
        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
      }

      return x;
    }


    // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
    function taylorSeries(Ctor, n, x, y, isHyperbolic) {
      var j, t, u, x2,
        pr = Ctor.precision,
        k = Math.ceil(pr / LOG_BASE);

      external = false;
      x2 = x.times(x);
      u = new Ctor(y);

      for (;;) {
        t = divide$1(u.times(x2), new Ctor(n++ * n++), pr, 1);
        u = isHyperbolic ? y.plus(t) : y.minus(t);
        y = divide$1(t.times(x2), new Ctor(n++ * n++), pr, 1);
        t = u.plus(y);

        if (t.d[k] !== void 0) {
          for (j = k; t.d[j] === u.d[j] && j--;);
          if (j == -1) break;
        }

        j = u;
        u = y;
        y = t;
        t = j;
      }

      external = true;
      t.d.length = k + 1;

      return t;
    }


    // Exponent e must be positive and non-zero.
    function tinyPow(b, e) {
      var n = b;
      while (--e) n *= b;
      return n;
    }


    // Return the absolute value of `x` reduced to less than or equal to half pi.
    function toLessThanHalfPi(Ctor, x) {
      var t,
        isNeg = x.s < 0,
        pi = getPi(Ctor, Ctor.precision, 1),
        halfPi = pi.times(0.5);

      x = x.abs();

      if (x.lte(halfPi)) {
        quadrant = isNeg ? 4 : 1;
        return x;
      }

      t = x.divToInt(pi);

      if (t.isZero()) {
        quadrant = isNeg ? 3 : 2;
      } else {
        x = x.minus(t.times(pi));

        // 0 <= x < pi
        if (x.lte(halfPi)) {
          quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
          return x;
        }

        quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
      }

      return x.minus(pi).abs();
    }


    /*
     * Return the value of Decimal `x` as a string in base `baseOut`.
     *
     * If the optional `sd` argument is present include a binary exponent suffix.
     */
    function toStringBinary(x, baseOut, sd, rm) {
      var base, e, i, k, len, roundUp, str, xd, y,
        Ctor = x.constructor,
        isExp = sd !== void 0;

      if (isExp) {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      } else {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      }

      if (!x.isFinite()) {
        str = nonFiniteToString(x);
      } else {
        str = finiteToString(x);
        i = str.indexOf('.');

        // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
        // minBinaryExponent = floor(decimalExponent * log[2](10))
        // log[2](10) = 3.321928094887362347870319429489390175864

        if (isExp) {
          base = 2;
          if (baseOut == 16) {
            sd = sd * 4 - 3;
          } else if (baseOut == 8) {
            sd = sd * 3 - 2;
          }
        } else {
          base = baseOut;
        }

        // Convert the number as an integer then divide the result by its base raised to a power such
        // that the fraction part will be restored.

        // Non-integer.
        if (i >= 0) {
          str = str.replace('.', '');
          y = new Ctor(1);
          y.e = str.length - i;
          y.d = convertBase(finiteToString(y), 10, base);
          y.e = y.d.length;
        }

        xd = convertBase(str, 10, base);
        e = len = xd.length;

        // Remove trailing zeros.
        for (; xd[--len] == 0;) xd.pop();

        if (!xd[0]) {
          str = isExp ? '0p+0' : '0';
        } else {
          if (i < 0) {
            e--;
          } else {
            x = new Ctor(x);
            x.d = xd;
            x.e = e;
            x = divide$1(x, y, sd, rm, 0, base);
            xd = x.d;
            e = x.e;
            roundUp = inexact;
          }

          // The rounding digit, i.e. the digit after the digit that may be rounded up.
          i = xd[sd];
          k = base / 2;
          roundUp = roundUp || xd[sd + 1] !== void 0;

          roundUp = rm < 4
            ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
            : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
              rm === (x.s < 0 ? 8 : 7));

          xd.length = sd;

          if (roundUp) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (; ++xd[--sd] > base - 1;) {
              xd[sd] = 0;
              if (!sd) {
                ++e;
                xd.unshift(1);
              }
            }
          }

          // Determine trailing zeros.
          for (len = xd.length; !xd[len - 1]; --len);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

          // Add binary exponent suffix?
          if (isExp) {
            if (len > 1) {
              if (baseOut == 16 || baseOut == 8) {
                i = baseOut == 16 ? 4 : 3;
                for (--len; len % i; len++) str += '0';
                xd = convertBase(str, base, baseOut);
                for (len = xd.length; !xd[len - 1]; --len);

                // xd[0] will always be be 1
                for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
              } else {
                str = str.charAt(0) + '.' + str.slice(1);
              }
            }

            str =  str + (e < 0 ? 'p' : 'p+') + e;
          } else if (e < 0) {
            for (; ++e;) str = '0' + str;
            str = '0.' + str;
          } else {
            if (++e > len) for (e -= len; e-- ;) str += '0';
            else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
          }
        }

        str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
      }

      return x.s < 0 ? '-' + str : str;
    }


    // Does not strip trailing zeros.
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }


    // Decimal methods


    /*
     *  abs
     *  acos
     *  acosh
     *  add
     *  asin
     *  asinh
     *  atan
     *  atanh
     *  atan2
     *  cbrt
     *  ceil
     *  clamp
     *  clone
     *  config
     *  cos
     *  cosh
     *  div
     *  exp
     *  floor
     *  hypot
     *  ln
     *  log
     *  log2
     *  log10
     *  max
     *  min
     *  mod
     *  mul
     *  pow
     *  random
     *  round
     *  set
     *  sign
     *  sin
     *  sinh
     *  sqrt
     *  sub
     *  sum
     *  tan
     *  tanh
     *  trunc
     */


    /*
     * Return a new Decimal whose value is the absolute value of `x`.
     *
     * x {number|string|Decimal}
     *
     */
    function abs$1(x) {
      return new this(x).abs();
    }


    /*
     * Return a new Decimal whose value is the arccosine in radians of `x`.
     *
     * x {number|string|Decimal}
     *
     */
    function acos$1(x) {
      return new this(x).acos();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function acosh(x) {
      return new this(x).acosh();
    }


    /*
     * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function add$1(x, y) {
      return new this(x).plus(y);
    }


    /*
     * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function asin$2(x) {
      return new this(x).asin();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function asinh(x) {
      return new this(x).asinh();
    }


    /*
     * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function atan$1(x) {
      return new this(x).atan();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function atanh(x) {
      return new this(x).atanh();
    }


    /*
     * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
     * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi, pi]
     *
     * y {number|string|Decimal} The y-coordinate.
     * x {number|string|Decimal} The x-coordinate.
     *
     * atan2(±0, -0)               = ±pi
     * atan2(±0, +0)               = ±0
     * atan2(±0, -x)               = ±pi for x > 0
     * atan2(±0, x)                = ±0 for x > 0
     * atan2(-y, ±0)               = -pi/2 for y > 0
     * atan2(y, ±0)                = pi/2 for y > 0
     * atan2(±y, -Infinity)        = ±pi for finite y > 0
     * atan2(±y, +Infinity)        = ±0 for finite y > 0
     * atan2(±Infinity, x)         = ±pi/2 for finite x
     * atan2(±Infinity, -Infinity) = ±3*pi/4
     * atan2(±Infinity, +Infinity) = ±pi/4
     * atan2(NaN, x) = NaN
     * atan2(y, NaN) = NaN
     *
     */
    function atan2$1(y, x) {
      y = new this(y);
      x = new this(x);
      var r,
        pr = this.precision,
        rm = this.rounding,
        wpr = pr + 4;

      // Either NaN
      if (!y.s || !x.s) {
        r = new this(NaN);

      // Both ±Infinity
      } else if (!y.d && !x.d) {
        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
        r.s = y.s;

      // x is ±Infinity or y is ±0
      } else if (!x.d || y.isZero()) {
        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
        r.s = y.s;

      // y is ±Infinity or x is ±0
      } else if (!y.d || x.isZero()) {
        r = getPi(this, wpr, 1).times(0.5);
        r.s = y.s;

      // Both non-zero and finite
      } else if (x.s < 0) {
        this.precision = wpr;
        this.rounding = 1;
        r = this.atan(divide$1(y, x, wpr, 1));
        x = getPi(this, wpr, 1);
        this.precision = pr;
        this.rounding = rm;
        r = y.s < 0 ? r.minus(x) : r.plus(x);
      } else {
        r = this.atan(divide$1(y, x, wpr, 1));
      }

      return r;
    }


    /*
     * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function cbrt(x) {
      return new this(x).cbrt();
    }


    /*
     * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
     *
     * x {number|string|Decimal}
     *
     */
    function ceil(x) {
      return finalise(x = new this(x), x.e + 1, 2);
    }


    /*
     * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
     *
     * x {number|string|Decimal}
     * min {number|string|Decimal}
     * max {number|string|Decimal}
     *
     */
    function clamp(x, min, max) {
      return new this(x).clamp(min, max);
    }


    /*
     * Configure global settings for a Decimal constructor.
     *
     * `obj` is an object with one or more of the following properties,
     *
     *   precision  {number}
     *   rounding   {number}
     *   toExpNeg   {number}
     *   toExpPos   {number}
     *   maxE       {number}
     *   minE       {number}
     *   modulo     {number}
     *   crypto     {boolean|number}
     *   defaults   {true}
     *
     * E.g. Decimal.config({ precision: 20, rounding: 4 })
     *
     */
    function config(obj) {
      if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
      var i, p, v,
        useDefaults = obj.defaults === true,
        ps = [
          'precision', 1, MAX_DIGITS,
          'rounding', 0, 8,
          'toExpNeg', -EXP_LIMIT, 0,
          'toExpPos', 0, EXP_LIMIT,
          'maxE', 0, EXP_LIMIT,
          'minE', -EXP_LIMIT, 0,
          'modulo', 0, 9
        ];

      for (i = 0; i < ps.length; i += 3) {
        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
          else throw Error(invalidArgument + p + ': ' + v);
        }
      }

      if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (v === true || v === false || v === 0 || v === 1) {
          if (v) {
            if (typeof crypto != 'undefined' && crypto &&
              (crypto.getRandomValues || crypto.randomBytes)) {
              this[p] = true;
            } else {
              throw Error(cryptoUnavailable);
            }
          } else {
            this[p] = false;
          }
        } else {
          throw Error(invalidArgument + p + ': ' + v);
        }
      }

      return this;
    }


    /*
     * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function cos$3(x) {
      return new this(x).cos();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function cosh(x) {
      return new this(x).cosh();
    }


    /*
     * Create and return a Decimal constructor with the same configuration properties as this Decimal
     * constructor.
     *
     */
    function clone(obj) {
      var i, p, ps;

      /*
       * The Decimal constructor and exported function.
       * Return a new Decimal instance.
       *
       * v {number|string|Decimal} A numeric value.
       *
       */
      function Decimal(v) {
        var e, i, t,
          x = this;

        // Decimal called without new.
        if (!(x instanceof Decimal)) return new Decimal(v);

        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
        // which points to Object.
        x.constructor = Decimal;

        // Duplicate.
        if (isDecimalInstance(v)) {
          x.s = v.s;

          if (external) {
            if (!v.d || v.e > Decimal.maxE) {

              // Infinity.
              x.e = NaN;
              x.d = null;
            } else if (v.e < Decimal.minE) {

              // Zero.
              x.e = 0;
              x.d = [0];
            } else {
              x.e = v.e;
              x.d = v.d.slice();
            }
          } else {
            x.e = v.e;
            x.d = v.d ? v.d.slice() : v.d;
          }

          return;
        }

        t = typeof v;

        if (t === 'number') {
          if (v === 0) {
            x.s = 1 / v < 0 ? -1 : 1;
            x.e = 0;
            x.d = [0];
            return;
          }

          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }

          // Fast path for small integers.
          if (v === ~~v && v < 1e7) {
            for (e = 0, i = v; i >= 10; i /= 10) e++;

            if (external) {
              if (e > Decimal.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (e < Decimal.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = e;
                x.d = [v];
              }
            } else {
              x.e = e;
              x.d = [v];
            }

            return;

          // Infinity, NaN.
          } else if (v * 0 !== 0) {
            if (!v) x.s = NaN;
            x.e = NaN;
            x.d = null;
            return;
          }

          return parseDecimal(x, v.toString());

        } else if (t !== 'string') {
          throw Error(invalidArgument + v);
        }

        // Minus sign?
        if ((i = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          // Plus sign?
          if (i === 43) v = v.slice(1);
          x.s = 1;
        }

        return isDecimal$2.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }

      Decimal.prototype = P;

      Decimal.ROUND_UP = 0;
      Decimal.ROUND_DOWN = 1;
      Decimal.ROUND_CEIL = 2;
      Decimal.ROUND_FLOOR = 3;
      Decimal.ROUND_HALF_UP = 4;
      Decimal.ROUND_HALF_DOWN = 5;
      Decimal.ROUND_HALF_EVEN = 6;
      Decimal.ROUND_HALF_CEIL = 7;
      Decimal.ROUND_HALF_FLOOR = 8;
      Decimal.EUCLID = 9;

      Decimal.config = Decimal.set = config;
      Decimal.clone = clone;
      Decimal.isDecimal = isDecimalInstance;

      Decimal.abs = abs$1;
      Decimal.acos = acos$1;
      Decimal.acosh = acosh;        // ES6
      Decimal.add = add$1;
      Decimal.asin = asin$2;
      Decimal.asinh = asinh;        // ES6
      Decimal.atan = atan$1;
      Decimal.atanh = atanh;        // ES6
      Decimal.atan2 = atan2$1;
      Decimal.cbrt = cbrt;          // ES6
      Decimal.ceil = ceil;
      Decimal.clamp = clamp;
      Decimal.cos = cos$3;
      Decimal.cosh = cosh;          // ES6
      Decimal.div = div;
      Decimal.exp = exp;
      Decimal.floor = floor;
      Decimal.hypot = hypot;        // ES6
      Decimal.ln = ln;
      Decimal.log = log;
      Decimal.log10 = log10;        // ES6
      Decimal.log2 = log2;          // ES6
      Decimal.max = max;
      Decimal.min = min;
      Decimal.mod = mod$1;
      Decimal.mul = mul;
      Decimal.pow = pow$1;
      Decimal.random = random;
      Decimal.round = round;
      Decimal.sign = sign$1;          // ES6
      Decimal.sin = sin$3;
      Decimal.sinh = sinh;          // ES6
      Decimal.sqrt = sqrt$1;
      Decimal.sub = sub;
      Decimal.sum = sum;
      Decimal.tan = tan$4;
      Decimal.tanh = tanh;          // ES6
      Decimal.trunc = trunc;        // ES6

      if (obj === void 0) obj = {};
      if (obj) {
        if (obj.defaults !== true) {
          ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
          for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
        }
      }

      Decimal.config(obj);

      return Decimal;
    }


    /*
     * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function div(x, y) {
      return new this(x).div(y);
    }


    /*
     * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} The power to which to raise the base of the natural log.
     *
     */
    function exp(x) {
      return new this(x).exp();
    }


    /*
     * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
     *
     * x {number|string|Decimal}
     *
     */
    function floor(x) {
      return finalise(x = new this(x), x.e + 1, 3);
    }


    /*
     * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
     * rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
     *
     * arguments {number|string|Decimal}
     *
     */
    function hypot() {
      var i, n,
        t = new this(0);

      external = false;

      for (i = 0; i < arguments.length;) {
        n = new this(arguments[i++]);
        if (!n.d) {
          if (n.s) {
            external = true;
            return new this(1 / 0);
          }
          t = n;
        } else if (t.d) {
          t = t.plus(n.times(n));
        }
      }

      external = true;

      return t.sqrt();
    }


    /*
     * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
     * otherwise return false.
     *
     */
    function isDecimalInstance(obj) {
      return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
    }


    /*
     * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function ln(x) {
      return new this(x).ln();
    }


    /*
     * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
     * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * log[y](x)
     *
     * x {number|string|Decimal} The argument of the logarithm.
     * y {number|string|Decimal} The base of the logarithm.
     *
     */
    function log(x, y) {
      return new this(x).log(y);
    }


    /*
     * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function log2(x) {
      return new this(x).log(2);
    }


    /*
     * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function log10(x) {
      return new this(x).log(10);
    }


    /*
     * Return a new Decimal whose value is the maximum of the arguments.
     *
     * arguments {number|string|Decimal}
     *
     */
    function max() {
      return maxOrMin(this, arguments, 'lt');
    }


    /*
     * Return a new Decimal whose value is the minimum of the arguments.
     *
     * arguments {number|string|Decimal}
     *
     */
    function min() {
      return maxOrMin(this, arguments, 'gt');
    }


    /*
     * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function mod$1(x, y) {
      return new this(x).mod(y);
    }


    /*
     * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function mul(x, y) {
      return new this(x).mul(y);
    }


    /*
     * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} The base.
     * y {number|string|Decimal} The exponent.
     *
     */
    function pow$1(x, y) {
      return new this(x).pow(y);
    }


    /*
     * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
     * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
     * are produced).
     *
     * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
     *
     */
    function random(sd) {
      var d, e, k, n,
        i = 0,
        r = new this(1),
        rd = [];

      if (sd === void 0) sd = this.precision;
      else checkInt32(sd, 1, MAX_DIGITS);

      k = Math.ceil(sd / LOG_BASE);

      if (!this.crypto) {
        for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

      // Browsers supporting crypto.getRandomValues.
      } else if (crypto.getRandomValues) {
        d = crypto.getRandomValues(new Uint32Array(k));

        for (; i < k;) {
          n = d[i];

          // 0 <= n < 4294967296
          // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
          if (n >= 4.29e9) {
            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
          } else {

            // 0 <= n <= 4289999999
            // 0 <= (n % 1e7) <= 9999999
            rd[i++] = n % 1e7;
          }
        }

      // Node.js supporting crypto.randomBytes.
      } else if (crypto.randomBytes) {

        // buffer
        d = crypto.randomBytes(k *= 4);

        for (; i < k;) {

          // 0 <= n < 2147483648
          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

          // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
          if (n >= 2.14e9) {
            crypto.randomBytes(4).copy(d, i);
          } else {

            // 0 <= n <= 2139999999
            // 0 <= (n % 1e7) <= 9999999
            rd.push(n % 1e7);
            i += 4;
          }
        }

        i = k / 4;
      } else {
        throw Error(cryptoUnavailable);
      }

      k = rd[--i];
      sd %= LOG_BASE;

      // Convert trailing digits to zeros according to sd.
      if (k && sd) {
        n = mathpow(10, LOG_BASE - sd);
        rd[i] = (k / n | 0) * n;
      }

      // Remove trailing words which are zero.
      for (; rd[i] === 0; i--) rd.pop();

      // Zero?
      if (i < 0) {
        e = 0;
        rd = [0];
      } else {
        e = -1;

        // Remove leading words which are zero and adjust exponent accordingly.
        for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

        // Count the digits of the first word of rd to determine leading zeros.
        for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

        // Adjust the exponent for leading zeros of the first word of rd.
        if (k < LOG_BASE) e -= LOG_BASE - k;
      }

      r.e = e;
      r.d = rd;

      return r;
    }


    /*
     * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
     *
     * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
     *
     * x {number|string|Decimal}
     *
     */
    function round(x) {
      return finalise(x = new this(x), x.e + 1, this.rounding);
    }


    /*
     * Return
     *   1    if x > 0,
     *  -1    if x < 0,
     *   0    if x is 0,
     *  -0    if x is -0,
     *   NaN  otherwise
     *
     * x {number|string|Decimal}
     *
     */
    function sign$1(x) {
      x = new this(x);
      return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
    }


    /*
     * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function sin$3(x) {
      return new this(x).sin();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function sinh(x) {
      return new this(x).sinh();
    }


    /*
     * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function sqrt$1(x) {
      return new this(x).sqrt();
    }


    /*
     * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function sub(x, y) {
      return new this(x).sub(y);
    }


    /*
     * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * Only the result is rounded, not the intermediate calculations.
     *
     * arguments {number|string|Decimal}
     *
     */
    function sum() {
      var i = 0,
        args = arguments,
        x = new this(args[i]);

      external = false;
      for (; x.s && ++i < args.length;) x = x.plus(args[i]);
      external = true;

      return finalise(x, this.precision, this.rounding);
    }


    /*
     * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function tan$4(x) {
      return new this(x).tan();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function tanh(x) {
      return new this(x).tanh();
    }


    /*
     * Return a new Decimal whose value is `x` truncated to an integer.
     *
     * x {number|string|Decimal}
     *
     */
    function trunc(x) {
      return finalise(x = new this(x), x.e + 1, 1);
    }


    P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
    P[Symbol.toStringTag] = 'Decimal';

    // Create and configure initial Decimal constructor.
    var Decimal = P.constructor = clone(DEFAULTS);

    // Create the internal constants from their string values.
    LN10 = new Decimal(LN10);
    PI = new Decimal(PI);

    var name$13 = 'BigNumber';
    var dependencies$13 = ['?on', 'config'];
    var createBigNumberClass = /* #__PURE__ */factory(name$13, dependencies$13, _ref => {
      var {
        on,
        config
      } = _ref;
      var BigNumber = Decimal.clone({
        precision: config.precision,
        modulo: Decimal.EUCLID
      });
      BigNumber.prototype = Object.create(BigNumber.prototype);
      /**
       * Attach type information
       */

      BigNumber.prototype.type = 'BigNumber';
      BigNumber.prototype.isBigNumber = true;
      /**
       * Get a JSON representation of a BigNumber containing
       * type information
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "BigNumber", "value": "0.2"}`
       */

      BigNumber.prototype.toJSON = function () {
        return {
          mathjs: 'BigNumber',
          value: this.toString()
        };
      };
      /**
       * Instantiate a BigNumber from a JSON object
       * @param {Object} json  a JSON object structured as:
       *                       `{"mathjs": "BigNumber", "value": "0.2"}`
       * @return {BigNumber}
       */

      BigNumber.fromJSON = function (json) {
        return new BigNumber(json.value);
      };
      if (on) {
        // listen for changed in the configuration, automatically apply changed precision
        on('config', function (curr, prev) {
          if (curr.precision !== prev.precision) {
            BigNumber.config({
              precision: curr.precision
            });
          }
        });
      }
      return BigNumber;
    }, {
      isClass: true
    });

    var complexExports = {};
    var complex$1 = {
      get exports(){ return complexExports; },
      set exports(v){ complexExports = v; },
    };

    /**
     * @license Complex.js v2.1.1 12/05/2020
     *
     * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/
    (function (module, exports) {
      /**
       *
       * This class allows the manipulation of complex numbers.
       * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
       *
       * Object form
       * { re: <real>, im: <imaginary> }
       * { arg: <angle>, abs: <radius> }
       * { phi: <angle>, r: <radius> }
       *
       * Array / Vector form
       * [ real, imaginary ]
       *
       * Double form
       * 99.3 - Single double value
       *
       * String form
       * '23.1337' - Simple real number
       * '15+3i' - a simple complex number
       * '3-i' - a simple complex number
       *
       * Example:
       *
       * var c = new Complex('99.3+8i');
       * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
       *
       */

      (function (root) {

        var cosh = Math.cosh || function (x) {
          return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
        };
        var sinh = Math.sinh || function (x) {
          return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
        };

        /**
         * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).
         *
         * @param {number} x
         * @returns {number} cos(x) - 1
         */
        var cosm1 = function (x) {
          var b = Math.PI / 4;
          if (-b > x || x > b) {
            return Math.cos(x) - 1.0;
          }

          /* Calculate horner form of polynomial of taylor series in Q
          var fac = 1, alt = 1, pol = {};
          for (var i = 0; i <= 16; i++) {
            fac*= i || 1;
            if (i % 2 == 0) {
              pol[i] = new Fraction(1, alt * fac);
              alt = -alt;
            }
          }
          console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1
          */

          var xx = x * x;
          return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888000 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
        };
        var hypot = function (x, y) {
          var a = Math.abs(x);
          var b = Math.abs(y);
          if (a < 3000 && b < 3000) {
            return Math.sqrt(a * a + b * b);
          }
          if (a < b) {
            a = b;
            b = x / y;
          } else {
            b = y / x;
          }
          return a * Math.sqrt(1 + b * b);
        };
        var parser_exit = function () {
          throw SyntaxError('Invalid Param');
        };

        /**
         * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
         *
         * @param {number} a
         * @param {number} b
         * @returns {number}
         */
        function logHypot(a, b) {
          var _a = Math.abs(a);
          var _b = Math.abs(b);
          if (a === 0) {
            return Math.log(_b);
          }
          if (b === 0) {
            return Math.log(_a);
          }
          if (_a < 3000 && _b < 3000) {
            return Math.log(a * a + b * b) * 0.5;
          }

          /* I got 4 ideas to compute this property without overflow:
           *
           * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate
           *
           * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)
            Math.log(a * a + b * b) / 2
            *
           *
           * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)
            var fn = function(a, b) {
           a = Math.abs(a);
           b = Math.abs(b);
           var t = Math.min(a, b);
           a = Math.max(a, b);
           t = t / a;
            return Math.log(a) + Math.log(1 + t * t) / 2;
           };
            * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)
            Math.log(a / Math.cos(Math.atan2(b, a)))
            * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)
            Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))
            */

          a = a / 2;
          b = b / 2;
          return 0.5 * Math.log(a * a + b * b) + Math.LN2;
        }
        var parse = function (a, b) {
          var z = {
            're': 0,
            'im': 0
          };
          if (a === undefined || a === null) {
            z['re'] = z['im'] = 0;
          } else if (b !== undefined) {
            z['re'] = a;
            z['im'] = b;
          } else switch (typeof a) {
            case 'object':
              if ('im' in a && 're' in a) {
                z['re'] = a['re'];
                z['im'] = a['im'];
              } else if ('abs' in a && 'arg' in a) {
                if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
                  return Complex['INFINITY'];
                }
                z['re'] = a['abs'] * Math.cos(a['arg']);
                z['im'] = a['abs'] * Math.sin(a['arg']);
              } else if ('r' in a && 'phi' in a) {
                if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
                  return Complex['INFINITY'];
                }
                z['re'] = a['r'] * Math.cos(a['phi']);
                z['im'] = a['r'] * Math.sin(a['phi']);
              } else if (a.length === 2) {
                // Quick array check
                z['re'] = a[0];
                z['im'] = a[1];
              } else {
                parser_exit();
              }
              break;
            case 'string':
              z['im'] = /* void */
              z['re'] = 0;
              var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              var plus = 1;
              var minus = 0;
              if (tokens === null) {
                parser_exit();
              }
              for (var i = 0; i < tokens.length; i++) {
                var c = tokens[i];
                if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
                  plus++;
                } else if (c === '-') {
                  minus++;
                } else if (c === 'i' || c === 'I') {
                  if (plus + minus === 0) {
                    parser_exit();
                  }
                  if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
                    z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
                    i++;
                  } else {
                    z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
                  }
                  plus = minus = 0;
                } else {
                  if (plus + minus === 0 || isNaN(c)) {
                    parser_exit();
                  }
                  if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
                    z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
                    i++;
                  } else {
                    z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
                  }
                  plus = minus = 0;
                }
              }

              // Still something on the stack
              if (plus + minus > 0) {
                parser_exit();
              }
              break;
            case 'number':
              z['im'] = 0;
              z['re'] = a;
              break;
            default:
              parser_exit();
          }
          if (isNaN(z['re']) || isNaN(z['im'])) ;
          return z;
        };

        /**
         * @constructor
         * @returns {Complex}
         */
        function Complex(a, b) {
          if (!(this instanceof Complex)) {
            return new Complex(a, b);
          }
          var z = parse(a, b);
          this['re'] = z['re'];
          this['im'] = z['im'];
        }
        Complex.prototype = {
          're': 0,
          'im': 0,
          /**
           * Calculates the sign of a complex number, which is a normalized complex
           *
           * @returns {Complex}
           */
          'sign': function () {
            var abs = this['abs']();
            return new Complex(this['re'] / abs, this['im'] / abs);
          },
          /**
           * Adds two complex numbers
           *
           * @returns {Complex}
           */
          'add': function (a, b) {
            var z = new Complex(a, b);

            // Infinity + Infinity = NaN
            if (this['isInfinite']() && z['isInfinite']()) {
              return Complex['NAN'];
            }

            // Infinity + z = Infinity { where z != Infinity }
            if (this['isInfinite']() || z['isInfinite']()) {
              return Complex['INFINITY'];
            }
            return new Complex(this['re'] + z['re'], this['im'] + z['im']);
          },
          /**
           * Subtracts two complex numbers
           *
           * @returns {Complex}
           */
          'sub': function (a, b) {
            var z = new Complex(a, b);

            // Infinity - Infinity = NaN
            if (this['isInfinite']() && z['isInfinite']()) {
              return Complex['NAN'];
            }

            // Infinity - z = Infinity { where z != Infinity }
            if (this['isInfinite']() || z['isInfinite']()) {
              return Complex['INFINITY'];
            }
            return new Complex(this['re'] - z['re'], this['im'] - z['im']);
          },
          /**
           * Multiplies two complex numbers
           *
           * @returns {Complex}
           */
          'mul': function (a, b) {
            var z = new Complex(a, b);

            // Infinity * 0 = NaN
            if (this['isInfinite']() && z['isZero']() || this['isZero']() && z['isInfinite']()) {
              return Complex['NAN'];
            }

            // Infinity * z = Infinity { where z != 0 }
            if (this['isInfinite']() || z['isInfinite']()) {
              return Complex['INFINITY'];
            }

            // Short circuit for real values
            if (z['im'] === 0 && this['im'] === 0) {
              return new Complex(this['re'] * z['re'], 0);
            }
            return new Complex(this['re'] * z['re'] - this['im'] * z['im'], this['re'] * z['im'] + this['im'] * z['re']);
          },
          /**
           * Divides two complex numbers
           *
           * @returns {Complex}
           */
          'div': function (a, b) {
            var z = new Complex(a, b);

            // 0 / 0 = NaN and Infinity / Infinity = NaN
            if (this['isZero']() && z['isZero']() || this['isInfinite']() && z['isInfinite']()) {
              return Complex['NAN'];
            }

            // Infinity / 0 = Infinity
            if (this['isInfinite']() || z['isZero']()) {
              return Complex['INFINITY'];
            }

            // 0 / Infinity = 0
            if (this['isZero']() || z['isInfinite']()) {
              return Complex['ZERO'];
            }
            a = this['re'];
            b = this['im'];
            var c = z['re'];
            var d = z['im'];
            var t, x;
            if (0 === d) {
              // Divisor is real
              return new Complex(a / c, b / c);
            }
            if (Math.abs(c) < Math.abs(d)) {
              x = c / d;
              t = c * x + d;
              return new Complex((a * x + b) / t, (b * x - a) / t);
            } else {
              x = d / c;
              t = d * x + c;
              return new Complex((a + b * x) / t, (b - a * x) / t);
            }
          },
          /**
           * Calculate the power of two complex numbers
           *
           * @returns {Complex}
           */
          'pow': function (a, b) {
            var z = new Complex(a, b);
            a = this['re'];
            b = this['im'];
            if (z['isZero']()) {
              return Complex['ONE'];
            }

            // If the exponent is real
            if (z['im'] === 0) {
              if (b === 0 && a > 0) {
                return new Complex(Math.pow(a, z['re']), 0);
              } else if (a === 0) {
                // If base is fully imaginary

                switch ((z['re'] % 4 + 4) % 4) {
                  case 0:
                    return new Complex(Math.pow(b, z['re']), 0);
                  case 1:
                    return new Complex(0, Math.pow(b, z['re']));
                  case 2:
                    return new Complex(-Math.pow(b, z['re']), 0);
                  case 3:
                    return new Complex(0, -Math.pow(b, z['re']));
                }
              }
            }

            /* I couldn't find a good formula, so here is a derivation and optimization
             *
             * z_1^z_2 = (a + bi)^(c + di)
             *         = exp((c + di) * log(a + bi)
             *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
             * =>...
             * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
             * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
             *
             * =>...
             * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
             * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
             *
             * =>
             * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
             * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
             *
             */

            if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
              return Complex['ZERO'];
            }
            var arg = Math.atan2(b, a);
            var loh = logHypot(a, b);
            a = Math.exp(z['re'] * loh - z['im'] * arg);
            b = z['im'] * loh + z['re'] * arg;
            return new Complex(a * Math.cos(b), a * Math.sin(b));
          },
          /**
           * Calculate the complex square root
           *
           * @returns {Complex}
           */
          'sqrt': function () {
            var a = this['re'];
            var b = this['im'];
            var r = this['abs']();
            var re, im;
            if (a >= 0) {
              if (b === 0) {
                return new Complex(Math.sqrt(a), 0);
              }
              re = 0.5 * Math.sqrt(2.0 * (r + a));
            } else {
              re = Math.abs(b) / Math.sqrt(2 * (r - a));
            }
            if (a <= 0) {
              im = 0.5 * Math.sqrt(2.0 * (r - a));
            } else {
              im = Math.abs(b) / Math.sqrt(2 * (r + a));
            }
            return new Complex(re, b < 0 ? -im : im);
          },
          /**
           * Calculate the complex exponent
           *
           * @returns {Complex}
           */
          'exp': function () {
            var tmp = Math.exp(this['re']);
            if (this['im'] === 0) ;
            return new Complex(tmp * Math.cos(this['im']), tmp * Math.sin(this['im']));
          },
          /**
           * Calculate the complex exponent and subtracts one.
           *
           * This may be more accurate than `Complex(x).exp().sub(1)` if
           * `x` is small.
           *
           * @returns {Complex}
           */
          'expm1': function () {
            /**
             * exp(a + i*b) - 1
             = exp(a) * (cos(b) + j*sin(b)) - 1
             = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
             */

            var a = this['re'];
            var b = this['im'];
            return new Complex(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));
          },
          /**
           * Calculate the natural log
           *
           * @returns {Complex}
           */
          'log': function () {
            var a = this['re'];
            var b = this['im'];
            return new Complex(logHypot(a, b), Math.atan2(b, a));
          },
          /**
           * Calculate the magnitude of the complex number
           *
           * @returns {number}
           */
          'abs': function () {
            return hypot(this['re'], this['im']);
          },
          /**
           * Calculate the angle of the complex number
           *
           * @returns {number}
           */
          'arg': function () {
            return Math.atan2(this['im'], this['re']);
          },
          /**
           * Calculate the sine of the complex number
           *
           * @returns {Complex}
           */
          'sin': function () {
            // sin(z) = ( e^iz - e^-iz ) / 2i 
            //        = sin(a)cosh(b) + i cos(a)sinh(b)

            var a = this['re'];
            var b = this['im'];
            return new Complex(Math.sin(a) * cosh(b), Math.cos(a) * sinh(b));
          },
          /**
           * Calculate the cosine
           *
           * @returns {Complex}
           */
          'cos': function () {
            // cos(z) = ( e^iz + e^-iz ) / 2 
            //        = cos(a)cosh(b) - i sin(a)sinh(b)

            var a = this['re'];
            var b = this['im'];
            return new Complex(Math.cos(a) * cosh(b), -Math.sin(a) * sinh(b));
          },
          /**
           * Calculate the tangent
           *
           * @returns {Complex}
           */
          'tan': function () {
            // tan(z) = sin(z) / cos(z) 
            //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )
            //        = ( e^2iz - 1 ) / i( e^2iz + 1 )
            //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )

            var a = 2 * this['re'];
            var b = 2 * this['im'];
            var d = Math.cos(a) + cosh(b);
            return new Complex(Math.sin(a) / d, sinh(b) / d);
          },
          /**
           * Calculate the cotangent
           *
           * @returns {Complex}
           */
          'cot': function () {
            // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

            var a = 2 * this['re'];
            var b = 2 * this['im'];
            var d = Math.cos(a) - cosh(b);
            return new Complex(-Math.sin(a) / d, sinh(b) / d);
          },
          /**
           * Calculate the secant
           *
           * @returns {Complex}
           */
          'sec': function () {
            // sec(c) = 2 / (e^(ci) + e^(-ci))

            var a = this['re'];
            var b = this['im'];
            var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);
            return new Complex(Math.cos(a) * cosh(b) / d, Math.sin(a) * sinh(b) / d);
          },
          /**
           * Calculate the cosecans
           *
           * @returns {Complex}
           */
          'csc': function () {
            // csc(c) = 2i / (e^(ci) - e^(-ci))

            var a = this['re'];
            var b = this['im'];
            var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);
            return new Complex(Math.sin(a) * cosh(b) / d, -Math.cos(a) * sinh(b) / d);
          },
          /**
           * Calculate the complex arcus sinus
           *
           * @returns {Complex}
           */
          'asin': function () {
            // asin(c) = -i * log(ci + sqrt(1 - c^2))

            var a = this['re'];
            var b = this['im'];
            var t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();
            var t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();
            return new Complex(t2['im'], -t2['re']);
          },
          /**
           * Calculate the complex arcus cosinus
           *
           * @returns {Complex}
           */
          'acos': function () {
            // acos(c) = i * log(c - i * sqrt(1 - c^2))

            var a = this['re'];
            var b = this['im'];
            var t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();
            var t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();
            return new Complex(Math.PI / 2 - t2['im'], t2['re']);
          },
          /**
           * Calculate the complex arcus tangent
           *
           * @returns {Complex}
           */
          'atan': function () {
            // atan(c) = i / 2 log((i + x) / (i - x))

            var a = this['re'];
            var b = this['im'];
            if (a === 0) {
              if (b === 1) {
                return new Complex(0, Infinity);
              }
              if (b === -1) {
                return new Complex(0, -Infinity);
              }
            }
            var d = a * a + (1.0 - b) * (1.0 - b);
            var t1 = new Complex((1 - b * b - a * a) / d, -2 * a / d).log();
            return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
          },
          /**
           * Calculate the complex arcus cotangent
           *
           * @returns {Complex}
           */
          'acot': function () {
            // acot(c) = i / 2 log((c - i) / (c + i))

            var a = this['re'];
            var b = this['im'];
            if (b === 0) {
              return new Complex(Math.atan2(1, a), 0);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex(a / d, -b / d).atan() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();
          },
          /**
           * Calculate the complex arcus secant
           *
           * @returns {Complex}
           */
          'asec': function () {
            // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

            var a = this['re'];
            var b = this['im'];
            if (a === 0 && b === 0) {
              return new Complex(0, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex(a / d, -b / d).acos() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();
          },
          /**
           * Calculate the complex arcus cosecans
           *
           * @returns {Complex}
           */
          'acsc': function () {
            // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

            var a = this['re'];
            var b = this['im'];
            if (a === 0 && b === 0) {
              return new Complex(Math.PI / 2, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex(a / d, -b / d).asin() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();
          },
          /**
           * Calculate the complex sinh
           *
           * @returns {Complex}
           */
          'sinh': function () {
            // sinh(c) = (e^c - e^-c) / 2

            var a = this['re'];
            var b = this['im'];
            return new Complex(sinh(a) * Math.cos(b), cosh(a) * Math.sin(b));
          },
          /**
           * Calculate the complex cosh
           *
           * @returns {Complex}
           */
          'cosh': function () {
            // cosh(c) = (e^c + e^-c) / 2

            var a = this['re'];
            var b = this['im'];
            return new Complex(cosh(a) * Math.cos(b), sinh(a) * Math.sin(b));
          },
          /**
           * Calculate the complex tanh
           *
           * @returns {Complex}
           */
          'tanh': function () {
            // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

            var a = 2 * this['re'];
            var b = 2 * this['im'];
            var d = cosh(a) + Math.cos(b);
            return new Complex(sinh(a) / d, Math.sin(b) / d);
          },
          /**
           * Calculate the complex coth
           *
           * @returns {Complex}
           */
          'coth': function () {
            // coth(c) = (e^c + e^-c) / (e^c - e^-c)

            var a = 2 * this['re'];
            var b = 2 * this['im'];
            var d = cosh(a) - Math.cos(b);
            return new Complex(sinh(a) / d, -Math.sin(b) / d);
          },
          /**
           * Calculate the complex coth
           *
           * @returns {Complex}
           */
          'csch': function () {
            // csch(c) = 2 / (e^c - e^-c)

            var a = this['re'];
            var b = this['im'];
            var d = Math.cos(2 * b) - cosh(2 * a);
            return new Complex(-2 * sinh(a) * Math.cos(b) / d, 2 * cosh(a) * Math.sin(b) / d);
          },
          /**
           * Calculate the complex sech
           *
           * @returns {Complex}
           */
          'sech': function () {
            // sech(c) = 2 / (e^c + e^-c)

            var a = this['re'];
            var b = this['im'];
            var d = Math.cos(2 * b) + cosh(2 * a);
            return new Complex(2 * cosh(a) * Math.cos(b) / d, -2 * sinh(a) * Math.sin(b) / d);
          },
          /**
           * Calculate the complex asinh
           *
           * @returns {Complex}
           */
          'asinh': function () {
            // asinh(c) = log(c + sqrt(c^2 + 1))

            var tmp = this['im'];
            this['im'] = -this['re'];
            this['re'] = tmp;
            var res = this['asin']();
            this['re'] = -this['im'];
            this['im'] = tmp;
            tmp = res['re'];
            res['re'] = -res['im'];
            res['im'] = tmp;
            return res;
          },
          /**
           * Calculate the complex acosh
           *
           * @returns {Complex}
           */
          'acosh': function () {
            // acosh(c) = log(c + sqrt(c^2 - 1))

            var res = this['acos']();
            if (res['im'] <= 0) {
              var tmp = res['re'];
              res['re'] = -res['im'];
              res['im'] = tmp;
            } else {
              var tmp = res['im'];
              res['im'] = -res['re'];
              res['re'] = tmp;
            }
            return res;
          },
          /**
           * Calculate the complex atanh
           *
           * @returns {Complex}
           */
          'atanh': function () {
            // atanh(c) = log((1+c) / (1-c)) / 2

            var a = this['re'];
            var b = this['im'];
            var noIM = a > 1 && b === 0;
            var oneMinus = 1 - a;
            var onePlus = 1 + a;
            var d = oneMinus * oneMinus + b * b;
            var x = d !== 0 ? new Complex((onePlus * oneMinus - b * b) / d, (b * oneMinus + onePlus * b) / d) : new Complex(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);
            var temp = x['re'];
            x['re'] = logHypot(x['re'], x['im']) / 2;
            x['im'] = Math.atan2(x['im'], temp) / 2;
            if (noIM) {
              x['im'] = -x['im'];
            }
            return x;
          },
          /**
           * Calculate the complex acoth
           *
           * @returns {Complex}
           */
          'acoth': function () {
            // acoth(c) = log((c+1) / (c-1)) / 2

            var a = this['re'];
            var b = this['im'];
            if (a === 0 && b === 0) {
              return new Complex(0, Math.PI / 2);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex(a / d, -b / d).atanh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atanh();
          },
          /**
           * Calculate the complex acsch
           *
           * @returns {Complex}
           */
          'acsch': function () {
            // acsch(c) = log((1+sqrt(1+c^2))/c)

            var a = this['re'];
            var b = this['im'];
            if (b === 0) {
              return new Complex(a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity, 0);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex(a / d, -b / d).asinh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asinh();
          },
          /**
           * Calculate the complex asech
           *
           * @returns {Complex}
           */
          'asech': function () {
            // asech(c) = log((1+sqrt(1-c^2))/c)

            var a = this['re'];
            var b = this['im'];
            if (this['isZero']()) {
              return Complex['INFINITY'];
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex(a / d, -b / d).acosh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acosh();
          },
          /**
           * Calculate the complex inverse 1/z
           *
           * @returns {Complex}
           */
          'inverse': function () {
            // 1 / 0 = Infinity and 1 / Infinity = 0
            if (this['isZero']()) {
              return Complex['INFINITY'];
            }
            if (this['isInfinite']()) {
              return Complex['ZERO'];
            }
            var a = this['re'];
            var b = this['im'];
            var d = a * a + b * b;
            return new Complex(a / d, -b / d);
          },
          /**
           * Returns the complex conjugate
           *
           * @returns {Complex}
           */
          'conjugate': function () {
            return new Complex(this['re'], -this['im']);
          },
          /**
           * Gets the negated complex number
           *
           * @returns {Complex}
           */
          'neg': function () {
            return new Complex(-this['re'], -this['im']);
          },
          /**
           * Ceils the actual complex number
           *
           * @returns {Complex}
           */
          'ceil': function (places) {
            places = Math.pow(10, places || 0);
            return new Complex(Math.ceil(this['re'] * places) / places, Math.ceil(this['im'] * places) / places);
          },
          /**
           * Floors the actual complex number
           *
           * @returns {Complex}
           */
          'floor': function (places) {
            places = Math.pow(10, places || 0);
            return new Complex(Math.floor(this['re'] * places) / places, Math.floor(this['im'] * places) / places);
          },
          /**
           * Ceils the actual complex number
           *
           * @returns {Complex}
           */
          'round': function (places) {
            places = Math.pow(10, places || 0);
            return new Complex(Math.round(this['re'] * places) / places, Math.round(this['im'] * places) / places);
          },
          /**
           * Compares two complex numbers
           *
           * **Note:** new Complex(Infinity).equals(Infinity) === false
           *
           * @returns {boolean}
           */
          'equals': function (a, b) {
            var z = new Complex(a, b);
            return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] && Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
          },
          /**
           * Clones the actual object
           *
           * @returns {Complex}
           */
          'clone': function () {
            return new Complex(this['re'], this['im']);
          },
          /**
           * Gets a string of the actual complex number
           *
           * @returns {string}
           */
          'toString': function () {
            var a = this['re'];
            var b = this['im'];
            var ret = "";
            if (this['isNaN']()) {
              return 'NaN';
            }
            if (this['isInfinite']()) {
              return 'Infinity';
            }
            if (Math.abs(a) < Complex['EPSILON']) {
              a = 0;
            }
            if (Math.abs(b) < Complex['EPSILON']) {
              b = 0;
            }

            // If is real number
            if (b === 0) {
              return ret + a;
            }
            if (a !== 0) {
              ret += a;
              ret += " ";
              if (b < 0) {
                b = -b;
                ret += "-";
              } else {
                ret += "+";
              }
              ret += " ";
            } else if (b < 0) {
              b = -b;
              ret += "-";
            }
            if (1 !== b) {
              // b is the absolute imaginary part
              ret += b;
            }
            return ret + "i";
          },
          /**
           * Returns the actual number as a vector
           *
           * @returns {Array}
           */
          'toVector': function () {
            return [this['re'], this['im']];
          },
          /**
           * Returns the actual real value of the current object
           *
           * @returns {number|null}
           */
          'valueOf': function () {
            if (this['im'] === 0) {
              return this['re'];
            }
            return null;
          },
          /**
           * Determines whether a complex number is not on the Riemann sphere.
           *
           * @returns {boolean}
           */
          'isNaN': function () {
            return isNaN(this['re']) || isNaN(this['im']);
          },
          /**
           * Determines whether or not a complex number is at the zero pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          'isZero': function () {
            return this['im'] === 0 && this['re'] === 0;
          },
          /**
           * Determines whether a complex number is not at the infinity pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          'isFinite': function () {
            return isFinite(this['re']) && isFinite(this['im']);
          },
          /**
           * Determines whether or not a complex number is at the infinity pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          'isInfinite': function () {
            return !(this['isNaN']() || this['isFinite']());
          }
        };
        Complex['ZERO'] = new Complex(0, 0);
        Complex['ONE'] = new Complex(1, 0);
        Complex['I'] = new Complex(0, 1);
        Complex['PI'] = new Complex(Math.PI, 0);
        Complex['E'] = new Complex(Math.E, 0);
        Complex['INFINITY'] = new Complex(Infinity, Infinity);
        Complex['NAN'] = new Complex(NaN, NaN);
        Complex['EPSILON'] = 1e-15;
        {
          Object.defineProperty(Complex, "__esModule", {
            'value': true
          });
          Complex['default'] = Complex;
          Complex['Complex'] = Complex;
          module['exports'] = Complex;
        }
      })();
    })(complex$1);
    var Complex$1 = /*@__PURE__*/getDefaultExportFromCjs(complexExports);

    var name$12 = 'Complex';
    var dependencies$12 = [];
    var createComplexClass = /* #__PURE__ */factory(name$12, dependencies$12, () => {
      /**
       * Attach type information
       */
      Complex$1.prototype.type = 'Complex';
      Complex$1.prototype.isComplex = true;
      /**
       * Get a JSON representation of the complex number
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
       */

      Complex$1.prototype.toJSON = function () {
        return {
          mathjs: 'Complex',
          re: this.re,
          im: this.im
        };
      };
      /*
       * Return the value of the complex number in polar notation
       * The angle phi will be set in the interval of [-pi, pi].
       * @return {{r: number, phi: number}} Returns and object with properties r and phi.
       */

      Complex$1.prototype.toPolar = function () {
        return {
          r: this.abs(),
          phi: this.arg()
        };
      };
      /**
       * Get a string representation of the complex number,
       * with optional formatting options.
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @return {string} str
       */

      Complex$1.prototype.format = function (options) {
        var str = '';
        var im = this.im;
        var re = this.re;
        var strRe = format$2(this.re, options);
        var strIm = format$2(this.im, options); // round either re or im when smaller than the configured precision

        var precision = isNumber(options) ? options : options ? options.precision : null;
        if (precision !== null) {
          var epsilon = Math.pow(10, -precision);
          if (Math.abs(re / im) < epsilon) {
            re = 0;
          }
          if (Math.abs(im / re) < epsilon) {
            im = 0;
          }
        }
        if (im === 0) {
          // real value
          str = strRe;
        } else if (re === 0) {
          // purely complex value
          if (im === 1) {
            str = 'i';
          } else if (im === -1) {
            str = '-i';
          } else {
            str = strIm + 'i';
          }
        } else {
          // complex value
          if (im < 0) {
            if (im === -1) {
              str = strRe + ' - i';
            } else {
              str = strRe + ' - ' + strIm.substring(1) + 'i';
            }
          } else {
            if (im === 1) {
              str = strRe + ' + i';
            } else {
              str = strRe + ' + ' + strIm + 'i';
            }
          }
        }
        return str;
      };
      /**
       * Create a complex number from polar coordinates
       *
       * Usage:
       *
       *     Complex.fromPolar(r: number, phi: number) : Complex
       *     Complex.fromPolar({r: number, phi: number}) : Complex
       *
       * @param {*} args...
       * @return {Complex}
       */

      Complex$1.fromPolar = function (args) {
        switch (arguments.length) {
          case 1:
            {
              var arg = arguments[0];
              if (typeof arg === 'object') {
                return Complex$1(arg);
              } else {
                throw new TypeError('Input has to be an object with r and phi keys.');
              }
            }
          case 2:
            {
              var r = arguments[0];
              var phi = arguments[1];
              if (isNumber(r)) {
                if (isUnit(phi) && phi.hasBase('ANGLE')) {
                  // convert unit to a number in radians
                  phi = phi.toNumber('rad');
                }
                if (isNumber(phi)) {
                  return new Complex$1({
                    r,
                    phi
                  });
                }
                throw new TypeError('Phi is not a number nor an angle unit.');
              } else {
                throw new TypeError('Radius r is not a number.');
              }
            }
          default:
            throw new SyntaxError('Wrong number of arguments in function fromPolar');
        }
      };
      Complex$1.prototype.valueOf = Complex$1.prototype.toString;
      /**
       * Create a Complex number from a JSON object
       * @param {Object} json  A JSON Object structured as
       *                       {"mathjs": "Complex", "re": 2, "im": 3}
       *                       All properties are optional, default values
       *                       for `re` and `im` are 0.
       * @return {Complex} Returns a new Complex number
       */

      Complex$1.fromJSON = function (json) {
        return new Complex$1(json);
      };
      /**
       * Compare two complex numbers, `a` and `b`:
       *
       * - Returns 1 when the real part of `a` is larger than the real part of `b`
       * - Returns -1 when the real part of `a` is smaller than the real part of `b`
       * - Returns 1 when the real parts are equal
       *   and the imaginary part of `a` is larger than the imaginary part of `b`
       * - Returns -1 when the real parts are equal
       *   and the imaginary part of `a` is smaller than the imaginary part of `b`
       * - Returns 0 when both real and imaginary parts are equal.
       *
       * @params {Complex} a
       * @params {Complex} b
       * @returns {number} Returns the comparison result: -1, 0, or 1
       */

      Complex$1.compare = function (a, b) {
        if (a.re > b.re) {
          return 1;
        }
        if (a.re < b.re) {
          return -1;
        }
        if (a.im > b.im) {
          return 1;
        }
        if (a.im < b.im) {
          return -1;
        }
        return 0;
      };
      return Complex$1;
    }, {
      isClass: true
    });

    var fractionExports = {};
    var fraction$1 = {
      get exports(){ return fractionExports; },
      set exports(v){ fractionExports = v; },
    };

    /**
     * @license Fraction.js v4.2.0 05/03/2022
     * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
     *
     * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/
    (function (module, exports) {
      /**
       *
       * This class offers the possibility to calculate fractions.
       * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
       *
       * Array/Object form
       * [ 0 => <nominator>, 1 => <denominator> ]
       * [ n => <nominator>, d => <denominator> ]
       *
       * Integer form
       * - Single integer value
       *
       * Double form
       * - Single double value
       *
       * String form
       * 123.456 - a simple double
       * 123/456 - a string fraction
       * 123.'456' - a double with repeating decimal places
       * 123.(456) - synonym
       * 123.45'6' - a double with repeating last place
       * 123.45(6) - synonym
       *
       * Example:
       *
       * var f = new Fraction("9.4'31'");
       * f.mul([-4, 3]).div(4.9);
       *
       */

      (function (root) {

        // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
        // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
        // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
        var MAX_CYCLE_LEN = 2000;

        // Parsed data to avoid calling "new" all the time
        var P = {
          "s": 1,
          "n": 0,
          "d": 1
        };
        function assign(n, s) {
          if (isNaN(n = parseInt(n, 10))) {
            throw Fraction['InvalidParameter'];
          }
          return n * s;
        }

        // Creates a new Fraction internally without the need of the bulky constructor
        function newFraction(n, d) {
          if (d === 0) {
            throw Fraction['DivisionByZero'];
          }
          var f = Object.create(Fraction.prototype);
          f["s"] = n < 0 ? -1 : 1;
          n = n < 0 ? -n : n;
          var a = gcd(n, d);
          f["n"] = n / a;
          f["d"] = d / a;
          return f;
        }
        function factorize(num) {
          var factors = {};
          var n = num;
          var i = 2;
          var s = 4;
          while (s <= n) {
            while (n % i === 0) {
              n /= i;
              factors[i] = (factors[i] || 0) + 1;
            }
            s += 1 + 2 * i++;
          }
          if (n !== num) {
            if (n > 1) factors[n] = (factors[n] || 0) + 1;
          } else {
            factors[num] = (factors[num] || 0) + 1;
          }
          return factors;
        }
        var parse = function (p1, p2) {
          var n = 0,
            d = 1,
            s = 1;
          var v = 0,
            w = 0,
            x = 0,
            y = 1,
            z = 1;
          var A = 0,
            B = 1;
          var C = 1,
            D = 1;
          var N = 10000000;
          var M;
          if (p1 === undefined || p1 === null) ; else if (p2 !== undefined) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
              throw Fraction['NonIntegerParameter'];
            }
          } else switch (typeof p1) {
            case "object":
              {
                if ("d" in p1 && "n" in p1) {
                  n = p1["n"];
                  d = p1["d"];
                  if ("s" in p1) n *= p1["s"];
                } else if (0 in p1) {
                  n = p1[0];
                  if (1 in p1) d = p1[1];
                } else {
                  throw Fraction['InvalidParameter'];
                }
                s = n * d;
                break;
              }
            case "number":
              {
                if (p1 < 0) {
                  s = p1;
                  p1 = -p1;
                }
                if (p1 % 1 === 0) {
                  n = p1;
                } else if (p1 > 0) {
                  // check for != 0, scale would become NaN (log(0)), which converges really slow

                  if (p1 >= 1) {
                    z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                    p1 /= z;
                  }

                  // Using Farey Sequences
                  // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

                  while (B <= N && D <= N) {
                    M = (A + C) / (B + D);
                    if (p1 === M) {
                      if (B + D <= N) {
                        n = A + C;
                        d = B + D;
                      } else if (D > B) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                      break;
                    } else {
                      if (p1 > M) {
                        A += C;
                        B += D;
                      } else {
                        C += A;
                        D += B;
                      }
                      if (B > N) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                    }
                  }
                  n *= z;
                } else if (isNaN(p1) || isNaN(p2)) {
                  d = n = NaN;
                }
                break;
              }
            case "string":
              {
                B = p1.match(/\d+|./g);
                if (B === null) throw Fraction['InvalidParameter'];
                if (B[A] === '-') {
                  // Check for minus sign at the beginning
                  s = -1;
                  A++;
                } else if (B[A] === '+') {
                  // Check for plus sign at the beginning
                  A++;
                }
                if (B.length === A + 1) {
                  // Check if it's just a simple number "1234"
                  w = assign(B[A++], s);
                } else if (B[A + 1] === '.' || B[A] === '.') {
                  // Check if it's a decimal number

                  if (B[A] !== '.') {
                    // Handle 0.5 and .5
                    v = assign(B[A++], s);
                  }
                  A++;

                  // Check for decimal places
                  if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                    w = assign(B[A], s);
                    y = Math.pow(10, B[A].length);
                    A++;
                  }

                  // Check for repeating places
                  if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                    x = assign(B[A + 1], s);
                    z = Math.pow(10, B[A + 1].length) - 1;
                    A += 3;
                  }
                } else if (B[A + 1] === '/' || B[A + 1] === ':') {
                  // Check for a simple fraction "123/456" or "123:456"
                  w = assign(B[A], s);
                  y = assign(B[A + 2], 1);
                  A += 3;
                } else if (B[A + 3] === '/' && B[A + 1] === ' ') {
                  // Check for a complex fraction "123 1/2"
                  v = assign(B[A], s);
                  w = assign(B[A + 2], s);
                  y = assign(B[A + 4], 1);
                  A += 5;
                }
                if (B.length <= A) {
                  // Check for more tokens on the stack
                  d = y * z;
                  s = /* void */
                  n = x + d * v + z * w;
                  break;
                }

                /* Fall through on error */
              }

            default:
              throw Fraction['InvalidParameter'];
          }
          if (d === 0) {
            throw Fraction['DivisionByZero'];
          }
          P["s"] = s < 0 ? -1 : 1;
          P["n"] = Math.abs(n);
          P["d"] = Math.abs(d);
        };
        function modpow(b, e, m) {
          var r = 1;
          for (; e > 0; b = b * b % m, e >>= 1) {
            if (e & 1) {
              r = r * b % m;
            }
          }
          return r;
        }
        function cycleLen(n, d) {
          for (; d % 2 === 0; d /= 2) {}
          for (; d % 5 === 0; d /= 5) {}
          if (d === 1)
            // Catch non-cyclic numbers
            return 0;

          // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
          // 10^(d-1) % d == 1
          // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
          // as we want to translate the numbers to strings.

          var rem = 10 % d;
          var t = 1;
          for (; rem !== 1; t++) {
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN) return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
          }

          return t;
        }
        function cycleStart(n, d, len) {
          var rem1 = 1;
          var rem2 = modpow(10, len, d);
          for (var t = 0; t < 300; t++) {
            // s < ~log10(Number.MAX_VALUE)
            // Solve 10^s == 10^(s+t) (mod d)

            if (rem1 === rem2) return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
          }
          return 0;
        }
        function gcd(a, b) {
          if (!a) return b;
          if (!b) return a;
          while (1) {
            a %= b;
            if (!a) return b;
            b %= a;
            if (!b) return a;
          }
        }

        /**
         * Module constructor
         *
         * @constructor
         * @param {number|Fraction=} a
         * @param {number=} b
         */
        function Fraction(a, b) {
          parse(a, b);
          if (this instanceof Fraction) {
            a = gcd(P["d"], P["n"]); // Abuse variable a
            this["s"] = P["s"];
            this["n"] = P["n"] / a;
            this["d"] = P["d"] / a;
          } else {
            return newFraction(P['s'] * P['n'], P['d']);
          }
        }
        Fraction['DivisionByZero'] = new Error("Division by Zero");
        Fraction['InvalidParameter'] = new Error("Invalid argument");
        Fraction['NonIntegerParameter'] = new Error("Parameters must be integer");
        Fraction.prototype = {
          "s": 1,
          "n": 0,
          "d": 1,
          /**
           * Calculates the absolute value
           *
           * Ex: new Fraction(-4).abs() => 4
           **/
          "abs": function () {
            return newFraction(this["n"], this["d"]);
          },
          /**
           * Inverts the sign of the current fraction
           *
           * Ex: new Fraction(-4).neg() => 4
           **/
          "neg": function () {
            return newFraction(-this["s"] * this["n"], this["d"]);
          },
          /**
           * Adds two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
           **/
          "add": function (a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
          },
          /**
           * Subtracts two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
           **/
          "sub": function (a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
          },
          /**
           * Multiplies two rational numbers
           *
           * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
           **/
          "mul": function (a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["n"], this["d"] * P["d"]);
          },
          /**
           * Divides two rational numbers
           *
           * Ex: new Fraction("-17.(345)").inverse().div(3)
           **/
          "div": function (a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["d"], this["d"] * P["n"]);
          },
          /**
           * Clones the actual object
           *
           * Ex: new Fraction("-17.(345)").clone()
           **/
          "clone": function () {
            return newFraction(this['s'] * this['n'], this['d']);
          },
          /**
           * Calculates the modulo of two rational numbers - a more precise fmod
           *
           * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
           **/
          "mod": function (a, b) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
              return new Fraction(NaN);
            }
            if (a === undefined) {
              return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse(a, b);
            if (0 === P["n"] && 0 === this["d"]) {
              throw Fraction['DivisionByZero'];
            }

            /*
             * First silly attempt, kinda slow
             *
             return that["sub"]({
             "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
             "d": num["d"],
             "s": this["s"]
             });*/

            /*
             * New attempt: a1 / b1 = a2 / b2 * q + r
             * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
             * => (b2 * a1 % a2 * b1) / (b1 * b2)
             */
            return newFraction(this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]), P["d"] * this["d"]);
          },
          /**
           * Calculates the fractional gcd of two rational numbers
           *
           * Ex: new Fraction(5,8).gcd(3,7) => 1/56
           */
          "gcd": function (a, b) {
            parse(a, b);

            // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

            return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
          },
          /**
           * Calculates the fractional lcm of two rational numbers
           *
           * Ex: new Fraction(5,8).lcm(3,7) => 15
           */
          "lcm": function (a, b) {
            parse(a, b);

            // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

            if (P["n"] === 0 && this["n"] === 0) {
              return newFraction(0, 1);
            }
            return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
          },
          /**
           * Calculates the ceil of a rational number
           *
           * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
           **/
          "ceil": function (places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Calculates the floor of a rational number
           *
           * Ex: new Fraction('4.(3)').floor() => (4 / 1)
           **/
          "floor": function (places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Rounds a rational numbers
           *
           * Ex: new Fraction('4.(3)').round() => (4 / 1)
           **/
          "round": function (places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Gets the inverse of the fraction, means numerator and denominator are exchanged
           *
           * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
           **/
          "inverse": function () {
            return newFraction(this["s"] * this["d"], this["n"]);
          },
          /**
           * Calculates the fraction to some rational exponent, if possible
           *
           * Ex: new Fraction(-1,2).pow(-3) => -8
           */
          "pow": function (a, b) {
            parse(a, b);

            // Trivial case when exp is an integer

            if (P['d'] === 1) {
              if (P['s'] < 0) {
                return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
              } else {
                return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
              }
            }

            // Negative roots become complex
            //     (-a/b)^(c/d) = x
            // <=> (-1)^(c/d) * (a/b)^(c/d) = x
            // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
            // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
            // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
            if (this['s'] < 0) return null;

            // Now prime factor n and d
            var N = factorize(this['n']);
            var D = factorize(this['d']);

            // Exponentiate and take root for n and d individually
            var n = 1;
            var d = 1;
            for (var k in N) {
              if (k === '1') continue;
              if (k === '0') {
                n = 0;
                break;
              }
              N[k] *= P['n'];
              if (N[k] % P['d'] === 0) {
                N[k] /= P['d'];
              } else return null;
              n *= Math.pow(k, N[k]);
            }
            for (var k in D) {
              if (k === '1') continue;
              D[k] *= P['n'];
              if (D[k] % P['d'] === 0) {
                D[k] /= P['d'];
              } else return null;
              d *= Math.pow(k, D[k]);
            }
            if (P['s'] < 0) {
              return newFraction(d, n);
            }
            return newFraction(n, d);
          },
          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "equals": function (a, b) {
            parse(a, b);
            return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
          },

          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "compare": function (a, b) {
            parse(a, b);
            var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
            return (0 < t) - (t < 0);
          },
          "simplify": function (eps) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
              return this;
            }
            eps = eps || 0.001;
            var thisABS = this['abs']();
            var cont = thisABS['toContinued']();
            for (var i = 1; i < cont.length; i++) {
              var s = newFraction(cont[i - 1], 1);
              for (var k = i - 2; k >= 0; k--) {
                s = s['inverse']()['add'](cont[k]);
              }
              if (s['sub'](thisABS)['abs']().valueOf() < eps) {
                return s['mul'](this['s']);
              }
            }
            return this;
          },
          /**
           * Check if two rational numbers are divisible
           *
           * Ex: new Fraction(19.6).divisible(1.5);
           */
          "divisible": function (a, b) {
            parse(a, b);
            return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
          },
          /**
           * Returns a decimal representation of the fraction
           *
           * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
           **/
          'valueOf': function () {
            return this["s"] * this["n"] / this["d"];
          },
          /**
           * Returns a string-fraction representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
           **/
          'toFraction': function (excludeWhole) {
            var whole,
              str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += '-';
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                str += " ";
                n %= d;
              }
              str += n;
              str += '/';
              str += d;
            }
            return str;
          },
          /**
           * Returns a latex representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
           **/
          'toLatex': function (excludeWhole) {
            var whole,
              str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += '-';
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                n %= d;
              }
              str += "\\frac{";
              str += n;
              str += '}{';
              str += d;
              str += '}';
            }
            return str;
          },
          /**
           * Returns an array of continued fraction elements
           *
           * Ex: new Fraction("7/8").toContinued() => [0,1,7]
           */
          'toContinued': function () {
            var t;
            var a = this['n'];
            var b = this['d'];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
              return res;
            }
            do {
              res.push(Math.floor(a / b));
              t = a % b;
              a = b;
              b = t;
            } while (a !== 1);
            return res;
          },
          /**
           * Creates a string representation of a fraction with all digits
           *
           * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
           **/
          'toString': function (dec) {
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
              return "NaN";
            }
            dec = dec || 15; // 15 = decimal places when no repetation

            var cycLen = cycleLen(N, D); // Cycle length
            var cycOff = cycleStart(N, D, cycLen); // Cycle start

            var str = this['s'] < 0 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N) str += ".";
            if (cycLen) {
              for (var i = cycOff; i--;) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += "(";
              for (var i = cycLen; i--;) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += ")";
            } else {
              for (var i = dec; N && i--;) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
            }
            return str;
          }
        };
        {
          Object.defineProperty(Fraction, "__esModule", {
            'value': true
          });
          Fraction['default'] = Fraction;
          Fraction['Fraction'] = Fraction;
          module['exports'] = Fraction;
        }
      })();
    })(fraction$1);
    var Fraction$1 = /*@__PURE__*/getDefaultExportFromCjs(fractionExports);

    var name$11 = 'Fraction';
    var dependencies$11 = [];
    var createFractionClass = /* #__PURE__ */factory(name$11, dependencies$11, () => {
      /**
       * Attach type information
       */
      Fraction$1.prototype.type = 'Fraction';
      Fraction$1.prototype.isFraction = true;
      /**
       * Get a JSON representation of a Fraction containing type information
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "Fraction", "n": 3, "d": 8}`
       */

      Fraction$1.prototype.toJSON = function () {
        return {
          mathjs: 'Fraction',
          n: this.s * this.n,
          d: this.d
        };
      };
      /**
       * Instantiate a Fraction from a JSON object
       * @param {Object} json  a JSON object structured as:
       *                       `{"mathjs": "Fraction", "n": 3, "d": 8}`
       * @return {BigNumber}
       */

      Fraction$1.fromJSON = function (json) {
        return new Fraction$1(json);
      };
      return Fraction$1;
    }, {
      isClass: true
    });

    var name$10 = 'Matrix';
    var dependencies$10 = [];
    var createMatrixClass = /* #__PURE__ */factory(name$10, dependencies$10, () => {
      /**
       * @constructor Matrix
       *
       * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
       * array. A matrix can be constructed as:
       *
       *     let matrix = math.matrix(data)
       *
       * Matrix contains the functions to resize, get and set values, get the size,
       * clone the matrix and to convert the matrix to a vector, array, or scalar.
       * Furthermore, one can iterate over the matrix using map and forEach.
       * The internal Array of the Matrix can be accessed using the function valueOf.
       *
       * Example usage:
       *
       *     let matrix = math.matrix([[1, 2], [3, 4]])
       *     matix.size()              // [2, 2]
       *     matrix.resize([3, 2], 5)
       *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
       *     matrix.subset([1,2])       // 3 (indexes are zero-based)
       *
       */
      function Matrix() {
        if (!(this instanceof Matrix)) {
          throw new SyntaxError('Constructor must be called with the new operator');
        }
      }
      /**
       * Attach type information
       */

      Matrix.prototype.type = 'Matrix';
      Matrix.prototype.isMatrix = true;
      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()   // retrieve storage format
       *
       * @return {string}           The storage format.
       */

      Matrix.prototype.storage = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke storage on a Matrix interface');
      };
      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()    // retrieve matrix datatype
       *
       * @return {string}           The datatype.
       */

      Matrix.prototype.datatype = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke datatype on a Matrix interface');
      };
      /**
       * Create a new Matrix With the type of the current matrix instance
       * @param {Array | Object} data
       * @param {string} [datatype]
       */

      Matrix.prototype.create = function (data, datatype) {
        throw new Error('Cannot invoke create on a Matrix interface');
      };
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */

      Matrix.prototype.subset = function (index, replacement, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke subset on a Matrix interface');
      };
      /**
       * Get a single element from the matrix.
       * @param {number[]} index   Zero-based index
       * @return {*} value
       */

      Matrix.prototype.get = function (index) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke get on a Matrix interface');
      };
      /**
       * Replace a single element in the matrix.
       * @param {number[]} index   Zero-based index
       * @param {*} value
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be left undefined.
       * @return {Matrix} self
       */

      Matrix.prototype.set = function (index, value, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke set on a Matrix interface');
      };
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @param {number[]} size           The new size the matrix should have.
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {Matrix}                 The resized matrix
       */

      Matrix.prototype.resize = function (size, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke resize on a Matrix interface');
      };
      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * @param {number[]} size           The new size the matrix should have.
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {Matrix}                 The reshaped matrix
       */

      Matrix.prototype.reshape = function (size, defaultValue) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke reshape on a Matrix interface');
      };
      /**
       * Create a clone of the matrix
       * @return {Matrix} clone
       */

      Matrix.prototype.clone = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke clone on a Matrix interface');
      };
      /**
       * Retrieve the size of the matrix.
       * @returns {number[]} size
       */

      Matrix.prototype.size = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke size on a Matrix interface');
      };
      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *
       * @return {Matrix} matrix
       */

      Matrix.prototype.map = function (callback, skipZeros) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke map on a Matrix interface');
      };
      /**
       * Execute a callback function on each entry of the matrix.
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       */

      Matrix.prototype.forEach = function (callback) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke forEach on a Matrix interface');
      };
      /**
       * Iterate over the matrix elements
       * @return {Iterable<{ value, index: number[] }>}
       */

      Matrix.prototype[Symbol.iterator] = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot iterate a Matrix interface');
      };
      /**
       * Create an Array with a copy of the data of the Matrix
       * @returns {Array} array
       */

      Matrix.prototype.toArray = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke toArray on a Matrix interface');
      };
      /**
       * Get the primitive value of the Matrix: a multidimensional array
       * @returns {Array} array
       */

      Matrix.prototype.valueOf = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke valueOf on a Matrix interface');
      };
      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */

      Matrix.prototype.format = function (options) {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke format on a Matrix interface');
      };
      /**
       * Get a string representation of the matrix
       * @returns {string} str
       */

      Matrix.prototype.toString = function () {
        // must be implemented by each of the Matrix implementations
        throw new Error('Cannot invoke toString on a Matrix interface');
      };
      return Matrix;
    }, {
      isClass: true
    });

    var name$$ = 'DenseMatrix';
    var dependencies$$ = ['Matrix'];
    var createDenseMatrixClass = /* #__PURE__ */factory(name$$, dependencies$$, _ref => {
      var {
        Matrix
      } = _ref;

      /**
       * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
       * @class DenseMatrix
       * @enum {{ value, index: number[] }}
       */
      function DenseMatrix(data, datatype) {
        if (!(this instanceof DenseMatrix)) {
          throw new SyntaxError('Constructor must be called with the new operator');
        }
        if (datatype && !isString(datatype)) {
          throw new Error('Invalid datatype: ' + datatype);
        }
        if (isMatrix(data)) {
          // check data is a DenseMatrix
          if (data.type === 'DenseMatrix') {
            // clone data & size
            this._data = clone$1(data._data);
            this._size = clone$1(data._size);
            this._datatype = datatype || data._datatype;
          } else {
            // build data from existing matrix
            this._data = data.toArray();
            this._size = data.size();
            this._datatype = datatype || data._datatype;
          }
        } else if (data && isArray(data.data) && isArray(data.size)) {
          // initialize fields from JSON representation
          this._data = data.data;
          this._size = data.size; // verify the dimensions of the array

          validate(this._data, this._size);
          this._datatype = datatype || data.datatype;
        } else if (isArray(data)) {
          // replace nested Matrices with Arrays
          this._data = preprocess(data); // get the dimensions of the array

          this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array

          validate(this._data, this._size); // data type unknown

          this._datatype = datatype;
        } else if (data) {
          // unsupported type
          throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
        } else {
          // nothing provided
          this._data = [];
          this._size = [0];
          this._datatype = datatype;
        }
      }
      DenseMatrix.prototype = new Matrix();
      /**
       * Create a new DenseMatrix
       */

      DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {
        return new DenseMatrix(data, datatype);
      };
      /**
       * Attach type information
       */

      DenseMatrix.prototype.type = 'DenseMatrix';
      DenseMatrix.prototype.isDenseMatrix = true;
      /**
       * Get the matrix type
       *
       * Usage:
       *    const matrixType = matrix.getDataType()  // retrieves the matrix type
       *
       * @memberOf DenseMatrix
       * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
       */

      DenseMatrix.prototype.getDataType = function () {
        return getArrayDataType(this._data, typeOf);
      };
      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()  // retrieve storage format
       *
       * @memberof DenseMatrix
       * @return {string}           The storage format.
       */

      DenseMatrix.prototype.storage = function () {
        return 'dense';
      };
      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()   // retrieve matrix datatype
       *
       * @memberof DenseMatrix
       * @return {string}           The datatype.
       */

      DenseMatrix.prototype.datatype = function () {
        return this._datatype;
      };
      /**
       * Create a new DenseMatrix
       * @memberof DenseMatrix
       * @param {Array} data
       * @param {string} [datatype]
       */

      DenseMatrix.prototype.create = function (data, datatype) {
        return new DenseMatrix(data, datatype);
      };
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @memberof DenseMatrix
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */

      DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
        switch (arguments.length) {
          case 1:
            return _get(this, index);
          // intentional fall through

          case 2:
          case 3:
            return _set(this, index, replacement, defaultValue);
          default:
            throw new SyntaxError('Wrong number of arguments');
        }
      };
      /**
       * Get a single element from the matrix.
       * @memberof DenseMatrix
       * @param {number[]} index   Zero-based index
       * @return {*} value
       */

      DenseMatrix.prototype.get = function (index) {
        if (!isArray(index)) {
          throw new TypeError('Array expected');
        }
        if (index.length !== this._size.length) {
          throw new DimensionError(index.length, this._size.length);
        } // check index

        for (var x = 0; x < index.length; x++) {
          validateIndex(index[x], this._size[x]);
        }
        var data = this._data;
        for (var i = 0, ii = index.length; i < ii; i++) {
          var indexI = index[i];
          validateIndex(indexI, data.length);
          data = data[indexI];
        }
        return data;
      };
      /**
       * Replace a single element in the matrix.
       * @memberof DenseMatrix
       * @param {number[]} index   Zero-based index
       * @param {*} value
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be left undefined.
       * @return {DenseMatrix} self
       */

      DenseMatrix.prototype.set = function (index, value, defaultValue) {
        if (!isArray(index)) {
          throw new TypeError('Array expected');
        }
        if (index.length < this._size.length) {
          throw new DimensionError(index.length, this._size.length, '<');
        }
        var i, ii, indexI; // enlarge matrix when needed

        var size = index.map(function (i) {
          return i + 1;
        });
        _fit(this, size, defaultValue); // traverse over the dimensions

        var data = this._data;
        for (i = 0, ii = index.length - 1; i < ii; i++) {
          indexI = index[i];
          validateIndex(indexI, data.length);
          data = data[indexI];
        } // set new value

        indexI = index[index.length - 1];
        validateIndex(indexI, data.length);
        data[indexI] = value;
        return this;
      };
      /**
       * Get a submatrix of this matrix
       * @memberof DenseMatrix
       * @param {DenseMatrix} matrix
       * @param {Index} index   Zero-based index
       * @private
       */

      function _get(matrix, index) {
        if (!isIndex(index)) {
          throw new TypeError('Invalid index');
        }
        var isScalar = index.isScalar();
        if (isScalar) {
          // return a scalar
          return matrix.get(index.min());
        } else {
          // validate dimensions
          var size = index.size();
          if (size.length !== matrix._size.length) {
            throw new DimensionError(size.length, matrix._size.length);
          } // validate if any of the ranges in the index is out of range

          var min = index.min();
          var max = index.max();
          for (var i = 0, ii = matrix._size.length; i < ii; i++) {
            validateIndex(min[i], matrix._size[i]);
            validateIndex(max[i], matrix._size[i]);
          } // retrieve submatrix
          // TODO: more efficient when creating an empty matrix and setting _data and _size manually

          return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
        }
      }
      /**
       * Recursively get a submatrix of a multi dimensional matrix.
       * Index is not checked for correct number or length of dimensions.
       * @memberof DenseMatrix
       * @param {Array} data
       * @param {Index} index
       * @param {number} dims   Total number of dimensions
       * @param {number} dim    Current dimension
       * @return {Array} submatrix
       * @private
       */

      function _getSubmatrix(data, index, dims, dim) {
        var last = dim === dims - 1;
        var range = index.dimension(dim);
        if (last) {
          return range.map(function (i) {
            validateIndex(i, data.length);
            return data[i];
          }).valueOf();
        } else {
          return range.map(function (i) {
            validateIndex(i, data.length);
            var child = data[i];
            return _getSubmatrix(child, index, dims, dim + 1);
          }).valueOf();
        }
      }
      /**
       * Replace a submatrix in this matrix
       * Indexes are zero-based.
       * @memberof DenseMatrix
       * @param {DenseMatrix} matrix
       * @param {Index} index
       * @param {DenseMatrix | Array | *} submatrix
       * @param {*} defaultValue          Default value, filled in on new entries when
       *                                  the matrix is resized.
       * @return {DenseMatrix} matrix
       * @private
       */

      function _set(matrix, index, submatrix, defaultValue) {
        if (!index || index.isIndex !== true) {
          throw new TypeError('Invalid index');
        } // get index size and check whether the index contains a single value

        var iSize = index.size();
        var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

        var sSize;
        if (isMatrix(submatrix)) {
          sSize = submatrix.size();
          submatrix = submatrix.valueOf();
        } else {
          sSize = arraySize(submatrix);
        }
        if (isScalar) {
          // set a scalar
          // check whether submatrix is a scalar
          if (sSize.length !== 0) {
            throw new TypeError('Scalar expected');
          }
          matrix.set(index.min(), submatrix, defaultValue);
        } else {
          // set a submatrix
          // validate dimensions
          if (iSize.length < matrix._size.length) {
            throw new DimensionError(iSize.length, matrix._size.length, '<');
          }
          if (sSize.length < iSize.length) {
            // calculate number of missing outer dimensions
            var i = 0;
            var outer = 0;
            while (iSize[i] === 1 && sSize[i] === 1) {
              i++;
            }
            while (iSize[i] === 1) {
              outer++;
              i++;
            } // unsqueeze both outer and inner dimensions

            submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
          } // check whether the size of the submatrix matches the index size

          if (!deepStrictEqual(iSize, sSize)) {
            throw new DimensionError(iSize, sSize, '>');
          } // enlarge matrix when needed

          var size = index.max().map(function (i) {
            return i + 1;
          });
          _fit(matrix, size, defaultValue); // insert the sub matrix

          var dims = iSize.length;
          var dim = 0;
          _setSubmatrix(matrix._data, index, submatrix, dims, dim);
        }
        return matrix;
      }
      /**
       * Replace a submatrix of a multi dimensional matrix.
       * @memberof DenseMatrix
       * @param {Array} data
       * @param {Index} index
       * @param {Array} submatrix
       * @param {number} dims   Total number of dimensions
       * @param {number} dim
       * @private
       */

      function _setSubmatrix(data, index, submatrix, dims, dim) {
        var last = dim === dims - 1;
        var range = index.dimension(dim);
        if (last) {
          range.forEach(function (dataIndex, subIndex) {
            validateIndex(dataIndex);
            data[dataIndex] = submatrix[subIndex[0]];
          });
        } else {
          range.forEach(function (dataIndex, subIndex) {
            validateIndex(dataIndex);
            _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
          });
        }
      }
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @memberof DenseMatrix
       * @param {number[] || Matrix} size The new size the matrix should have.
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {Matrix}                 The resized matrix
       */

      DenseMatrix.prototype.resize = function (size, defaultValue, copy) {
        // validate arguments
        if (!isCollection(size)) {
          throw new TypeError('Array or Matrix expected');
        } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector

        var sizeArray = size.valueOf().map(value => {
          return Array.isArray(value) && value.length === 1 ? value[0] : value;
        }); // matrix to resize

        var m = copy ? this.clone() : this; // resize matrix

        return _resize(m, sizeArray, defaultValue);
      };
      function _resize(matrix, size, defaultValue) {
        // check size
        if (size.length === 0) {
          // first value in matrix
          var v = matrix._data; // go deep

          while (isArray(v)) {
            v = v[0];
          }
          return v;
        } // resize matrix

        matrix._size = size.slice(0); // copy the array

        matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix

        return matrix;
      }
      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * NOTE: This might be better suited to copy by default, instead of modifying
       *       in place. For now, it operates in place to remain consistent with
       *       resize().
       *
       * @memberof DenseMatrix
       * @param {number[]} size           The new size the matrix should have.
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {Matrix}                 The reshaped matrix
       */

      DenseMatrix.prototype.reshape = function (size, copy) {
        var m = copy ? this.clone() : this;
        m._data = reshape(m._data, size);
        var currentLength = m._size.reduce((length, size) => length * size);
        m._size = processSizesWildcard(size, currentLength);
        return m;
      };
      /**
       * Enlarge the matrix when it is smaller than given size.
       * If the matrix is larger or equal sized, nothing is done.
       * @memberof DenseMatrix
       * @param {DenseMatrix} matrix           The matrix to be resized
       * @param {number[]} size
       * @param {*} defaultValue          Default value, filled in on new entries.
       * @private
       */

      function _fit(matrix, size, defaultValue) {
        var
        // copy the array
        newSize = matrix._size.slice(0);
        var changed = false; // add dimensions when needed

        while (newSize.length < size.length) {
          newSize.push(0);
          changed = true;
        } // enlarge size when needed

        for (var i = 0, ii = size.length; i < ii; i++) {
          if (size[i] > newSize[i]) {
            newSize[i] = size[i];
            changed = true;
          }
        }
        if (changed) {
          // resize only when size is changed
          _resize(matrix, newSize, defaultValue);
        }
      }
      /**
       * Create a clone of the matrix
       * @memberof DenseMatrix
       * @return {DenseMatrix} clone
       */

      DenseMatrix.prototype.clone = function () {
        var m = new DenseMatrix({
          data: clone$1(this._data),
          size: clone$1(this._size),
          datatype: this._datatype
        });
        return m;
      };
      /**
       * Retrieve the size of the matrix.
       * @memberof DenseMatrix
       * @returns {number[]} size
       */

      DenseMatrix.prototype.size = function () {
        return this._size.slice(0); // return a clone of _size
      };
      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @memberof DenseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       *
       * @return {DenseMatrix} matrix
       */

      DenseMatrix.prototype.map = function (callback) {
        // matrix instance
        var me = this;
        var recurse = function recurse(value, index) {
          if (isArray(value)) {
            return value.map(function (child, i) {
              return recurse(child, index.concat(i));
            });
          } else {
            return callback(value, index, me);
          }
        }; // determine the new datatype when the original matrix has datatype defined
        // TODO: should be done in matrix constructor instead

        var data = recurse(this._data, []);
        var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;
        return new DenseMatrix(data, datatype);
      };
      /**
       * Execute a callback function on each entry of the matrix.
       * @memberof DenseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       */

      DenseMatrix.prototype.forEach = function (callback) {
        // matrix instance
        var me = this;
        var recurse = function recurse(value, index) {
          if (isArray(value)) {
            value.forEach(function (child, i) {
              recurse(child, index.concat(i));
            });
          } else {
            callback(value, index, me);
          }
        };
        recurse(this._data, []);
      };
      /**
       * Iterate over the matrix elements
       * @return {Iterable<{ value, index: number[] }>}
       */

      DenseMatrix.prototype[Symbol.iterator] = function* () {
        var recurse = function* recurse(value, index) {
          if (isArray(value)) {
            for (var i = 0; i < value.length; i++) {
              yield* recurse(value[i], index.concat(i));
            }
          } else {
            yield {
              value,
              index
            };
          }
        };
        yield* recurse(this._data, []);
      };
      /**
       * Returns an array containing the rows of a 2D matrix
       * @returns {Array<Matrix>}
       */

      DenseMatrix.prototype.rows = function () {
        var result = [];
        var s = this.size();
        if (s.length !== 2) {
          throw new TypeError('Rows can only be returned for a 2D matrix.');
        }
        var data = this._data;
        for (var row of data) {
          result.push(new DenseMatrix([row], this._datatype));
        }
        return result;
      };
      /**
       * Returns an array containing the columns of a 2D matrix
       * @returns {Array<Matrix>}
       */

      DenseMatrix.prototype.columns = function () {
        var _this = this;
        var result = [];
        var s = this.size();
        if (s.length !== 2) {
          throw new TypeError('Rows can only be returned for a 2D matrix.');
        }
        var data = this._data;
        var _loop = function _loop(i) {
          var col = data.map(row => [row[i]]);
          result.push(new DenseMatrix(col, _this._datatype));
        };
        for (var i = 0; i < s[1]; i++) {
          _loop(i);
        }
        return result;
      };
      /**
       * Create an Array with a copy of the data of the DenseMatrix
       * @memberof DenseMatrix
       * @returns {Array} array
       */

      DenseMatrix.prototype.toArray = function () {
        return clone$1(this._data);
      };
      /**
       * Get the primitive value of the DenseMatrix: a multidimensional array
       * @memberof DenseMatrix
       * @returns {Array} array
       */

      DenseMatrix.prototype.valueOf = function () {
        return this._data;
      };
      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @memberof DenseMatrix
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */

      DenseMatrix.prototype.format = function (options) {
        return format(this._data, options);
      };
      /**
       * Get a string representation of the matrix
       * @memberof DenseMatrix
       * @returns {string} str
       */

      DenseMatrix.prototype.toString = function () {
        return format(this._data);
      };
      /**
       * Get a JSON representation of the matrix
       * @memberof DenseMatrix
       * @returns {Object}
       */

      DenseMatrix.prototype.toJSON = function () {
        return {
          mathjs: 'DenseMatrix',
          data: this._data,
          size: this._size,
          datatype: this._datatype
        };
      };
      /**
       * Get the kth Matrix diagonal.
       *
       * @memberof DenseMatrix
       * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
       *
       * @returns {Matrix}                     The matrix with the diagonal values.
       */

      DenseMatrix.prototype.diagonal = function (k) {
        // validate k if any
        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) {
            k = k.toNumber();
          } // is must be an integer

          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number');
          }
        } else {
          // default value
          k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0; // rows & columns

        var rows = this._size[0];
        var columns = this._size[1]; // number diagonal values

        var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix

        var data = []; // loop rows

        for (var i = 0; i < n; i++) {
          data[i] = this._data[i + kSub][i + kSuper];
        } // create DenseMatrix

        return new DenseMatrix({
          data,
          size: [n],
          datatype: this._datatype
        });
      };
      /**
       * Create a diagonal matrix.
       *
       * @memberof DenseMatrix
       * @param {Array} size                     The matrix size.
       * @param {number | Matrix | Array } value The values for the diagonal.
       * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
       * @param {number} [defaultValue]          The default value for non-diagonal
       * @param {string} [datatype]              The datatype for the diagonal
       *
       * @returns {DenseMatrix}
       */

      DenseMatrix.diagonal = function (size, value, k, defaultValue) {
        if (!isArray(size)) {
          throw new TypeError('Array expected, size parameter');
        }
        if (size.length !== 2) {
          throw new Error('Only two dimensions matrix are supported');
        } // map size & validate

        size = size.map(function (s) {
          // check it is a big number
          if (isBigNumber(s)) {
            // convert it
            s = s.toNumber();
          } // validate arguments

          if (!isNumber(s) || !isInteger(s) || s < 1) {
            throw new Error('Size values must be positive integers');
          }
          return s;
        }); // validate k if any

        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) {
            k = k.toNumber();
          } // is must be an integer

          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number');
          }
        } else {
          // default value
          k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0; // rows and columns

        var rows = size[0];
        var columns = size[1]; // number of non-zero items

        var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

        var _value; // check value

        if (isArray(value)) {
          // validate array
          if (value.length !== n) {
            // number of values in array must be n
            throw new Error('Invalid value array length');
          } // define function

          _value = function _value(i) {
            // return value @ i
            return value[i];
          };
        } else if (isMatrix(value)) {
          // matrix size
          var ms = value.size(); // validate matrix

          if (ms.length !== 1 || ms[0] !== n) {
            // number of values in array must be n
            throw new Error('Invalid matrix length');
          } // define function

          _value = function _value(i) {
            // return value @ i
            return value.get([i]);
          };
        } else {
          // define function
          _value = function _value() {
            // return value
            return value;
          };
        } // discover default value if needed

        if (!defaultValue) {
          // check first value in array
          defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero
          : 0;
        } // empty array

        var data = []; // check we need to resize array

        if (size.length > 0) {
          // resize array
          data = resize(data, size, defaultValue); // fill diagonal

          for (var d = 0; d < n; d++) {
            data[d + kSub][d + kSuper] = _value(d);
          }
        } // create DenseMatrix

        return new DenseMatrix({
          data,
          size: [rows, columns]
        });
      };
      /**
       * Generate a matrix from a JSON object
       * @memberof DenseMatrix
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
       *                       where mathjs is optional
       * @returns {DenseMatrix}
       */

      DenseMatrix.fromJSON = function (json) {
        return new DenseMatrix(json);
      };
      /**
       * Swap rows i and j in Matrix.
       *
       * @memberof DenseMatrix
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       *
       * @return {Matrix}        The matrix reference
       */

      DenseMatrix.prototype.swapRows = function (i, j) {
        // check index
        if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
          throw new Error('Row index must be positive integers');
        } // check dimensions

        if (this._size.length !== 2) {
          throw new Error('Only two dimensional matrix is supported');
        } // validate index

        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[0]); // swap rows

        DenseMatrix._swapRows(i, j, this._data); // return current instance

        return this;
      };
      /**
       * Swap rows i and j in Dense Matrix data structure.
       *
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       * @param {Array} data     Matrix data
       */

      DenseMatrix._swapRows = function (i, j, data) {
        // swap values i <-> j
        var vi = data[i];
        data[i] = data[j];
        data[j] = vi;
      };
      /**
       * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
       * Matrices. Replaces all nested Matrices with Arrays
       * @memberof DenseMatrix
       * @param {Array} data
       * @return {Array} data
       */

      function preprocess(data) {
        for (var i = 0, ii = data.length; i < ii; i++) {
          var elem = data[i];
          if (isArray(elem)) {
            data[i] = preprocess(elem);
          } else if (elem && elem.isMatrix === true) {
            data[i] = preprocess(elem.valueOf());
          }
        }
        return data;
      }
      return DenseMatrix;
    }, {
      isClass: true
    });

    /**
     * Execute the callback function element wise for each element in array and any
     * nested array
     * Returns an array with the results
     * @param {Array | Matrix} array
     * @param {Function} callback   The callback is called with two parameters:
     *                              value1 and value2, which contain the current
     *                              element of both arrays.
     * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
     *
     * @return {Array | Matrix} res
     */

    function deepMap(array, callback, skipZeros) {
      if (array && typeof array.map === 'function') {
        // TODO: replace array.map with a for loop to improve performance
        return array.map(function (x) {
          return deepMap(x, callback);
        });
      } else {
        return callback(array);
      }
    }

    var n1$1 = 'number';
    var n2 = 'number, number';
    function absNumber(a) {
      return Math.abs(a);
    }
    absNumber.signature = n1$1;
    function addNumber(a, b) {
      return a + b;
    }
    addNumber.signature = n2;
    function multiplyNumber(a, b) {
      return a * b;
    }
    multiplyNumber.signature = n2;
    function unaryMinusNumber(x) {
      return -x;
    }
    unaryMinusNumber.signature = n1$1;

    function signNumber(x) {
      return sign$2(x);
    }
    signNumber.signature = n1$1;
    /**
     * Calculates the power of x to y, x^y, for two numbers.
     * @param {number} x
     * @param {number} y
     * @return {number} res
     */

    function powNumber(x, y) {
      // x^Infinity === 0 if -1 < x < 1
      // A real number 0 is returned instead of complex(0)
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return Math.pow(x, y);
    }
    powNumber.signature = n2;

    var n1 = 'number';
    function isZeroNumber(x) {
      return x === 0;
    }
    isZeroNumber.signature = n1;

    var name$_ = 'isZero';
    var dependencies$_ = ['typed'];
    var createIsZero = /* #__PURE__ */factory(name$_, dependencies$_, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Test whether a value is zero.
       * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
       * `Complex`, and `Unit`.
       *
       * The function is evaluated element-wise in case of Array or Matrix input.
       *
       * Syntax:
       *
       *     math.isZero(x)
       *
       * Examples:
       *
       *    math.isZero(0)                     // returns true
       *    math.isZero(2)                     // returns false
       *    math.isZero(0.5)                   // returns false
       *    math.isZero(math.bignumber(0))     // returns true
       *    math.isZero(math.fraction(0))      // returns true
       *    math.isZero(math.fraction(1,3))    // returns false
       *    math.isZero(math.complex('2 - 4i') // returns false
       *    math.isZero(math.complex('0i')     // returns true
       *    math.isZero('0')                   // returns true
       *    math.isZero('2')                   // returns false
       *    math.isZero([2, 0, -3]')           // returns [false, true, false]
       *
       * See also:
       *
       *    isNumeric, isPositive, isNegative, isInteger
       *
       * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
       * @return {boolean}  Returns true when `x` is zero.
       *                    Throws an error in case of an unknown data type.
       */
      return typed(name$_, {
        number: isZeroNumber,
        BigNumber: function BigNumber(x) {
          return x.isZero();
        },
        Complex: function Complex(x) {
          return x.re === 0 && x.im === 0;
        },
        Fraction: function Fraction(x) {
          return x.d === 1 && x.n === 0;
        },
        Unit: function Unit(x) {
          return this(x.value);
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    /**
     * Compares two BigNumbers.
     * @param {BigNumber} x       First value to compare
     * @param {BigNumber} y       Second value to compare
     * @param {number} [epsilon]  The maximum relative difference between x and y
     *                            If epsilon is undefined or null, the function will
     *                            test whether x and y are exactly equal.
     * @return {boolean} whether the two numbers are nearly equal
     */
    function nearlyEqual(x, y, epsilon) {
      // if epsilon is null or undefined, test whether x and y are exactly equal
      if (epsilon === null || epsilon === undefined) {
        return x.eq(y);
      } // use "==" operator, handles infinities

      if (x.eq(y)) {
        return true;
      } // NaN

      if (x.isNaN() || y.isNaN()) {
        return false;
      } // at this point x and y should be finite

      if (x.isFinite() && y.isFinite()) {
        // check numbers are very close, needed when comparing numbers near zero
        var diff = x.minus(y).abs();
        if (diff.isZero()) {
          return true;
        } else {
          // use relative error
          var max = x.constructor.max(x.abs(), y.abs());
          return diff.lte(max.times(epsilon));
        }
      } // Infinite and Number or negative Infinite and positive Infinite cases

      return false;
    }

    /**
     * Test whether two complex values are equal provided a given epsilon.
     * Does not use or change the global Complex.EPSILON setting
     * @param {Complex} x
     * @param {Complex} y
     * @param {number} epsilon
     * @returns {boolean}
     */

    function complexEquals(x, y, epsilon) {
      return nearlyEqual$1(x.re, y.re, epsilon) && nearlyEqual$1(x.im, y.im, epsilon);
    }

    var name$Z = 'equalScalar';
    var dependencies$Z = ['typed', 'config'];
    var createEqualScalar = /* #__PURE__ */factory(name$Z, dependencies$Z, _ref => {
      var {
        typed,
        config
      } = _ref;

      /**
       * Test whether two scalar values are nearly equal.
       *
       * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
       * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
       * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
       * @private
       */
      return typed(name$Z, {
        'boolean, boolean': function booleanBoolean(x, y) {
          return x === y;
        },
        'number, number': function numberNumber(x, y) {
          return nearlyEqual$1(x, y, config.epsilon);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.eq(y) || nearlyEqual(x, y, config.epsilon);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.equals(y);
        },
        'Complex, Complex': function ComplexComplex(x, y) {
          return complexEquals(x, y, config.epsilon);
        },
        'Unit, Unit': function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error('Cannot compare units with different base');
          }
          return this(x.value, y.value);
        }
      });
    });
    factory(name$Z, ['typed', 'config'], _ref2 => {
      var {
        typed,
        config
      } = _ref2;
      return typed(name$Z, {
        'number, number': function numberNumber(x, y) {
          return nearlyEqual$1(x, y, config.epsilon);
        }
      });
    });

    var name$Y = 'SparseMatrix';
    var dependencies$Y = ['typed', 'equalScalar', 'Matrix'];
    var createSparseMatrixClass = /* #__PURE__ */factory(name$Y, dependencies$Y, _ref => {
      var {
        typed,
        equalScalar,
        Matrix
      } = _ref;

      /**
       * Sparse Matrix implementation. This type implements
       * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
       * format for two-dimensional sparse matrices.
       * @class SparseMatrix
       */
      function SparseMatrix(data, datatype) {
        if (!(this instanceof SparseMatrix)) {
          throw new SyntaxError('Constructor must be called with the new operator');
        }
        if (datatype && !isString(datatype)) {
          throw new Error('Invalid datatype: ' + datatype);
        }
        if (isMatrix(data)) {
          // create from matrix
          _createFromMatrix(this, data, datatype);
        } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
          // initialize fields
          this._values = data.values;
          this._index = data.index;
          this._ptr = data.ptr;
          this._size = data.size;
          this._datatype = datatype || data.datatype;
        } else if (isArray(data)) {
          // create from array
          _createFromArray(this, data, datatype);
        } else if (data) {
          // unsupported type
          throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
        } else {
          // nothing provided
          this._values = [];
          this._index = [];
          this._ptr = [0];
          this._size = [0, 0];
          this._datatype = datatype;
        }
      }
      function _createFromMatrix(matrix, source, datatype) {
        // check matrix type
        if (source.type === 'SparseMatrix') {
          // clone arrays
          matrix._values = source._values ? clone$1(source._values) : undefined;
          matrix._index = clone$1(source._index);
          matrix._ptr = clone$1(source._ptr);
          matrix._size = clone$1(source._size);
          matrix._datatype = datatype || source._datatype;
        } else {
          // build from matrix data
          _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
        }
      }
      function _createFromArray(matrix, data, datatype) {
        // initialize fields
        matrix._values = [];
        matrix._index = [];
        matrix._ptr = [];
        matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice

        var rows = data.length;
        var columns = 0; // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0;
        if (isString(datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

          zero = typed.convert(0, datatype);
        } // check we have rows (empty array)

        if (rows > 0) {
          // column index
          var j = 0;
          do {
            // store pointer to values index
            matrix._ptr.push(matrix._index.length); // loop rows

            for (var i = 0; i < rows; i++) {
              // current row
              var row = data[i]; // check row is an array

              if (isArray(row)) {
                // update columns if needed (only on first column)
                if (j === 0 && columns < row.length) {
                  columns = row.length;
                } // check row has column

                if (j < row.length) {
                  // value
                  var v = row[j]; // check value != 0

                  if (!eq(v, zero)) {
                    // store value
                    matrix._values.push(v); // index

                    matrix._index.push(i);
                  }
                }
              } else {
                // update columns if needed (only on first column)
                if (j === 0 && columns < 1) {
                  columns = 1;
                } // check value != 0 (row is a scalar)

                if (!eq(row, zero)) {
                  // store value
                  matrix._values.push(row); // index

                  matrix._index.push(i);
                }
              }
            } // increment index

            j++;
          } while (j < columns);
        } // store number of values in ptr

        matrix._ptr.push(matrix._index.length); // size

        matrix._size = [rows, columns];
      }
      SparseMatrix.prototype = new Matrix();
      /**
       * Create a new SparseMatrix
       */

      SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {
        return new SparseMatrix(data, datatype);
      };
      /**
       * Attach type information
       */

      SparseMatrix.prototype.type = 'SparseMatrix';
      SparseMatrix.prototype.isSparseMatrix = true;
      /**
       * Get the matrix type
       *
       * Usage:
       *    const matrixType = matrix.getDataType()  // retrieves the matrix type
       *
       * @memberOf SparseMatrix
       * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
       */

      SparseMatrix.prototype.getDataType = function () {
        return getArrayDataType(this._values, typeOf);
      };
      /**
       * Get the storage format used by the matrix.
       *
       * Usage:
       *     const format = matrix.storage()   // retrieve storage format
       *
       * @memberof SparseMatrix
       * @return {string}           The storage format.
       */

      SparseMatrix.prototype.storage = function () {
        return 'sparse';
      };
      /**
       * Get the datatype of the data stored in the matrix.
       *
       * Usage:
       *     const format = matrix.datatype()    // retrieve matrix datatype
       *
       * @memberof SparseMatrix
       * @return {string}           The datatype.
       */

      SparseMatrix.prototype.datatype = function () {
        return this._datatype;
      };
      /**
       * Create a new SparseMatrix
       * @memberof SparseMatrix
       * @param {Array} data
       * @param {string} [datatype]
       */

      SparseMatrix.prototype.create = function (data, datatype) {
        return new SparseMatrix(data, datatype);
      };
      /**
       * Get the matrix density.
       *
       * Usage:
       *     const density = matrix.density()                   // retrieve matrix density
       *
       * @memberof SparseMatrix
       * @return {number}           The matrix density.
       */

      SparseMatrix.prototype.density = function () {
        // rows & columns
        var rows = this._size[0];
        var columns = this._size[1]; // calculate density

        return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
      };
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @memberof SparseMatrix
       * @param {Index} index
       * @param {Array | Matrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */

      SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {
        // check it is a pattern matrix
        if (!this._values) {
          throw new Error('Cannot invoke subset on a Pattern only matrix');
        } // check arguments

        switch (arguments.length) {
          case 1:
            return _getsubset(this, index);
          // intentional fall through

          case 2:
          case 3:
            return _setsubset(this, index, replacement, defaultValue);
          default:
            throw new SyntaxError('Wrong number of arguments');
        }
      };
      function _getsubset(matrix, idx) {
        // check idx
        if (!isIndex(idx)) {
          throw new TypeError('Invalid index');
        }
        var isScalar = idx.isScalar();
        if (isScalar) {
          // return a scalar
          return matrix.get(idx.min());
        } // validate dimensions

        var size = idx.size();
        if (size.length !== matrix._size.length) {
          throw new DimensionError(size.length, matrix._size.length);
        } // vars

        var i, ii, k, kk; // validate if any of the ranges in the index is out of range

        var min = idx.min();
        var max = idx.max();
        for (i = 0, ii = matrix._size.length; i < ii; i++) {
          validateIndex(min[i], matrix._size[i]);
          validateIndex(max[i], matrix._size[i]);
        } // matrix arrays

        var mvalues = matrix._values;
        var mindex = matrix._index;
        var mptr = matrix._ptr; // rows & columns dimensions for result matrix

        var rows = idx.dimension(0);
        var columns = idx.dimension(1); // workspace & permutation vector

        var w = [];
        var pv = []; // loop rows in resulting matrix

        rows.forEach(function (i, r) {
          // update permutation vector
          pv[i] = r[0]; // mark i in workspace

          w[i] = true;
        }); // result matrix arrays

        var values = mvalues ? [] : undefined;
        var index = [];
        var ptr = []; // loop columns in result matrix

        columns.forEach(function (j) {
          // update ptr
          ptr.push(index.length); // loop values in column j

          for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
            // row
            i = mindex[k]; // check row is in result matrix

            if (w[i] === true) {
              // push index
              index.push(pv[i]); // check we need to process values

              if (values) {
                values.push(mvalues[k]);
              }
            }
          }
        }); // update ptr

        ptr.push(index.length); // return matrix

        return new SparseMatrix({
          values,
          index,
          ptr,
          size,
          datatype: matrix._datatype
        });
      }
      function _setsubset(matrix, index, submatrix, defaultValue) {
        // check index
        if (!index || index.isIndex !== true) {
          throw new TypeError('Invalid index');
        } // get index size and check whether the index contains a single value

        var iSize = index.size();
        var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

        var sSize;
        if (isMatrix(submatrix)) {
          // submatrix size
          sSize = submatrix.size(); // use array representation

          submatrix = submatrix.toArray();
        } else {
          // get submatrix size (array, scalar)
          sSize = arraySize(submatrix);
        } // check index is a scalar

        if (isScalar) {
          // verify submatrix is a scalar
          if (sSize.length !== 0) {
            throw new TypeError('Scalar expected');
          } // set value

          matrix.set(index.min(), submatrix, defaultValue);
        } else {
          // validate dimensions, index size must be one or two dimensions
          if (iSize.length !== 1 && iSize.length !== 2) {
            throw new DimensionError(iSize.length, matrix._size.length, '<');
          } // check submatrix and index have the same dimensions

          if (sSize.length < iSize.length) {
            // calculate number of missing outer dimensions
            var i = 0;
            var outer = 0;
            while (iSize[i] === 1 && sSize[i] === 1) {
              i++;
            }
            while (iSize[i] === 1) {
              outer++;
              i++;
            } // unsqueeze both outer and inner dimensions

            submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
          } // check whether the size of the submatrix matches the index size

          if (!deepStrictEqual(iSize, sSize)) {
            throw new DimensionError(iSize, sSize, '>');
          } // insert the sub matrix

          if (iSize.length === 1) {
            // if the replacement index only has 1 dimension, go trough each one and set its value
            var range = index.dimension(0);
            range.forEach(function (dataIndex, subIndex) {
              validateIndex(dataIndex);
              matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
            });
          } else {
            // if the replacement index has 2 dimensions, go through each one and set the value in the correct index
            var firstDimensionRange = index.dimension(0);
            var secondDimensionRange = index.dimension(1);
            firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {
              validateIndex(firstDataIndex);
              secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {
                validateIndex(secondDataIndex);
                matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
              });
            });
          }
        }
        return matrix;
      }
      /**
       * Get a single element from the matrix.
       * @memberof SparseMatrix
       * @param {number[]} index   Zero-based index
       * @return {*} value
       */

      SparseMatrix.prototype.get = function (index) {
        if (!isArray(index)) {
          throw new TypeError('Array expected');
        }
        if (index.length !== this._size.length) {
          throw new DimensionError(index.length, this._size.length);
        } // check it is a pattern matrix

        if (!this._values) {
          throw new Error('Cannot invoke get on a Pattern only matrix');
        } // row and column

        var i = index[0];
        var j = index[1]; // check i, j are valid

        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[1]); // find value index

        var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row

        if (k < this._ptr[j + 1] && this._index[k] === i) {
          return this._values[k];
        }
        return 0;
      };
      /**
       * Replace a single element in the matrix.
       * @memberof SparseMatrix
       * @param {number[]} index   Zero-based index
       * @param {*} v
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be set to zero.
       * @return {SparseMatrix} self
       */

      SparseMatrix.prototype.set = function (index, v, defaultValue) {
        if (!isArray(index)) {
          throw new TypeError('Array expected');
        }
        if (index.length !== this._size.length) {
          throw new DimensionError(index.length, this._size.length);
        } // check it is a pattern matrix

        if (!this._values) {
          throw new Error('Cannot invoke set on a Pattern only matrix');
        } // row and column

        var i = index[0];
        var j = index[1]; // rows & columns

        var rows = this._size[0];
        var columns = this._size[1]; // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0;
        if (isString(this._datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype

          zero = typed.convert(0, this._datatype);
        } // check we need to resize matrix

        if (i > rows - 1 || j > columns - 1) {
          // resize matrix
          _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns

          rows = this._size[0];
          columns = this._size[1];
        } // check i, j are valid

        validateIndex(i, rows);
        validateIndex(j, columns); // find value index

        var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row

        if (k < this._ptr[j + 1] && this._index[k] === i) {
          // check value != 0
          if (!eq(v, zero)) {
            // update value
            this._values[k] = v;
          } else {
            // remove value from matrix
            _remove(k, j, this._values, this._index, this._ptr);
          }
        } else {
          // insert value @ (i, j)
          _insert(k, i, j, v, this._values, this._index, this._ptr);
        }
        return this;
      };
      function _getValueIndex(i, top, bottom, index) {
        // check row is on the bottom side
        if (bottom - top === 0) {
          return bottom;
        } // loop rows [top, bottom[

        for (var r = top; r < bottom; r++) {
          // check we found value index
          if (index[r] === i) {
            return r;
          }
        } // we did not find row

        return top;
      }
      function _remove(k, j, values, index, ptr) {
        // remove value @ k
        values.splice(k, 1);
        index.splice(k, 1); // update pointers

        for (var x = j + 1; x < ptr.length; x++) {
          ptr[x]--;
        }
      }
      function _insert(k, i, j, v, values, index, ptr) {
        // insert value
        values.splice(k, 0, v); // update row for k

        index.splice(k, 0, i); // update column pointers

        for (var x = j + 1; x < ptr.length; x++) {
          ptr[x]++;
        }
      }
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @memberof SparseMatrix
       * @param {number[] | Matrix} size  The new size the matrix should have.
       *                                  Since sparse matrices are always two-dimensional,
       *                                  size must be two numbers in either an array or a matrix
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {Matrix}                 The resized matrix
       */

      SparseMatrix.prototype.resize = function (size, defaultValue, copy) {
        // validate arguments
        if (!isCollection(size)) {
          throw new TypeError('Array or Matrix expected');
        } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector

        var sizeArray = size.valueOf().map(value => {
          return Array.isArray(value) && value.length === 1 ? value[0] : value;
        });
        if (sizeArray.length !== 2) {
          throw new Error('Only two dimensions matrix are supported');
        } // check sizes

        sizeArray.forEach(function (value) {
          if (!isNumber(value) || !isInteger(value) || value < 0) {
            throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(sizeArray) + ')');
          }
        }); // matrix to resize

        var m = copy ? this.clone() : this; // resize matrix

        return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
      };
      function _resize(matrix, rows, columns, defaultValue) {
        // value to insert at the time of growing matrix
        var value = defaultValue || 0; // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0;
        if (isString(matrix._datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

          zero = typed.convert(0, matrix._datatype); // convert value to the same datatype

          value = typed.convert(value, matrix._datatype);
        } // should we insert the value?

        var ins = !eq(value, zero); // old columns and rows

        var r = matrix._size[0];
        var c = matrix._size[1];
        var i, j, k; // check we need to increase columns

        if (columns > c) {
          // loop new columns
          for (j = c; j < columns; j++) {
            // update matrix._ptr for current column
            matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values

            if (ins) {
              // loop rows
              for (i = 0; i < r; i++) {
                // add new matrix._values
                matrix._values.push(value); // update matrix._index

                matrix._index.push(i);
              }
            }
          } // store number of matrix._values in matrix._ptr

          matrix._ptr[columns] = matrix._values.length;
        } else if (columns < c) {
          // truncate matrix._ptr
          matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index

          matrix._values.splice(matrix._ptr[columns], matrix._values.length);
          matrix._index.splice(matrix._ptr[columns], matrix._index.length);
        } // update columns

        c = columns; // check we need to increase rows

        if (rows > r) {
          // check we have to insert values
          if (ins) {
            // inserts
            var n = 0; // loop columns

            for (j = 0; j < c; j++) {
              // update matrix._ptr for current column
              matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values

              k = matrix._ptr[j + 1] + n; // pointer

              var p = 0; // loop new rows, initialize pointer

              for (i = r; i < rows; i++, p++) {
                // add value
                matrix._values.splice(k + p, 0, value); // update matrix._index

                matrix._index.splice(k + p, 0, i); // increment inserts

                n++;
              }
            } // store number of matrix._values in matrix._ptr

            matrix._ptr[c] = matrix._values.length;
          }
        } else if (rows < r) {
          // deletes
          var d = 0; // loop columns

          for (j = 0; j < c; j++) {
            // update matrix._ptr for current column
            matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column

            var k0 = matrix._ptr[j];
            var k1 = matrix._ptr[j + 1] - d; // loop matrix._index

            for (k = k0; k < k1; k++) {
              // row
              i = matrix._index[k]; // check we need to delete value and matrix._index

              if (i > rows - 1) {
                // remove value
                matrix._values.splice(k, 1); // remove item from matrix._index

                matrix._index.splice(k, 1); // increase deletes

                d++;
              }
            }
          } // update matrix._ptr for current column

          matrix._ptr[j] = matrix._values.length;
        } // update matrix._size

        matrix._size[0] = rows;
        matrix._size[1] = columns; // return matrix

        return matrix;
      }
      /**
       * Reshape the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (reshape in place).
       *
       * NOTE: This might be better suited to copy by default, instead of modifying
       *       in place. For now, it operates in place to remain consistent with
       *       resize().
       *
       * @memberof SparseMatrix
       * @param {number[]} sizes          The new size the matrix should have.
       *                                  Since sparse matrices are always two-dimensional,
       *                                  size must be two numbers in either an array or a matrix
       * @param {boolean} [copy]          Return a reshaped copy of the matrix
       *
       * @return {Matrix}                 The reshaped matrix
       */

      SparseMatrix.prototype.reshape = function (sizes, copy) {
        // validate arguments
        if (!isArray(sizes)) {
          throw new TypeError('Array expected');
        }
        if (sizes.length !== 2) {
          throw new Error('Sparse matrices can only be reshaped in two dimensions');
        } // check sizes

        sizes.forEach(function (value) {
          if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
            throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format(sizes) + ')');
          }
        });
        var currentLength = this._size[0] * this._size[1];
        sizes = processSizesWildcard(sizes, currentLength);
        var newLength = sizes[0] * sizes[1]; // m * n must not change

        if (currentLength !== newLength) {
          throw new Error('Reshaping sparse matrix will result in the wrong number of elements');
        } // matrix to reshape

        var m = copy ? this.clone() : this; // return unchanged if the same shape

        if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
          return m;
        } // Convert to COO format (generate a column index)

        var colIndex = [];
        for (var i = 0; i < m._ptr.length; i++) {
          for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
            colIndex.push(i);
          }
        } // Clone the values array

        var values = m._values.slice(); // Clone the row index array

        var rowIndex = m._index.slice(); // Transform the (row, column) indices

        for (var _i = 0; _i < m._index.length; _i++) {
          var r1 = rowIndex[_i];
          var c1 = colIndex[_i];
          var flat = r1 * m._size[1] + c1;
          colIndex[_i] = flat % sizes[1];
          rowIndex[_i] = Math.floor(flat / sizes[1]);
        } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
        // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
        // sorting several arrays based on some other array.
        // OR, we could easily just:
        // 1. Remove all values from the matrix

        m._values.length = 0;
        m._index.length = 0;
        m._ptr.length = sizes[1] + 1;
        m._size = sizes.slice();
        for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
          m._ptr[_i2] = 0;
        } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
        // This step is probably the most time-consuming

        for (var h = 0; h < values.length; h++) {
          var _i3 = rowIndex[h];
          var _j = colIndex[h];
          var v = values[h];
          var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
          _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
        } // The value indices are inserted out of order, but apparently that's... still OK?

        return m;
      };
      /**
       * Create a clone of the matrix
       * @memberof SparseMatrix
       * @return {SparseMatrix} clone
       */

      SparseMatrix.prototype.clone = function () {
        var m = new SparseMatrix({
          values: this._values ? clone$1(this._values) : undefined,
          index: clone$1(this._index),
          ptr: clone$1(this._ptr),
          size: clone$1(this._size),
          datatype: this._datatype
        });
        return m;
      };
      /**
       * Retrieve the size of the matrix.
       * @memberof SparseMatrix
       * @returns {number[]} size
       */

      SparseMatrix.prototype.size = function () {
        return this._size.slice(0); // copy the Array
      };
      /**
       * Create a new matrix with the results of the callback function executed on
       * each entry of the matrix.
       * @memberof SparseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *
       * @return {SparseMatrix} matrix
       */

      SparseMatrix.prototype.map = function (callback, skipZeros) {
        // check it is a pattern matrix
        if (!this._values) {
          throw new Error('Cannot invoke map on a Pattern only matrix');
        } // matrix instance

        var me = this; // rows and columns

        var rows = this._size[0];
        var columns = this._size[1]; // invoke callback

        var invoke = function invoke(v, i, j) {
          // invoke callback
          return callback(v, [i, j], me);
        }; // invoke _map

        return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
      };
      /**
       * Create a new matrix with the results of the callback function executed on the interval
       * [minRow..maxRow, minColumn..maxColumn].
       */

      function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
        // result arrays
        var values = [];
        var index = [];
        var ptr = []; // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0;
        if (isString(matrix._datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

          zero = typed.convert(0, matrix._datatype);
        } // invoke callback

        var invoke = function invoke(v, x, y) {
          // invoke callback
          v = callback(v, x, y); // check value != 0

          if (!eq(v, zero)) {
            // store value
            values.push(v); // index

            index.push(x);
          }
        }; // loop columns

        for (var j = minColumn; j <= maxColumn; j++) {
          // store pointer to values index
          ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]

          var k0 = matrix._ptr[j];
          var k1 = matrix._ptr[j + 1];
          if (skipZeros) {
            // loop k within [k0, k1[
            for (var k = k0; k < k1; k++) {
              // row index
              var i = matrix._index[k]; // check i is in range

              if (i >= minRow && i <= maxRow) {
                // value @ k
                invoke(matrix._values[k], i - minRow, j - minColumn);
              }
            }
          } else {
            // create a cache holding all defined values
            var _values = {};
            for (var _k = k0; _k < k1; _k++) {
              var _i4 = matrix._index[_k];
              _values[_i4] = matrix._values[_k];
            } // loop over all rows (indexes can be unordered so we can't use that),
            // and either read the value or zero

            for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
              var value = _i5 in _values ? _values[_i5] : 0;
              invoke(value, _i5 - minRow, j - minColumn);
            }
          }
        } // store number of values in ptr

        ptr.push(values.length); // return sparse matrix

        return new SparseMatrix({
          values,
          index,
          ptr,
          size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
        });
      }
      /**
       * Execute a callback function on each entry of the matrix.
       * @memberof SparseMatrix
       * @param {Function} callback   The callback function is invoked with three
       *                              parameters: the value of the element, the index
       *                              of the element, and the Matrix being traversed.
       * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
       *                              If false, the indices are guaranteed to be in order,
       *                              if true, the indices can be unordered.
       */

      SparseMatrix.prototype.forEach = function (callback, skipZeros) {
        // check it is a pattern matrix
        if (!this._values) {
          throw new Error('Cannot invoke forEach on a Pattern only matrix');
        } // matrix instance

        var me = this; // rows and columns

        var rows = this._size[0];
        var columns = this._size[1]; // loop columns

        for (var j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1];
          if (skipZeros) {
            // loop k within [k0, k1[
            for (var k = k0; k < k1; k++) {
              // row index
              var i = this._index[k]; // value @ k

              callback(this._values[k], [i, j], me);
            }
          } else {
            // create a cache holding all defined values
            var values = {};
            for (var _k2 = k0; _k2 < k1; _k2++) {
              var _i6 = this._index[_k2];
              values[_i6] = this._values[_k2];
            } // loop over all rows (indexes can be unordered so we can't use that),
            // and either read the value or zero

            for (var _i7 = 0; _i7 < rows; _i7++) {
              var value = _i7 in values ? values[_i7] : 0;
              callback(value, [_i7, j], me);
            }
          }
        }
      };
      /**
       * Iterate over the matrix elements, skipping zeros
       * @return {Iterable<{ value, index: number[] }>}
       */

      SparseMatrix.prototype[Symbol.iterator] = function* () {
        if (!this._values) {
          throw new Error('Cannot iterate a Pattern only matrix');
        }
        var columns = this._size[1];
        for (var j = 0; j < columns; j++) {
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            // row index
            var i = this._index[k];
            yield {
              value: this._values[k],
              index: [i, j]
            };
          }
        }
      };
      /**
       * Create an Array with a copy of the data of the SparseMatrix
       * @memberof SparseMatrix
       * @returns {Array} array
       */

      SparseMatrix.prototype.toArray = function () {
        return _toArray(this._values, this._index, this._ptr, this._size, true);
      };
      /**
       * Get the primitive value of the SparseMatrix: a two dimensions array
       * @memberof SparseMatrix
       * @returns {Array} array
       */

      SparseMatrix.prototype.valueOf = function () {
        return _toArray(this._values, this._index, this._ptr, this._size, false);
      };
      function _toArray(values, index, ptr, size, copy) {
        // rows and columns
        var rows = size[0];
        var columns = size[1]; // result

        var a = []; // vars

        var i, j; // initialize array

        for (i = 0; i < rows; i++) {
          a[i] = [];
          for (j = 0; j < columns; j++) {
            a[i][j] = 0;
          }
        } // loop columns

        for (j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          var k0 = ptr[j];
          var k1 = ptr[j + 1]; // loop k within [k0, k1[

          for (var k = k0; k < k1; k++) {
            // row index
            i = index[k]; // set value (use one for pattern matrix)

            a[i][j] = values ? copy ? clone$1(values[k]) : values[k] : 1;
          }
        }
        return a;
      }
      /**
       * Get a string representation of the matrix, with optional formatting options.
       * @memberof SparseMatrix
       * @param {Object | number | Function} [options]  Formatting options. See
       *                                                lib/utils/number:format for a
       *                                                description of the available
       *                                                options.
       * @returns {string} str
       */

      SparseMatrix.prototype.format = function (options) {
        // rows and columns
        var rows = this._size[0];
        var columns = this._size[1]; // density

        var density = this.density(); // rows & columns

        var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\n'; // loop columns

        for (var j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1]; // loop k within [k0, k1[

          for (var k = k0; k < k1; k++) {
            // row index
            var i = this._index[k]; // append value

            str += '\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');
          }
        }
        return str;
      };
      /**
       * Get a string representation of the matrix
       * @memberof SparseMatrix
       * @returns {string} str
       */

      SparseMatrix.prototype.toString = function () {
        return format(this.toArray());
      };
      /**
       * Get a JSON representation of the matrix
       * @memberof SparseMatrix
       * @returns {Object}
       */

      SparseMatrix.prototype.toJSON = function () {
        return {
          mathjs: 'SparseMatrix',
          values: this._values,
          index: this._index,
          ptr: this._ptr,
          size: this._size,
          datatype: this._datatype
        };
      };
      /**
       * Get the kth Matrix diagonal.
       *
       * @memberof SparseMatrix
       * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
       *
       * @returns {Matrix}                     The matrix vector with the diagonal values.
       */

      SparseMatrix.prototype.diagonal = function (k) {
        // validate k if any
        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) {
            k = k.toNumber();
          } // is must be an integer

          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number');
          }
        } else {
          // default value
          k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0; // rows & columns

        var rows = this._size[0];
        var columns = this._size[1]; // number diagonal values

        var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays

        var values = [];
        var index = [];
        var ptr = []; // initial ptr value

        ptr[0] = 0; // loop columns

        for (var j = kSuper; j < columns && values.length < n; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1]; // loop x within [k0, k1[

          for (var x = k0; x < k1; x++) {
            // row index
            var i = this._index[x]; // check row

            if (i === j - kSuper + kSub) {
              // value on this column
              values.push(this._values[x]); // store row

              index[values.length - 1] = i - kSub; // exit loop

              break;
            }
          }
        } // close ptr

        ptr.push(values.length); // return matrix

        return new SparseMatrix({
          values,
          index,
          ptr,
          size: [n, 1]
        });
      };
      /**
       * Generate a matrix from a JSON object
       * @memberof SparseMatrix
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
       *                       where mathjs is optional
       * @returns {SparseMatrix}
       */

      SparseMatrix.fromJSON = function (json) {
        return new SparseMatrix(json);
      };
      /**
       * Create a diagonal matrix.
       *
       * @memberof SparseMatrix
       * @param {Array} size                       The matrix size.
       * @param {number | Array | Matrix } value   The values for the diagonal.
       * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
       * @param {number} [defaultValue]            The default value for non-diagonal
       * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
       *
       * @returns {SparseMatrix}
       */

      SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
        if (!isArray(size)) {
          throw new TypeError('Array expected, size parameter');
        }
        if (size.length !== 2) {
          throw new Error('Only two dimensions matrix are supported');
        } // map size & validate

        size = size.map(function (s) {
          // check it is a big number
          if (isBigNumber(s)) {
            // convert it
            s = s.toNumber();
          } // validate arguments

          if (!isNumber(s) || !isInteger(s) || s < 1) {
            throw new Error('Size values must be positive integers');
          }
          return s;
        }); // validate k if any

        if (k) {
          // convert BigNumber to a number
          if (isBigNumber(k)) {
            k = k.toNumber();
          } // is must be an integer

          if (!isNumber(k) || !isInteger(k)) {
            throw new TypeError('The parameter k must be an integer number');
          }
        } else {
          // default value
          k = 0;
        } // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0;
        if (isString(datatype)) {
          // find signature that matches (datatype, datatype)
          eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

          zero = typed.convert(0, datatype);
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0; // rows and columns

        var rows = size[0];
        var columns = size[1]; // number of non-zero items

        var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

        var _value; // check value

        if (isArray(value)) {
          // validate array
          if (value.length !== n) {
            // number of values in array must be n
            throw new Error('Invalid value array length');
          } // define function

          _value = function _value(i) {
            // return value @ i
            return value[i];
          };
        } else if (isMatrix(value)) {
          // matrix size
          var ms = value.size(); // validate matrix

          if (ms.length !== 1 || ms[0] !== n) {
            // number of values in array must be n
            throw new Error('Invalid matrix length');
          } // define function

          _value = function _value(i) {
            // return value @ i
            return value.get([i]);
          };
        } else {
          // define function
          _value = function _value() {
            // return value
            return value;
          };
        } // create arrays

        var values = [];
        var index = [];
        var ptr = []; // loop items

        for (var j = 0; j < columns; j++) {
          // number of rows with value
          ptr.push(values.length); // diagonal index

          var i = j - kSuper; // check we need to set diagonal value

          if (i >= 0 && i < n) {
            // get value @ i
            var v = _value(i); // check for zero

            if (!eq(v, zero)) {
              // column
              index.push(i + kSub); // add value

              values.push(v);
            }
          }
        } // last value should be number of values

        ptr.push(values.length); // create SparseMatrix

        return new SparseMatrix({
          values,
          index,
          ptr,
          size: [rows, columns]
        });
      };
      /**
       * Swap rows i and j in Matrix.
       *
       * @memberof SparseMatrix
       * @param {number} i       Matrix row index 1
       * @param {number} j       Matrix row index 2
       *
       * @return {Matrix}        The matrix reference
       */

      SparseMatrix.prototype.swapRows = function (i, j) {
        // check index
        if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
          throw new Error('Row index must be positive integers');
        } // check dimensions

        if (this._size.length !== 2) {
          throw new Error('Only two dimensional matrix is supported');
        } // validate index

        validateIndex(i, this._size[0]);
        validateIndex(j, this._size[0]); // swap rows

        SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance

        return this;
      };
      /**
       * Loop rows with data in column j.
       *
       * @param {number} j            Column
       * @param {Array} values        Matrix values
       * @param {Array} index         Matrix row indeces
       * @param {Array} ptr           Matrix column pointers
       * @param {Function} callback   Callback function invoked for every row in column j
       */

      SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {
        // indeces for column j
        var k0 = ptr[j];
        var k1 = ptr[j + 1]; // loop

        for (var k = k0; k < k1; k++) {
          // invoke callback
          callback(index[k], values[k]);
        }
      };
      /**
       * Swap rows x and y in Sparse Matrix data structures.
       *
       * @param {number} x         Matrix row index 1
       * @param {number} y         Matrix row index 2
       * @param {number} columns   Number of columns in matrix
       * @param {Array} values     Matrix values
       * @param {Array} index      Matrix row indeces
       * @param {Array} ptr        Matrix column pointers
       */

      SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {
        // loop columns
        for (var j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          var k0 = ptr[j];
          var k1 = ptr[j + 1]; // find value index @ x

          var kx = _getValueIndex(x, k0, k1, index); // find value index @ x

          var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix

          if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
            // swap values (check for pattern matrix)
            if (values) {
              var v = values[kx];
              values[kx] = values[ky];
              values[ky] = v;
            } // next column

            continue;
          } // check x row exist & no y row

          if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
            // value @ x (check for pattern matrix)
            var vx = values ? values[kx] : undefined; // insert value @ y

            index.splice(ky, 0, y);
            if (values) {
              values.splice(ky, 0, vx);
            } // remove value @ x (adjust array index if needed)

            index.splice(ky <= kx ? kx + 1 : kx, 1);
            if (values) {
              values.splice(ky <= kx ? kx + 1 : kx, 1);
            } // next column

            continue;
          } // check y row exist & no x row

          if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
            // value @ y (check for pattern matrix)
            var vy = values ? values[ky] : undefined; // insert value @ x

            index.splice(kx, 0, x);
            if (values) {
              values.splice(kx, 0, vy);
            } // remove value @ y (adjust array index if needed)

            index.splice(kx <= ky ? ky + 1 : ky, 1);
            if (values) {
              values.splice(kx <= ky ? ky + 1 : ky, 1);
            }
          }
        }
      };
      return SparseMatrix;
    }, {
      isClass: true
    });

    var name$X = 'number';
    var dependencies$X = ['typed'];
    /**
     * Separates the radix, integer part, and fractional part of a non decimal number string
     * @param {string} input string to parse
     * @returns {object} the parts of the string or null if not a valid input
     */

    function getNonDecimalNumberParts(input) {
      var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
      if (nonDecimalWithRadixMatch) {
        var radix = {
          '0b': 2,
          '0o': 8,
          '0x': 16
        }[nonDecimalWithRadixMatch[1]];
        var integerPart = nonDecimalWithRadixMatch[2];
        var fractionalPart = nonDecimalWithRadixMatch[3];
        return {
          input,
          radix,
          integerPart,
          fractionalPart
        };
      } else {
        return null;
      }
    }
    /**
     * Makes a number from a radix, and integer part, and a fractional part
     * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)
     * @returns {number} the number
     */

    function makeNumberFromNonDecimalParts(parts) {
      var n = parseInt(parts.integerPart, parts.radix);
      var f = 0;
      for (var i = 0; i < parts.fractionalPart.length; i++) {
        var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
        f += digitValue / Math.pow(parts.radix, i + 1);
      }
      var result = n + f;
      if (isNaN(result)) {
        throw new SyntaxError('String "' + parts.input + '" is no valid number');
      }
      return result;
    }
    var createNumber = /* #__PURE__ */factory(name$X, dependencies$X, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Create a number or convert a string, boolean, or unit to a number.
       * When value is a matrix, all elements will be converted to number.
       *
       * Syntax:
       *
       *    math.number(value)
       *    math.number(unit, valuelessUnit)
       *
       * Examples:
       *
       *    math.number(2)                         // returns number 2
       *    math.number('7.2')                     // returns number 7.2
       *    math.number(true)                      // returns number 1
       *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]
       *    math.number(math.unit('52cm'), 'm')    // returns 0.52
       *
       * See also:
       *
       *    bignumber, boolean, complex, index, matrix, string, unit
       *
       * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
       * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
       * @return {number | Array | Matrix} The created number
       */
      var number = typed('number', {
        '': function _() {
          return 0;
        },
        number: function number(x) {
          return x;
        },
        string: function string(x) {
          if (x === 'NaN') return NaN;
          var nonDecimalNumberParts = getNonDecimalNumberParts(x);
          if (nonDecimalNumberParts) {
            return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
          }
          var size = 0;
          var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
          if (wordSizeSuffixMatch) {
            // x includes a size suffix like 0xffffi32, so we extract
            // the suffix and remove it from x
            size = Number(wordSizeSuffixMatch[2]);
            x = wordSizeSuffixMatch[1];
          }
          var num = Number(x);
          if (isNaN(num)) {
            throw new SyntaxError('String "' + x + '" is no valid number');
          }
          if (wordSizeSuffixMatch) {
            // x is a signed bin, oct, or hex literal
            // num is the value of string x if x is interpreted as unsigned
            if (num > 2 ** size - 1) {
              // literal is too large for size suffix
              throw new SyntaxError("String \"".concat(x, "\" is out of range"));
            } // check if the bit at index size - 1 is set and if so do the twos complement

            if (num >= 2 ** (size - 1)) {
              num = num - 2 ** size;
            }
          }
          return num;
        },
        BigNumber: function BigNumber(x) {
          return x.toNumber();
        },
        Fraction: function Fraction(x) {
          return x.valueOf();
        },
        Unit: function Unit(x) {
          throw new Error('Second argument with valueless unit expected');
        },
        null: function _null(x) {
          return 0;
        },
        'Unit, string | Unit': function UnitStringUnit(unit, valuelessUnit) {
          return unit.toNumber(valuelessUnit);
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      }); // reviver function to parse a JSON object like:
      //
      //     {"mathjs":"number","value":"2.3"}
      //
      // into a number 2.3

      number.fromJSON = function (json) {
        return parseFloat(json.value);
      };
      return number;
    });

    var name$W = 'bignumber';
    var dependencies$W = ['typed', 'BigNumber'];
    var createBignumber = /* #__PURE__ */factory(name$W, dependencies$W, _ref => {
      var {
        typed,
        BigNumber
      } = _ref;

      /**
       * Create a BigNumber, which can store numbers with arbitrary precision.
       * When a matrix is provided, all elements will be converted to BigNumber.
       *
       * Syntax:
       *
       *    math.bignumber(x)
       *
       * Examples:
       *
       *    0.1 + 0.2                                  // returns number 0.30000000000000004
       *    math.bignumber(0.1) + math.bignumber(0.2)  // returns BigNumber 0.3
       *
       *
       *    7.2e500                                    // returns number Infinity
       *    math.bignumber('7.2e500')                  // returns BigNumber 7.2e500
       *
       * See also:
       *
       *    boolean, complex, index, matrix, string, unit
       *
       * @param {number | string | Fraction | BigNumber | Array | Matrix | boolean | null} [value]  Value for the big number,
       *                                                    0 by default.
       * @returns {BigNumber} The created bignumber
       */
      return typed('bignumber', {
        '': function _() {
          return new BigNumber(0);
        },
        number: function number(x) {
          // convert to string to prevent errors in case of >15 digits
          return new BigNumber(x + '');
        },
        string: function string(x) {
          var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
          if (wordSizeSuffixMatch) {
            // x has a word size suffix
            var size = wordSizeSuffixMatch[2];
            var n = BigNumber(wordSizeSuffixMatch[1]);
            var twoPowSize = new BigNumber(2).pow(Number(size));
            if (n.gt(twoPowSize.sub(1))) {
              throw new SyntaxError("String \"".concat(x, "\" is out of range"));
            }
            var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
            if (n.gte(twoPowSizeSubOne)) {
              return n.sub(twoPowSize);
            } else {
              return n;
            }
          }
          return new BigNumber(x);
        },
        BigNumber: function BigNumber(x) {
          // we assume a BigNumber is immutable
          return x;
        },
        Fraction: function Fraction(x) {
          return new BigNumber(x.n).div(x.d).times(x.s);
        },
        null: function _null(x) {
          return new BigNumber(0);
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    var name$V = 'complex';
    var dependencies$V = ['typed', 'Complex'];
    var createComplex = /* #__PURE__ */factory(name$V, dependencies$V, _ref => {
      var {
        typed,
        Complex
      } = _ref;

      /**
       * Create a complex value or convert a value to a complex value.
       *
       * Syntax:
       *
       *     math.complex()                           // creates a complex value with zero
       *                                              // as real and imaginary part.
       *     math.complex(re : number, im : string)   // creates a complex value with provided
       *                                              // values for real and imaginary part.
       *     math.complex(re : number)                // creates a complex value with provided
       *                                              // real value and zero imaginary part.
       *     math.complex(complex : Complex)          // clones the provided complex value.
       *     math.complex(arg : string)               // parses a string into a complex value.
       *     math.complex(array : Array)              // converts the elements of the array
       *                                              // or matrix element wise into a
       *                                              // complex value.
       *     math.complex({re: number, im: number})   // creates a complex value with provided
       *                                              // values for real an imaginary part.
       *     math.complex({r: number, phi: number})   // creates a complex value with provided
       *                                              // polar coordinates
       *
       * Examples:
       *
       *    const a = math.complex(3, -4)     // a = Complex 3 - 4i
       *    a.re = 5                          // a = Complex 5 - 4i
       *    const i = a.im                    // Number -4
       *    const b = math.complex('2 + 6i')  // Complex 2 + 6i
       *    const c = math.complex()          // Complex 0 + 0i
       *    const d = math.add(a, b)          // Complex 5 + 2i
       *
       * See also:
       *
       *    bignumber, boolean, index, matrix, number, string, unit
       *
       * @param {* | Array | Matrix} [args]
       *            Arguments specifying the real and imaginary part of the complex number
       * @return {Complex | Array | Matrix} Returns a complex value
       */
      return typed('complex', {
        '': function _() {
          return Complex.ZERO;
        },
        number: function number(x) {
          return new Complex(x, 0);
        },
        'number, number': function numberNumber(re, im) {
          return new Complex(re, im);
        },
        // TODO: this signature should be redundant
        'BigNumber, BigNumber': function BigNumberBigNumber(re, im) {
          return new Complex(re.toNumber(), im.toNumber());
        },
        Fraction: function Fraction(x) {
          return new Complex(x.valueOf(), 0);
        },
        Complex: function Complex(x) {
          return x.clone();
        },
        string: function string(x) {
          return Complex(x); // for example '2 + 3i'
        },

        null: function _null(x) {
          return Complex(0);
        },
        Object: function Object(x) {
          if ('re' in x && 'im' in x) {
            return new Complex(x.re, x.im);
          }
          if ('r' in x && 'phi' in x || 'abs' in x && 'arg' in x) {
            return new Complex(x);
          }
          throw new Error('Expected object with properties (re and im) or (r and phi) or (abs and arg)');
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    var name$U = 'fraction';
    var dependencies$U = ['typed', 'Fraction'];
    var createFraction = /* #__PURE__ */factory(name$U, dependencies$U, _ref => {
      var {
        typed,
        Fraction
      } = _ref;

      /**
       * Create a fraction or convert a value to a fraction.
       *
       * With one numeric argument, produces the closest rational approximation to the
       * input.
       * With two arguments, the first is the numerator and the second is the denominator,
       * and creates the corresponding fraction. Both numerator and denominator must be
       * integers.
       * With one object argument, looks for the integer numerator as the value of property
       * 'n' and the integer denominator as the value of property 'd'.
       * With a matrix argument, creates a matrix of the same shape with entries
       * converted into fractions.
       *
       * Syntax:
       *     math.fraction(value)
       *     math.fraction(numerator, denominator)
       *     math.fraction({n: numerator, d: denominator})
       *     math.fraction(matrix: Array | Matrix)
       *
       * Examples:
       *
       *     math.fraction(6.283)             // returns Fraction 6283/1000
       *     math.fraction(1, 3)              // returns Fraction 1/3
       *     math.fraction('2/3')             // returns Fraction 2/3
       *     math.fraction({n: 2, d: 3})      // returns Fraction 2/3
       *     math.fraction([0.2, 0.25, 1.25]) // returns Array [1/5, 1/4, 5/4]
       *     math.fraction(4, 5.1)            // throws Error: Parameters must be integer
       *
       * See also:
       *
       *    bignumber, number, string, unit
       *
       * @param {number | string | Fraction | BigNumber | Array | Matrix} [args]
       *            Arguments specifying the value, or numerator and denominator of
       *            the fraction
       * @return {Fraction | Array | Matrix} Returns a fraction
       */
      return typed('fraction', {
        number: function number(x) {
          if (!isFinite(x) || isNaN(x)) {
            throw new Error(x + ' cannot be represented as a fraction');
          }
          return new Fraction(x);
        },
        string: function string(x) {
          return new Fraction(x);
        },
        'number, number': function numberNumber(numerator, denominator) {
          return new Fraction(numerator, denominator);
        },
        null: function _null(x) {
          return new Fraction(0);
        },
        BigNumber: function BigNumber(x) {
          return new Fraction(x.toString());
        },
        Fraction: function Fraction(x) {
          return x; // fractions are immutable
        },

        Object: function Object(x) {
          return new Fraction(x);
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    var name$T = 'matrix';
    var dependencies$T = ['typed', 'Matrix', 'DenseMatrix', 'SparseMatrix'];
    var createMatrix = /* #__PURE__ */factory(name$T, dependencies$T, _ref => {
      var {
        typed,
        Matrix,
        DenseMatrix,
        SparseMatrix
      } = _ref;

      /**
       * Create a Matrix. The function creates a new `math.Matrix` object from
       * an `Array`. A Matrix has utility functions to manipulate the data in the
       * matrix, like getting the size and getting or setting values in the matrix.
       * Supported storage formats are 'dense' and 'sparse'.
       *
       * Syntax:
       *
       *    math.matrix()                         // creates an empty matrix using default storage format (dense).
       *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
       *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
       *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
       *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
       *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
       *
       * Examples:
       *
       *    let m = math.matrix([[1, 2], [3, 4]])
       *    m.size()                        // Array [2, 2]
       *    m.resize([3, 2], 5)
       *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
       *    m.get([1, 0])                    // number 3
       *
       * See also:
       *
       *    bignumber, boolean, complex, index, number, string, unit, sparse
       *
       * @param {Array | Matrix} [data]    A multi dimensional array
       * @param {string} [format]          The Matrix storage format, either `'dense'` or `'sparse'`
       * @param {string} [datatype]        Type of the values
       *
       * @return {Matrix} The created matrix
       */
      return typed(name$T, {
        '': function _() {
          return _create([]);
        },
        string: function string(format) {
          return _create([], format);
        },
        'string, string': function stringString(format, datatype) {
          return _create([], format, datatype);
        },
        Array: function Array(data) {
          return _create(data);
        },
        Matrix: function Matrix(data) {
          return _create(data, data.storage());
        },
        'Array | Matrix, string': _create,
        'Array | Matrix, string, string': _create
      });
      /**
       * Create a new Matrix with given storage format
       * @param {Array} data
       * @param {string} [format]
       * @param {string} [datatype]
       * @returns {Matrix} Returns a new Matrix
       * @private
       */

      function _create(data, format, datatype) {
        // get storage format constructor
        if (format === 'dense' || format === 'default' || format === undefined) {
          return new DenseMatrix(data, datatype);
        }
        if (format === 'sparse') {
          return new SparseMatrix(data, datatype);
        }
        throw new TypeError('Unknown matrix type ' + JSON.stringify(format) + '.');
      }
    });

    var name$S = 'matrixFromColumns';
    var dependencies$S = ['typed', 'matrix', 'flatten', 'size'];
    var createMatrixFromColumns = /* #__PURE__ */factory(name$S, dependencies$S, _ref => {
      var {
        typed,
        matrix,
        flatten,
        size
      } = _ref;

      /**
       * Create a dense matrix from vectors as individual columns.
       * If you pass row vectors, they will be transposed (but not conjugated!)
       *
       * Syntax:
       *
       *    math.matrixFromColumns(...arr)
       *    math.matrixFromColumns(col1, col2)
       *    math.matrixFromColumns(col1, col2, col3)
       *
       * Examples:
       *
       *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])
       *    math.matrixFromColumns(...vectors)
       *
       * See also:
       *
       *    matrix, matrixFromRows, matrixFromFunction, zeros
       *
       * @param {... Array | Matrix} cols Multiple columns
       * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
       */
      return typed(name$S, {
        '...Array': function Array(arr) {
          return _createArray(arr);
        },
        '...Matrix': function Matrix(arr) {
          return matrix(_createArray(arr.map(m => m.toArray())));
        } // TODO implement this properly for SparseMatrix
      });

      function _createArray(arr) {
        if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');
        var N = checkVectorTypeAndReturnLength(arr[0]); // create an array with empty rows

        var result = [];
        for (var i = 0; i < N; i++) {
          result[i] = [];
        } // loop columns

        for (var col of arr) {
          var colLength = checkVectorTypeAndReturnLength(col);
          if (colLength !== N) {
            throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (colLength | 0));
          }
          var f = flatten(col); // push a value to each row

          for (var _i = 0; _i < N; _i++) {
            result[_i].push(f[_i]);
          }
        }
        return result;
      }
      function checkVectorTypeAndReturnLength(vec) {
        var s = size(vec);
        if (s.length === 1) {
          // 1D vector
          return s[0];
        } else if (s.length === 2) {
          // 2D vector
          if (s[0] === 1) {
            // row vector
            return s[1];
          } else if (s[1] === 1) {
            // col vector
            return s[0];
          } else {
            throw new TypeError('At least one of the arguments is not a vector.');
          }
        } else {
          throw new TypeError('Only one- or two-dimensional vectors are supported.');
        }
      }
    });

    var name$R = 'unaryMinus';
    var dependencies$R = ['typed'];
    var createUnaryMinus = /* #__PURE__ */factory(name$R, dependencies$R, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Inverse the sign of a value, apply a unary minus operation.
       *
       * For matrices, the function is evaluated element wise. Boolean values and
       * strings will be converted to a number. For complex numbers, both real and
       * complex value are inverted.
       *
       * Syntax:
       *
       *    math.unaryMinus(x)
       *
       * Examples:
       *
       *    math.unaryMinus(3.5)      // returns -3.5
       *    math.unaryMinus(-4.2)     // returns 4.2
       *
       * See also:
       *
       *    add, subtract, unaryPlus
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
       * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
       */
      return typed(name$R, {
        number: unaryMinusNumber,
        Complex: function Complex(x) {
          return x.neg();
        },
        BigNumber: function BigNumber(x) {
          return x.neg();
        },
        Fraction: function Fraction(x) {
          return x.neg();
        },
        Unit: function Unit(x) {
          var res = x.clone();
          res.value = this(x.value);
          return res;
        },
        'Array | Matrix': function ArrayMatrix(x) {
          // deep map collection, skip zeros since unaryMinus(0) = 0
          return deepMap(x, this);
        } // TODO: add support for string
      });
    });

    var name$Q = 'abs';
    var dependencies$Q = ['typed'];
    var createAbs = /* #__PURE__ */factory(name$Q, dependencies$Q, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Calculate the absolute value of a number. For matrices, the function is
       * evaluated element wise.
       *
       * Syntax:
       *
       *    math.abs(x)
       *
       * Examples:
       *
       *    math.abs(3.5)                // returns number 3.5
       *    math.abs(-4.2)               // returns number 4.2
       *
       *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
       *
       * See also:
       *
       *    sign
       *
       * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
       *            A number or matrix for which to get the absolute value
       * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
       *            Absolute value of `x`
       */
      return typed(name$Q, {
        number: absNumber,
        Complex: function Complex(x) {
          return x.abs();
        },
        BigNumber: function BigNumber(x) {
          return x.abs();
        },
        Fraction: function Fraction(x) {
          return x.abs();
        },
        'Array | Matrix': function ArrayMatrix(x) {
          // deep map collection, skip zeros since abs(0) = 0
          return deepMap(x, this);
        },
        Unit: function Unit(x) {
          return x.abs();
        }
      });
    });

    var name$P = 'addScalar';
    var dependencies$P = ['typed'];
    var createAddScalar = /* #__PURE__ */factory(name$P, dependencies$P, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Add two scalar values, `x + y`.
       * This function is meant for internal use: it is used by the public function
       * `add`
       *
       * This function does not support collections (Array or Matrix).
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
       * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
       * @return {number | BigNumber | Fraction | Complex | Unit}     Sum of `x` and `y`
       * @private
       */
      return typed(name$P, {
        'number, number': addNumber,
        'Complex, Complex': function ComplexComplex(x, y) {
          return x.add(y);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.plus(y);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.add(y);
        },
        'Unit, Unit': function UnitUnit(x, y) {
          if (x.value === null || x.value === undefined) throw new Error('Parameter x contains a unit with undefined value');
          if (y.value === null || y.value === undefined) throw new Error('Parameter y contains a unit with undefined value');
          if (!x.equalBase(y)) throw new Error('Units do not match');
          var res = x.clone();
          res.value = this(res.value, y.value);
          res.fixPrefix = false;
          return res;
        }
      });
    });

    var name$O = 'algorithm11';
    var dependencies$O = ['typed', 'equalScalar'];
    var createAlgorithm11 = /* #__PURE__ */factory(name$O, dependencies$O, _ref => {
      var {
        typed,
        equalScalar
      } = _ref;

      /**
       * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
       * Callback function invoked NZ times (number of nonzero items in S).
       *
       *
       *          ┌  f(Sij, b)  ; S(i,j) !== 0
       * C(i,j) = ┤
       *          └  0          ; otherwise
       *
       *
       * @param {Matrix}   s                 The SparseMatrix instance (S)
       * @param {Scalar}   b                 The Scalar value
       * @param {Function} callback          The f(Aij,b) operation to invoke
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
       *
       * @return {Matrix}                    SparseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
       */
      return function algorithm11(s, b, callback, inverse) {
        // sparse matrix arrays
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

        if (!avalues) {
          throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // datatype

        var dt; // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string') {
          // datatype
          dt = adt; // find signature that matches (dt, dt)

          eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

          zero = typed.convert(0, dt); // convert b to the same datatype

          b = typed.convert(b, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // result arrays

        var cvalues = [];
        var cindex = [];
        var cptr = []; // loop columns

        for (var j = 0; j < columns; j++) {
          // initialize ptr
          cptr[j] = cindex.length; // values in j

          for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            // row
            var i = aindex[k]; // invoke callback

            var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b); // check value is zero

            if (!eq(v, zero)) {
              // push index & value
              cindex.push(i);
              cvalues.push(v);
            }
          }
        } // update ptr

        cptr[columns] = cindex.length; // return sparse matrix

        return s.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });

    var name$N = 'algorithm12';
    var dependencies$N = ['typed', 'DenseMatrix'];
    var createAlgorithm12 = /* #__PURE__ */factory(name$N, dependencies$N, _ref => {
      var {
        typed,
        DenseMatrix
      } = _ref;

      /**
       * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
       * Callback function invoked MxN times.
       *
       *
       *          ┌  f(Sij, b)  ; S(i,j) !== 0
       * C(i,j) = ┤
       *          └  f(0, b)    ; otherwise
       *
       *
       * @param {Matrix}   s                 The SparseMatrix instance (S)
       * @param {Scalar}   b                 The Scalar value
       * @param {Function} callback          The f(Aij,b) operation to invoke
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
       */
      return function algorithm12(s, b, callback, inverse) {
        // sparse matrix arrays
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

        if (!avalues) {
          throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // datatype

        var dt; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string') {
          // datatype
          dt = adt; // convert b to the same datatype

          b = typed.convert(b, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // result arrays

        var cdata = []; // workspaces

        var x = []; // marks indicating we have a value in x for a given column

        var w = []; // loop columns

        for (var j = 0; j < columns; j++) {
          // columns mark
          var mark = j + 1; // values in j

          for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            // row
            var r = aindex[k]; // update workspace

            x[r] = avalues[k];
            w[r] = mark;
          } // loop rows

          for (var i = 0; i < rows; i++) {
            // initialize C on first column
            if (j === 0) {
              // create row array
              cdata[i] = [];
            } // check sparse matrix has a value @ i,j

            if (w[i] === mark) {
              // invoke callback, update C
              cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
            } else {
              // dense matrix value @ i, j
              cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
            }
          }
        } // return dense matrix

        return new DenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });

    var name$M = 'algorithm14';
    var dependencies$M = ['typed'];
    var createAlgorithm14 = /* #__PURE__ */factory(name$M, dependencies$M, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
       * Callback function invoked MxN times.
       *
       * C(i,j,...z) = f(Aij..z, b)
       *
       * @param {Matrix}   a                 The DenseMatrix instance (A)
       * @param {Scalar}   b                 The Scalar value
       * @param {Function} callback          The f(Aij..z,b) operation to invoke
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
       */
      return function algorithm14(a, b, callback, inverse) {
        // a arrays
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype; // datatype

        var dt; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string') {
          // datatype
          dt = adt; // convert b to the same datatype

          b = typed.convert(b, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // populate cdata, iterate through dimensions

        var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : []; // c matrix

        return a.createDenseMatrix({
          data: cdata,
          size: clone$1(asize),
          datatype: dt
        });
      }; // recursive function

      function _iterate(f, level, s, n, av, bv, inverse) {
        // initialize array for this level
        var cv = []; // check we reach the last level

        if (level === s.length - 1) {
          // loop arrays in last level
          for (var i = 0; i < n; i++) {
            // invoke callback and store value
            cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
          }
        } else {
          // iterate current level
          for (var j = 0; j < n; j++) {
            // iterate next level
            cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
          }
        }
        return cv;
      }
    });

    var name$L = 'algorithm01';
    var dependencies$L = ['typed'];
    var createAlgorithm01 = /* #__PURE__ */factory(name$L, dependencies$L, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
       * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
       *
       *
       *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
       * C(i,j) = ┤
       *          └  Dij          ; otherwise
       *
       *
       * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
       * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
       * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
       */
      return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
        // dense matrix arrays
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype; // sparse matrix arrays

        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype; // validate dimensions

        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        } // check rows & columns

        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        } // sparse matrix cannot be a Pattern matrix

        if (!bvalues) {
          throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // process data types

        var dt = typeof adt === 'string' && adt === bdt ? adt : undefined; // callback function

        var cf = dt ? typed.find(callback, [dt, dt]) : callback; // vars

        var i, j; // result (DenseMatrix)

        var cdata = []; // initialize c

        for (i = 0; i < rows; i++) {
          cdata[i] = [];
        } // workspace

        var x = []; // marks indicating we have a value in x for a given column

        var w = []; // loop columns in b

        for (j = 0; j < columns; j++) {
          // column mark
          var mark = j + 1; // values in column j

          for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            // row
            i = bindex[k]; // update workspace

            x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]); // mark i as updated

            w[i] = mark;
          } // loop rows

          for (i = 0; i < rows; i++) {
            // check row is in workspace
            if (w[i] === mark) {
              // c[i][j] was already calculated
              cdata[i][j] = x[i];
            } else {
              // item does not exist in S
              cdata[i][j] = adata[i][j];
            }
          }
        } // return dense matrix

        return denseMatrix.createDenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });

    var name$K = 'algorithm04';
    var dependencies$K = ['typed', 'equalScalar'];
    var createAlgorithm04 = /* #__PURE__ */factory(name$K, dependencies$K, _ref => {
      var {
        typed,
        equalScalar
      } = _ref;

      /**
       * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
       * Callback function invoked MAX(NNZA, NNZB) times
       *
       *
       *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
       * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0
       *          └  B(i,j)       ; B(i,j) !== 0
       *
       *
       * @param {Matrix}   a                 The SparseMatrix instance (A)
       * @param {Matrix}   b                 The SparseMatrix instance (B)
       * @param {Function} callback          The f(Aij,Bij) operation to invoke
       *
       * @return {Matrix}                    SparseMatrix (C)
       *
       * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
       */
      return function algorithm04(a, b, callback) {
        // sparse matrix arrays
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype; // sparse matrix arrays

        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype; // validate dimensions

        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        } // check rows & columns

        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // datatype

        var dt; // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt; // find signature that matches (dt, dt)

          eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

          zero = typed.convert(0, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // result arrays

        var cvalues = avalues && bvalues ? [] : undefined;
        var cindex = [];
        var cptr = []; // workspace

        var xa = avalues && bvalues ? [] : undefined;
        var xb = avalues && bvalues ? [] : undefined; // marks indicating we have a value in x for a given column

        var wa = [];
        var wb = []; // vars

        var i, j, k, k0, k1; // loop columns

        for (j = 0; j < columns; j++) {
          // update cptr
          cptr[j] = cindex.length; // columns mark

          var mark = j + 1; // loop A(:,j)

          for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            // row
            i = aindex[k]; // update c

            cindex.push(i); // update workspace

            wa[i] = mark; // check we need to process values

            if (xa) {
              xa[i] = avalues[k];
            }
          } // loop B(:,j)

          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            // row
            i = bindex[k]; // check row exists in A

            if (wa[i] === mark) {
              // update record in xa @ i
              if (xa) {
                // invoke callback
                var v = cf(xa[i], bvalues[k]); // check for zero

                if (!eq(v, zero)) {
                  // update workspace
                  xa[i] = v;
                } else {
                  // remove mark (index will be removed later)
                  wa[i] = null;
                }
              }
            } else {
              // update c
              cindex.push(i); // update workspace

              wb[i] = mark; // check we need to process values

              if (xb) {
                xb[i] = bvalues[k];
              }
            }
          } // check we need to process values (non pattern matrix)

          if (xa && xb) {
            // initialize first index in j
            k = cptr[j]; // loop index in j

            while (k < cindex.length) {
              // row
              i = cindex[k]; // check workspace has value @ i

              if (wa[i] === mark) {
                // push value (Aij != 0 || (Aij != 0 && Bij != 0))
                cvalues[k] = xa[i]; // increment pointer

                k++;
              } else if (wb[i] === mark) {
                // push value (bij != 0)
                cvalues[k] = xb[i]; // increment pointer

                k++;
              } else {
                // remove index @ k
                cindex.splice(k, 1);
              }
            }
          }
        } // update cptr

        cptr[columns] = cindex.length; // return sparse matrix

        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });

    var name$J = 'algorithm10';
    var dependencies$J = ['typed', 'DenseMatrix'];
    var createAlgorithm10 = /* #__PURE__ */factory(name$J, dependencies$J, _ref => {
      var {
        typed,
        DenseMatrix
      } = _ref;

      /**
       * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
       * Callback function invoked NZ times (number of nonzero items in S).
       *
       *
       *          ┌  f(Sij, b)  ; S(i,j) !== 0
       * C(i,j) = ┤
       *          └  b          ; otherwise
       *
       *
       * @param {Matrix}   s                 The SparseMatrix instance (S)
       * @param {Scalar}   b                 The Scalar value
       * @param {Function} callback          The f(Aij,b) operation to invoke
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
       */
      return function algorithm10(s, b, callback, inverse) {
        // sparse matrix arrays
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

        if (!avalues) {
          throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // datatype

        var dt; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string') {
          // datatype
          dt = adt; // convert b to the same datatype

          b = typed.convert(b, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // result arrays

        var cdata = []; // workspaces

        var x = []; // marks indicating we have a value in x for a given column

        var w = []; // loop columns

        for (var j = 0; j < columns; j++) {
          // columns mark
          var mark = j + 1; // values in j

          for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            // row
            var r = aindex[k]; // update workspace

            x[r] = avalues[k];
            w[r] = mark;
          } // loop rows

          for (var i = 0; i < rows; i++) {
            // initialize C on first column
            if (j === 0) {
              // create row array
              cdata[i] = [];
            } // check sparse matrix has a value @ i,j

            if (w[i] === mark) {
              // invoke callback, update C
              cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
            } else {
              // dense matrix value @ i, j
              cdata[i][j] = b;
            }
          }
        } // return dense matrix

        return new DenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });

    var name$I = 'algorithm13';
    var dependencies$I = ['typed'];
    var createAlgorithm13 = /* #__PURE__ */factory(name$I, dependencies$I, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
       * Callback function invoked MxN times.
       *
       * C(i,j,...z) = f(Aij..z, Bij..z)
       *
       * @param {Matrix}   a                 The DenseMatrix instance (A)
       * @param {Matrix}   b                 The DenseMatrix instance (B)
       * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
       */
      return function algorithm13(a, b, callback) {
        // a arrays
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype; // b arrays

        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype; // c arrays

        var csize = []; // validate dimensions

        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        } // validate each one of the dimension sizes

        for (var s = 0; s < asize.length; s++) {
          // must match
          if (asize[s] !== bsize[s]) {
            throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
          } // update dimension in c

          csize[s] = asize[s];
        } // datatype

        var dt; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt; // callback

          cf = typed.find(callback, [dt, dt]);
        } // populate cdata, iterate through dimensions

        var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : []; // c matrix

        return a.createDenseMatrix({
          data: cdata,
          size: csize,
          datatype: dt
        });
      }; // recursive function

      function _iterate(f, level, s, n, av, bv) {
        // initialize array for this level
        var cv = []; // check we reach the last level

        if (level === s.length - 1) {
          // loop arrays in last level
          for (var i = 0; i < n; i++) {
            // invoke callback and store value
            cv[i] = f(av[i], bv[i]);
          }
        } else {
          // iterate current level
          for (var j = 0; j < n; j++) {
            // iterate next level
            cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
          }
        }
        return cv;
      }
    });

    var name$H = 'algorithm03';
    var dependencies$H = ['typed'];
    var createAlgorithm03 = /* #__PURE__ */factory(name$H, dependencies$H, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
       * Callback function invoked M*N times.
       *
       *
       *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
       * C(i,j) = ┤
       *          └  f(Dij, 0)    ; otherwise
       *
       *
       * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
       * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
       * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
       * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
       */
      return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
        // dense matrix arrays
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype; // sparse matrix arrays

        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype; // validate dimensions

        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        } // check rows & columns

        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        } // sparse matrix cannot be a Pattern matrix

        if (!bvalues) {
          throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // datatype

        var dt; // zero value

        var zero = 0; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt; // convert 0 to the same datatype

          zero = typed.convert(0, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // result (DenseMatrix)

        var cdata = []; // initialize dense matrix

        for (var z = 0; z < rows; z++) {
          // initialize row
          cdata[z] = [];
        } // workspace

        var x = []; // marks indicating we have a value in x for a given column

        var w = []; // loop columns in b

        for (var j = 0; j < columns; j++) {
          // column mark
          var mark = j + 1; // values in column j

          for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            // row
            var i = bindex[k]; // update workspace

            x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
            w[i] = mark;
          } // process workspace

          for (var y = 0; y < rows; y++) {
            // check we have a calculated value for current row
            if (w[y] === mark) {
              // use calculated value
              cdata[y][j] = x[y];
            } else {
              // calculate value
              cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
            }
          }
        } // return dense matrix

        return denseMatrix.createDenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });

    var name$G = 'algorithm05';
    var dependencies$G = ['typed', 'equalScalar'];
    var createAlgorithm05 = /* #__PURE__ */factory(name$G, dependencies$G, _ref => {
      var {
        typed,
        equalScalar
      } = _ref;

      /**
       * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
       * Callback function invoked MAX(NNZA, NNZB) times
       *
       *
       *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
       * C(i,j) = ┤
       *          └  0            ; otherwise
       *
       *
       * @param {Matrix}   a                 The SparseMatrix instance (A)
       * @param {Matrix}   b                 The SparseMatrix instance (B)
       * @param {Function} callback          The f(Aij,Bij) operation to invoke
       *
       * @return {Matrix}                    SparseMatrix (C)
       *
       * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
       */
      return function algorithm05(a, b, callback) {
        // sparse matrix arrays
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype; // sparse matrix arrays

        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype; // validate dimensions

        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        } // check rows & columns

        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // datatype

        var dt; // equal signature to use

        var eq = equalScalar; // zero value

        var zero = 0; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt; // find signature that matches (dt, dt)

          eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

          zero = typed.convert(0, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // result arrays

        var cvalues = avalues && bvalues ? [] : undefined;
        var cindex = [];
        var cptr = []; // workspaces

        var xa = cvalues ? [] : undefined;
        var xb = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column

        var wa = [];
        var wb = []; // vars

        var i, j, k, k1; // loop columns

        for (j = 0; j < columns; j++) {
          // update cptr
          cptr[j] = cindex.length; // columns mark

          var mark = j + 1; // loop values A(:,j)

          for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
            // row
            i = aindex[k]; // push index

            cindex.push(i); // update workspace

            wa[i] = mark; // check we need to process values

            if (xa) {
              xa[i] = avalues[k];
            }
          } // loop values B(:,j)

          for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
            // row
            i = bindex[k]; // check row existed in A

            if (wa[i] !== mark) {
              // push index
              cindex.push(i);
            } // update workspace

            wb[i] = mark; // check we need to process values

            if (xb) {
              xb[i] = bvalues[k];
            }
          } // check we need to process values (non pattern matrix)

          if (cvalues) {
            // initialize first index in j
            k = cptr[j]; // loop index in j

            while (k < cindex.length) {
              // row
              i = cindex[k]; // marks

              var wai = wa[i];
              var wbi = wb[i]; // check Aij or Bij are nonzero

              if (wai === mark || wbi === mark) {
                // matrix values @ i,j
                var va = wai === mark ? xa[i] : zero;
                var vb = wbi === mark ? xb[i] : zero; // Cij

                var vc = cf(va, vb); // check for zero

                if (!eq(vc, zero)) {
                  // push value
                  cvalues.push(vc); // increment pointer

                  k++;
                } else {
                  // remove value @ i, do not increment pointer
                  cindex.splice(k, 1);
                }
              }
            }
          }
        } // update cptr

        cptr[columns] = cindex.length; // return sparse matrix

        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });

    var name$F = 'multiplyScalar';
    var dependencies$F = ['typed'];
    var createMultiplyScalar = /* #__PURE__ */factory(name$F, dependencies$F, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Multiply two scalar values, `x * y`.
       * This function is meant for internal use: it is used by the public function
       * `multiply`
       *
       * This function does not support collections (Array or Matrix).
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
       * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
       * @return {number | BigNumber | Fraction | Complex | Unit}     Multiplication of `x` and `y`
       * @private
       */
      return typed('multiplyScalar', {
        'number, number': multiplyNumber,
        'Complex, Complex': function ComplexComplex(x, y) {
          return x.mul(y);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.times(y);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.mul(y);
        },
        'number | Fraction | BigNumber | Complex, Unit': function numberFractionBigNumberComplexUnit(x, y) {
          var res = y.clone();
          res.value = res.value === null ? res._normalize(x) : this(res.value, x);
          return res;
        },
        'Unit, number | Fraction | BigNumber | Complex': function UnitNumberFractionBigNumberComplex(x, y) {
          var res = x.clone();
          res.value = res.value === null ? res._normalize(y) : this(res.value, y);
          return res;
        },
        'Unit, Unit': function UnitUnit(x, y) {
          return x.multiply(y);
        }
      });
    });

    var name$E = 'multiply';
    var dependencies$E = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];
    var createMultiply = /* #__PURE__ */factory(name$E, dependencies$E, _ref => {
      var {
        typed,
        matrix,
        addScalar,
        multiplyScalar,
        equalScalar,
        dot
      } = _ref;
      var algorithm11 = createAlgorithm11({
        typed,
        equalScalar
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      function _validateMatrixDimensions(size1, size2) {
        // check left operand dimensions
        switch (size1.length) {
          case 1:
            // check size2
            switch (size2.length) {
              case 1:
                // Vector x Vector
                if (size1[0] !== size2[0]) {
                  // throw error
                  throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
                }
                break;
              case 2:
                // Vector x Matrix
                if (size1[0] !== size2[0]) {
                  // throw error
                  throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
                }
                break;
              default:
                throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
            }
            break;
          case 2:
            // check size2
            switch (size2.length) {
              case 1:
                // Matrix x Vector
                if (size1[1] !== size2[0]) {
                  // throw error
                  throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
                }
                break;
              case 2:
                // Matrix x Matrix
                if (size1[1] !== size2[0]) {
                  // throw error
                  throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
                }
                break;
              default:
                throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
            }
            break;
          default:
            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
        }
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            Dense Vector   (N)
       * @param {Matrix} b            Dense Vector   (N)
       *
       * @return {number}             Scalar value
       */

      function _multiplyVectorVector(a, b, n) {
        // check empty vector
        if (n === 0) {
          throw new Error('Cannot multiply two empty vectors');
        }
        return dot(a, b);
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            Dense Vector   (M)
       * @param {Matrix} b            Matrix         (MxN)
       *
       * @return {Matrix}             Dense Vector   (N)
       */

      function _multiplyVectorMatrix(a, b) {
        // process storage
        if (b.storage() !== 'dense') {
          throw new Error('Support for SparseMatrix not implemented');
        }
        return _multiplyVectorDenseMatrix(a, b);
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            Dense Vector   (M)
       * @param {Matrix} b            Dense Matrix   (MxN)
       *
       * @return {Matrix}             Dense Vector   (N)
       */

      function _multiplyVectorDenseMatrix(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype; // b dense

        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype; // rows & columns

        var alength = asize[0];
        var bcolumns = bsize[1]; // datatype

        var dt; // addScalar signature to use

        var af = addScalar; // multiplyScalar signature to use

        var mf = multiplyScalar; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          // datatype
          dt = adt; // find signatures that matches (dt, dt)

          af = typed.find(addScalar, [dt, dt]);
          mf = typed.find(multiplyScalar, [dt, dt]);
        } // result

        var c = []; // loop matrix columns

        for (var j = 0; j < bcolumns; j++) {
          // sum (do not initialize it with zero)
          var sum = mf(adata[0], bdata[0][j]); // loop vector

          for (var i = 1; i < alength; i++) {
            // multiply & accumulate
            sum = af(sum, mf(adata[i], bdata[i][j]));
          }
          c[j] = sum;
        } // return matrix

        return a.createDenseMatrix({
          data: c,
          size: [bcolumns],
          datatype: dt
        });
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            Matrix         (MxN)
       * @param {Matrix} b            Dense Vector   (N)
       *
       * @return {Matrix}             Dense Vector   (M)
       */

      var _multiplyMatrixVector = typed('_multiplyMatrixVector', {
        'DenseMatrix, any': _multiplyDenseMatrixVector,
        'SparseMatrix, any': _multiplySparseMatrixVector
      });
      /**
       * C = A * B
       *
       * @param {Matrix} a            Matrix         (MxN)
       * @param {Matrix} b            Matrix         (NxC)
       *
       * @return {Matrix}             Matrix         (MxC)
       */

      var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {
        'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,
        'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,
        'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,
        'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix
      });
      /**
       * C = A * B
       *
       * @param {Matrix} a            DenseMatrix  (MxN)
       * @param {Matrix} b            Dense Vector (N)
       *
       * @return {Matrix}             Dense Vector (M)
       */

      function _multiplyDenseMatrixVector(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype; // b dense

        var bdata = b._data;
        var bdt = b._datatype; // rows & columns

        var arows = asize[0];
        var acolumns = asize[1]; // datatype

        var dt; // addScalar signature to use

        var af = addScalar; // multiplyScalar signature to use

        var mf = multiplyScalar; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          // datatype
          dt = adt; // find signatures that matches (dt, dt)

          af = typed.find(addScalar, [dt, dt]);
          mf = typed.find(multiplyScalar, [dt, dt]);
        } // result

        var c = []; // loop matrix a rows

        for (var i = 0; i < arows; i++) {
          // current row
          var row = adata[i]; // sum (do not initialize it with zero)

          var sum = mf(row[0], bdata[0]); // loop matrix a columns

          for (var j = 1; j < acolumns; j++) {
            // multiply & accumulate
            sum = af(sum, mf(row[j], bdata[j]));
          }
          c[i] = sum;
        } // return matrix

        return a.createDenseMatrix({
          data: c,
          size: [arows],
          datatype: dt
        });
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            DenseMatrix    (MxN)
       * @param {Matrix} b            DenseMatrix    (NxC)
       *
       * @return {Matrix}             DenseMatrix    (MxC)
       */

      function _multiplyDenseMatrixDenseMatrix(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype; // b dense

        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype; // rows & columns

        var arows = asize[0];
        var acolumns = asize[1];
        var bcolumns = bsize[1]; // datatype

        var dt; // addScalar signature to use

        var af = addScalar; // multiplyScalar signature to use

        var mf = multiplyScalar; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          // datatype
          dt = adt; // find signatures that matches (dt, dt)

          af = typed.find(addScalar, [dt, dt]);
          mf = typed.find(multiplyScalar, [dt, dt]);
        } // result

        var c = []; // loop matrix a rows

        for (var i = 0; i < arows; i++) {
          // current row
          var row = adata[i]; // initialize row array

          c[i] = []; // loop matrix b columns

          for (var j = 0; j < bcolumns; j++) {
            // sum (avoid initializing sum to zero)
            var sum = mf(row[0], bdata[0][j]); // loop matrix a columns

            for (var x = 1; x < acolumns; x++) {
              // multiply & accumulate
              sum = af(sum, mf(row[x], bdata[x][j]));
            }
            c[i][j] = sum;
          }
        } // return matrix

        return a.createDenseMatrix({
          data: c,
          size: [arows, bcolumns],
          datatype: dt
        });
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            DenseMatrix    (MxN)
       * @param {Matrix} b            SparseMatrix   (NxC)
       *
       * @return {Matrix}             SparseMatrix   (MxC)
       */

      function _multiplyDenseMatrixSparseMatrix(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype; // b sparse

        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype; // validate b matrix

        if (!bvalues) {
          throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
        } // rows & columns

        var arows = asize[0];
        var bcolumns = bsize[1]; // datatype

        var dt; // addScalar signature to use

        var af = addScalar; // multiplyScalar signature to use

        var mf = multiplyScalar; // equalScalar signature to use

        var eq = equalScalar; // zero value

        var zero = 0; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          // datatype
          dt = adt; // find signatures that matches (dt, dt)

          af = typed.find(addScalar, [dt, dt]);
          mf = typed.find(multiplyScalar, [dt, dt]);
          eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

          zero = typed.convert(0, dt);
        } // result

        var cvalues = [];
        var cindex = [];
        var cptr = []; // c matrix

        var c = b.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, bcolumns],
          datatype: dt
        }); // loop b columns

        for (var jb = 0; jb < bcolumns; jb++) {
          // update ptr
          cptr[jb] = cindex.length; // indeces in column jb

          var kb0 = bptr[jb];
          var kb1 = bptr[jb + 1]; // do not process column jb if no data exists

          if (kb1 > kb0) {
            // last row mark processed
            var last = 0; // loop a rows

            for (var i = 0; i < arows; i++) {
              // column mark
              var mark = i + 1; // C[i, jb]

              var cij = void 0; // values in b column j

              for (var kb = kb0; kb < kb1; kb++) {
                // row
                var ib = bindex[kb]; // check value has been initialized

                if (last !== mark) {
                  // first value in column jb
                  cij = mf(adata[i][ib], bvalues[kb]); // update mark

                  last = mark;
                } else {
                  // accumulate value
                  cij = af(cij, mf(adata[i][ib], bvalues[kb]));
                }
              } // check column has been processed and value != 0

              if (last === mark && !eq(cij, zero)) {
                // push row & value
                cindex.push(i);
                cvalues.push(cij);
              }
            }
          }
        } // update ptr

        cptr[bcolumns] = cindex.length; // return sparse matrix

        return c;
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            SparseMatrix    (MxN)
       * @param {Matrix} b            Dense Vector (N)
       *
       * @return {Matrix}             SparseMatrix    (M, 1)
       */

      function _multiplySparseMatrixVector(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype; // validate a matrix

        if (!avalues) {
          throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
        } // b dense

        var bdata = b._data;
        var bdt = b._datatype; // rows & columns

        var arows = a._size[0];
        var brows = b._size[0]; // result

        var cvalues = [];
        var cindex = [];
        var cptr = []; // datatype

        var dt; // addScalar signature to use

        var af = addScalar; // multiplyScalar signature to use

        var mf = multiplyScalar; // equalScalar signature to use

        var eq = equalScalar; // zero value

        var zero = 0; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          // datatype
          dt = adt; // find signatures that matches (dt, dt)

          af = typed.find(addScalar, [dt, dt]);
          mf = typed.find(multiplyScalar, [dt, dt]);
          eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

          zero = typed.convert(0, dt);
        } // workspace

        var x = []; // vector with marks indicating a value x[i] exists in a given column

        var w = []; // update ptr

        cptr[0] = 0; // rows in b

        for (var ib = 0; ib < brows; ib++) {
          // b[ib]
          var vbi = bdata[ib]; // check b[ib] != 0, avoid loops

          if (!eq(vbi, zero)) {
            // A values & index in ib column
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              // a row
              var ia = aindex[ka]; // check value exists in current j

              if (!w[ia]) {
                // ia is new entry in j
                w[ia] = true; // add i to pattern of C

                cindex.push(ia); // x(ia) = A

                x[ia] = mf(vbi, avalues[ka]);
              } else {
                // i exists in C already
                x[ia] = af(x[ia], mf(vbi, avalues[ka]));
              }
            }
          }
        } // copy values from x to column jb of c

        for (var p1 = cindex.length, p = 0; p < p1; p++) {
          // row
          var ic = cindex[p]; // copy value

          cvalues[p] = x[ic];
        } // update ptr

        cptr[1] = cindex.length; // return sparse matrix

        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, 1],
          datatype: dt
        });
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            SparseMatrix      (MxN)
       * @param {Matrix} b            DenseMatrix       (NxC)
       *
       * @return {Matrix}             SparseMatrix      (MxC)
       */

      function _multiplySparseMatrixDenseMatrix(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype; // validate a matrix

        if (!avalues) {
          throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
        } // b dense

        var bdata = b._data;
        var bdt = b._datatype; // rows & columns

        var arows = a._size[0];
        var brows = b._size[0];
        var bcolumns = b._size[1]; // datatype

        var dt; // addScalar signature to use

        var af = addScalar; // multiplyScalar signature to use

        var mf = multiplyScalar; // equalScalar signature to use

        var eq = equalScalar; // zero value

        var zero = 0; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          // datatype
          dt = adt; // find signatures that matches (dt, dt)

          af = typed.find(addScalar, [dt, dt]);
          mf = typed.find(multiplyScalar, [dt, dt]);
          eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

          zero = typed.convert(0, dt);
        } // result

        var cvalues = [];
        var cindex = [];
        var cptr = []; // c matrix

        var c = a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, bcolumns],
          datatype: dt
        }); // workspace

        var x = []; // vector with marks indicating a value x[i] exists in a given column

        var w = []; // loop b columns

        for (var jb = 0; jb < bcolumns; jb++) {
          // update ptr
          cptr[jb] = cindex.length; // mark in workspace for current column

          var mark = jb + 1; // rows in jb

          for (var ib = 0; ib < brows; ib++) {
            // b[ib, jb]
            var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops

            if (!eq(vbij, zero)) {
              // A values & index in ib column
              for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                // a row
                var ia = aindex[ka]; // check value exists in current j

                if (w[ia] !== mark) {
                  // ia is new entry in j
                  w[ia] = mark; // add i to pattern of C

                  cindex.push(ia); // x(ia) = A

                  x[ia] = mf(vbij, avalues[ka]);
                } else {
                  // i exists in C already
                  x[ia] = af(x[ia], mf(vbij, avalues[ka]));
                }
              }
            }
          } // copy values from x to column jb of c

          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            // row
            var ic = cindex[p]; // copy value

            cvalues[p] = x[ic];
          }
        } // update ptr

        cptr[bcolumns] = cindex.length; // return sparse matrix

        return c;
      }
      /**
       * C = A * B
       *
       * @param {Matrix} a            SparseMatrix      (MxN)
       * @param {Matrix} b            SparseMatrix      (NxC)
       *
       * @return {Matrix}             SparseMatrix      (MxC)
       */

      function _multiplySparseMatrixSparseMatrix(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype; // b sparse

        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bdt = b._datatype; // rows & columns

        var arows = a._size[0];
        var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data

        var values = avalues && bvalues; // datatype

        var dt; // addScalar signature to use

        var af = addScalar; // multiplyScalar signature to use

        var mf = multiplyScalar; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          // datatype
          dt = adt; // find signatures that matches (dt, dt)

          af = typed.find(addScalar, [dt, dt]);
          mf = typed.find(multiplyScalar, [dt, dt]);
        } // result

        var cvalues = values ? [] : undefined;
        var cindex = [];
        var cptr = []; // c matrix

        var c = a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, bcolumns],
          datatype: dt
        }); // workspace

        var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column

        var w = []; // variables

        var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns

        for (var jb = 0; jb < bcolumns; jb++) {
          // update ptr
          cptr[jb] = cindex.length; // mark in workspace for current column

          var mark = jb + 1; // B values & index in j

          for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
            // b row
            ib = bindex[kb]; // check we need to process values

            if (values) {
              // loop values in a[:,ib]
              for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                // row
                ia = aindex[ka]; // check value exists in current j

                if (w[ia] !== mark) {
                  // ia is new entry in j
                  w[ia] = mark; // add i to pattern of C

                  cindex.push(ia); // x(ia) = A

                  x[ia] = mf(bvalues[kb], avalues[ka]);
                } else {
                  // i exists in C already
                  x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
                }
              }
            } else {
              // loop values in a[:,ib]
              for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                // row
                ia = aindex[ka]; // check value exists in current j

                if (w[ia] !== mark) {
                  // ia is new entry in j
                  w[ia] = mark; // add i to pattern of C

                  cindex.push(ia);
                }
              }
            }
          } // check we need to process matrix values (pattern matrix)

          if (values) {
            // copy values from x to column jb of c
            for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
              // row
              var ic = cindex[p]; // copy value

              cvalues[p] = x[ic];
            }
          }
        } // update ptr

        cptr[bcolumns] = cindex.length; // return sparse matrix

        return c;
      }
      /**
       * Multiply two or more values, `x * y`.
       * For matrices, the matrix product is calculated.
       *
       * Syntax:
       *
       *    math.multiply(x, y)
       *    math.multiply(x, y, z, ...)
       *
       * Examples:
       *
       *    math.multiply(4, 5.2)        // returns number 20.8
       *    math.multiply(2, 3, 4)       // returns number 24
       *
       *    const a = math.complex(2, 3)
       *    const b = math.complex(4, 1)
       *    math.multiply(a, b)          // returns Complex 5 + 14i
       *
       *    const c = [[1, 2], [4, 3]]
       *    const d = [[1, 2, 3], [3, -4, 7]]
       *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
       *
       *    const e = math.unit('2.1 km')
       *    math.multiply(3, e)          // returns Unit 6.3 km
       *
       * See also:
       *
       *    divide, prod, cross, dot
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
       * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
       */

      return typed(name$E, extend({
        // we extend the signatures of multiplyScalar with signatures dealing with matrices
        'Array, Array': function ArrayArray(x, y) {
          // check dimensions
          _validateMatrixDimensions(arraySize(x), arraySize(y)); // use dense matrix implementation

          var m = this(matrix(x), matrix(y)); // return array or scalar

          return isMatrix(m) ? m.valueOf() : m;
        },
        'Matrix, Matrix': function MatrixMatrix(x, y) {
          // dimensions
          var xsize = x.size();
          var ysize = y.size(); // check dimensions

          _validateMatrixDimensions(xsize, ysize); // process dimensions

          if (xsize.length === 1) {
            // process y dimensions
            if (ysize.length === 1) {
              // Vector * Vector
              return _multiplyVectorVector(x, y, xsize[0]);
            } // Vector * Matrix

            return _multiplyVectorMatrix(x, y);
          } // process y dimensions

          if (ysize.length === 1) {
            // Matrix * Vector
            return _multiplyMatrixVector(x, y);
          } // Matrix * Matrix

          return _multiplyMatrixMatrix(x, y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use Matrix * Matrix implementation
          return this(x, matrix(y));
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use Matrix * Matrix implementation
          return this(matrix(x, y.storage()), y);
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm11(x, y, multiplyScalar, false);
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, multiplyScalar, false);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm11(y, x, multiplyScalar, true);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, multiplyScalar, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
        },
        'any, any': multiplyScalar,
        'any, any, ...any': function anyAnyAny(x, y, rest) {
          var result = this(x, y);
          for (var i = 0; i < rest.length; i++) {
            result = this(result, rest[i]);
          }
          return result;
        }
      }, multiplyScalar.signatures));
    });

    var name$D = 'sign';
    var dependencies$D = ['typed', 'BigNumber', 'Fraction', 'complex'];
    var createSign = /* #__PURE__ */factory(name$D, dependencies$D, _ref => {
      var {
        typed,
        BigNumber: _BigNumber,
        complex,
        Fraction: _Fraction
      } = _ref;

      /**
       * Compute the sign of a value. The sign of a value x is:
       *
       * -  1 when x > 0
       * - -1 when x < 0
       * -  0 when x == 0
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.sign(x)
       *
       * Examples:
       *
       *    math.sign(3.5)               // returns 1
       *    math.sign(-4.2)              // returns -1
       *    math.sign(0)                 // returns 0
       *
       *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
       *
       * See also:
       *
       *    abs
       *
       * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
       *            The number for which to determine the sign
       * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}e
       *            The sign of `x`
       */
      return typed(name$D, {
        number: signNumber,
        Complex: function Complex(x) {
          return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
        },
        BigNumber: function BigNumber(x) {
          return new _BigNumber(x.cmp(0));
        },
        Fraction: function Fraction(x) {
          return new _Fraction(x.s, 1);
        },
        'Array | Matrix': function ArrayMatrix(x) {
          // deep map collection, skip zeros since sign(0) = 0
          return deepMap(x, this);
        },
        Unit: function Unit(x) {
          if (!x._isDerived() && x.units[0].unit.offset !== 0) {
            throw new TypeError('sign is ambiguous for units with offset');
          }
          return this(x.value);
        }
      });
    });

    var name$C = 'sqrt';
    var dependencies$C = ['config', 'typed', 'Complex'];
    var createSqrt = /* #__PURE__ */factory(name$C, dependencies$C, _ref => {
      var {
        config,
        typed,
        Complex
      } = _ref;

      /**
       * Calculate the square root of a value.
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.sqrt(x)
       *
       * Examples:
       *
       *    math.sqrt(25)                // returns 5
       *    math.square(5)               // returns 25
       *    math.sqrt(-4)                // returns Complex 2i
       *
       * See also:
       *
       *    square, multiply, cube, cbrt, sqrtm
       *
       * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
       *            Value for which to calculate the square root.
       * @return {number | BigNumber | Complex | Array | Matrix | Unit}
       *            Returns the square root of `x`
       */
      return typed('sqrt', {
        number: _sqrtNumber,
        Complex: function Complex(x) {
          return x.sqrt();
        },
        BigNumber: function BigNumber(x) {
          if (!x.isNegative() || config.predictable) {
            return x.sqrt();
          } else {
            // negative value -> downgrade to number to do complex value computation
            return _sqrtNumber(x.toNumber());
          }
        },
        'Array | Matrix': function ArrayMatrix(x) {
          // deep map collection, skip zeros since sqrt(0) = 0
          return deepMap(x, this);
        },
        Unit: function Unit(x) {
          // Someday will work for complex units when they are implemented
          return x.pow(0.5);
        }
      });
      /**
       * Calculate sqrt for a number
       * @param {number} x
       * @returns {number | Complex} Returns the square root of x
       * @private
       */

      function _sqrtNumber(x) {
        if (isNaN(x)) {
          return NaN;
        } else if (x >= 0 || config.predictable) {
          return Math.sqrt(x);
        } else {
          return new Complex(x, 0).sqrt();
        }
      }
    });

    var name$B = 'subtract';
    var dependencies$B = ['typed', 'matrix', 'equalScalar', 'addScalar', 'unaryMinus', 'DenseMatrix'];
    var createSubtract = /* #__PURE__ */factory(name$B, dependencies$B, _ref => {
      var {
        typed,
        matrix,
        equalScalar,
        addScalar,
        unaryMinus,
        DenseMatrix
      } = _ref;
      // TODO: split function subtract in two: subtract and subtractScalar
      var algorithm01 = createAlgorithm01({
        typed
      });
      var algorithm03 = createAlgorithm03({
        typed
      });
      var algorithm05 = createAlgorithm05({
        typed,
        equalScalar
      });
      var algorithm10 = createAlgorithm10({
        typed,
        DenseMatrix
      });
      var algorithm13 = createAlgorithm13({
        typed
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Subtract two values, `x - y`.
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.subtract(x, y)
       *
       * Examples:
       *
       *    math.subtract(5.3, 2)        // returns number 3.3
       *
       *    const a = math.complex(2, 3)
       *    const b = math.complex(4, 1)
       *    math.subtract(a, b)          // returns Complex -2 + 2i
       *
       *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
       *
       *    const c = math.unit('2.1 km')
       *    const d = math.unit('500m')
       *    math.subtract(c, d)          // returns Unit 1.6 km
       *
       * See also:
       *
       *    add
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
       *            Initial value
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
       *            Value to subtract from `x`
       * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
       *            Subtraction of `x` and `y`
       */

      return typed(name$B, {
        'number, number': function numberNumber(x, y) {
          return x - y;
        },
        'Complex, Complex': function ComplexComplex(x, y) {
          return x.sub(y);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.minus(y);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.sub(y);
        },
        'Unit, Unit': function UnitUnit(x, y) {
          if (x.value === null) {
            throw new Error('Parameter x contains a unit with undefined value');
          }
          if (y.value === null) {
            throw new Error('Parameter y contains a unit with undefined value');
          }
          if (!x.equalBase(y)) {
            throw new Error('Units do not match');
          }
          var res = x.clone();
          res.value = this(res.value, y.value);
          res.fixPrefix = false;
          return res;
        },
        'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm05(x, y, this);
        },
        'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm03(y, x, this, true);
        },
        'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm01(x, y, this, false);
        },
        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm13(x, y, this);
        },
        'Array, Array': function ArrayArray(x, y) {
          // use matrix implementation
          return this(matrix(x), matrix(y)).valueOf();
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use matrix implementation
          return this(matrix(x), y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use matrix implementation
          return this(x, matrix(y));
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm10(x, unaryMinus(y), addScalar);
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm10(y, x, this, true);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, this, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, this, true).valueOf();
        }
      });
    });
    /**
     * Check whether matrix x and y have the same number of dimensions.
     * Throws a DimensionError when dimensions are not equal
     * @param {Matrix} x
     * @param {Matrix} y
     */

    function checkEqualDimensions(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      if (xsize.length !== ysize.length) {
        throw new DimensionError(xsize.length, ysize.length);
      }
    }

    var name$A = 'algorithm07';
    var dependencies$A = ['typed', 'DenseMatrix'];
    var createAlgorithm07 = /* #__PURE__ */factory(name$A, dependencies$A, _ref => {
      var {
        typed,
        DenseMatrix
      } = _ref;

      /**
       * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
       * Callback function invoked MxN times.
       *
       * C(i,j) = f(Aij, Bij)
       *
       * @param {Matrix}   a                 The SparseMatrix instance (A)
       * @param {Matrix}   b                 The SparseMatrix instance (B)
       * @param {Function} callback          The f(Aij,Bij) operation to invoke
       *
       * @return {Matrix}                    DenseMatrix (C)
       *
       * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
       */
      return function algorithm07(a, b, callback) {
        // sparse matrix arrays
        var asize = a._size;
        var adt = a._datatype; // sparse matrix arrays

        var bsize = b._size;
        var bdt = b._datatype; // validate dimensions

        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        } // check rows & columns

        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        } // rows & columns

        var rows = asize[0];
        var columns = asize[1]; // datatype

        var dt; // zero value

        var zero = 0; // callback signature to use

        var cf = callback; // process data types

        if (typeof adt === 'string' && adt === bdt) {
          // datatype
          dt = adt; // convert 0 to the same datatype

          zero = typed.convert(0, dt); // callback

          cf = typed.find(callback, [dt, dt]);
        } // vars

        var i, j; // result arrays

        var cdata = []; // initialize c

        for (i = 0; i < rows; i++) {
          cdata[i] = [];
        } // workspaces

        var xa = [];
        var xb = []; // marks indicating we have a value in x for a given column

        var wa = [];
        var wb = []; // loop columns

        for (j = 0; j < columns; j++) {
          // columns mark
          var mark = j + 1; // scatter the values of A(:,j) into workspace

          _scatter(a, j, wa, xa, mark); // scatter the values of B(:,j) into workspace

          _scatter(b, j, wb, xb, mark); // loop rows

          for (i = 0; i < rows; i++) {
            // matrix values @ i,j
            var va = wa[i] === mark ? xa[i] : zero;
            var vb = wb[i] === mark ? xb[i] : zero; // invoke callback

            cdata[i][j] = cf(va, vb);
          }
        } // return dense matrix

        return new DenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
      function _scatter(m, j, w, x, mark) {
        // a arrays
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr; // loop values in column j

        for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
          // row
          var i = index[k]; // update workspace

          w[i] = mark;
          x[i] = values[k];
        }
      }
    });

    var name$z = 'conj';
    var dependencies$z = ['typed'];
    var createConj = /* #__PURE__ */factory(name$z, dependencies$z, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Compute the complex conjugate of a complex value.
       * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.conj(x)
       *
       * Examples:
       *
       *    math.conj(math.complex('2 + 3i'))  // returns Complex 2 - 3i
       *    math.conj(math.complex('2 - 3i'))  // returns Complex 2 + 3i
       *    math.conj(math.complex('-5.2i'))  // returns Complex 5.2i
       *
       * See also:
       *
       *    re, im, arg, abs
       *
       * @param {number | BigNumber | Complex | Array | Matrix} x
       *            A complex number or array with complex numbers
       * @return {number | BigNumber | Complex | Array | Matrix}
       *            The complex conjugate of x
       */
      return typed(name$z, {
        number: function number(x) {
          return x;
        },
        BigNumber: function BigNumber(x) {
          return x;
        },
        Complex: function Complex(x) {
          return x.conjugate();
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    var name$y = 'im';
    var dependencies$y = ['typed'];
    var createIm = /* #__PURE__ */factory(name$y, dependencies$y, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Get the imaginary part of a complex number.
       * For a complex number `a + bi`, the function returns `b`.
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.im(x)
       *
       * Examples:
       *
       *    const a = math.complex(2, 3)
       *    math.re(a)                     // returns number 2
       *    math.im(a)                     // returns number 3
       *
       *    math.re(math.complex('-5.2i')) // returns number -5.2
       *    math.re(math.complex(2.4))     // returns number 0
       *
       * See also:
       *
       *    re, conj, abs, arg
       *
       * @param {number | BigNumber | Complex | Array | Matrix} x
       *            A complex number or array with complex numbers
       * @return {number | BigNumber | Array | Matrix} The imaginary part of x
       */
      return typed(name$y, {
        number: function number(x) {
          return 0;
        },
        BigNumber: function BigNumber(x) {
          return x.mul(0);
        },
        Fraction: function Fraction(x) {
          return x.mul(0);
        },
        Complex: function Complex(x) {
          return x.im;
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    var name$x = 're';
    var dependencies$x = ['typed'];
    var createRe = /* #__PURE__ */factory(name$x, dependencies$x, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Get the real part of a complex number.
       * For a complex number `a + bi`, the function returns `a`.
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.re(x)
       *
       * Examples:
       *
       *    const a = math.complex(2, 3)
       *    math.re(a)                     // returns number 2
       *    math.im(a)                     // returns number 3
       *
       *    math.re(math.complex('-5.2i')) // returns number 0
       *    math.re(math.complex(2.4))     // returns number 2.4
       *
       * See also:
       *
       *    im, conj, abs, arg
       *
       * @param {number | BigNumber | Complex | Array | Matrix} x
       *            A complex number or array with complex numbers
       * @return {number | BigNumber | Array | Matrix} The real part of x
       */
      return typed(name$x, {
        number: function number(x) {
          return x;
        },
        BigNumber: function BigNumber(x) {
          return x;
        },
        Fraction: function Fraction(x) {
          return x;
        },
        Complex: function Complex(x) {
          return x.re;
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    var name$w = 'column';
    var dependencies$w = ['typed', 'Index', 'matrix', 'range'];
    var createColumn = /* #__PURE__ */factory(name$w, dependencies$w, _ref => {
      var {
        typed,
        Index,
        matrix,
        range
      } = _ref;

      /**
       * Return a column from a Matrix.
       *
       * Syntax:
       *
       *     math.column(value, index)
       *
       * Example:
       *
       *     // get a column
       *     const d = [[1, 2], [3, 4]]
       *     math.column(d, 1) // returns [[2], [4]]
       *
       * See also:
       *
       *     row
       *
       * @param {Array | Matrix } value   An array or matrix
       * @param {number} column           The index of the column
       * @return {Array | Matrix}         The retrieved column
       */
      return typed(name$w, {
        'Matrix, number': _column,
        'Array, number': function ArrayNumber(value, column) {
          return _column(matrix(clone$1(value)), column).valueOf();
        }
      });
      /**
       * Retrieve a column of a matrix
       * @param {Matrix } value  A matrix
       * @param {number} column  The index of the column
       * @return {Matrix}        The retrieved column
       */

      function _column(value, column) {
        // check dimensions
        if (value.size().length !== 2) {
          throw new Error('Only two dimensional matrix is supported');
        }
        validateIndex(column, value.size()[1]);
        var rowRange = range(0, value.size()[0]);
        var index = new Index(rowRange, column);
        return value.subset(index);
      }
    });

    var name$v = 'cross';
    var dependencies$v = ['typed', 'matrix', 'subtract', 'multiply'];
    var createCross = /* #__PURE__ */factory(name$v, dependencies$v, _ref => {
      var {
        typed,
        matrix,
        subtract,
        multiply
      } = _ref;

      /**
       * Calculate the cross product for two vectors in three dimensional space.
       * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
       * as:
       *
       *    cross(A, B) = [
       *      a2 * b3 - a3 * b2,
       *      a3 * b1 - a1 * b3,
       *      a1 * b2 - a2 * b1
       *    ]
       *
       * If one of the input vectors has a dimension greater than 1, the output
       * vector will be a 1x3 (2-dimensional) matrix.
       *
       * Syntax:
       *
       *    math.cross(x, y)
       *
       * Examples:
       *
       *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]
       *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]
       *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]
       *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]
       *
       * See also:
       *
       *    dot, multiply
       *
       * @param  {Array | Matrix} x   First vector
       * @param  {Array | Matrix} y   Second vector
       * @return {Array | Matrix}     Returns the cross product of `x` and `y`
       */
      return typed(name$v, {
        'Matrix, Matrix': function MatrixMatrix(x, y) {
          return matrix(_cross(x.toArray(), y.toArray()));
        },
        'Matrix, Array': function MatrixArray(x, y) {
          return matrix(_cross(x.toArray(), y));
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          return matrix(_cross(x, y.toArray()));
        },
        'Array, Array': _cross
      });
      /**
       * Calculate the cross product for two arrays
       * @param {Array} x  First vector
       * @param {Array} y  Second vector
       * @returns {Array} Returns the cross product of x and y
       * @private
       */

      function _cross(x, y) {
        var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
        x = squeeze(x);
        y = squeeze(y);
        var xSize = arraySize(x);
        var ySize = arraySize(y);
        if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
          throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
        }
        var product = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];
        if (highestDimension > 1) {
          return [product];
        } else {
          return product;
        }
      }
    });

    var name$u = 'diag';
    var dependencies$u = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];
    var createDiag = /* #__PURE__ */factory(name$u, dependencies$u, _ref => {
      var {
        typed,
        matrix,
        DenseMatrix,
        SparseMatrix
      } = _ref;

      /**
       * Create a diagonal matrix or retrieve the diagonal of a matrix
       *
       * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
       * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
       * When k is positive, the values are placed on the super diagonal.
       * When k is negative, the values are placed on the sub diagonal.
       *
       * Syntax:
       *
       *     math.diag(X)
       *     math.diag(X, format)
       *     math.diag(X, k)
       *     math.diag(X, k, format)
       *
       * Examples:
       *
       *     // create a diagonal matrix
       *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
       *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
       *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
       *
       *    // retrieve the diagonal from a matrix
       *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
       *    math.diag(a)   // returns [1, 5, 9]
       *
       * See also:
       *
       *     ones, zeros, identity
       *
       * @param {Matrix | Array} x          A two dimensional matrix or a vector
       * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
       *                                    in or retrieved.
       * @param {string} [format='dense']   The matrix storage format.
       *
       * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
       */
      return typed(name$u, {
        // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
        Array: function Array(x) {
          return _diag(x, 0, arraySize(x), null);
        },
        'Array, number': function ArrayNumber(x, k) {
          return _diag(x, k, arraySize(x), null);
        },
        'Array, BigNumber': function ArrayBigNumber(x, k) {
          return _diag(x, k.toNumber(), arraySize(x), null);
        },
        'Array, string': function ArrayString(x, format) {
          return _diag(x, 0, arraySize(x), format);
        },
        'Array, number, string': function ArrayNumberString(x, k, format) {
          return _diag(x, k, arraySize(x), format);
        },
        'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {
          return _diag(x, k.toNumber(), arraySize(x), format);
        },
        Matrix: function Matrix(x) {
          return _diag(x, 0, x.size(), x.storage());
        },
        'Matrix, number': function MatrixNumber(x, k) {
          return _diag(x, k, x.size(), x.storage());
        },
        'Matrix, BigNumber': function MatrixBigNumber(x, k) {
          return _diag(x, k.toNumber(), x.size(), x.storage());
        },
        'Matrix, string': function MatrixString(x, format) {
          return _diag(x, 0, x.size(), format);
        },
        'Matrix, number, string': function MatrixNumberString(x, k, format) {
          return _diag(x, k, x.size(), format);
        },
        'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {
          return _diag(x, k.toNumber(), x.size(), format);
        }
      });
      /**
       * Creeate diagonal matrix from a vector or vice versa
       * @param {Array | Matrix} x
       * @param {number} k
       * @param {string} format Storage format for matrix. If null,
       *                          an Array is returned
       * @returns {Array | Matrix}
       * @private
       */

      function _diag(x, k, size, format) {
        if (!isInteger(k)) {
          throw new TypeError('Second parameter in function diag must be an integer');
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0; // check dimensions

        switch (size.length) {
          case 1:
            return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);
          case 2:
            return _getDiagonal(x, k, format, size, kSub, kSuper);
        }
        throw new RangeError('Matrix for function diag must be 2 dimensional');
      }
      function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
        // matrix size
        var ms = [l + kSub, l + kSuper];
        if (format && format !== 'sparse' && format !== 'dense') {
          throw new TypeError("Unknown matrix type ".concat(format, "\""));
        } // create diagonal matrix

        var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix

        return format !== null ? m : m.valueOf();
      }
      function _getDiagonal(x, k, format, s, kSub, kSuper) {
        // check x is a Matrix
        if (isMatrix(x)) {
          // get diagonal matrix
          var dm = x.diagonal(k); // check we need to return a matrix

          if (format !== null) {
            // check we need to change matrix format
            if (format !== dm.storage()) {
              return matrix(dm, format);
            }
            return dm;
          }
          return dm.valueOf();
        } // vector size

        var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values

        var vector = []; // loop diagonal

        for (var i = 0; i < n; i++) {
          vector[i] = x[i + kSub][i + kSuper];
        } // check we need to return a matrix

        return format !== null ? matrix(vector) : vector;
      }
    });

    var name$t = 'flatten';
    var dependencies$t = ['typed', 'matrix'];
    var createFlatten = /* #__PURE__ */factory(name$t, dependencies$t, _ref => {
      var {
        typed,
        matrix
      } = _ref;

      /**
       * Flatten a multi dimensional matrix into a single dimensional matrix.
       * It is guaranteed to always return a clone of the argument.
       *
       * Syntax:
       *
       *    math.flatten(x)
       *
       * Examples:
       *
       *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]
       *
       * See also:
       *
       *    concat, resize, size, squeeze
       *
       * @param {Matrix | Array} x   Matrix to be flattened
       * @return {Matrix | Array} Returns the flattened matrix
       */
      return typed(name$t, {
        Array: function Array(x) {
          return flatten$1(clone$1(x));
        },
        Matrix: function Matrix(x) {
          var flat = flatten$1(clone$1(x.toArray())); // TODO: return the same matrix type as x

          return matrix(flat);
        }
      });
    });

    var name$s = 'identity';
    var dependencies$s = ['typed', 'config', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix'];
    var createIdentity = /* #__PURE__ */factory(name$s, dependencies$s, _ref => {
      var {
        typed,
        config,
        matrix,
        BigNumber,
        DenseMatrix,
        SparseMatrix
      } = _ref;

      /**
       * Create a 2-dimensional identity matrix with size m x n or n x n.
       * The matrix has ones on the diagonal and zeros elsewhere.
       *
       * Syntax:
       *
       *    math.identity(n)
       *    math.identity(n, format)
       *    math.identity(m, n)
       *    math.identity(m, n, format)
       *    math.identity([m, n])
       *    math.identity([m, n], format)
       *
       * Examples:
       *
       *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
       *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]
       *
       *    const A = [[1, 2, 3], [4, 5, 6]]
       *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]
       *
       * See also:
       *
       *    diag, ones, zeros, size, range
       *
       * @param {...number | Matrix | Array} size   The size for the matrix
       * @param {string} [format]                   The Matrix storage format
       *
       * @return {Matrix | Array | number} A matrix with ones on the diagonal.
       */
      return typed(name$s, {
        '': function _() {
          return config.matrix === 'Matrix' ? matrix([]) : [];
        },
        string: function string(format) {
          return matrix(format);
        },
        'number | BigNumber': function numberBigNumber(rows) {
          return _identity(rows, rows, config.matrix === 'Matrix' ? 'dense' : undefined);
        },
        'number | BigNumber, string': function numberBigNumberString(rows, format) {
          return _identity(rows, rows, format);
        },
        'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(rows, cols) {
          return _identity(rows, cols, config.matrix === 'Matrix' ? 'dense' : undefined);
        },
        'number | BigNumber, number | BigNumber, string': function numberBigNumberNumberBigNumberString(rows, cols, format) {
          return _identity(rows, cols, format);
        },
        Array: function Array(size) {
          return _identityVector(size);
        },
        'Array, string': function ArrayString(size, format) {
          return _identityVector(size, format);
        },
        Matrix: function Matrix(size) {
          return _identityVector(size.valueOf(), size.storage());
        },
        'Matrix, string': function MatrixString(size, format) {
          return _identityVector(size.valueOf(), format);
        }
      });
      function _identityVector(size, format) {
        switch (size.length) {
          case 0:
            return format ? matrix(format) : [];
          case 1:
            return _identity(size[0], size[0], format);
          case 2:
            return _identity(size[0], size[1], format);
          default:
            throw new Error('Vector containing two values expected');
        }
      }
      /**
       * Create an identity matrix
       * @param {number | BigNumber} rows
       * @param {number | BigNumber} cols
       * @param {string} [format]
       * @returns {Matrix}
       * @private
       */

      function _identity(rows, cols, format) {
        // BigNumber constructor with the right precision
        var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
        if (isBigNumber(rows)) rows = rows.toNumber();
        if (isBigNumber(cols)) cols = cols.toNumber();
        if (!isInteger(rows) || rows < 1) {
          throw new Error('Parameters in function identity must be positive integers');
        }
        if (!isInteger(cols) || cols < 1) {
          throw new Error('Parameters in function identity must be positive integers');
        }
        var one = Big ? new BigNumber(1) : 1;
        var defaultValue = Big ? new Big(0) : 0;
        var size = [rows, cols]; // check we need to return a matrix

        if (format) {
          // create diagonal matrix (use optimized implementation for storage format)
          if (format === 'sparse') {
            return SparseMatrix.diagonal(size, one, 0, defaultValue);
          }
          if (format === 'dense') {
            return DenseMatrix.diagonal(size, one, 0, defaultValue);
          }
          throw new TypeError("Unknown matrix type \"".concat(format, "\""));
        } // create and resize array

        var res = resize([], size, defaultValue); // fill in ones on the diagonal

        var minimum = rows < cols ? rows : cols; // fill diagonal

        for (var d = 0; d < minimum; d++) {
          res[d][d] = one;
        }
        return res;
      }
    });

    function noBignumber() {
      throw new Error('No "bignumber" implementation available');
    }
    function noFraction() {
      throw new Error('No "fraction" implementation available');
    }
    function noMatrix() {
      throw new Error('No "matrix" implementation available');
    }

    var name$r = 'range';
    var dependencies$r = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq'];
    var createRange = /* #__PURE__ */factory(name$r, dependencies$r, _ref => {
      var {
        typed,
        config,
        matrix,
        bignumber,
        smaller,
        smallerEq,
        larger,
        largerEq
      } = _ref;

      /**
       * Create an array from a range.
       * By default, the range end is excluded. This can be customized by providing
       * an extra parameter `includeEnd`.
       *
       * Syntax:
       *
       *     math.range(str [, includeEnd])               // Create a range from a string,
       *                                                  // where the string contains the
       *                                                  // start, optional step, and end,
       *                                                  // separated by a colon.
       *     math.range(start, end [, includeEnd])        // Create a range with start and
       *                                                  // end and a step size of 1.
       *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
       *                                                  // and end.
       *
       * Where:
       *
       * - `str: string`
       *   A string 'start:end' or 'start:step:end'
       * - `start: {number | BigNumber}`
       *   Start of the range
       * - `end: number | BigNumber`
       *   End of the range, excluded by default, included when parameter includeEnd=true
       * - `step: number | BigNumber`
       *   Step size. Default value is 1.
       * - `includeEnd: boolean`
       *   Option to specify whether to include the end or not. False by default.
       *
       * Examples:
       *
       *     math.range(2, 6)        // [2, 3, 4, 5]
       *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
       *     math.range('2:1:6')     // [2, 3, 4, 5]
       *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
       *
       * See also:
       *
       *     ones, zeros, size, subset
       *
       * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
       * @return {Array | Matrix} range
       */
      return typed(name$r, {
        // TODO: simplify signatures when typed-function supports default values and optional arguments
        // TODO: a number or boolean should not be converted to string here
        string: _strRange,
        'string, boolean': _strRange,
        'number, number': function numberNumber(start, end) {
          return _out(_rangeEx(start, end, 1));
        },
        'number, number, number': function numberNumberNumber(start, end, step) {
          return _out(_rangeEx(start, end, step));
        },
        'number, number, boolean': function numberNumberBoolean(start, end, includeEnd) {
          return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
        },
        'number, number, number, boolean': function numberNumberNumberBoolean(start, end, step, includeEnd) {
          return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(start, end) {
          var BigNumber = start.constructor;
          return _out(_bigRangeEx(start, end, new BigNumber(1)));
        },
        'BigNumber, BigNumber, BigNumber': function BigNumberBigNumberBigNumber(start, end, step) {
          return _out(_bigRangeEx(start, end, step));
        },
        'BigNumber, BigNumber, boolean': function BigNumberBigNumberBoolean(start, end, includeEnd) {
          var BigNumber = start.constructor;
          return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber(1))) : _out(_bigRangeEx(start, end, new BigNumber(1)));
        },
        'BigNumber, BigNumber, BigNumber, boolean': function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
          return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
        }
      });
      function _out(arr) {
        if (config.matrix === 'Matrix') {
          return matrix ? matrix(arr) : noMatrix();
        }
        return arr;
      }
      function _strRange(str, includeEnd) {
        var r = _parse(str);
        if (!r) {
          throw new SyntaxError('String "' + str + '" is no valid range');
        }
        var fn;
        if (config.number === 'BigNumber') {
          if (bignumber === undefined) {
            noBignumber();
          }
          fn = includeEnd ? _bigRangeInc : _bigRangeEx;
          return _out(fn(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
        } else {
          fn = includeEnd ? _rangeInc : _rangeEx;
          return _out(fn(r.start, r.end, r.step));
        }
      }
      /**
       * Create a range with numbers. End is excluded
       * @param {number} start
       * @param {number} end
       * @param {number} step
       * @returns {Array} range
       * @private
       */

      function _rangeEx(start, end, step) {
        var array = [];
        var x = start;
        if (step > 0) {
          while (smaller(x, end)) {
            array.push(x);
            x += step;
          }
        } else if (step < 0) {
          while (larger(x, end)) {
            array.push(x);
            x += step;
          }
        }
        return array;
      }
      /**
       * Create a range with numbers. End is included
       * @param {number} start
       * @param {number} end
       * @param {number} step
       * @returns {Array} range
       * @private
       */

      function _rangeInc(start, end, step) {
        var array = [];
        var x = start;
        if (step > 0) {
          while (smallerEq(x, end)) {
            array.push(x);
            x += step;
          }
        } else if (step < 0) {
          while (largerEq(x, end)) {
            array.push(x);
            x += step;
          }
        }
        return array;
      }
      /**
       * Create a range with big numbers. End is excluded
       * @param {BigNumber} start
       * @param {BigNumber} end
       * @param {BigNumber} step
       * @returns {Array} range
       * @private
       */

      function _bigRangeEx(start, end, step) {
        var zero = bignumber(0);
        var array = [];
        var x = start;
        if (step.gt(zero)) {
          while (smaller(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        } else if (step.lt(zero)) {
          while (larger(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        }
        return array;
      }
      /**
       * Create a range with big numbers. End is included
       * @param {BigNumber} start
       * @param {BigNumber} end
       * @param {BigNumber} step
       * @returns {Array} range
       * @private
       */

      function _bigRangeInc(start, end, step) {
        var zero = bignumber(0);
        var array = [];
        var x = start;
        if (step.gt(zero)) {
          while (smallerEq(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        } else if (step.lt(zero)) {
          while (largerEq(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        }
        return array;
      }
      /**
       * Parse a string into a range,
       * The string contains the start, optional step, and end, separated by a colon.
       * If the string does not contain a valid range, null is returned.
       * For example str='0:2:11'.
       * @param {string} str
       * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
       * @private
       */

      function _parse(str) {
        var args = str.split(':'); // number

        var nums = args.map(function (arg) {
          // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
          return Number(arg);
        });
        var invalid = nums.some(function (num) {
          return isNaN(num);
        });
        if (invalid) {
          return null;
        }
        switch (nums.length) {
          case 2:
            return {
              start: nums[0],
              end: nums[1],
              step: 1
            };
          case 3:
            return {
              start: nums[0],
              end: nums[2],
              step: nums[1]
            };
          default:
            return null;
        }
      }
    });

    var name$q = 'size';
    var dependencies$q = ['typed', 'config', '?matrix'];
    var createSize = /* #__PURE__ */factory(name$q, dependencies$q, _ref => {
      var {
        typed,
        config,
        matrix
      } = _ref;

      /**
       * Calculate the size of a matrix or scalar.
       *
       * Syntax:
       *
       *     math.size(x)
       *
       * Examples:
       *
       *     math.size(2.3)                  // returns []
       *     math.size('hello world')        // returns [11]
       *
       *     const A = [[1, 2, 3], [4, 5, 6]]
       *     math.size(A)                    // returns [2, 3]
       *     math.size(math.range(1,6))      // returns [5]
       *
       * See also:
       *
       *     count, resize, squeeze, subset
       *
       * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
       * @return {Array | Matrix} A vector with size of `x`.
       */
      return typed(name$q, {
        Matrix: function Matrix(x) {
          return x.create(x.size());
        },
        Array: arraySize,
        string: function string(x) {
          return config.matrix === 'Array' ? [x.length] : matrix([x.length]);
        },
        'number | Complex | BigNumber | Unit | boolean | null': function numberComplexBigNumberUnitBooleanNull(x) {
          // scalar
          return config.matrix === 'Array' ? [] : matrix ? matrix([]) : noMatrix();
        }
      });
    });

    var name$p = 'transpose';
    var dependencies$p = ['typed', 'matrix'];
    var createTranspose = /* #__PURE__ */factory(name$p, dependencies$p, _ref => {
      var {
        typed,
        matrix
      } = _ref;

      /**
       * Transpose a matrix. All values of the matrix are reflected over its
       * main diagonal. Only applicable to two dimensional matrices containing
       * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
       * vectors and scalars return the input unchanged.
       *
       * Syntax:
       *
       *     math.transpose(x)
       *
       * Examples:
       *
       *     const A = [[1, 2, 3], [4, 5, 6]]
       *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]
       *
       * See also:
       *
       *     diag, inv, subset, squeeze
       *
       * @param {Array | Matrix} x  Matrix to be transposed
       * @return {Array | Matrix}   The transposed matrix
       */
      return typed('transpose', {
        Array: function Array(x) {
          // use dense matrix implementation
          return this(matrix(x)).valueOf();
        },
        Matrix: function Matrix(x) {
          // matrix size
          var size = x.size(); // result

          var c; // process dimensions

          switch (size.length) {
            case 1:
              // vector
              c = x.clone();
              break;
            case 2:
              {
                // rows and columns
                var rows = size[0];
                var columns = size[1]; // check columns

                if (columns === 0) {
                  // throw exception
                  throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');
                } // process storage format

                switch (x.storage()) {
                  case 'dense':
                    c = _denseTranspose(x, rows, columns);
                    break;
                  case 'sparse':
                    c = _sparseTranspose(x, rows, columns);
                    break;
                }
              }
              break;
            default:
              // multi dimensional
              throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');
          }
          return c;
        },
        // scalars
        any: function any(x) {
          return clone$1(x);
        }
      });
      function _denseTranspose(m, rows, columns) {
        // matrix array
        var data = m._data; // transposed matrix data

        var transposed = [];
        var transposedRow; // loop columns

        for (var j = 0; j < columns; j++) {
          // initialize row
          transposedRow = transposed[j] = []; // loop rows

          for (var i = 0; i < rows; i++) {
            // set data
            transposedRow[i] = clone$1(data[i][j]);
          }
        } // return matrix

        return m.createDenseMatrix({
          data: transposed,
          size: [columns, rows],
          datatype: m._datatype
        });
      }
      function _sparseTranspose(m, rows, columns) {
        // matrix arrays
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr; // result matrices

        var cvalues = values ? [] : undefined;
        var cindex = [];
        var cptr = []; // row counts

        var w = [];
        for (var x = 0; x < rows; x++) {
          w[x] = 0;
        } // vars

        var p, l, j; // loop values in matrix

        for (p = 0, l = index.length; p < l; p++) {
          // number of values in row
          w[index[p]]++;
        } // cumulative sum

        var sum = 0; // initialize cptr with the cummulative sum of row counts

        for (var i = 0; i < rows; i++) {
          // update cptr
          cptr.push(sum); // update sum

          sum += w[i]; // update w

          w[i] = cptr[i];
        } // update cptr

        cptr.push(sum); // loop columns

        for (j = 0; j < columns; j++) {
          // values & index in column
          for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
            // C values & index
            var q = w[index[k]]++; // C[j, i] = A[i, j]

            cindex[q] = j; // check we need to process values (pattern matrix)

            if (values) {
              cvalues[q] = clone$1(values[k]);
            }
          }
        } // return matrix

        return m.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [columns, rows],
          datatype: m._datatype
        });
      }
    });

    var name$o = 'ctranspose';
    var dependencies$o = ['typed', 'transpose', 'conj'];
    var createCtranspose = /* #__PURE__ */factory(name$o, dependencies$o, _ref => {
      var {
        typed,
        transpose,
        conj
      } = _ref;

      /**
       * Transpose and complex conjugate a matrix. All values of the matrix are
       * reflected over its main diagonal and then the complex conjugate is
       * taken. This is equivalent to complex conjugation for scalars and
       * vectors.
       *
       * Syntax:
       *
       *     math.ctranspose(x)
       *
       * Examples:
       *
       *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]
       *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]
       *
       * See also:
       *
       *     transpose, diag, inv, subset, squeeze
       *
       * @param {Array | Matrix} x  Matrix to be ctransposed
       * @return {Array | Matrix}   The ctransposed matrix
       */
      return typed(name$o, {
        any: function any(x) {
          return conj(transpose(x));
        }
      });
    });

    var name$n = 'zeros';
    var dependencies$n = ['typed', 'config', 'matrix', 'BigNumber'];
    var createZeros = /* #__PURE__ */factory(name$n, dependencies$n, _ref => {
      var {
        typed,
        config,
        matrix,
        BigNumber
      } = _ref;

      /**
       * Create a matrix filled with zeros. The created matrix can have one or
       * multiple dimensions.
       *
       * Syntax:
       *
       *    math.zeros(m)
       *    math.zeros(m, format)
       *    math.zeros(m, n)
       *    math.zeros(m, n, format)
       *    math.zeros([m, n])
       *    math.zeros([m, n], format)
       *
       * Examples:
       *
       *    math.zeros(3)                  // returns [0, 0, 0]
       *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
       *    math.zeros(3, 'dense')         // returns [0, 0, 0]
       *
       *    const A = [[1, 2, 3], [4, 5, 6]]
       *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]
       *
       * See also:
       *
       *    ones, identity, size, range
       *
       * @param {...number | Array} size    The size of each dimension of the matrix
       * @param {string} [format]           The Matrix storage format
       *
       * @return {Array | Matrix}           A matrix filled with zeros
       */
      return typed(name$n, {
        '': function _() {
          return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');
        },
        // math.zeros(m, n, p, ..., format)
        // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
        '...number | BigNumber | string': function numberBigNumberString(size) {
          var last = size[size.length - 1];
          if (typeof last === 'string') {
            var format = size.pop();
            return _zeros(size, format);
          } else if (config.matrix === 'Array') {
            return _zeros(size);
          } else {
            return _zeros(size, 'default');
          }
        },
        Array: _zeros,
        Matrix: function Matrix(size) {
          var format = size.storage();
          return _zeros(size.valueOf(), format);
        },
        'Array | Matrix, string': function ArrayMatrixString(size, format) {
          return _zeros(size.valueOf(), format);
        }
      });
      /**
       * Create an Array or Matrix with zeros
       * @param {Array} size
       * @param {string} [format='default']
       * @return {Array | Matrix}
       * @private
       */

      function _zeros(size, format) {
        var hasBigNumbers = _normalize(size);
        var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
        _validate(size);
        if (format) {
          // return a matrix
          var m = matrix(format);
          if (size.length > 0) {
            return m.resize(size, defaultValue);
          }
          return m;
        } else {
          // return an Array
          var arr = [];
          if (size.length > 0) {
            return resize(arr, size, defaultValue);
          }
          return arr;
        }
      } // replace BigNumbers with numbers, returns true if size contained BigNumbers

      function _normalize(size) {
        var hasBigNumbers = false;
        size.forEach(function (value, index, arr) {
          if (isBigNumber(value)) {
            hasBigNumbers = true;
            arr[index] = value.toNumber();
          }
        });
        return hasBigNumbers;
      } // validate arguments

      function _validate(size) {
        size.forEach(function (value) {
          if (typeof value !== 'number' || !isInteger(value) || value < 0) {
            throw new Error('Parameters in function zeros must be positive integers');
          }
        });
      }
    }); // TODO: zeros contains almost the same code as ones. Reuse this?

    var name$m = 'numeric';
    var dependencies$m = ['number', '?bignumber', '?fraction'];
    var createNumeric = /* #__PURE__ */factory(name$m, dependencies$m, _ref => {
      var {
        number: _number,
        bignumber,
        fraction
      } = _ref;
      var validInputTypes = {
        string: true,
        number: true,
        BigNumber: true,
        Fraction: true
      }; // Load the conversion functions for each output type

      var validOutputTypes = {
        number: x => _number(x),
        BigNumber: bignumber ? x => bignumber(x) : noBignumber,
        Fraction: fraction ? x => fraction(x) : noFraction
      };
      /**
       * Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.
       *
       * Syntax:
       *
       *    math.numeric(x)
       *
       * Examples:
       *
       *    math.numeric('4')                           // returns number 4
       *    math.numeric('4', 'number')                 // returns number 4
       *    math.numeric('4', 'BigNumber')              // returns BigNumber 4
       *    math.numeric('4', 'Fraction')               // returns Fraction 4
       *    math.numeric(4, 'Fraction')                 // returns Fraction 4
       *    math.numeric(math.fraction(2, 5), 'number') // returns number 0.4
       *
       * See also:
       *
       *    number, fraction, bignumber, string, format
       *
       * @param {string | number | BigNumber | Fraction } value
       *              A numeric value or a string containing a numeric value
       * @param {string} outputType
       *              Desired numeric output type.
       *              Available values: 'number', 'BigNumber', or 'Fraction'
       * @return {number | BigNumber | Fraction}
       *              Returns an instance of the numeric in the requested type
       */

      return function numeric(value, outputType) {
        var inputType = typeOf(value);
        if (!(inputType in validInputTypes)) {
          throw new TypeError('Cannot convert ' + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(', '));
        }
        if (!(outputType in validOutputTypes)) {
          throw new TypeError('Cannot convert ' + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(', '));
        }
        if (outputType === inputType) {
          return value;
        } else {
          return validOutputTypes[outputType](value);
        }
      };
    });

    var name$l = 'divideScalar';
    var dependencies$l = ['typed', 'numeric'];
    var createDivideScalar = /* #__PURE__ */factory(name$l, dependencies$l, _ref => {
      var {
        typed,
        numeric
      } = _ref;

      /**
       * Divide two scalar values, `x / y`.
       * This function is meant for internal use: it is used by the public functions
       * `divide` and `inv`.
       *
       * This function does not support collections (Array or Matrix).
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
       * @param  {number | BigNumber | Fraction | Complex} y          Denominator
       * @return {number | BigNumber | Fraction | Complex | Unit}     Quotient, `x / y`
       * @private
       */
      return typed(name$l, {
        'number, number': function numberNumber(x, y) {
          return x / y;
        },
        'Complex, Complex': function ComplexComplex(x, y) {
          return x.div(y);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.div(y);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.div(y);
        },
        'Unit, number | Fraction | BigNumber': function UnitNumberFractionBigNumber(x, y) {
          var res = x.clone(); // TODO: move the divide function to Unit.js, it uses internals of Unit

          var one = numeric(1, typeOf(y));
          res.value = this(res.value === null ? res._normalize(one) : res.value, y);
          return res;
        },
        'number | Fraction | BigNumber, Unit': function numberFractionBigNumberUnit(x, y) {
          var res = y.clone();
          res = res.pow(-1); // TODO: move the divide function to Unit.js, it uses internals of Unit

          var one = numeric(1, typeOf(x));
          res.value = this(x, y.value === null ? y._normalize(one) : y.value);
          return res;
        },
        'Unit, Unit': function UnitUnit(x, y) {
          return x.divide(y);
        }
      });
    });

    var name$k = 'pow';
    var dependencies$k = ['typed', 'config', 'identity', 'multiply', 'matrix', 'inv', 'fraction', 'number', 'Complex'];
    var createPow = /* #__PURE__ */factory(name$k, dependencies$k, _ref => {
      var {
        typed,
        config,
        identity,
        multiply,
        matrix,
        inv,
        number,
        fraction,
        Complex
      } = _ref;

      /**
       * Calculates the power of x to y, `x ^ y`.
       *
       * Matrix exponentiation is supported for square matrices `x` and integers `y`:
       * when `y` is nonnegative, `x` may be any square matrix; and when `y` is
       * negative, `x` must be invertible, and then this function returns
       * inv(x)^(-y).
       *
       * For cubic roots of negative numbers, the function returns the principal
       * root by default. In order to let the function return the real root,
       * math.js can be configured with `math.config({predictable: true})`.
       * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
       *
       * Syntax:
       *
       *    math.pow(x, y)
       *
       * Examples:
       *
       *    math.pow(2, 3)               // returns number 8
       *
       *    const a = math.complex(2, 3)
       *    math.pow(a, 2)                // returns Complex -5 + 12i
       *
       *    const b = [[1, 2], [4, 3]]
       *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
       *
       *    const c = [[1, 2], [4, 3]]
       *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]
       *
       * See also:
       *
       *    multiply, sqrt, cbrt, nthRoot
       *
       * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
       * @param  {number | BigNumber | Complex} y                          The exponent
       * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
       */
      return typed(name$k, {
        'number, number': _pow,
        'Complex, Complex': function ComplexComplex(x, y) {
          return x.pow(y);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          if (y.isInteger() || x >= 0 || config.predictable) {
            return x.pow(y);
          } else {
            return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
          }
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          var result = x.pow(y);
          if (result != null) {
            return result;
          }
          if (config.predictable) {
            throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');
          } else {
            return _pow(x.valueOf(), y.valueOf());
          }
        },
        'Array, number': _powArray,
        'Array, BigNumber': function ArrayBigNumber(x, y) {
          return _powArray(x, y.toNumber());
        },
        'Matrix, number': _powMatrix,
        'Matrix, BigNumber': function MatrixBigNumber(x, y) {
          return _powMatrix(x, y.toNumber());
        },
        'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {
          return x.pow(y);
        }
      });
      /**
       * Calculates the power of x to y, x^y, for two numbers.
       * @param {number} x
       * @param {number} y
       * @return {number | Complex} res
       * @private
       */

      function _pow(x, y) {
        // Alternatively could define a 'realmode' config option or something, but
        // 'predictable' will work for now
        if (config.predictable && !isInteger(y) && x < 0) {
          // Check to see if y can be represented as a fraction
          try {
            var yFrac = fraction(y);
            var yNum = number(yFrac);
            if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
              if (yFrac.d % 2 === 1) {
                return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
              }
            }
          } catch (ex) {// fraction() throws an error if y is Infinity, etc.
          } // Unable to express y as a fraction, so continue on
        } // **for predictable mode** x^Infinity === NaN if x < -1
        // N.B. this behavour is different from `Math.pow` which gives
        // (-2)^Infinity === Infinity

        if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
          return NaN;
        }
        if (isInteger(y) || x >= 0 || config.predictable) {
          return powNumber(x, y);
        } else {
          // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow
          // x^Infinity === 0 if -1 < x < 1
          // A real number 0 is returned instead of complex(0)
          if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
            return 0;
          }
          return new Complex(x, 0).pow(y, 0);
        }
      }
      /**
       * Calculate the power of a 2d array
       * @param {Array} x     must be a 2 dimensional, square matrix
       * @param {number} y    a integer value (positive if `x` is not invertible)
       * @returns {Array}
       * @private
       */

      function _powArray(x, y) {
        if (!isInteger(y)) {
          throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');
        } // verify that A is a 2 dimensional square matrix

        var s = arraySize(x);
        if (s.length !== 2) {
          throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
        }
        if (s[0] !== s[1]) {
          throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
        }
        if (y < 0) {
          try {
            return _powArray(inv(x), -y);
          } catch (error) {
            if (error.message === 'Cannot calculate inverse, determinant is zero') {
              throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');
            }
            throw error;
          }
        }
        var res = identity(s[0]).valueOf();
        var px = x;
        while (y >= 1) {
          if ((y & 1) === 1) {
            res = multiply(px, res);
          }
          y >>= 1;
          px = multiply(px, px);
        }
        return res;
      }
      /**
       * Calculate the power of a 2d matrix
       * @param {Matrix} x     must be a 2 dimensional, square matrix
       * @param {number} y    a positive, integer value
       * @returns {Matrix}
       * @private
       */

      function _powMatrix(x, y) {
        return matrix(_powArray(x.valueOf(), y));
      }
    });

    function createSolveValidation(_ref) {
      var {
        DenseMatrix
      } = _ref;

      /**
       * Validates matrix and column vector b for backward/forward substitution algorithms.
       *
       * @param {Matrix} m            An N x N matrix
       * @param {Array | Matrix} b    A column vector
       * @param {Boolean} copy        Return a copy of vector b
       *
       * @return {DenseMatrix}        Dense column vector b
       */
      return function solveValidation(m, b, copy) {
        var mSize = m.size();
        if (mSize.length !== 2) {
          throw new RangeError('Matrix must be two dimensional (size: ' + format(mSize) + ')');
        }
        var rows = mSize[0];
        var columns = mSize[1];
        if (rows !== columns) {
          throw new RangeError('Matrix must be square (size: ' + format(mSize) + ')');
        }
        var data = [];
        if (isMatrix(b)) {
          var bSize = b.size();
          var bdata = b._data; // 1-dim vector

          if (bSize.length === 1) {
            if (bSize[0] !== rows) {
              throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
            }
            for (var i = 0; i < rows; i++) {
              data[i] = [bdata[i]];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          } // 2-dim column

          if (bSize.length === 2) {
            if (bSize[0] !== rows || bSize[1] !== 1) {
              throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
            }
            if (isDenseMatrix(b)) {
              if (copy) {
                data = [];
                for (var _i = 0; _i < rows; _i++) {
                  data[_i] = [bdata[_i][0]];
                }
                return new DenseMatrix({
                  data,
                  size: [rows, 1],
                  datatype: b._datatype
                });
              }
              return b;
            }
            if (isSparseMatrix(b)) {
              for (var _i2 = 0; _i2 < rows; _i2++) {
                data[_i2] = [0];
              }
              var values = b._values;
              var index = b._index;
              var ptr = b._ptr;
              for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
                var _i3 = index[k];
                data[_i3][0] = values[k];
              }
              return new DenseMatrix({
                data,
                size: [rows, 1],
                datatype: b._datatype
              });
            }
          }
          throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
        }
        if (isArray(b)) {
          var bsize = arraySize(b);
          if (bsize.length === 1) {
            if (bsize[0] !== rows) {
              throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
            }
            for (var _i4 = 0; _i4 < rows; _i4++) {
              data[_i4] = [b[_i4]];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1]
            });
          }
          if (bsize.length === 2) {
            if (bsize[0] !== rows || bsize[1] !== 1) {
              throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
            }
            for (var _i5 = 0; _i5 < rows; _i5++) {
              data[_i5] = [b[_i5][0]];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1]
            });
          }
          throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
        }
      };
    }

    var name$j = 'usolve';
    var dependencies$j = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
    var createUsolve = /* #__PURE__ */factory(name$j, dependencies$j, _ref => {
      var {
        typed,
        matrix,
        divideScalar,
        multiplyScalar,
        subtract,
        equalScalar,
        DenseMatrix
      } = _ref;
      var solveValidation = createSolveValidation({
        DenseMatrix
      });
      /**
       * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.
       *
       * `U * x = b`
       *
       * Syntax:
       *
       *    math.usolve(U, b)
       *
       * Examples:
       *
       *    const a = [[-2, 3], [2, 1]]
       *    const b = [11, 9]
       *    const x = usolve(a, b)  // [[8], [9]]
       *
       * See also:
       *
       *    usolveAll, lup, slu, usolve, lusolve
       *
       * @param {Matrix, Array} U       A N x N matrix or array (U)
       * @param {Matrix, Array} b       A column vector with the b values
       *
       * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
       */

      return typed(name$j, {
        'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
          return _sparseBackwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
          return _denseBackwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
          var m = matrix(a);
          var r = _denseBackwardSubstitution(m, b);
          return r.valueOf();
        }
      });
      function _denseBackwardSubstitution(m, b) {
        // make b into a column vector
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1]; // result

        var x = [];
        var mdata = m._data; // loop columns backwards

        for (var j = columns - 1; j >= 0; j--) {
          // b[j]
          var bj = bdata[j][0] || 0; // x[j]

          var xj = void 0;
          if (!equalScalar(bj, 0)) {
            // value at [j, j]
            var vjj = mdata[j][j];
            if (equalScalar(vjj, 0)) {
              // system cannot be solved
              throw new Error('Linear system cannot be solved since matrix is singular');
            }
            xj = divideScalar(bj, vjj); // loop rows

            for (var i = j - 1; i >= 0; i--) {
              // update copy of b
              bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
            }
          } else {
            // zero value at j
            xj = 0;
          } // update x

          x[j] = [xj];
        }
        return new DenseMatrix({
          data: x,
          size: [rows, 1]
        });
      }
      function _sparseBackwardSubstitution(m, b) {
        // make b into a column vector
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr; // result

        var x = []; // loop columns backwards

        for (var j = columns - 1; j >= 0; j--) {
          var bj = bdata[j][0] || 0;
          if (!equalScalar(bj, 0)) {
            // non-degenerate row, find solution
            var vjj = 0; // upper triangular matrix values & index (column j)

            var jValues = [];
            var jIndices = []; // first & last indeces in column

            var firstIndex = ptr[j];
            var lastIndex = ptr[j + 1]; // values in column, find value at [j, j], loop backwards

            for (var k = lastIndex - 1; k >= firstIndex; k--) {
              var i = index[k]; // check row (rows are not sorted!)

              if (i === j) {
                vjj = values[k];
              } else if (i < j) {
                // store upper triangular
                jValues.push(values[k]);
                jIndices.push(i);
              }
            } // at this point we must have a value in vjj

            if (equalScalar(vjj, 0)) {
              throw new Error('Linear system cannot be solved since matrix is singular');
            }
            var xj = divideScalar(bj, vjj);
            for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
              var _i = jIndices[_k];
              bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
            }
            x[j] = [xj];
          } else {
            // degenerate row, we can choose any value
            x[j] = [0];
          }
        }
        return new DenseMatrix({
          data: x,
          size: [rows, 1]
        });
      }
    });

    var name$i = 'usolveAll';
    var dependencies$i = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
    var createUsolveAll = /* #__PURE__ */factory(name$i, dependencies$i, _ref => {
      var {
        typed,
        matrix,
        divideScalar,
        multiplyScalar,
        subtract,
        equalScalar,
        DenseMatrix
      } = _ref;
      var solveValidation = createSolveValidation({
        DenseMatrix
      });
      /**
       * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.
       *
       * `U * x = b`
       *
       * Syntax:
       *
       *    math.usolveAll(U, b)
       *
       * Examples:
       *
       *    const a = [[-2, 3], [2, 1]]
       *    const b = [11, 9]
       *    const x = usolveAll(a, b)  // [ [[8], [9]] ]
       *
       * See also:
       *
       *    usolve, lup, slu, usolve, lusolve
       *
       * @param {Matrix, Array} U       A N x N matrix or array (U)
       * @param {Matrix, Array} b       A column vector with the b values
       *
       * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
       */

      return typed(name$i, {
        'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
          return _sparseBackwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
          return _denseBackwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
          var m = matrix(a);
          var R = _denseBackwardSubstitution(m, b);
          return R.map(r => r.valueOf());
        }
      });
      function _denseBackwardSubstitution(m, b_) {
        // the algorithm is derived from
        // https://www.overleaf.com/read/csvgqdxggyjv
        // array of right-hand sides
        var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
        var M = m._data;
        var rows = m._size[0];
        var columns = m._size[1]; // loop columns backwards

        for (var i = columns - 1; i >= 0; i--) {
          var L = B.length; // loop right-hand sides

          for (var k = 0; k < L; k++) {
            var b = B[k];
            if (!equalScalar(M[i][i], 0)) {
              // non-singular row
              b[i] = divideScalar(b[i], M[i][i]);
              for (var j = i - 1; j >= 0; j--) {
                // b[j] -= b[i] * M[j,i]
                b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
              }
            } else if (!equalScalar(b[i], 0)) {
              // singular row, nonzero RHS
              if (k === 0) {
                // There is no valid solution
                return [];
              } else {
                // This RHS is invalid but other solutions may still exist
                B.splice(k, 1);
                k -= 1;
                L -= 1;
              }
            } else if (k === 0) {
              // singular row, RHS is zero
              var bNew = [...b];
              bNew[i] = 1;
              for (var _j = i - 1; _j >= 0; _j--) {
                bNew[_j] = subtract(bNew[_j], M[_j][i]);
              }
              B.push(bNew);
            }
          }
        }
        return B.map(x => new DenseMatrix({
          data: x.map(e => [e]),
          size: [rows, 1]
        }));
      }
      function _sparseBackwardSubstitution(m, b_) {
        // array of right-hand sides
        var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr; // loop columns backwards

        for (var i = columns - 1; i >= 0; i--) {
          var L = B.length; // loop right-hand sides

          for (var k = 0; k < L; k++) {
            var b = B[k]; // values & indices (column i)

            var iValues = [];
            var iIndices = []; // first & last indeces in column

            var firstIndex = ptr[i];
            var lastIndex = ptr[i + 1]; // find the value at [i, i]

            var Mii = 0;
            for (var j = lastIndex - 1; j >= firstIndex; j--) {
              var J = index[j]; // check row

              if (J === i) {
                Mii = values[j];
              } else if (J < i) {
                // store upper triangular
                iValues.push(values[j]);
                iIndices.push(J);
              }
            }
            if (!equalScalar(Mii, 0)) {
              // non-singular row
              b[i] = divideScalar(b[i], Mii); // loop upper triangular

              for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
                var _J = iIndices[_j2];
                b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
              }
            } else if (!equalScalar(b[i], 0)) {
              // singular row, nonzero RHS
              if (k === 0) {
                // There is no valid solution
                return [];
              } else {
                // This RHS is invalid but other solutions may still exist
                B.splice(k, 1);
                k -= 1;
                L -= 1;
              }
            } else if (k === 0) {
              // singular row, RHS is zero
              var bNew = [...b];
              bNew[i] = 1; // loop upper triangular

              for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
                var _J2 = iIndices[_j3];
                bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
              }
              B.push(bNew);
            }
          }
        }
        return B.map(x => new DenseMatrix({
          data: x.map(e => [e]),
          size: [rows, 1]
        }));
      }
    });

    var name$h = 'equal';
    var dependencies$h = ['typed', 'matrix', 'equalScalar', 'DenseMatrix'];
    var createEqual = /* #__PURE__ */factory(name$h, dependencies$h, _ref => {
      var {
        typed,
        matrix,
        equalScalar,
        DenseMatrix
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed
      });
      var algorithm07 = createAlgorithm07({
        typed,
        DenseMatrix
      });
      var algorithm12 = createAlgorithm12({
        typed,
        DenseMatrix
      });
      var algorithm13 = createAlgorithm13({
        typed
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Test whether two values are equal.
       *
       * The function tests whether the relative difference between x and y is
       * smaller than the configured epsilon. The function cannot be used to
       * compare values smaller than approximately 2.22e-16.
       *
       * For matrices, the function is evaluated element wise.
       * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
       *
       * Values `null` and `undefined` are compared strictly, thus `null` is only
       * equal to `null` and nothing else, and `undefined` is only equal to
       * `undefined` and nothing else. Strings are compared by their numerical value.
       *
       * Syntax:
       *
       *    math.equal(x, y)
       *
       * Examples:
       *
       *    math.equal(2 + 2, 3)         // returns false
       *    math.equal(2 + 2, 4)         // returns true
       *
       *    const a = math.unit('50 cm')
       *    const b = math.unit('5 m')
       *    math.equal(a, b)             // returns true
       *
       *    const c = [2, 5, 1]
       *    const d = [2, 7, 1]
       *
       *    math.equal(c, d)             // returns [true, false, true]
       *    math.deepEqual(c, d)         // returns false
       *
       *    math.equal("1000", "1e3")    // returns true
       *    math.equal(0, null)          // returns false
       *
       * See also:
       *
       *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
       *
       * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
       * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
       * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
       */

      return typed(name$h, {
        'any, any': function anyAny(x, y) {
          // strict equality for null and undefined?
          if (x === null) {
            return y === null;
          }
          if (y === null) {
            return x === null;
          }
          if (x === undefined) {
            return y === undefined;
          }
          if (y === undefined) {
            return x === undefined;
          }
          return equalScalar(x, y);
        },
        'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, equalScalar);
        },
        'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, equalScalar, true);
        },
        'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, equalScalar, false);
        },
        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, equalScalar);
        },
        'Array, Array': function ArrayArray(x, y) {
          // use matrix implementation
          return this(matrix(x), matrix(y)).valueOf();
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use matrix implementation
          return this(matrix(x), y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use matrix implementation
          return this(x, matrix(y));
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm12(x, y, equalScalar, false);
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, equalScalar, false);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm12(y, x, equalScalar, true);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, equalScalar, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, equalScalar, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, equalScalar, true).valueOf();
        }
      });
    });
    factory(name$h, ['typed', 'equalScalar'], _ref2 => {
      var {
        typed,
        equalScalar
      } = _ref2;
      return typed(name$h, {
        'any, any': function anyAny(x, y) {
          // strict equality for null and undefined?
          if (x === null) {
            return y === null;
          }
          if (y === null) {
            return x === null;
          }
          if (x === undefined) {
            return y === undefined;
          }
          if (y === undefined) {
            return x === undefined;
          }
          return equalScalar(x, y);
        }
      });
    });

    var name$g = 'smaller';
    var dependencies$g = ['typed', 'config', 'matrix', 'DenseMatrix'];
    var createSmaller = /* #__PURE__ */factory(name$g, dependencies$g, _ref => {
      var {
        typed,
        config,
        matrix,
        DenseMatrix
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed
      });
      var algorithm07 = createAlgorithm07({
        typed,
        DenseMatrix
      });
      var algorithm12 = createAlgorithm12({
        typed,
        DenseMatrix
      });
      var algorithm13 = createAlgorithm13({
        typed
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Test whether value x is smaller than y.
       *
       * The function returns true when x is smaller than y and the relative
       * difference between x and y is smaller than the configured epsilon. The
       * function cannot be used to compare values smaller than approximately 2.22e-16.
       *
       * For matrices, the function is evaluated element wise.
       * Strings are compared by their numerical value.
       *
       * Syntax:
       *
       *    math.smaller(x, y)
       *
       * Examples:
       *
       *    math.smaller(2, 3)            // returns true
       *    math.smaller(5, 2 * 2)        // returns false
       *
       *    const a = math.unit('5 cm')
       *    const b = math.unit('2 inch')
       *    math.smaller(a, b)            // returns true
       *
       * See also:
       *
       *    equal, unequal, smallerEq, smaller, smallerEq, compare
       *
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
       * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
       */

      return typed(name$g, {
        'boolean, boolean': function booleanBoolean(x, y) {
          return x < y;
        },
        'number, number': function numberNumber(x, y) {
          return x < y && !nearlyEqual$1(x, y, config.epsilon);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.lt(y) && !nearlyEqual(x, y, config.epsilon);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.compare(y) === -1;
        },
        'Complex, Complex': function ComplexComplex(x, y) {
          throw new TypeError('No ordering relation is defined for complex numbers');
        },
        'Unit, Unit': function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error('Cannot compare units with different base');
          }
          return this(x.value, y.value);
        },
        'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        'Array, Array': function ArrayArray(x, y) {
          // use matrix implementation
          return this(matrix(x), matrix(y)).valueOf();
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use matrix implementation
          return this(matrix(x), y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use matrix implementation
          return this(x, matrix(y));
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, this, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, this, true).valueOf();
        }
      });
    });

    var name$f = 'smallerEq';
    var dependencies$f = ['typed', 'config', 'matrix', 'DenseMatrix'];
    var createSmallerEq = /* #__PURE__ */factory(name$f, dependencies$f, _ref => {
      var {
        typed,
        config,
        matrix,
        DenseMatrix
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed
      });
      var algorithm07 = createAlgorithm07({
        typed,
        DenseMatrix
      });
      var algorithm12 = createAlgorithm12({
        typed,
        DenseMatrix
      });
      var algorithm13 = createAlgorithm13({
        typed
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Test whether value x is smaller or equal to y.
       *
       * The function returns true when x is smaller than y or the relative
       * difference between x and y is smaller than the configured epsilon. The
       * function cannot be used to compare values smaller than approximately 2.22e-16.
       *
       * For matrices, the function is evaluated element wise.
       * Strings are compared by their numerical value.
       *
       * Syntax:
       *
       *    math.smallerEq(x, y)
       *
       * Examples:
       *
       *    math.smaller(1 + 2, 3)        // returns false
       *    math.smallerEq(1 + 2, 3)      // returns true
       *
       * See also:
       *
       *    equal, unequal, smaller, larger, largerEq, compare
       *
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
       * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
       */

      return typed(name$f, {
        'boolean, boolean': function booleanBoolean(x, y) {
          return x <= y;
        },
        'number, number': function numberNumber(x, y) {
          return x <= y || nearlyEqual$1(x, y, config.epsilon);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.lte(y) || nearlyEqual(x, y, config.epsilon);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.compare(y) !== 1;
        },
        'Complex, Complex': function ComplexComplex() {
          throw new TypeError('No ordering relation is defined for complex numbers');
        },
        'Unit, Unit': function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error('Cannot compare units with different base');
          }
          return this(x.value, y.value);
        },
        'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        'Array, Array': function ArrayArray(x, y) {
          // use matrix implementation
          return this(matrix(x), matrix(y)).valueOf();
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use matrix implementation
          return this(matrix(x), y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use matrix implementation
          return this(x, matrix(y));
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, this, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, this, true).valueOf();
        }
      });
    });

    var name$e = 'larger';
    var dependencies$e = ['typed', 'config', 'matrix', 'DenseMatrix'];
    var createLarger = /* #__PURE__ */factory(name$e, dependencies$e, _ref => {
      var {
        typed,
        config,
        matrix,
        DenseMatrix
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed
      });
      var algorithm07 = createAlgorithm07({
        typed,
        DenseMatrix
      });
      var algorithm12 = createAlgorithm12({
        typed,
        DenseMatrix
      });
      var algorithm13 = createAlgorithm13({
        typed
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Test whether value x is larger than y.
       *
       * The function returns true when x is larger than y and the relative
       * difference between x and y is larger than the configured epsilon. The
       * function cannot be used to compare values smaller than approximately 2.22e-16.
       *
       * For matrices, the function is evaluated element wise.
       * Strings are compared by their numerical value.
       *
       * Syntax:
       *
       *    math.larger(x, y)
       *
       * Examples:
       *
       *    math.larger(2, 3)             // returns false
       *    math.larger(5, 2 + 2)         // returns true
       *
       *    const a = math.unit('5 cm')
       *    const b = math.unit('2 inch')
       *    math.larger(a, b)             // returns false
       *
       * See also:
       *
       *    equal, unequal, smaller, smallerEq, largerEq, compare
       *
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
       * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
       */

      return typed(name$e, {
        'boolean, boolean': function booleanBoolean(x, y) {
          return x > y;
        },
        'number, number': function numberNumber(x, y) {
          return x > y && !nearlyEqual$1(x, y, config.epsilon);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.gt(y) && !nearlyEqual(x, y, config.epsilon);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.compare(y) === 1;
        },
        'Complex, Complex': function ComplexComplex() {
          throw new TypeError('No ordering relation is defined for complex numbers');
        },
        'Unit, Unit': function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error('Cannot compare units with different base');
          }
          return this(x.value, y.value);
        },
        'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        'Array, Array': function ArrayArray(x, y) {
          // use matrix implementation
          return this(matrix(x), matrix(y)).valueOf();
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use matrix implementation
          return this(matrix(x), y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use matrix implementation
          return this(x, matrix(y));
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, this, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, this, true).valueOf();
        }
      });
    });

    var name$d = 'largerEq';
    var dependencies$d = ['typed', 'config', 'matrix', 'DenseMatrix'];
    var createLargerEq = /* #__PURE__ */factory(name$d, dependencies$d, _ref => {
      var {
        typed,
        config,
        matrix,
        DenseMatrix
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed
      });
      var algorithm07 = createAlgorithm07({
        typed,
        DenseMatrix
      });
      var algorithm12 = createAlgorithm12({
        typed,
        DenseMatrix
      });
      var algorithm13 = createAlgorithm13({
        typed
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Test whether value x is larger or equal to y.
       *
       * The function returns true when x is larger than y or the relative
       * difference between x and y is smaller than the configured epsilon. The
       * function cannot be used to compare values smaller than approximately 2.22e-16.
       *
       * For matrices, the function is evaluated element wise.
       * Strings are compared by their numerical value.
       *
       * Syntax:
       *
       *    math.largerEq(x, y)
       *
       * Examples:
       *
       *    math.larger(2, 1 + 1)         // returns false
       *    math.largerEq(2, 1 + 1)       // returns true
       *
       * See also:
       *
       *    equal, unequal, smaller, smallerEq, larger, compare
       *
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
       * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
       * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
       */

      return typed(name$d, {
        'boolean, boolean': function booleanBoolean(x, y) {
          return x >= y;
        },
        'number, number': function numberNumber(x, y) {
          return x >= y || nearlyEqual$1(x, y, config.epsilon);
        },
        'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
          return x.gte(y) || nearlyEqual(x, y, config.epsilon);
        },
        'Fraction, Fraction': function FractionFraction(x, y) {
          return x.compare(y) !== -1;
        },
        'Complex, Complex': function ComplexComplex() {
          throw new TypeError('No ordering relation is defined for complex numbers');
        },
        'Unit, Unit': function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error('Cannot compare units with different base');
          }
          return this(x.value, y.value);
        },
        'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        'Array, Array': function ArrayArray(x, y) {
          // use matrix implementation
          return this(matrix(x), matrix(y)).valueOf();
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use matrix implementation
          return this(matrix(x), y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use matrix implementation
          return this(x, matrix(y));
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, this, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, this, true).valueOf();
        }
      });
    });

    var name$c = 'ImmutableDenseMatrix';
    var dependencies$c = ['smaller', 'DenseMatrix'];
    var createImmutableDenseMatrixClass = /* #__PURE__ */factory(name$c, dependencies$c, _ref => {
      var {
        smaller,
        DenseMatrix
      } = _ref;
      function ImmutableDenseMatrix(data, datatype) {
        if (!(this instanceof ImmutableDenseMatrix)) {
          throw new SyntaxError('Constructor must be called with the new operator');
        }
        if (datatype && !isString(datatype)) {
          throw new Error('Invalid datatype: ' + datatype);
        }
        if (isMatrix(data) || isArray(data)) {
          // use DenseMatrix implementation
          var matrix = new DenseMatrix(data, datatype); // internal structures

          this._data = matrix._data;
          this._size = matrix._size;
          this._datatype = matrix._datatype;
          this._min = null;
          this._max = null;
        } else if (data && isArray(data.data) && isArray(data.size)) {
          // initialize fields from JSON representation
          this._data = data.data;
          this._size = data.size;
          this._datatype = data.datatype;
          this._min = typeof data.min !== 'undefined' ? data.min : null;
          this._max = typeof data.max !== 'undefined' ? data.max : null;
        } else if (data) {
          // unsupported type
          throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
        } else {
          // nothing provided
          this._data = [];
          this._size = [0];
          this._datatype = datatype;
          this._min = null;
          this._max = null;
        }
      }
      ImmutableDenseMatrix.prototype = new DenseMatrix();
      /**
       * Attach type information
       */

      ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
      ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
      /**
       * Get a subset of the matrix, or replace a subset of the matrix.
       *
       * Usage:
       *     const subset = matrix.subset(index)               // retrieve subset
       *     const value = matrix.subset(index, replacement)   // replace subset
       *
       * @param {Index} index
       * @param {Array | ImmutableDenseMatrix | *} [replacement]
       * @param {*} [defaultValue=0]      Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be filled with zeros.
       */

      ImmutableDenseMatrix.prototype.subset = function (index) {
        switch (arguments.length) {
          case 1:
            {
              // use base implementation
              var m = DenseMatrix.prototype.subset.call(this, index); // check result is a matrix

              if (isMatrix(m)) {
                // return immutable matrix
                return new ImmutableDenseMatrix({
                  data: m._data,
                  size: m._size,
                  datatype: m._datatype
                });
              }
              return m;
            }
          // intentional fall through

          case 2:
          case 3:
            throw new Error('Cannot invoke set subset on an Immutable Matrix instance');
          default:
            throw new SyntaxError('Wrong number of arguments');
        }
      };
      /**
       * Replace a single element in the matrix.
       * @param {Number[]} index   Zero-based index
       * @param {*} value
       * @param {*} [defaultValue]        Default value, filled in on new entries when
       *                                  the matrix is resized. If not provided,
       *                                  new matrix elements will be left undefined.
       * @return {ImmutableDenseMatrix} self
       */

      ImmutableDenseMatrix.prototype.set = function () {
        throw new Error('Cannot invoke set on an Immutable Matrix instance');
      };
      /**
       * Resize the matrix to the given size. Returns a copy of the matrix when
       * `copy=true`, otherwise return the matrix itself (resize in place).
       *
       * @param {Number[]} size           The new size the matrix should have.
       * @param {*} [defaultValue=0]      Default value, filled in on new entries.
       *                                  If not provided, the matrix elements will
       *                                  be filled with zeros.
       * @param {boolean} [copy]          Return a resized copy of the matrix
       *
       * @return {Matrix}                 The resized matrix
       */

      ImmutableDenseMatrix.prototype.resize = function () {
        throw new Error('Cannot invoke resize on an Immutable Matrix instance');
      };
      /**
       * Disallows reshaping in favor of immutability.
       *
       * @throws {Error} Operation not allowed
       */

      ImmutableDenseMatrix.prototype.reshape = function () {
        throw new Error('Cannot invoke reshape on an Immutable Matrix instance');
      };
      /**
       * Create a clone of the matrix
       * @return {ImmutableDenseMatrix} clone
       */

      ImmutableDenseMatrix.prototype.clone = function () {
        return new ImmutableDenseMatrix({
          data: clone$1(this._data),
          size: clone$1(this._size),
          datatype: this._datatype
        });
      };
      /**
       * Get a JSON representation of the matrix
       * @returns {Object}
       */

      ImmutableDenseMatrix.prototype.toJSON = function () {
        return {
          mathjs: 'ImmutableDenseMatrix',
          data: this._data,
          size: this._size,
          datatype: this._datatype
        };
      };
      /**
       * Generate a matrix from a JSON object
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
       *                       where mathjs is optional
       * @returns {ImmutableDenseMatrix}
       */

      ImmutableDenseMatrix.fromJSON = function (json) {
        return new ImmutableDenseMatrix(json);
      };
      /**
       * Swap rows i and j in Matrix.
       *
       * @param {Number} i       Matrix row index 1
       * @param {Number} j       Matrix row index 2
       *
       * @return {Matrix}        The matrix reference
       */

      ImmutableDenseMatrix.prototype.swapRows = function () {
        throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
      };
      /**
       * Calculate the minimum value in the set
       * @return {Number | undefined} min
       */

      ImmutableDenseMatrix.prototype.min = function () {
        // check min has been calculated before
        if (this._min === null) {
          // minimum
          var m = null; // compute min

          this.forEach(function (v) {
            if (m === null || smaller(v, m)) {
              m = v;
            }
          });
          this._min = m !== null ? m : undefined;
        }
        return this._min;
      };
      /**
       * Calculate the maximum value in the set
       * @return {Number | undefined} max
       */

      ImmutableDenseMatrix.prototype.max = function () {
        // check max has been calculated before
        if (this._max === null) {
          // maximum
          var m = null; // compute max

          this.forEach(function (v) {
            if (m === null || smaller(m, v)) {
              m = v;
            }
          });
          this._max = m !== null ? m : undefined;
        }
        return this._max;
      };
      return ImmutableDenseMatrix;
    }, {
      isClass: true
    });

    var name$b = 'Index';
    var dependencies$b = ['ImmutableDenseMatrix'];
    var createIndexClass = /* #__PURE__ */factory(name$b, dependencies$b, _ref => {
      var {
        ImmutableDenseMatrix
      } = _ref;

      /**
       * Create an index. An Index can store ranges and sets for multiple dimensions.
       * Matrix.get, Matrix.set, and math.subset accept an Index as input.
       *
       * Usage:
       *     const index = new Index(range1, range2, matrix1, array1, ...)
       *
       * Where each parameter can be any of:
       *     A number
       *     A string (containing a name of an object property)
       *     An instance of Range
       *     An Array with the Set values
       *     A Matrix with the Set values
       *
       * The parameters start, end, and step must be integer numbers.
       *
       * @class Index
       * @Constructor Index
       * @param {...*} ranges
       */
      function Index(ranges) {
        if (!(this instanceof Index)) {
          throw new SyntaxError('Constructor must be called with the new operator');
        }
        this._dimensions = [];
        this._isScalar = true;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
          var arg = arguments[i];
          if (isRange(arg)) {
            this._dimensions.push(arg);
            this._isScalar = false;
          } else if (Array.isArray(arg) || isMatrix(arg)) {
            // create matrix
            var m = _createImmutableMatrix(arg.valueOf());
            this._dimensions.push(m); // size

            var size = m.size(); // scalar

            if (size.length !== 1 || size[0] !== 1) {
              this._isScalar = false;
            }
          } else if (typeof arg === 'number') {
            this._dimensions.push(_createImmutableMatrix([arg]));
          } else if (typeof arg === 'string') {
            // object property (arguments.count should be 1)
            this._dimensions.push(arg);
          } else {
            throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
          } // TODO: implement support for wildcard '*'
        }
      }
      /**
       * Attach type information
       */

      Index.prototype.type = 'Index';
      Index.prototype.isIndex = true;
      function _createImmutableMatrix(arg) {
        // loop array elements
        for (var i = 0, l = arg.length; i < l; i++) {
          if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
            throw new TypeError('Index parameters must be positive integer numbers');
          }
        } // create matrix

        return new ImmutableDenseMatrix(arg);
      }
      /**
       * Create a clone of the index
       * @memberof Index
       * @return {Index} clone
       */

      Index.prototype.clone = function () {
        var index = new Index();
        index._dimensions = clone$1(this._dimensions);
        index._isScalar = this._isScalar;
        return index;
      };
      /**
       * Create an index from an array with ranges/numbers
       * @memberof Index
       * @param {Array.<Array | number>} ranges
       * @return {Index} index
       * @private
       */

      Index.create = function (ranges) {
        var index = new Index();
        Index.apply(index, ranges);
        return index;
      };
      /**
       * Retrieve the size of the index, the number of elements for each dimension.
       * @memberof Index
       * @returns {number[]} size
       */

      Index.prototype.size = function () {
        var size = [];
        for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
          var d = this._dimensions[i];
          size[i] = typeof d === 'string' ? 1 : d.size()[0];
        }
        return size;
      };
      /**
       * Get the maximum value for each of the indexes ranges.
       * @memberof Index
       * @returns {number[]} max
       */

      Index.prototype.max = function () {
        var values = [];
        for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
          var range = this._dimensions[i];
          values[i] = typeof range === 'string' ? range : range.max();
        }
        return values;
      };
      /**
       * Get the minimum value for each of the indexes ranges.
       * @memberof Index
       * @returns {number[]} min
       */

      Index.prototype.min = function () {
        var values = [];
        for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
          var range = this._dimensions[i];
          values[i] = typeof range === 'string' ? range : range.min();
        }
        return values;
      };
      /**
       * Loop over each of the ranges of the index
       * @memberof Index
       * @param {Function} callback   Called for each range with a Range as first
       *                              argument, the dimension as second, and the
       *                              index object as third.
       */

      Index.prototype.forEach = function (callback) {
        for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
          callback(this._dimensions[i], i, this);
        }
      };
      /**
       * Retrieve the dimension for the given index
       * @memberof Index
       * @param {Number} dim                  Number of the dimension
       * @returns {Range | null} range
       */

      Index.prototype.dimension = function (dim) {
        return this._dimensions[dim] || null;
      };
      /**
       * Test whether this index contains an object property
       * @returns {boolean} Returns true if the index is an object property
       */

      Index.prototype.isObjectProperty = function () {
        return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';
      };
      /**
       * Returns the object property name when the Index holds a single object property,
       * else returns null
       * @returns {string | null}
       */

      Index.prototype.getObjectProperty = function () {
        return this.isObjectProperty() ? this._dimensions[0] : null;
      };
      /**
       * Test whether this index contains only a single value.
       *
       * This is the case when the index is created with only scalar values as ranges,
       * not for ranges resolving into a single value.
       * @memberof Index
       * @return {boolean} isScalar
       */

      Index.prototype.isScalar = function () {
        return this._isScalar;
      };
      /**
       * Expand the Index into an array.
       * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
       * @memberof Index
       * @returns {Array} array
       */

      Index.prototype.toArray = function () {
        var array = [];
        for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
          var dimension = this._dimensions[i];
          array.push(typeof dimension === 'string' ? dimension : dimension.toArray());
        }
        return array;
      };
      /**
       * Get the primitive value of the Index, a two dimensional array.
       * Equivalent to Index.toArray().
       * @memberof Index
       * @returns {Array} array
       */

      Index.prototype.valueOf = Index.prototype.toArray;
      /**
       * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
       * @memberof Index
       * @returns {String} str
       */

      Index.prototype.toString = function () {
        var strings = [];
        for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
          var dimension = this._dimensions[i];
          if (typeof dimension === 'string') {
            strings.push(JSON.stringify(dimension));
          } else {
            strings.push(dimension.toString());
          }
        }
        return '[' + strings.join(', ') + ']';
      };
      /**
       * Get a JSON representation of the Index
       * @memberof Index
       * @returns {Object} Returns a JSON object structured as:
       *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
       */

      Index.prototype.toJSON = function () {
        return {
          mathjs: 'Index',
          dimensions: this._dimensions
        };
      };
      /**
       * Instantiate an Index from a JSON object
       * @memberof Index
       * @param {Object} json A JSON object structured as:
       *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
       * @return {Index}
       */

      Index.fromJSON = function (json) {
        return Index.create(json.dimensions);
      };
      return Index;
    }, {
      isClass: true
    });

    var name$a = 'atan';
    var dependencies$a = ['typed'];
    var createAtan = /* #__PURE__ */factory(name$a, dependencies$a, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Calculate the inverse tangent of a value.
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.atan(x)
       *
       * Examples:
       *
       *    math.atan(0.5)           // returns number 0.4636476090008061
       *    math.atan(math.tan(1.5)) // returns number 1.5
       *
       *    math.atan(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
       *
       * See also:
       *
       *    tan, asin, acos
       *
       * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
       * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x
       */
      return typed('atan', {
        number: function number(x) {
          return Math.atan(x);
        },
        Complex: function Complex(x) {
          return x.atan();
        },
        BigNumber: function BigNumber(x) {
          return x.atan();
        },
        'Array | Matrix': function ArrayMatrix(x) {
          // deep map collection, skip zeros since atan(0) = 0
          return deepMap(x, this);
        }
      });
    });

    var name$9 = 'cos';
    var dependencies$9 = ['typed'];
    var createCos = /* #__PURE__ */factory(name$9, dependencies$9, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Calculate the cosine of a value.
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.cos(x)
       *
       * Examples:
       *
       *    math.cos(2)                      // returns number -0.4161468365471422
       *    math.cos(math.pi / 4)            // returns number  0.7071067811865475
       *    math.cos(math.unit(180, 'deg'))  // returns number -1
       *    math.cos(math.unit(60, 'deg'))   // returns number  0.5
       *
       *    const angle = 0.2
       *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
       *
       * See also:
       *
       *    cos, tan
       *
       * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
       * @return {number | BigNumber | Complex | Array | Matrix} Cosine of x
       */
      return typed(name$9, {
        number: Math.cos,
        Complex: function Complex(x) {
          return x.cos();
        },
        BigNumber: function BigNumber(x) {
          return x.cos();
        },
        Unit: function Unit(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError('Unit in function cos is no angle');
          }
          return this(x.value);
        },
        'Array | Matrix': function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });

    var name$8 = 'sin';
    var dependencies$8 = ['typed'];
    var createSin = /* #__PURE__ */factory(name$8, dependencies$8, _ref => {
      var {
        typed
      } = _ref;

      /**
       * Calculate the sine of a value.
       *
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.sin(x)
       *
       * Examples:
       *
       *    math.sin(2)                      // returns number 0.9092974268256813
       *    math.sin(math.pi / 4)            // returns number 0.7071067811865475
       *    math.sin(math.unit(90, 'deg'))   // returns number 1
       *    math.sin(math.unit(30, 'deg'))   // returns number 0.5
       *
       *    const angle = 0.2
       *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
       *
       * See also:
       *
       *    cos, tan
       *
       * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
       * @return {number | BigNumber | Complex | Array | Matrix} Sine of x
       */
      return typed(name$8, {
        number: Math.sin,
        Complex: function Complex(x) {
          return x.sin();
        },
        BigNumber: function BigNumber(x) {
          return x.sin();
        },
        Unit: function Unit(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError('Unit in function sin is no angle');
          }
          return this(x.value);
        },
        'Array | Matrix': function ArrayMatrix(x) {
          // deep map collection, skip zeros since sin(0) = 0
          return deepMap(x, this);
        }
      });
    });

    var name$7 = 'add';
    var dependencies$7 = ['typed', 'matrix', 'addScalar', 'equalScalar', 'DenseMatrix', 'SparseMatrix'];
    var createAdd = /* #__PURE__ */factory(name$7, dependencies$7, _ref => {
      var {
        typed,
        matrix,
        addScalar,
        equalScalar,
        DenseMatrix,
        SparseMatrix
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed
      });
      var algorithm04 = createAlgorithm04({
        typed,
        equalScalar
      });
      var algorithm10 = createAlgorithm10({
        typed,
        DenseMatrix
      });
      var algorithm13 = createAlgorithm13({
        typed
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Add two or more values, `x + y`.
       * For matrices, the function is evaluated element wise.
       *
       * Syntax:
       *
       *    math.add(x, y)
       *    math.add(x, y, z, ...)
       *
       * Examples:
       *
       *    math.add(2, 3)               // returns number 5
       *    math.add(2, 3, 4)            // returns number 9
       *
       *    const a = math.complex(2, 3)
       *    const b = math.complex(-4, 1)
       *    math.add(a, b)               // returns Complex -2 + 4i
       *
       *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
       *
       *    const c = math.unit('5 cm')
       *    const d = math.unit('2.1 mm')
       *    math.add(c, d)               // returns Unit 52.1 mm
       *
       *    math.add("2.3", "4")         // returns number 6.3
       *
       * See also:
       *
       *    subtract, sum
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
       * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
       */

      return typed(name$7, extend({
        // we extend the signatures of addScalar with signatures dealing with matrices
        'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, addScalar);
        },
        'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
          return algorithm01(x, y, addScalar, false);
        },
        'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
          return algorithm01(y, x, addScalar, true);
        },
        'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
          return algorithm04(x, y, addScalar);
        },
        'Array, Array': function ArrayArray(x, y) {
          // use matrix implementation
          return this(matrix(x), matrix(y)).valueOf();
        },
        'Array, Matrix': function ArrayMatrix(x, y) {
          // use matrix implementation
          return this(matrix(x), y);
        },
        'Matrix, Array': function MatrixArray(x, y) {
          // use matrix implementation
          return this(x, matrix(y));
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, addScalar, false);
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm10(x, y, addScalar, false);
        },
        'any, DenseMatrix': function anyDenseMatrix(x, y) {
          return algorithm14(y, x, addScalar, true);
        },
        'any, SparseMatrix': function anySparseMatrix(x, y) {
          return algorithm10(y, x, addScalar, true);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, addScalar, false).valueOf();
        },
        'any, Array': function anyArray(x, y) {
          // use matrix implementation
          return algorithm14(matrix(y), x, addScalar, true).valueOf();
        },
        'any, any': addScalar,
        'any, any, ...any': function anyAnyAny(x, y, rest) {
          var result = this(x, y);
          for (var i = 0; i < rest.length; i++) {
            result = this(result, rest[i]);
          }
          return result;
        }
      }, addScalar.signatures));
    });

    var name$6 = 'norm';
    var dependencies$6 = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix', 'ctranspose', 'eigs'];
    var createNorm = /* #__PURE__ */factory(name$6, dependencies$6, _ref => {
      var {
        typed,
        abs,
        add,
        pow,
        conj,
        sqrt,
        multiply,
        equalScalar,
        larger,
        smaller,
        matrix,
        ctranspose,
        eigs
      } = _ref;

      /**
       * Calculate the norm of a number, vector or matrix.
       *
       * The second parameter p is optional. If not provided, it defaults to 2.
       *
       * Syntax:
       *
       *    math.norm(x)
       *    math.norm(x, p)
       *
       * Examples:
       *
       *    math.abs(-3.5)                         // returns 3.5
       *    math.norm(-3.5)                        // returns 3.5
       *
       *    math.norm(math.complex(3, -4))         // returns 5
       *
       *    math.norm([1, 2, -3], Infinity)        // returns 3
       *    math.norm([1, 2, -3], -Infinity)       // returns 1
       *
       *    math.norm([3, 4], 2)                   // returns 5
       *
       *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
       *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
       *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
       *
       * See also:
       *
       *    abs, hypot
       *
       * @param  {number | BigNumber | Complex | Array | Matrix} x
       *            Value for which to calculate the norm
       * @param  {number | BigNumber | string} [p=2]
       *            Vector space.
       *            Supported numbers include Infinity and -Infinity.
       *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
       * @return {number | BigNumber} the p-norm
       */
      return typed(name$6, {
        number: Math.abs,
        Complex: function Complex(x) {
          return x.abs();
        },
        BigNumber: function BigNumber(x) {
          // norm(x) = abs(x)
          return x.abs();
        },
        boolean: function boolean(x) {
          // norm(x) = abs(x)
          return Math.abs(x);
        },
        Array: function Array(x) {
          return _norm(matrix(x), 2);
        },
        Matrix: function Matrix(x) {
          return _norm(x, 2);
        },
        'number | Complex | BigNumber | boolean, number | BigNumber | string': function numberComplexBigNumberBooleanNumberBigNumberString(x) {
          // ignore second parameter, TODO: remove the option of second parameter for these types
          return this(x);
        },
        'Array, number | BigNumber | string': function ArrayNumberBigNumberString(x, p) {
          return _norm(matrix(x), p);
        },
        'Matrix, number | BigNumber | string': function MatrixNumberBigNumberString(x, p) {
          return _norm(x, p);
        }
      });
      /**
       * Calculate the plus infinity norm for a vector
       * @param {Matrix} x
       * @returns {number} Returns the norm
       * @private
       */

      function _vectorNormPlusInfinity(x) {
        // norm(x, Infinity) = max(abs(x))
        var pinf = 0; // skip zeros since abs(0) === 0

        x.forEach(function (value) {
          var v = abs(value);
          if (larger(v, pinf)) {
            pinf = v;
          }
        }, true);
        return pinf;
      }
      /**
       * Calculate the minus infinity norm for a vector
       * @param {Matrix} x
       * @returns {number} Returns the norm
       * @private
       */

      function _vectorNormMinusInfinity(x) {
        // norm(x, -Infinity) = min(abs(x))
        var ninf; // skip zeros since abs(0) === 0

        x.forEach(function (value) {
          var v = abs(value);
          if (!ninf || smaller(v, ninf)) {
            ninf = v;
          }
        }, true);
        return ninf || 0;
      }
      /**
       * Calculate the norm for a vector
       * @param {Matrix} x
       * @param {number | string} p
       * @returns {number} Returns the norm
       * @private
       */

      function _vectorNorm(x, p) {
        // check p
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
          return _vectorNormPlusInfinity(x);
        }
        if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
          return _vectorNormMinusInfinity(x);
        }
        if (p === 'fro') {
          return _norm(x, 2);
        }
        if (typeof p === 'number' && !isNaN(p)) {
          // check p != 0
          if (!equalScalar(p, 0)) {
            // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
            var n = 0; // skip zeros since abs(0) === 0

            x.forEach(function (value) {
              n = add(pow(abs(value), p), n);
            }, true);
            return pow(n, 1 / p);
          }
          return Number.POSITIVE_INFINITY;
        } // invalid parameter value

        throw new Error('Unsupported parameter value');
      }
      /**
       * Calculate the Frobenius norm for a matrix
       * @param {Matrix} x
       * @returns {number} Returns the norm
       * @private
       */

      function _matrixNormFrobenius(x) {
        // norm(x) = sqrt(sum(diag(x'x)))
        var fro = 0;
        x.forEach(function (value, index) {
          fro = add(fro, multiply(value, conj(value)));
        });
        return abs(sqrt(fro));
      }
      /**
       * Calculate the norm L1 for a matrix
       * @param {Matrix} x
       * @returns {number} Returns the norm
       * @private
       */

      function _matrixNormOne(x) {
        // norm(x) = the largest column sum
        var c = []; // result

        var maxc = 0; // skip zeros since abs(0) == 0

        x.forEach(function (value, index) {
          var j = index[1];
          var cj = add(c[j] || 0, abs(value));
          if (larger(cj, maxc)) {
            maxc = cj;
          }
          c[j] = cj;
        }, true);
        return maxc;
      }
      /**
       * Calculate the norm L2 for a matrix
       * @param {Matrix} x
       * @returns {number} Returns the norm
       * @private
       */

      function _matrixNormTwo(x) {
        // norm(x) = sqrt( max eigenvalue of A*.A)
        var sizeX = x.size();
        if (sizeX[0] !== sizeX[1]) {
          throw new RangeError('Invalid matrix dimensions');
        }
        var tx = ctranspose(x);
        var squaredX = multiply(tx, x);
        var eigenVals = eigs(squaredX).values.toArray();
        var rho = eigenVals[eigenVals.length - 1];
        return abs(sqrt(rho));
      }
      /**
       * Calculate the infinity norm for a matrix
       * @param {Matrix} x
       * @returns {number} Returns the norm
       * @private
       */

      function _matrixNormInfinity(x) {
        // norm(x) = the largest row sum
        var r = []; // result

        var maxr = 0; // skip zeros since abs(0) == 0

        x.forEach(function (value, index) {
          var i = index[0];
          var ri = add(r[i] || 0, abs(value));
          if (larger(ri, maxr)) {
            maxr = ri;
          }
          r[i] = ri;
        }, true);
        return maxr;
      }
      /**
       * Calculate the norm for a 2D Matrix (M*N)
       * @param {Matrix} x
       * @param {number | string} p
       * @returns {number} Returns the norm
       * @private
       */

      function _matrixNorm(x, p) {
        // check p
        if (p === 1) {
          return _matrixNormOne(x);
        }
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
          return _matrixNormInfinity(x);
        }
        if (p === 'fro') {
          return _matrixNormFrobenius(x);
        }
        if (p === 2) {
          return _matrixNormTwo(x);
        } // invalid parameter value

        throw new Error('Unsupported parameter value ' + p);
      }
      /**
       * Calculate the norm for an array
       * @param {Matrix} x
       * @param {number | string} p
       * @returns {number} Returns the norm
       * @private
       */

      function _norm(x, p) {
        // size
        var sizeX = x.size(); // check if it is a vector

        if (sizeX.length === 1) {
          return _vectorNorm(x, p);
        } // MxN matrix

        if (sizeX.length === 2) {
          if (sizeX[0] && sizeX[1]) {
            return _matrixNorm(x, p);
          } else {
            throw new RangeError('Invalid matrix dimensions');
          }
        }
      }
    });

    var name$5 = 'dot';
    var dependencies$5 = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];
    var createDot = /* #__PURE__ */factory(name$5, dependencies$5, _ref => {
      var {
        typed,
        addScalar,
        multiplyScalar,
        conj,
        size
      } = _ref;

      /**
       * Calculate the dot product of two vectors. The dot product of
       * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:
       *
       *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn
       *
       * Syntax:
       *
       *    math.dot(x, y)
       *
       * Examples:
       *
       *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15
       *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15
       *
       * See also:
       *
       *    multiply, cross
       *
       * @param  {Array | Matrix} x     First vector
       * @param  {Array | Matrix} y     Second vector
       * @return {number}               Returns the dot product of `x` and `y`
       */
      return typed(name$5, {
        'Array | DenseMatrix, Array | DenseMatrix': _denseDot,
        'SparseMatrix, SparseMatrix': _sparseDot
      });
      function _validateDim(x, y) {
        var xSize = _size(x);
        var ySize = _size(y);
        var xLen, yLen;
        if (xSize.length === 1) {
          xLen = xSize[0];
        } else if (xSize.length === 2 && xSize[1] === 1) {
          xLen = xSize[0];
        } else {
          throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');
        }
        if (ySize.length === 1) {
          yLen = ySize[0];
        } else if (ySize.length === 2 && ySize[1] === 1) {
          yLen = ySize[0];
        } else {
          throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');
        }
        if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');
        if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');
        return xLen;
      }
      function _denseDot(a, b) {
        var N = _validateDim(a, b);
        var adata = isMatrix(a) ? a._data : a;
        var adt = isMatrix(a) ? a._datatype : undefined;
        var bdata = isMatrix(b) ? b._data : b;
        var bdt = isMatrix(b) ? b._datatype : undefined; // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)

        var aIsColumn = _size(a).length === 2;
        var bIsColumn = _size(b).length === 2;
        var add = addScalar;
        var mul = multiplyScalar; // process data types

        if (adt && bdt && adt === bdt && typeof adt === 'string') {
          var dt = adt; // find signatures that matches (dt, dt)

          add = typed.find(addScalar, [dt, dt]);
          mul = typed.find(multiplyScalar, [dt, dt]);
        } // both vectors 1-dimensional

        if (!aIsColumn && !bIsColumn) {
          var c = mul(conj(adata[0]), bdata[0]);
          for (var i = 1; i < N; i++) {
            c = add(c, mul(conj(adata[i]), bdata[i]));
          }
          return c;
        } // a is 1-dim, b is column

        if (!aIsColumn && bIsColumn) {
          var _c = mul(conj(adata[0]), bdata[0][0]);
          for (var _i = 1; _i < N; _i++) {
            _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));
          }
          return _c;
        } // a is column, b is 1-dim

        if (aIsColumn && !bIsColumn) {
          var _c2 = mul(conj(adata[0][0]), bdata[0]);
          for (var _i2 = 1; _i2 < N; _i2++) {
            _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));
          }
          return _c2;
        } // both vectors are column

        if (aIsColumn && bIsColumn) {
          var _c3 = mul(conj(adata[0][0]), bdata[0][0]);
          for (var _i3 = 1; _i3 < N; _i3++) {
            _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));
          }
          return _c3;
        }
      }
      function _sparseDot(x, y) {
        _validateDim(x, y);
        var xindex = x._index;
        var xvalues = x._values;
        var yindex = y._index;
        var yvalues = y._values; // TODO optimize add & mul using datatype

        var c = 0;
        var add = addScalar;
        var mul = multiplyScalar;
        var i = 0;
        var j = 0;
        while (i < xindex.length && j < yindex.length) {
          var I = xindex[i];
          var J = yindex[j];
          if (I < J) {
            i++;
            continue;
          }
          if (I > J) {
            j++;
            continue;
          }
          if (I === J) {
            c = add(c, mul(xvalues[i], yvalues[j]));
            i++;
            j++;
          }
        }
        return c;
      } // TODO remove this once #1771 is fixed

      function _size(x) {
        return isMatrix(x) ? x.size() : size(x);
      }
    });

    var name$4 = 'qr';
    var dependencies$4 = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];
    var createQr = /* #__PURE__ */factory(name$4, dependencies$4, _ref => {
      var {
        typed,
        matrix,
        zeros,
        identity,
        isZero,
        equal,
        sign,
        sqrt,
        conj,
        unaryMinus,
        addScalar,
        divideScalar,
        multiplyScalar,
        subtract,
        complex
      } = _ref;

      /**
       * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
       * two matrices (`Q`, `R`) where `Q` is an
       * orthogonal matrix and `R` is an upper triangular matrix.
       *
       * Syntax:
       *
       *    math.qr(A)
       *
       * Example:
       *
       *    const m = [
       *      [1, -1,  4],
       *      [1,  4, -2],
       *      [1,  4,  2],
       *      [1,  -1, 0]
       *    ]
       *    const result = math.qr(m)
       *    // r = {
       *    //   Q: [
       *    //     [0.5, -0.5,   0.5],
       *    //     [0.5,  0.5,  -0.5],
       *    //     [0.5,  0.5,   0.5],
       *    //     [0.5, -0.5,  -0.5],
       *    //   ],
       *    //   R: [
       *    //     [2, 3,  2],
       *    //     [0, 5, -2],
       *    //     [0, 0,  4],
       *    //     [0, 0,  0]
       *    //   ]
       *    // }
       *
       * See also:
       *
       *    lup, lusolve
       *
       * @param {Matrix | Array} A    A two dimensional matrix or array
       * for which to get the QR decomposition.
       *
       * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
       * matrix and R: the upper triangular matrix
       */
      return _extends(typed(name$4, {
        DenseMatrix: function DenseMatrix(m) {
          return _denseQR(m);
        },
        SparseMatrix: function SparseMatrix(m) {
          return _sparseQR();
        },
        Array: function Array(a) {
          // create dense matrix from array
          var m = matrix(a); // lup, use matrix implementation

          var r = _denseQR(m); // result

          return {
            Q: r.Q.valueOf(),
            R: r.R.valueOf()
          };
        }
      }), {
        _denseQRimpl
      });
      function _denseQRimpl(m) {
        // rows & columns (m x n)
        var rows = m._size[0]; // m

        var cols = m._size[1]; // n

        var Q = identity([rows], 'dense');
        var Qdata = Q._data;
        var R = m.clone();
        var Rdata = R._data; // vars

        var i, j, k;
        var w = zeros([rows], '');
        for (k = 0; k < Math.min(cols, rows); ++k) {
          /*
           * **k-th Household matrix**
           *
           * The matrix I - 2*v*transpose(v)
           * x     = first column of A
           * x1    = first element of x
           * alpha = x1 / |x1| * |x|
           * e1    = tranpose([1, 0, 0, ...])
           * u     = x - alpha * e1
           * v     = u / |u|
           *
           * Household matrix = I - 2 * v * tranpose(v)
           *
           *  * Initially Q = I and R = A.
           *  * Household matrix is a reflection in a plane normal to v which
           *    will zero out all but the top right element in R.
           *  * Appplying reflection to both Q and R will not change product.
           *  * Repeat this process on the (1,1) minor to get R as an upper
           *    triangular matrix.
           *  * Reflections leave the magnitude of the columns of Q unchanged
           *    so Q remains othoganal.
           *
           */
          var pivot = Rdata[k][k];
          var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));
          var conjSgn = conj(sgn);
          var alphaSquared = 0;
          for (i = k; i < rows; i++) {
            alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
          }
          var alpha = multiplyScalar(sgn, sqrt(alphaSquared));
          if (!isZero(alpha)) {
            // first element in vector u
            var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)

            w[k] = 1;
            for (i = k + 1; i < rows; i++) {
              w[i] = divideScalar(Rdata[i][k], u1);
            } // tau = - conj(u1 / alpha)

            var tau = unaryMinus(conj(divideScalar(u1, alpha)));
            var s = void 0;
            /*
             * tau and w have been choosen so that
             *
             * 2 * v * tranpose(v) = tau * w * tranpose(w)
             */

            /*
             * -- calculate R = R - tau * w * tranpose(w) * R --
             * Only do calculation with rows k to (rows-1)
             * Additionally columns 0 to (k-1) will not be changed by this
             *   multiplication so do not bother recalculating them
             */

            for (j = k; j < cols; j++) {
              s = 0.0; // calculate jth element of [tranpose(w) * R]

              for (i = k; i < rows; i++) {
                s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
              } // calculate the jth element of [tau * transpose(w) * R]

              s = multiplyScalar(s, tau);
              for (i = k; i < rows; i++) {
                Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
              }
            }
            /*
             * -- calculate Q = Q - tau * Q * w * transpose(w) --
             * Q is a square matrix (rows x rows)
             * Only do calculation with columns k to (rows-1)
             * Additionally rows 0 to (k-1) will not be changed by this
             *   multiplication so do not bother recalculating them
             */

            for (i = 0; i < rows; i++) {
              s = 0.0; // calculate ith element of [Q * w]

              for (j = k; j < rows; j++) {
                s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
              } // calculate the ith element of [tau * Q * w]

              s = multiplyScalar(s, tau);
              for (j = k; j < rows; ++j) {
                Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
              }
            }
          }
        } // return matrices

        return {
          Q,
          R,
          toString: function toString() {
            return 'Q: ' + this.Q.toString() + '\nR: ' + this.R.toString();
          }
        };
      }
      function _denseQR(m) {
        var ret = _denseQRimpl(m);
        var Rdata = ret.R._data;
        if (m._data.length > 0) {
          var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;
          for (var i = 0; i < Rdata.length; ++i) {
            for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
              Rdata[i][j] = zero;
            }
          }
        }
        return ret;
      }
      function _sparseQR(m) {
        throw new Error('qr not implemented for sparse matrices yet');
      }
    });

    var name$3 = 'det';
    var dependencies$3 = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];
    var createDet = /* #__PURE__ */factory(name$3, dependencies$3, _ref => {
      var {
        typed,
        matrix,
        subtract,
        multiply,
        divideScalar,
        isZero,
        unaryMinus
      } = _ref;

      /**
       * Calculate the determinant of a matrix.
       *
       * Syntax:
       *
       *    math.det(x)
       *
       * Examples:
       *
       *    math.det([[1, 2], [3, 4]]) // returns -2
       *
       *    const A = [
       *      [-2, 2, 3],
       *      [-1, 1, 3],
       *      [2, 0, -1]
       *    ]
       *    math.det(A) // returns 6
       *
       * See also:
       *
       *    inv
       *
       * @param {Array | Matrix} x  A matrix
       * @return {number} The determinant of `x`
       */
      return typed(name$3, {
        any: function any(x) {
          return clone$1(x);
        },
        'Array | Matrix': function det(x) {
          var size;
          if (isMatrix(x)) {
            size = x.size();
          } else if (Array.isArray(x)) {
            x = matrix(x);
            size = x.size();
          } else {
            // a scalar
            size = [];
          }
          switch (size.length) {
            case 0:
              // scalar
              return clone$1(x);
            case 1:
              // vector
              if (size[0] === 1) {
                return clone$1(x.valueOf()[0]);
              } else {
                throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
              }
            case 2:
              {
                // two dimensional array
                var rows = size[0];
                var cols = size[1];
                if (rows === cols) {
                  return _det(x.clone().valueOf(), rows);
                } else {
                  throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
                }
              }
            default:
              // multi dimensional array
              throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');
          }
        }
      });
      /**
       * Calculate the determinant of a matrix
       * @param {Array[]} matrix  A square, two dimensional matrix
       * @param {number} rows     Number of rows of the matrix (zero-based)
       * @param {number} cols     Number of columns of the matrix (zero-based)
       * @returns {number} det
       * @private
       */

      function _det(matrix, rows, cols) {
        if (rows === 1) {
          // this is a 1 x 1 matrix
          return clone$1(matrix[0][0]);
        } else if (rows === 2) {
          // this is a 2 x 2 matrix
          // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
          return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));
        } else {
          // Bareiss algorithm
          // this algorithm have same complexity as LUP decomposition (O(n^3))
          // but it preserve precision of floating point more relative to the LUP decomposition
          var negated = false;
          var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i

          for (var k = 0; k < rows; k++) {
            var k_ = rowIndices[k];
            if (isZero(matrix[k_][k])) {
              var _k = void 0;
              for (_k = k + 1; _k < rows; _k++) {
                if (!isZero(matrix[rowIndices[_k]][k])) {
                  k_ = rowIndices[_k];
                  rowIndices[_k] = rowIndices[k];
                  rowIndices[k] = k_;
                  negated = !negated;
                  break;
                }
              }
              if (_k === rows) return matrix[k_][k]; // some zero of the type
            }

            var piv = matrix[k_][k];
            var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];
            for (var i = k + 1; i < rows; i++) {
              var i_ = rowIndices[i];
              for (var j = k + 1; j < rows; j++) {
                matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);
              }
            }
          }
          var det = matrix[rowIndices[rows - 1]][rows - 1];
          return negated ? unaryMinus(det) : det;
        }
      }
    });

    var name$2 = 'inv';
    var dependencies$2 = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];
    var createInv = /* #__PURE__ */factory(name$2, dependencies$2, _ref => {
      var {
        typed,
        matrix,
        divideScalar,
        addScalar,
        multiply,
        unaryMinus,
        det,
        identity,
        abs
      } = _ref;

      /**
       * Calculate the inverse of a square matrix.
       *
       * Syntax:
       *
       *     math.inv(x)
       *
       * Examples:
       *
       *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]
       *     math.inv(4)                 // returns 0.25
       *     1 / 4                       // returns 0.25
       *
       * See also:
       *
       *     det, transpose
       *
       * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
       * @return {number | Complex | Array | Matrix} The inverse of `x`.
       */
      return typed(name$2, {
        'Array | Matrix': function ArrayMatrix(x) {
          var size = isMatrix(x) ? x.size() : arraySize(x);
          switch (size.length) {
            case 1:
              // vector
              if (size[0] === 1) {
                if (isMatrix(x)) {
                  return matrix([divideScalar(1, x.valueOf()[0])]);
                } else {
                  return [divideScalar(1, x[0])];
                }
              } else {
                throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
              }
            case 2:
              // two dimensional array
              {
                var rows = size[0];
                var cols = size[1];
                if (rows === cols) {
                  if (isMatrix(x)) {
                    return matrix(_inv(x.valueOf(), rows, cols), x.storage());
                  } else {
                    // return an Array
                    return _inv(x, rows, cols);
                  }
                } else {
                  throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
                }
              }
            default:
              // multi dimensional array
              throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');
          }
        },
        any: function any(x) {
          // scalar
          return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
        }
      });
      /**
       * Calculate the inverse of a square matrix
       * @param {Array[]} mat     A square matrix
       * @param {number} rows     Number of rows
       * @param {number} cols     Number of columns, must equal rows
       * @return {Array[]} inv    Inverse matrix
       * @private
       */

      function _inv(mat, rows, cols) {
        var r, s, f, value, temp;
        if (rows === 1) {
          // this is a 1 x 1 matrix
          value = mat[0][0];
          if (value === 0) {
            throw Error('Cannot calculate inverse, determinant is zero');
          }
          return [[divideScalar(1, value)]];
        } else if (rows === 2) {
          // this is a 2 x 2 matrix
          var d = det(mat);
          if (d === 0) {
            throw Error('Cannot calculate inverse, determinant is zero');
          }
          return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
        } else {
          // this is a matrix of 3 x 3 or larger
          // calculate inverse using gauss-jordan elimination
          //      https://en.wikipedia.org/wiki/Gaussian_elimination
          //      http://mathworld.wolfram.com/MatrixInverse.html
          //      http://math.uww.edu/~mcfarlat/inverse.htm
          // make a copy of the matrix (only the arrays, not of the elements)
          var A = mat.concat();
          for (r = 0; r < rows; r++) {
            A[r] = A[r].concat();
          } // create an identity matrix which in the end will contain the
          // matrix inverse

          var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions

          for (var c = 0; c < cols; c++) {
            // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]
            var ABig = abs(A[c][c]);
            var rBig = c;
            r = c + 1;
            while (r < rows) {
              if (abs(A[r][c]) > ABig) {
                ABig = abs(A[r][c]);
                rBig = r;
              }
              r++;
            }
            if (ABig === 0) {
              throw Error('Cannot calculate inverse, determinant is zero');
            }
            r = rBig;
            if (r !== c) {
              temp = A[c];
              A[c] = A[r];
              A[r] = temp;
              temp = B[c];
              B[c] = B[r];
              B[r] = temp;
            } // eliminate non-zero values on the other rows at column c

            var Ac = A[c];
            var Bc = B[c];
            for (r = 0; r < rows; r++) {
              var Ar = A[r];
              var Br = B[r];
              if (r !== c) {
                // eliminate value at column c and row r
                if (Ar[c] !== 0) {
                  f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value
                  // at column c

                  for (s = c; s < cols; s++) {
                    Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                  }
                  for (s = 0; s < cols; s++) {
                    Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                  }
                }
              } else {
                // normalize value at Acc to 1,
                // divide each value on row r with the value at Acc
                f = Ac[c];
                for (s = c; s < cols; s++) {
                  Ar[s] = divideScalar(Ar[s], f);
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = divideScalar(Br[s], f);
                }
              }
            }
          }
          return B;
        }
      }
    });

    function createComplexEigs(_ref) {
      var {
        addScalar,
        subtract,
        flatten,
        multiply,
        multiplyScalar,
        divideScalar,
        sqrt,
        abs,
        bignumber,
        diag,
        inv,
        qr,
        usolve,
        usolveAll,
        equal,
        complex,
        larger,
        smaller,
        matrixFromColumns,
        dot
      } = _ref;

      /**
       * @param {number[][]} arr the matrix to find eigenvalues of
       * @param {number} N size of the matrix
       * @param {number|BigNumber} prec precision, anything lower will be considered zero
       * @param {'number'|'BigNumber'|'Complex'} type
       * @param {boolean} findVectors should we find eigenvectors?
       *
       * @returns {{ values: number[], vectors: number[][] }}
       */
      function complexEigs(arr, N, prec, type, findVectors) {
        if (findVectors === undefined) {
          findVectors = true;
        } // TODO check if any row/col are zero except the diagonal
        // make sure corresponding rows and columns have similar magnitude
        // important because of numerical stability
        // MODIFIES arr by side effect!

        var R = balance(arr, N, prec, type, findVectors); // R is the row transformation matrix
        // arr = A' = R A R⁻¹, A is the original matrix
        // (if findVectors is false, R is undefined)
        // (And so to return to original matrix: A = R⁻¹ arr R)
        // TODO if magnitudes of elements vary over many orders,
        // move greatest elements to the top left corner
        // using similarity transformations, reduce the matrix
        // to Hessenberg form (upper triangular plus one subdiagonal row)
        // updates the transformation matrix R with new row operationsq
        // MODIFIES arr by side effect!

        reduceToHessenberg(arr, N, prec, type, findVectors, R); // still true that original A = R⁻¹ arr R)
        // find eigenvalues

        var {
          values,
          C
        } = iterateUntilTriangular(arr, N, prec, type, findVectors); // values is the list of eigenvalues, C is the column
        // transformation matrix that transforms arr, the hessenberg
        // matrix, to upper triangular
        // (So U = C⁻¹ arr C and the relationship between current arr
        // and original A is unchanged.)

        var vectors;
        if (findVectors) {
          vectors = findEigenvectors(arr, N, C, R, values, prec, type);
          vectors = matrixFromColumns(...vectors);
        }
        return {
          values,
          vectors
        };
      }
      /**
       * @param {number[][]} arr
       * @param {number} N
       * @param {number} prec
       * @param {'number'|'BigNumber'|'Complex'} type
       * @returns {number[][]}
       */

      function balance(arr, N, prec, type, findVectors) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var realzero = big ? bignumber(0) : 0;
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        var realone = big ? bignumber(1) : 1; // base of the floating-point arithmetic

        var radix = big ? bignumber(10) : 2;
        var radixSq = multiplyScalar(radix, radix); // the diagonal transformation matrix R

        var Rdiag;
        if (findVectors) {
          Rdiag = Array(N).fill(one);
        } // this isn't the only time we loop thru the matrix...

        var last = false;
        while (!last) {
          // ...haha I'm joking! unless...
          last = true;
          for (var i = 0; i < N; i++) {
            // compute the taxicab norm of i-th column and row
            // TODO optimize for complex numbers
            var colNorm = realzero;
            var rowNorm = realzero;
            for (var j = 0; j < N; j++) {
              if (i === j) continue;
              var c = abs(arr[i][j]); // should be real

              colNorm = addScalar(colNorm, c);
              rowNorm = addScalar(rowNorm, c);
            }
            if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
              // find integer power closest to balancing the matrix
              // (we want to scale only by integer powers of radix,
              // so that we don't lose any precision due to round-off)
              var f = realone;
              var _c = colNorm;
              var rowDivRadix = divideScalar(rowNorm, radix);
              var rowMulRadix = multiplyScalar(rowNorm, radix);
              while (smaller(_c, rowDivRadix)) {
                _c = multiplyScalar(_c, radixSq);
                f = multiplyScalar(f, radix);
              }
              while (larger(_c, rowMulRadix)) {
                _c = divideScalar(_c, radixSq);
                f = divideScalar(f, radix);
              } // check whether balancing is needed
              // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)

              var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95)); // apply balancing similarity transformation

              if (condition) {
                // we should loop once again to check whether
                // another rebalancing is needed
                last = false;
                var g = divideScalar(1, f);
                for (var _j = 0; _j < N; _j++) {
                  if (i === _j) {
                    continue;
                  }
                  arr[i][_j] = multiplyScalar(arr[i][_j], f);
                  arr[_j][i] = multiplyScalar(arr[_j][i], g);
                } // keep track of transformations

                if (findVectors) {
                  Rdiag[i] = multiplyScalar(Rdiag[i], f);
                }
              }
            }
          }
        } // return the diagonal row transformation matrix

        return diag(Rdiag);
      }
      /**
       * @param {number[][]} arr
       * @param {number} N
       * @param {number} prec
       * @param {'number'|'BigNumber'|'Complex'} type
       * @param {boolean} findVectors
       * @param {number[][]} R the row transformation matrix that will be modified
       */

      function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
        if (big) {
          prec = bignumber(prec);
        }
        for (var i = 0; i < N - 2; i++) {
          // Find the largest subdiag element in the i-th col
          var maxIndex = 0;
          var max = zero;
          for (var j = i + 1; j < N; j++) {
            var el = arr[j][i];
            if (smaller(abs(max), abs(el))) {
              max = el;
              maxIndex = j;
            }
          } // This col is pivoted, no need to do anything

          if (smaller(abs(max), prec)) {
            continue;
          }
          if (maxIndex !== i + 1) {
            // Interchange maxIndex-th and (i+1)-th row
            var tmp1 = arr[maxIndex];
            arr[maxIndex] = arr[i + 1];
            arr[i + 1] = tmp1; // Interchange maxIndex-th and (i+1)-th column

            for (var _j2 = 0; _j2 < N; _j2++) {
              var tmp2 = arr[_j2][maxIndex];
              arr[_j2][maxIndex] = arr[_j2][i + 1];
              arr[_j2][i + 1] = tmp2;
            } // keep track of transformations

            if (findVectors) {
              var tmp3 = R[maxIndex];
              R[maxIndex] = R[i + 1];
              R[i + 1] = tmp3;
            }
          } // Reduce following rows and columns

          for (var _j3 = i + 2; _j3 < N; _j3++) {
            var n = divideScalar(arr[_j3][i], max);
            if (n === 0) {
              continue;
            } // from j-th row subtract n-times (i+1)th row

            for (var k = 0; k < N; k++) {
              arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));
            } // to (i+1)th column add n-times j-th column

            for (var _k = 0; _k < N; _k++) {
              arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
            } // keep track of transformations

            if (findVectors) {
              for (var _k2 = 0; _k2 < N; _k2++) {
                R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
              }
            }
          }
        }
        return R;
      }
      /**
       * @returns {{values: values, C: Matrix}}
       * @see Press, Wiliams: Numerical recipes in Fortran 77
       * @see https://en.wikipedia.org/wiki/QR_algorithm
       */

      function iterateUntilTriangular(A, N, prec, type, findVectors) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        if (big) {
          prec = bignumber(prec);
        } // The Francis Algorithm
        // The core idea of this algorithm is that doing successive
        // A' = Q⁺AQ transformations will eventually converge to block-
        // upper-triangular with diagonal blocks either 1x1 or 2x2.
        // The Q here is the one from the QR decomposition, A = QR.
        // Since the eigenvalues of a block-upper-triangular matrix are
        // the eigenvalues of its diagonal blocks and we know how to find
        // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.

        var arr = clone$1(A); // the list of converged eigenvalues

        var lambdas = []; // size of arr, which will get smaller as eigenvalues converge

        var n = N; // the diagonal of the block-diagonal matrix that turns
        // converged 2x2 matrices into upper triangular matrices

        var Sdiag = []; // N×N matrix describing the overall transformation done during the QR algorithm

        var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined; // n×n matrix describing the QR transformations done since last convergence

        var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined; // last eigenvalue converged before this many steps

        var lastConvergenceBefore = 0;
        while (lastConvergenceBefore <= 100) {
          lastConvergenceBefore += 1; // TODO if the convergence is slow, do something clever
          // Perform the factorization

          var k = 0; // TODO set close to an eigenvalue

          for (var i = 0; i < n; i++) {
            arr[i][i] = subtract(arr[i][i], k);
          } // TODO do an implicit QR transformation

          var {
            Q,
            R
          } = qr(arr);
          arr = multiply(R, Q);
          for (var _i = 0; _i < n; _i++) {
            arr[_i][_i] = addScalar(arr[_i][_i], k);
          } // keep track of transformations

          if (findVectors) {
            Qpartial = multiply(Qpartial, Q);
          } // The rightmost diagonal element converged to an eigenvalue

          if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {
            lastConvergenceBefore = 0;
            lambdas.push(arr[n - 1][n - 1]); // keep track of transformations

            if (findVectors) {
              Sdiag.unshift([[1]]);
              inflateMatrix(Qpartial, N);
              Qtotal = multiply(Qtotal, Qpartial);
              if (n > 1) {
                Qpartial = diag(Array(n - 1).fill(one));
              }
            } // reduce the matrix size

            n -= 1;
            arr.pop();
            for (var _i2 = 0; _i2 < n; _i2++) {
              arr[_i2].pop();
            } // The rightmost diagonal 2x2 block converged
          } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {
            lastConvergenceBefore = 0;
            var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
            lambdas.push(...ll); // keep track of transformations

            if (findVectors) {
              Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
              inflateMatrix(Qpartial, N);
              Qtotal = multiply(Qtotal, Qpartial);
              if (n > 2) {
                Qpartial = diag(Array(n - 2).fill(one));
              }
            } // reduce the matrix size

            n -= 2;
            arr.pop();
            arr.pop();
            for (var _i3 = 0; _i3 < n; _i3++) {
              arr[_i3].pop();
              arr[_i3].pop();
            }
          }
          if (n === 0) {
            break;
          }
        } // standard sorting

        lambdas.sort((a, b) => +subtract(abs(a), abs(b))); // the algorithm didn't converge

        if (lastConvergenceBefore > 100) {
          var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));
          err.values = lambdas;
          err.vectors = [];
          throw err;
        } // combine the overall QR transformation Qtotal with the subsequent
        // transformation S that turns the diagonal 2x2 blocks to upper triangular

        var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;
        return {
          values: lambdas,
          C
        };
      }
      /**
       * @param {Matrix} A hessenberg-form matrix
       * @param {number} N size of A
       * @param {Matrix} C column transformation matrix that turns A into upper triangular
       * @param {Matrix} R similarity that turns original matrix into A
       * @param {number[]} values array of eigenvalues of A
       * @param {'number'|'BigNumber'|'Complex'} type
       * @returns {number[][]} eigenvalues
       */

      function findEigenvectors(A, N, C, R, values, prec, type) {
        var Cinv = inv(C);
        var U = multiply(Cinv, A, C);
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
        var one = big ? bignumber(1) : cplx ? complex(1) : 1; // turn values into a kind of "multiset"
        // this way it is easier to find eigenvectors

        var uniqueValues = [];
        var multiplicities = [];
        for (var λ of values) {
          var i = indexOf(uniqueValues, λ, equal);
          if (i === -1) {
            uniqueValues.push(λ);
            multiplicities.push(1);
          } else {
            multiplicities[i] += 1;
          }
        } // find eigenvectors by solving U − λE = 0
        // TODO replace with an iterative eigenvector algorithm
        // (this one might fail for imprecise eigenvalues)

        var vectors = [];
        var len = uniqueValues.length;
        var b = Array(N).fill(zero);
        var E = diag(Array(N).fill(one)); // eigenvalues for which usolve failed (due to numerical error)

        var failedLambdas = [];
        var _loop = function _loop(_i4) {
          var λ = uniqueValues[_i4];
          var S = subtract(U, multiply(λ, E)); // the characteristic matrix

          var solutions = usolveAll(S, b);
          solutions.shift(); // ignore the null vector
          // looks like we missed something, try inverse iteration

          while (solutions.length < multiplicities[_i4]) {
            var approxVec = inverseIterate(S, N, solutions, prec, type);
            if (approxVec == null) {
              // no more vectors were found
              failedLambdas.push(λ);
              break;
            }
            solutions.push(approxVec);
          } // Transform back into original array coordinates

          var correction = multiply(inv(R), C);
          solutions = solutions.map(v => multiply(correction, v));
          vectors.push(...solutions.map(v => flatten(v)));
        };
        for (var _i4 = 0; _i4 < len; _i4++) {
          _loop(_i4);
        }
        if (failedLambdas.length !== 0) {
          var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));
          err.values = values;
          err.vectors = vectors;
          throw err;
        }
        return vectors;
      }
      /**
       * Compute the eigenvalues of an 2x2 matrix
       * @return {[number,number]}
       */

      function eigenvalues2x2(a, b, c, d) {
        // λ± = ½ trA ± ½ √( tr²A - 4 detA )
        var trA = addScalar(a, d);
        var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
        var x = multiplyScalar(trA, 0.5);
        var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
        return [addScalar(x, y), subtract(x, y)];
      }
      /**
       * For an 2x2 matrix compute the transformation matrix S,
       * so that SAS⁻¹ is an upper triangular matrix
       * @return {[[number,number],[number,number]]}
       * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf
       * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
       */

      function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
        var one = big ? bignumber(1) : cplx ? complex(1) : 1; // matrix is already upper triangular
        // return an identity matrix

        if (smaller(abs(c), prec)) {
          return [[one, zero], [zero, one]];
        } // matrix is diagonalizable
        // return its eigenvectors as columns

        if (larger(abs(subtract(l1, l2)), prec)) {
          return [[subtract(l1, d), subtract(l2, d)], [c, c]];
        } // matrix is not diagonalizable
        // compute off-diagonal elements of N = A - λI
        // N₁₂ = 0 ⇒ S = ( N⃗₁, I⃗₁ )
        // N₁₂ ≠ 0 ⇒ S = ( N⃗₂, I⃗₂ )

        var na = subtract(a, l1);
        var nb = subtract(b, l1);
        var nc = subtract(c, l1);
        var nd = subtract(d, l1);
        if (smaller(abs(nb), prec)) {
          return [[na, one], [nc, zero]];
        } else {
          return [[nb, zero], [nd, one]];
        }
      }
      /**
       * Enlarge the matrix from n×n to N×N, setting the new
       * elements to 1 on diagonal and 0 elsewhere
       */

      function inflateMatrix(arr, N) {
        // add columns
        for (var i = 0; i < arr.length; i++) {
          arr[i].push(...Array(N - arr[i].length).fill(0));
        } // add rows

        for (var _i5 = arr.length; _i5 < N; _i5++) {
          arr.push(Array(N).fill(0));
          arr[_i5][_i5] = 1;
        }
        return arr;
      }
      /**
       * Create a block-diagonal matrix with the given square matrices on the diagonal
       * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal
       * @param {number} N the size of the resulting matrix
       */

      function blockDiag(arr, N) {
        var M = [];
        for (var i = 0; i < N; i++) {
          M[i] = Array(N).fill(0);
        }
        var I = 0;
        for (var sub of arr) {
          var n = sub.length;
          for (var _i6 = 0; _i6 < n; _i6++) {
            for (var j = 0; j < n; j++) {
              M[I + _i6][I + j] = sub[_i6][j];
            }
          }
          I += n;
        }
        return M;
      }
      /**
       * Finds the index of an element in an array using a custom equality function
       * @template T
       * @param {Array<T>} arr array in which to search
       * @param {T} el the element to find
       * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`
       * @returns {number} the index of `el`, or -1 when it's not in `arr`
       */

      function indexOf(arr, el, fn) {
        for (var i = 0; i < arr.length; i++) {
          if (fn(arr[i], el)) {
            return i;
          }
        }
        return -1;
      }
      /**
       * Provided a near-singular upper-triangular matrix A and a list of vectors,
       * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal
       * to each vector in the list
       * @template T
       * @param {T[][]} A near-singular square matrix
       * @param {number} N dimension
       * @param {T[][]} orthog list of vectors
       * @param {number} prec epsilon
       * @param {'number'|'BigNumber'|'Complex'} type
       * @return {T[] | null} eigenvector
       *
       * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration
       */

      function inverseIterate(A, N, orthog, prec, type) {
        var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;
        var b; // the vector
        // you better choose a random vector before I count to five

        var i = 0;
        while (true) {
          b = randomOrthogonalVector(N, orthog, type);
          b = usolve(A, b);
          if (larger(norm(b), largeNum)) {
            break;
          }
          if (++i >= 5) {
            return null;
          }
        } // you better converge before I count to ten

        i = 0;
        while (true) {
          var c = usolve(A, b);
          if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
            break;
          }
          if (++i >= 10) {
            return null;
          }
          b = normalize(c);
        }
        return b;
      }
      /**
       * Generates a random unit vector of dimension N, orthogonal to each vector in the list
       * @template T
       * @param {number} N dimension
       * @param {T[][]} orthog list of vectors
       * @param {'number'|'BigNumber'|'Complex'} type
       * @returns {T[]} random vector
       */

      function randomOrthogonalVector(N, orthog, type) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex'; // generate random vector with the correct type

        var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);
        if (big) {
          v = v.map(n => bignumber(n));
        }
        if (cplx) {
          v = v.map(n => complex(n));
        } // project to orthogonal complement

        v = orthogonalComplement(v, orthog); // normalize

        return normalize(v, type);
      }
      /**
       * Project vector v to the orthogonal complement of an array of vectors
       */

      function orthogonalComplement(v, orthog) {
        for (var w of orthog) {
          // v := v − (w, v)/∥w∥² w
          v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
        }
        return v;
      }
      /**
       * Calculate the norm of a vector.
       * We can't use math.norm because factory can't handle circular dependency.
       * Seriously, I'm really fed up with factory.
       */

      function norm(v) {
        return abs(sqrt(dot(v, v)));
      }
      /**
       * Normalize a vector
       * @template T
       * @param {T[]} v
       * @param {'number'|'BigNumber'|'Complex'} type
       * @returns {T[]} normalized vec
       */

      function normalize(v, type) {
        var big = type === 'BigNumber';
        var cplx = type === 'Complex';
        var one = big ? bignumber(1) : cplx ? complex(1) : 1;
        return multiply(divideScalar(one, norm(v)), v);
      }
      return complexEigs;
    }

    function createRealSymmetric(_ref) {
      var {
        config,
        addScalar,
        subtract,
        abs,
        atan,
        cos,
        sin,
        multiplyScalar,
        inv,
        bignumber,
        multiply,
        add
      } = _ref;

      /**
       * @param {number[] | BigNumber[]} arr
       * @param {number} N
       * @param {number} prec
       * @param {'number' | 'BigNumber'} type
       */
      function main(arr, N) {
        var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config.epsilon;
        var type = arguments.length > 3 ? arguments[3] : undefined;
        if (type === 'number') {
          return diag(arr, prec);
        }
        if (type === 'BigNumber') {
          return diagBig(arr, prec);
        }
        throw TypeError('Unsupported data type: ' + type);
      } // diagonalization implementation for number (efficient)

      function diag(x, precision) {
        var N = x.length;
        var e0 = Math.abs(precision / N);
        var psi;
        var Sij = new Array(N); // Sij is Identity Matrix

        for (var i = 0; i < N; i++) {
          Sij[i] = createArray(N, 0);
          Sij[i][i] = 1.0;
        } // initial error

        var Vab = getAij(x);
        while (Math.abs(Vab[1]) >= Math.abs(e0)) {
          var _i = Vab[0][0];
          var j = Vab[0][1];
          psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
          x = x1(x, psi, _i, j);
          Sij = Sij1(Sij, psi, _i, j);
          Vab = getAij(x);
        }
        var Ei = createArray(N, 0); // eigenvalues

        for (var _i2 = 0; _i2 < N; _i2++) {
          Ei[_i2] = x[_i2][_i2];
        }
        return sorting(clone$1(Ei), clone$1(Sij));
      } // diagonalization implementation for bigNumber

      function diagBig(x, precision) {
        var N = x.length;
        var e0 = abs(precision / N);
        var psi;
        var Sij = new Array(N); // Sij is Identity Matrix

        for (var i = 0; i < N; i++) {
          Sij[i] = createArray(N, 0);
          Sij[i][i] = 1.0;
        } // initial error

        var Vab = getAijBig(x);
        while (abs(Vab[1]) >= abs(e0)) {
          var _i3 = Vab[0][0];
          var j = Vab[0][1];
          psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
          x = x1Big(x, psi, _i3, j);
          Sij = Sij1Big(Sij, psi, _i3, j);
          Vab = getAijBig(x);
        }
        var Ei = createArray(N, 0); // eigenvalues

        for (var _i4 = 0; _i4 < N; _i4++) {
          Ei[_i4] = x[_i4][_i4];
        } // return [clone(Ei), clone(Sij)]

        return sorting(clone$1(Ei), clone$1(Sij));
      } // get angle

      function getTheta(aii, ajj, aij) {
        var denom = ajj - aii;
        if (Math.abs(denom) <= config.epsilon) {
          return Math.PI / 4.0;
        } else {
          return 0.5 * Math.atan(2.0 * aij / (ajj - aii));
        }
      } // get angle

      function getThetaBig(aii, ajj, aij) {
        var denom = subtract(ajj, aii);
        if (abs(denom) <= config.epsilon) {
          return bignumber(-1).acos().div(4);
        } else {
          return multiplyScalar(0.5, atan(multiply(2.0, aij, inv(denom))));
        }
      } // update eigvec

      function Sij1(Sij, theta, i, j) {
        var N = Sij.length;
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var Ski = createArray(N, 0);
        var Skj = createArray(N, 0);
        for (var k = 0; k < N; k++) {
          Ski[k] = c * Sij[k][i] - s * Sij[k][j];
          Skj[k] = s * Sij[k][i] + c * Sij[k][j];
        }
        for (var _k = 0; _k < N; _k++) {
          Sij[_k][i] = Ski[_k];
          Sij[_k][j] = Skj[_k];
        }
        return Sij;
      } // update eigvec for overlap

      function Sij1Big(Sij, theta, i, j) {
        var N = Sij.length;
        var c = cos(theta);
        var s = sin(theta);
        var Ski = createArray(N, bignumber(0));
        var Skj = createArray(N, bignumber(0));
        for (var k = 0; k < N; k++) {
          Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
          Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
        }
        for (var _k2 = 0; _k2 < N; _k2++) {
          Sij[_k2][i] = Ski[_k2];
          Sij[_k2][j] = Skj[_k2];
        }
        return Sij;
      } // update matrix

      function x1Big(Hij, theta, i, j) {
        var N = Hij.length;
        var c = bignumber(cos(theta));
        var s = bignumber(sin(theta));
        var c2 = multiplyScalar(c, c);
        var s2 = multiplyScalar(s, s);
        var Aki = createArray(N, bignumber(0));
        var Akj = createArray(N, bignumber(0)); // 2cs Hij

        var csHij = multiply(bignumber(2), c, s, Hij[i][j]); //  Aii

        var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
        var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j])); // 0  to i

        for (var k = 0; k < N; k++) {
          Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
          Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
        } // Modify Hij

        Hij[i][i] = Aii;
        Hij[j][j] = Ajj;
        Hij[i][j] = bignumber(0);
        Hij[j][i] = bignumber(0); // 0  to i

        for (var _k3 = 0; _k3 < N; _k3++) {
          if (_k3 !== i && _k3 !== j) {
            Hij[i][_k3] = Aki[_k3];
            Hij[_k3][i] = Aki[_k3];
            Hij[j][_k3] = Akj[_k3];
            Hij[_k3][j] = Akj[_k3];
          }
        }
        return Hij;
      } // update matrix

      function x1(Hij, theta, i, j) {
        var N = Hij.length;
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var c2 = c * c;
        var s2 = s * s;
        var Aki = createArray(N, 0);
        var Akj = createArray(N, 0); //  Aii

        var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
        var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j]; // 0  to i

        for (var k = 0; k < N; k++) {
          Aki[k] = c * Hij[i][k] - s * Hij[j][k];
          Akj[k] = s * Hij[i][k] + c * Hij[j][k];
        } // Modify Hij

        Hij[i][i] = Aii;
        Hij[j][j] = Ajj;
        Hij[i][j] = 0;
        Hij[j][i] = 0; // 0  to i

        for (var _k4 = 0; _k4 < N; _k4++) {
          if (_k4 !== i && _k4 !== j) {
            Hij[i][_k4] = Aki[_k4];
            Hij[_k4][i] = Aki[_k4];
            Hij[j][_k4] = Akj[_k4];
            Hij[_k4][j] = Akj[_k4];
          }
        }
        return Hij;
      } // get max off-diagonal value from Upper Diagonal

      function getAij(Mij) {
        var N = Mij.length;
        var maxMij = 0;
        var maxIJ = [0, 1];
        for (var i = 0; i < N; i++) {
          for (var j = i + 1; j < N; j++) {
            if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
              maxMij = Math.abs(Mij[i][j]);
              maxIJ = [i, j];
            }
          }
        }
        return [maxIJ, maxMij];
      } // get max off-diagonal value from Upper Diagonal

      function getAijBig(Mij) {
        var N = Mij.length;
        var maxMij = 0;
        var maxIJ = [0, 1];
        for (var i = 0; i < N; i++) {
          for (var j = i + 1; j < N; j++) {
            if (abs(maxMij) < abs(Mij[i][j])) {
              maxMij = abs(Mij[i][j]);
              maxIJ = [i, j];
            }
          }
        }
        return [maxIJ, maxMij];
      } // sort results

      function sorting(E, S) {
        var N = E.length;
        var values = Array(N);
        var vectors = Array(N);
        for (var k = 0; k < N; k++) {
          vectors[k] = Array(N);
        }
        for (var i = 0; i < N; i++) {
          var minID = 0;
          var minE = E[0];
          for (var j = 0; j < E.length; j++) {
            if (abs(E[j]) < abs(minE)) {
              minID = j;
              minE = E[minID];
            }
          }
          values[i] = E.splice(minID, 1)[0];
          for (var _k5 = 0; _k5 < N; _k5++) {
            vectors[_k5][i] = S[_k5][minID];
            S[_k5].splice(minID, 1);
          }
        }
        return {
          values,
          vectors
        };
      }
      /**
       * Create an array of a certain size and fill all items with an initial value
       * @param {number} size
       * @param {number} value
       * @return {number[]}
       */

      function createArray(size, value) {
        // TODO: as soon as all browsers support Array.fill, use that instead (IE doesn't support it)
        var array = new Array(size);
        for (var i = 0; i < size; i++) {
          array[i] = value;
        }
        return array;
      }
      return main;
    }

    var name$1 = 'eigs'; // The absolute state of math.js's dependency system:

    var dependencies$1 = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];
    var createEigs = /* #__PURE__ */factory(name$1, dependencies$1, _ref => {
      var {
        config,
        typed,
        matrix,
        addScalar,
        subtract,
        equal,
        abs,
        atan,
        cos,
        sin,
        multiplyScalar,
        divideScalar,
        inv,
        bignumber,
        multiply,
        add,
        larger,
        column,
        flatten,
        number,
        complex,
        sqrt,
        diag,
        qr,
        usolve,
        usolveAll,
        im,
        re,
        smaller,
        matrixFromColumns,
        dot
      } = _ref;
      var doRealSymetric = createRealSymmetric({
        config,
        addScalar,
        subtract,
        column,
        flatten,
        equal,
        abs,
        atan,
        cos,
        sin,
        multiplyScalar,
        inv,
        bignumber,
        complex,
        multiply,
        add
      });
      var doComplexEigs = createComplexEigs({
        config,
        addScalar,
        subtract,
        multiply,
        multiplyScalar,
        flatten,
        divideScalar,
        sqrt,
        abs,
        bignumber,
        diag,
        qr,
        inv,
        usolve,
        usolveAll,
        equal,
        complex,
        larger,
        smaller,
        matrixFromColumns,
        dot
      });
      /**
       * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.
       * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix –
       * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).
       * If the algorithm fails to converge, it will throw an error – in that case, however, you may still find useful information
       * in `err.values` and `err.vectors`.
       *
       * Syntax:
       *
       *     math.eigs(x, [prec])
       *
       * Examples:
       *
       *     const { eigs, multiply, column, transpose } = math
       *     const H = [[5, 2.3], [2.3, 1]]
       *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}
       *     const E = ans.values
       *     const U = ans.vectors
       *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))
       *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H
       *     E[0] == UTxHxU[0][0]  // returns true
       *
       * See also:
       *
       *     inv
       *
       * @param {Array | Matrix} x  Matrix to be diagonalized
       *
       * @param {number | BigNumber} [prec] Precision, default value: 1e-15
       * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.
       *
       */

      return typed('eigs', {
        Array: function Array(x) {
          var mat = matrix(x);
          return computeValuesAndVectors(mat);
        },
        'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {
          var mat = matrix(x);
          return computeValuesAndVectors(mat, prec);
        },
        Matrix: function Matrix(mat) {
          var {
            values,
            vectors
          } = computeValuesAndVectors(mat);
          return {
            values: matrix(values),
            vectors: matrix(vectors)
          };
        },
        'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {
          var {
            values,
            vectors
          } = computeValuesAndVectors(mat, prec);
          return {
            values: matrix(values),
            vectors: matrix(vectors)
          };
        }
      });
      function computeValuesAndVectors(mat, prec) {
        if (prec === undefined) {
          prec = config.epsilon;
        }
        var size = mat.size();
        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
        }
        var arr = mat.toArray();
        var N = size[0];
        if (isReal(arr, N, prec)) {
          coerceReal(arr, N);
          if (isSymmetric(arr, N, prec)) {
            var _type = coerceTypes(mat, arr, N);
            return doRealSymetric(arr, N, prec, _type);
          }
        }
        var type = coerceTypes(mat, arr, N);
        return doComplexEigs(arr, N, prec, type);
      }
      /** @return {boolean} */

      function isSymmetric(arr, N, prec) {
        for (var i = 0; i < N; i++) {
          for (var j = i; j < N; j++) {
            // TODO proper comparison of bignum and frac
            if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {
              return false;
            }
          }
        }
        return true;
      }
      /** @return {boolean} */

      function isReal(arr, N, prec) {
        for (var i = 0; i < N; i++) {
          for (var j = 0; j < N; j++) {
            // TODO proper comparison of bignum and frac
            if (larger(bignumber(abs(im(arr[i][j]))), prec)) {
              return false;
            }
          }
        }
        return true;
      }
      function coerceReal(arr, N) {
        for (var i = 0; i < N; i++) {
          for (var j = 0; j < N; j++) {
            arr[i][j] = re(arr[i][j]);
          }
        }
      }
      /** @return {'number' | 'BigNumber' | 'Complex'} */

      function coerceTypes(mat, arr, N) {
        /** @type {string} */
        var type = mat.datatype();
        if (type === 'number' || type === 'BigNumber' || type === 'Complex') {
          return type;
        }
        var hasNumber = false;
        var hasBig = false;
        var hasComplex = false;
        for (var i = 0; i < N; i++) {
          for (var j = 0; j < N; j++) {
            var el = arr[i][j];
            if (isNumber(el) || isFraction(el)) {
              hasNumber = true;
            } else if (isBigNumber(el)) {
              hasBig = true;
            } else if (isComplex(el)) {
              hasComplex = true;
            } else {
              throw TypeError('Unsupported type in Matrix: ' + typeOf(el));
            }
          }
        }
        if (hasBig && hasComplex) {
          console.warn('Complex BigNumbers not supported, this operation will lose precission.');
        }
        if (hasComplex) {
          for (var _i = 0; _i < N; _i++) {
            for (var _j = 0; _j < N; _j++) {
              arr[_i][_j] = complex(arr[_i][_j]);
            }
          }
          return 'Complex';
        }
        if (hasBig) {
          for (var _i2 = 0; _i2 < N; _i2++) {
            for (var _j2 = 0; _j2 < N; _j2++) {
              arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
            }
          }
          return 'BigNumber';
        }
        if (hasNumber) {
          for (var _i3 = 0; _i3 < N; _i3++) {
            for (var _j3 = 0; _j3 < N; _j3++) {
              arr[_i3][_j3] = number(arr[_i3][_j3]);
            }
          }
          return 'number';
        } else {
          throw TypeError('Matrix contains unsupported types only.');
        }
      }
    });

    var name = 'divide';
    var dependencies = ['typed', 'matrix', 'multiply', 'equalScalar', 'divideScalar', 'inv'];
    var createDivide = /* #__PURE__ */factory(name, dependencies, _ref => {
      var {
        typed,
        matrix,
        multiply,
        equalScalar,
        divideScalar,
        inv
      } = _ref;
      var algorithm11 = createAlgorithm11({
        typed,
        equalScalar
      });
      var algorithm14 = createAlgorithm14({
        typed
      });
      /**
       * Divide two values, `x / y`.
       * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
       *
       * Syntax:
       *
       *    math.divide(x, y)
       *
       * Examples:
       *
       *    math.divide(2, 3)            // returns number 0.6666666666666666
       *
       *    const a = math.complex(5, 14)
       *    const b = math.complex(4, 1)
       *    math.divide(a, b)            // returns Complex 2 + 3i
       *
       *    const c = [[7, -6], [13, -4]]
       *    const d = [[1, 2], [4, 3]]
       *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
       *
       *    const e = math.unit('18 km')
       *    math.divide(e, 4.5)          // returns Unit 4 km
       *
       * See also:
       *
       *    multiply
       *
       * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
       * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
       * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
       */

      return typed('divide', extend({
        // we extend the signatures of divideScalar with signatures dealing with matrices
        'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(x, y) {
          // TODO: implement matrix right division using pseudo inverse
          // https://www.mathworks.nl/help/matlab/ref/mrdivide.html
          // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
          // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
          return multiply(x, inv(y));
        },
        'DenseMatrix, any': function DenseMatrixAny(x, y) {
          return algorithm14(x, y, divideScalar, false);
        },
        'SparseMatrix, any': function SparseMatrixAny(x, y) {
          return algorithm11(x, y, divideScalar, false);
        },
        'Array, any': function ArrayAny(x, y) {
          // use matrix implementation
          return algorithm14(matrix(x), y, divideScalar, false).valueOf();
        },
        'any, Array | Matrix': function anyArrayMatrix(x, y) {
          return multiply(x, inv(y));
        }
      }, divideScalar.signatures));
    });

    /**
     * THIS FILE IS AUTO-GENERATED
     * DON'T MAKE CHANGES HERE
     */
    var BigNumber = /* #__PURE__ */createBigNumberClass({
      config: config$1
    });
    var Complex = /* #__PURE__ */createComplexClass({});
    var Fraction = /* #__PURE__ */createFractionClass({});
    var Matrix = /* #__PURE__ */createMatrixClass({});
    var DenseMatrix = /* #__PURE__ */createDenseMatrixClass({
      Matrix
    });
    var typed = /* #__PURE__ */createTyped({
      BigNumber,
      Complex,
      DenseMatrix,
      Fraction
    });
    var abs = /* #__PURE__ */createAbs({
      typed
    });
    var addScalar = /* #__PURE__ */createAddScalar({
      typed
    });
    var atan = /* #__PURE__ */createAtan({
      typed
    });
    var bignumber = /* #__PURE__ */createBignumber({
      BigNumber,
      typed
    });
    var complex = /* #__PURE__ */createComplex({
      Complex,
      typed
    });
    var conj = /* #__PURE__ */createConj({
      typed
    });
    var equalScalar = /* #__PURE__ */createEqualScalar({
      config: config$1,
      typed
    });
    var im = /* #__PURE__ */createIm({
      typed
    });
    var isZero = /* #__PURE__ */createIsZero({
      typed
    });
    var multiplyScalar = /* #__PURE__ */createMultiplyScalar({
      typed
    });
    var number = /* #__PURE__ */createNumber({
      typed
    });
    var re = /* #__PURE__ */createRe({
      typed
    });
    var sign = /* #__PURE__ */createSign({
      BigNumber,
      Fraction,
      complex,
      typed
    });
    var sin$2 = /* #__PURE__ */createSin({
      typed
    });
    var SparseMatrix = /* #__PURE__ */createSparseMatrixClass({
      Matrix,
      equalScalar,
      typed
    });
    var cos$2 = /* #__PURE__ */createCos({
      typed
    });
    var sqrt = /* #__PURE__ */createSqrt({
      Complex,
      config: config$1,
      typed
    });
    var unaryMinus = /* #__PURE__ */createUnaryMinus({
      typed
    });
    var fraction = /* #__PURE__ */createFraction({
      Fraction,
      typed
    });
    var matrix = /* #__PURE__ */createMatrix({
      DenseMatrix,
      Matrix,
      SparseMatrix,
      typed
    });
    var numeric = /* #__PURE__ */createNumeric({
      bignumber,
      fraction,
      number
    });
    var size = /* #__PURE__ */createSize({
      matrix,
      config: config$1,
      typed
    });
    var smaller = /* #__PURE__ */createSmaller({
      DenseMatrix,
      config: config$1,
      matrix,
      typed
    });
    var subtract = /* #__PURE__ */createSubtract({
      DenseMatrix,
      addScalar,
      equalScalar,
      matrix,
      typed,
      unaryMinus
    });
    var transpose = /* #__PURE__ */createTranspose({
      matrix,
      typed
    });
    var zeros = /* #__PURE__ */createZeros({
      BigNumber,
      config: config$1,
      matrix,
      typed
    });
    var ctranspose = /* #__PURE__ */createCtranspose({
      conj,
      transpose,
      typed
    });
    var diag = /* #__PURE__ */createDiag({
      DenseMatrix,
      SparseMatrix,
      matrix,
      typed
    });
    var divideScalar = /* #__PURE__ */createDivideScalar({
      numeric,
      typed
    });
    var equal = /* #__PURE__ */createEqual({
      DenseMatrix,
      equalScalar,
      matrix,
      typed
    });
    var flatten = /* #__PURE__ */createFlatten({
      matrix,
      typed
    });
    var largerEq = /* #__PURE__ */createLargerEq({
      DenseMatrix,
      config: config$1,
      matrix,
      typed
    });
    var matrixFromColumns = /* #__PURE__ */createMatrixFromColumns({
      flatten,
      matrix,
      size,
      typed
    });
    var smallerEq = /* #__PURE__ */createSmallerEq({
      DenseMatrix,
      config: config$1,
      matrix,
      typed
    });
    var usolve = /* #__PURE__ */createUsolve({
      DenseMatrix,
      divideScalar,
      equalScalar,
      matrix,
      multiplyScalar,
      subtract,
      typed
    });
    var add = /* #__PURE__ */createAdd({
      DenseMatrix,
      SparseMatrix,
      addScalar,
      equalScalar,
      matrix,
      typed
    });
    var dot = /* #__PURE__ */createDot({
      addScalar,
      conj,
      multiplyScalar,
      size,
      typed
    });
    var identity = /* #__PURE__ */createIdentity({
      BigNumber,
      DenseMatrix,
      SparseMatrix,
      config: config$1,
      matrix,
      typed
    });
    var larger = /* #__PURE__ */createLarger({
      DenseMatrix,
      config: config$1,
      matrix,
      typed
    });
    var multiply = /* #__PURE__ */createMultiply({
      addScalar,
      dot,
      equalScalar,
      matrix,
      multiplyScalar,
      typed
    });
    var qr = /* #__PURE__ */createQr({
      addScalar,
      complex,
      conj,
      divideScalar,
      equal,
      identity,
      isZero,
      matrix,
      multiplyScalar,
      sign,
      sqrt,
      subtract,
      typed,
      unaryMinus,
      zeros
    });
    var range = /* #__PURE__ */createRange({
      bignumber,
      matrix,
      config: config$1,
      larger,
      largerEq,
      smaller,
      smallerEq,
      typed
    });
    var usolveAll = /* #__PURE__ */createUsolveAll({
      DenseMatrix,
      divideScalar,
      equalScalar,
      matrix,
      multiplyScalar,
      subtract,
      typed
    });
    var cross = /* #__PURE__ */createCross({
      matrix,
      multiply,
      subtract,
      typed
    });
    var det = /* #__PURE__ */createDet({
      divideScalar,
      isZero,
      matrix,
      multiply,
      subtract,
      typed,
      unaryMinus
    });
    var ImmutableDenseMatrix = /* #__PURE__ */createImmutableDenseMatrixClass({
      DenseMatrix,
      smaller
    });
    var Index = /* #__PURE__ */createIndexClass({
      ImmutableDenseMatrix
    });
    var column = /* #__PURE__ */createColumn({
      Index,
      matrix,
      range,
      typed
    });
    var inv = /* #__PURE__ */createInv({
      abs,
      addScalar,
      det,
      divideScalar,
      identity,
      matrix,
      multiply,
      typed,
      unaryMinus
    });
    var pow = /* #__PURE__ */createPow({
      Complex,
      config: config$1,
      fraction,
      identity,
      inv,
      matrix,
      multiply,
      number,
      typed
    });
    var divide = /* #__PURE__ */createDivide({
      divideScalar,
      equalScalar,
      inv,
      matrix,
      multiply,
      typed
    });
    var eigs = /* #__PURE__ */createEigs({
      abs,
      add,
      addScalar,
      atan,
      bignumber,
      column,
      complex,
      config: config$1,
      cos: cos$2,
      diag,
      divideScalar,
      dot,
      equal,
      flatten,
      im,
      inv,
      larger,
      matrix,
      matrixFromColumns,
      multiply,
      multiplyScalar,
      number,
      qr,
      re,
      sin: sin$2,
      smaller,
      sqrt,
      subtract,
      typed,
      usolve,
      usolveAll
    });
    var norm = /* #__PURE__ */createNorm({
      abs,
      add,
      conj,
      ctranspose,
      eigs,
      equalScalar,
      larger,
      matrix,
      multiply,
      pow,
      smaller,
      sqrt,
      typed
    });

    function DegToRad(value) {
        return value * (Math.PI / 180);
    }
    function RadToDeg(value) {
        return value * (180 / Math.PI);
    }
    const MIN_LON = -180;
    const MAX_LON = 180;
    const EARTH_RADIUS = 3443.91846652;

    const sin$1 = (angle) => Math.sin(DegToRad(angle));
    const cos$1 = (angle) => Math.cos(DegToRad(angle));
    function asin$1(angle) {
        return RadToDeg(Math.asin(angle));
    }
    function atan2(y, x) {
        return RadToDeg(Math.atan2(y, x));
    }

    /**
     * Calculates the bearing from one point to another (referenced at the first coordinate, bearing can be different at different points between the two)
     * @param from
     * @param to
     */
    function bearingTo(from, to) {
        return (atan2(sin$1(to.long - from.long)
            * cos$1(to.lat), cos$1(from.lat) * sin$1(to.lat)
            - sin$1(from.lat)
                * cos$1(to.lat)
                * cos$1(to.long - from.long)) + 360)
            % 360;
    }

    const robustAcos$2 = (value) => {
        if (value > 1) {
            return 1;
        }
        if (value < -1) {
            return -1;
        }
        return value;
    };
    function clampAngle(a) {
        while (a >= 360) {
            a -= 360;
        }
        while (a < 0) {
            a += 360;
        }
        return a;
    }
    function diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    function coordinatesToSpherical(location) {
        return [
            cos$1(location.lat) * cos$1(location.long),
            cos$1(location.lat) * sin$1(location.long),
            sin$1(location.lat),
        ];
    }
    function sphericalToCoordinates(spherical) {
        return {
            lat: asin$1(spherical[2]),
            long: atan2(spherical[1], spherical[0]),
        };
    }

    /**
     * Calculates the distance between two coordinates on the globe
     * @param from
     * @param to
     */
    function distanceTo(from, to) {
        return Math.acos(robustAcos$2(sin$1(to.lat) * sin$1(from.lat)
            + cos$1(to.lat)
                * cos$1(from.lat)
                * cos$1(from.long - to.long))) * EARTH_RADIUS;
    }

    /**
     * Calculates a Coordinate at a bearing and distance from a reference point
     * @param place - Point to reference from
     * @param bearing
     * @param distance
     */
    function placeBearingDistance(place, bearing, distance) {
        const delta = distance / EARTH_RADIUS;
        const lat = asin$1(sin$1(place.lat) * Math.cos(delta)
            + cos$1(place.lat) * Math.sin(delta) * cos$1(bearing));
        let long = place.long
            + atan2(sin$1(bearing) * Math.sin(delta) * cos$1(place.lat), Math.cos(delta) - sin$1(place.lat) * sin$1(lat));
        if (long < MIN_LON || long > MAX_LON) {
            long = ((long + 540) % (360)) - 180;
        }
        return {
            lat,
            long,
        };
    }

    /**
     * Calculates the intercept points of two Coordinates and two bearings
     * @param point1
     * @param bearing1
     * @param point2
     * @param bearing2
     */
    function placeBearingIntersection(point1, bearing1, point2, bearing2) {
        const Pa11 = coordinatesToSpherical(point1);
        const point12 = placeBearingDistance(point1, clampAngle(bearing1), 500);
        const Pa12 = coordinatesToSpherical(point12);
        const Pa21 = coordinatesToSpherical(point2);
        const point22 = placeBearingDistance(point2, clampAngle(bearing2), 500);
        const Pa22 = coordinatesToSpherical(point22);
        const N1 = cross(Pa11, Pa12);
        const N2 = cross(Pa21, Pa22);
        const L = cross(N1, N2);
        const l = norm(L);
        const I1 = divide(L, l);
        const I2 = multiply(I1, -1);
        const s1 = sphericalToCoordinates(I1);
        const s2 = sphericalToCoordinates(I2);
        const brgTos1 = bearingTo(point1, s1);
        const brgTos2 = bearingTo(point1, s2);
        const delta1 = Math.abs(clampAngle(bearing1) - brgTos1);
        const delta2 = Math.abs(clampAngle(bearing1) - brgTos2);
        return [delta1 < delta2 ? s1 : s2, delta1 < delta2 ? s2 : s1];
    }

    function xyzToCoordinates(x, y, z) {
        const theta = Math.atan2(Math.sqrt(x ** 2 + y ** 2), z);
        // From: https://en.wikipedia.org/wiki/Spherical_coordinate_system#Coordinate_system_conversions
        let phi = NaN;
        if (x > 0)
            phi = Math.atan(y / x);
        else if (x < 0 && y >= 0)
            phi = Math.atan(y / x) + Math.PI;
        else if (x < 0 && y < 0)
            phi = Math.atan(y / x) - Math.PI;
        else if (x === 0 && y > 0)
            phi = Math.PI;
        else if (x === 0 && y < 0)
            phi = -Math.PI;
        return {
            lat: thetaToLat(theta),
            long: phiToLong(phi),
        };
    }
    function thetaToLat(theta) {
        return 90 - (theta * 180) / Math.PI;
    }
    function phiToLong(phi) {
        if (phi > Math.PI)
            return 180 - (phi * 180) / Math.PI;
        return (phi * 180) / Math.PI;
    }
    function latToTheta(lat) {
        return ((90 - lat) * Math.PI) / 180;
    }
    function longToPhi(long) {
        if (long < 0)
            return ((long + 360) * Math.PI) / 180;
        return (long * Math.PI) / 180;
    }
    function coordinatesToXyz(coordinates, radius) {
        const theta = latToTheta(coordinates.lat);
        const phi = longToPhi(coordinates.long);
        return [
            radius * Math.sin(theta) * Math.cos(phi),
            radius * Math.sin(theta) * Math.sin(phi),
            radius * Math.cos(theta),
        ];
    }
    function crossProduct(x1, y1, z1, x2, y2, z2) {
        return [y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2];
    }
    function thetaUnitVector(theta, phi) {
        return [Math.cos(theta) * Math.cos(phi), Math.cos(theta) * Math.sin(phi), -Math.sin(theta)];
    }
    function phiUnitVector(theta, phi) {
        return [-Math.sin(phi), Math.cos(phi), 0];
    }
    function calculateV(course, theta, phi) {
        const [thetaUnitX, thetaUnitY, thetaUnitZ] = thetaUnitVector(theta, phi);
        const [phiUnitX, phiUnitY, phiUnitZ] = phiUnitVector(theta, phi);
        return [
            -Math.cos(course) * thetaUnitX + Math.sin(course) * phiUnitX,
            -Math.cos(course) * thetaUnitY + Math.sin(course) * phiUnitY,
            -Math.cos(course) * thetaUnitZ + Math.sin(course) * phiUnitZ,
        ];
    }
    function solveWithPermutations(smallCircleCoordinates, ns, smallCircleRadius, permutations) {
        let permutation = permutations[0];
        let denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];
        for (let i = 1; Math.abs(denominator) < 1e-4 && i < 3; i++) {
            permutation = permutations[i];
            denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];
        }
        const A = (-ns[permutation[2]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2)) / 2 / denominator;
        const B = -(ns[permutation[2]] * smallCircleCoordinates[permutation[0]] - ns[permutation[0]] * smallCircleCoordinates[permutation[2]]) / denominator;
        const C = (ns[permutation[1]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2)) / 2 / denominator;
        const D = -(-ns[permutation[1]] * smallCircleCoordinates[permutation[0]] + ns[permutation[0]] * smallCircleCoordinates[permutation[1]]) / denominator;
        const discriminant = -(C ** 2) * (1 + B ** 2) + 2 * A * B * C * D - A ** 2 * (1 + D ** 2) + (1 + B ** 2 + D ** 2) * EARTH_RADIUS ** 2;
        if (discriminant < 0) {
            return null;
        }
        const result1 = [0, 0, 0];
        const result2 = [0, 0, 0];
        result1[permutation[0]] = (-A * B - C * D - Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
        result2[permutation[0]] = (-A * B - C * D + Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
        result1[permutation[1]] = A + B * result1[permutation[0]];
        result2[permutation[1]] = A + B * result2[permutation[0]];
        result1[permutation[2]] = C + D * result1[permutation[0]];
        result2[permutation[2]] = C + D * result2[permutation[0]];
        return [xyzToCoordinates(result1[0], result1[1], result1[2]), xyzToCoordinates(result2[0], result2[1], result2[2])];
    }
    function smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
        const smallCircleCoords = coordinatesToXyz(smallCircleCentre, EARTH_RADIUS);
        const [greatCircleX, greatCircleY, greatCircleZ] = coordinatesToXyz(greatCircleReference, EARTH_RADIUS);
        const [vx, vy, vz] = calculateV((greatCircleBearing * Math.PI) / 180, latToTheta(greatCircleReference.lat), longToPhi(greatCircleReference.long));
        const normalVector = crossProduct(greatCircleX, greatCircleY, greatCircleZ, vx, vy, vz);
        return solveWithPermutations(smallCircleCoords, normalVector, smallCircleRadius, [[0, 1, 2], [2, 0, 1], [1, 2, 0]]);
    }
    /**
     * Returns the first small circle intersection to occur on a given bearing
     * @param smallCircleCentre
     * @param smallCircleRadius
     * @param greatCircleReference
     * @param greatCircleBearing
     */
    function firstSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
        const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
        if (!intercepts)
            return null;
        if (distanceTo(greatCircleReference, smallCircleCentre) <= smallCircleRadius) {
            // The great circle reference is inside the circle, use the intercept which is in-front of the great circle reference as per the great circle bearing
            if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, intercepts[0]))) <= 90) {
                return intercepts[0];
            }
            return intercepts[1];
        }
        if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, smallCircleCentre))) <= 90) {
            // The small circle centre is in-front of the great circle reference, use the closest intercept
            if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
                return intercepts[0];
            }
            return intercepts[1];
        }
        // The small circle centre is behind the great circle reference, use the furthest intercept
        if (distanceTo(greatCircleReference, intercepts[0]) > distanceTo(greatCircleReference, intercepts[1])) {
            return intercepts[0];
        }
        return intercepts[1];
    }
    /**
     * Returns the closest to greatCircleReference of two intercepts between a great circle and a small circle
     * @param smallCircleCentre
     * @param smallCircleRadius
     * @param greatCircleReference
     * @param greatCircleBearing
     */
    function closestSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
        const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
        if (!intercepts)
            return null;
        if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
            return intercepts[0];
        }
        return intercepts[1];
    }

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    /** Generates fix names based on the ARINC default naming scheme. */
    class FixNamingScheme {
      /**
         * Generates a fix name for a vector type fix.
         *
         * @returns The generated fix name.
         */
      static vector() {
        return 'MANUAL';
      }

      /**
         * Generates a fix name for a heading to altitude type fix.
         *
         * @param altitudeFeet The altitude that will be flown to.
         *
         * @returns The generated fix name.
         */
      static headingUntilAltitude(altitudeFeet) {
        return Math.round(altitudeFeet).toString();
      }

      /**
       * Generates a fix name for a course to distance type fix.
       *
       * @param course The course that will be flown.
       * @param distance The distance along the course or from the reference fix.
       *
       * @returns The generated fix name.
       */
      static courseToDistance(course, distance) {
        const roundedDistance = Math.round(distance);
        const distanceAlpha = distance > 26 ? 'Z' : this.alphabet[roundedDistance];
        return "D".concat(course.toFixed(0).padStart(3, '0')).concat(distanceAlpha);
      }

      /**
       * Generates a fix name for a course turn to intercept type fix.
       *
       * @param course The course that will be turned to.
       *
       * @returns The generated fix name.
       */
      static courseToIntercept(course) {
        return 'INTCPT';
      }
    }
    _defineProperty$2(FixNamingScheme, "alphabet", ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']);

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    function WorldMagneticModel() {
      this.coff = ['  1,  0,  -29404.5  ,     0.0    ,    6.7  ,      0.0', '  1,  1,   -1450.7  ,  4652.9    ,    7.7  ,    -25.1', '  2,  0,   -2500.0  ,     0.0    ,  -11.5  ,      0.0', '  2,  1,    2982.0  , -2991.6    ,   -7.1  ,    -30.2', '  2,  2,    1676.8  ,  -734.8    ,   -2.2  ,    -23.9', '  3,  0,    1363.9  ,     0.0    ,    2.8  ,      0.0', '  3,  1,   -2381.0  ,   -82.2    ,   -6.2  ,      5.7', '  3,  2,    1236.2  ,   241.8    ,    3.4  ,     -1.0', '  3,  3,     525.7  ,  -542.9    ,  -12.2  ,      1.1', '  4,  0,     903.1  ,     0.0    ,   -1.1  ,      0.0', '  4,  1,     809.4  ,   282.0    ,   -1.6  ,      0.2', '  4,  2,      86.2  ,  -158.4    ,   -6.0  ,      6.9', '  4,  3,    -309.4  ,   199.8    ,    5.4  ,      3.7', '  4,  4,      47.9  ,  -350.1    ,   -5.5  ,     -5.6', '  5,  0,    -234.4  ,     0.0    ,   -0.3  ,      0.0', '  5,  1,     363.1  ,    47.7    ,    0.6  ,      0.1', '  5,  2,     187.8  ,   208.4    ,   -0.7  ,      2.5', '  5,  3,    -140.7  ,  -121.3    ,    0.1  ,     -0.9', '  5,  4,    -151.2  ,    32.2    ,    1.2  ,      3.0', '  5,  5,      13.7  ,    99.1    ,    1.0  ,      0.5', '  6,  0,      65.9  ,     0.0    ,   -0.6  ,      0.0', '  6,  1,      65.6  ,   -19.1    ,   -0.4  ,      0.1', '  6,  2,      73.0  ,    25.0    ,    0.5  ,     -1.8', '  6,  3,    -121.5  ,    52.7    ,    1.4  ,     -1.4', '  6,  4,     -36.2  ,   -64.4    ,   -1.4  ,      0.9', '  6,  5,      13.5  ,     9.0    ,   -0.0  ,      0.1', '  6,  6,     -64.7  ,    68.1    ,    0.8  ,      1.0', '  7,  0,      80.6  ,     0.0    ,   -0.1  ,      0.0', '  7,  1,     -76.8  ,   -51.4    ,   -0.3  ,      0.5', '  7,  2,      -8.3  ,   -16.8    ,   -0.1  ,      0.6', '  7,  3,      56.5  ,     2.3    ,    0.7  ,     -0.7', '  7,  4,      15.8  ,    23.5    ,    0.2  ,     -0.2', '  7,  5,       6.4  ,    -2.2    ,   -0.5  ,     -1.2', '  7,  6,      -7.2  ,   -27.2    ,   -0.8  ,      0.2', '  7,  7,       9.8  ,    -1.9    ,    1.0  ,      0.3', '  8,  0,      23.6  ,     0.0    ,   -0.1  ,      0.0', '  8,  1,       9.8  ,     8.4    ,    0.1  ,     -0.3', '  8,  2,     -17.5  ,   -15.3    ,   -0.1  ,      0.7', '  8,  3,      -0.4  ,    12.8    ,    0.5  ,     -0.2', '  8,  4,     -21.1  ,   -11.8    ,   -0.1  ,      0.5', '  8,  5,      15.3  ,    14.9    ,    0.4  ,     -0.3', '  8,  6,      13.7  ,     3.6    ,    0.5  ,     -0.5', '  8,  7,     -16.5  ,    -6.9    ,    0.0  ,      0.4', '  8,  8,      -0.3  ,     2.8    ,    0.4  ,      0.1', '  9,  0,       5.0  ,     0.0    ,   -0.1  ,      0.0', '  9,  1,       8.2  ,   -23.3    ,   -0.2  ,     -0.3', '  9,  2,       2.9  ,    11.1    ,   -0.0  ,      0.2', '  9,  3,      -1.4  ,     9.8    ,    0.4  ,     -0.4', '  9,  4,      -1.1  ,    -5.1    ,   -0.3  ,      0.4', '  9,  5,     -13.3  ,    -6.2    ,   -0.0  ,      0.1', '  9,  6,       1.1  ,     7.8    ,    0.3  ,     -0.0', '  9,  7,       8.9  ,     0.4    ,   -0.0  ,     -0.2', '  9,  8,      -9.3  ,    -1.5    ,   -0.0  ,      0.5', '  9,  9,     -11.9  ,     9.7    ,   -0.4  ,      0.2', ' 10,  0,      -1.9  ,     0.0    ,    0.0  ,      0.0', ' 10,  1,      -6.2  ,     3.4    ,   -0.0  ,     -0.0', ' 10,  2,      -0.1  ,    -0.2    ,   -0.0  ,      0.1', ' 10,  3,       1.7  ,     3.5    ,    0.2  ,     -0.3', ' 10,  4,      -0.9  ,     4.8    ,   -0.1  ,      0.1', ' 10,  5,       0.6  ,    -8.6    ,   -0.2  ,     -0.2', ' 10,  6,      -0.9  ,    -0.1    ,   -0.0  ,      0.1', ' 10,  7,       1.9  ,    -4.2    ,   -0.1  ,     -0.0', ' 10,  8,       1.4  ,    -3.4    ,   -0.2  ,     -0.1', ' 10,  9,      -2.4  ,    -0.1    ,   -0.1  ,      0.2', ' 10, 10,      -3.9  ,    -8.8    ,   -0.0  ,     -0.0', ' 11,  0,       3.0  ,     0.0    ,   -0.0  ,      0.0', ' 11,  1,      -1.4  ,    -0.0    ,   -0.1  ,     -0.0', ' 11,  2,      -2.5  ,     2.6    ,   -0.0  ,      0.1', ' 11,  3,       2.4  ,    -0.5    ,    0.0  ,      0.0', ' 11,  4,      -0.9  ,    -0.4    ,   -0.0  ,      0.2', ' 11,  5,       0.3  ,     0.6    ,   -0.1  ,     -0.0', ' 11,  6,      -0.7  ,    -0.2    ,    0.0  ,      0.0', ' 11,  7,      -0.1  ,    -1.7    ,   -0.0  ,      0.1', ' 11,  8,       1.4  ,    -1.6    ,   -0.1  ,     -0.0', ' 11,  9,      -0.6  ,    -3.0    ,   -0.1  ,     -0.1', ' 11, 10,       0.2  ,    -2.0    ,   -0.1  ,      0.0', ' 11, 11,       3.1  ,    -2.6    ,   -0.1  ,     -0.0', ' 12,  0,      -2.0  ,     0.0    ,    0.0  ,      0.0', ' 12,  1,      -0.1  ,    -1.2    ,   -0.0  ,     -0.0', ' 12,  2,       0.5  ,     0.5    ,   -0.0  ,      0.0', ' 12,  3,       1.3  ,     1.3    ,    0.0  ,     -0.1', ' 12,  4,      -1.2  ,    -1.8    ,   -0.0  ,      0.1', ' 12,  5,       0.7  ,     0.1    ,   -0.0  ,     -0.0', ' 12,  6,       0.3  ,     0.7    ,    0.0  ,      0.0', ' 12,  7,       0.5  ,    -0.1    ,   -0.0  ,     -0.0', ' 12,  8,      -0.2  ,     0.6    ,    0.0  ,      0.1', ' 12,  9,      -0.5  ,     0.2    ,   -0.0  ,     -0.0', ' 12, 10,       0.1  ,    -0.9    ,   -0.0  ,     -0.0', ' 12, 11,      -1.1  ,    -0.0    ,   -0.0  ,      0.0', ' 12, 12,      -0.3  ,     0.5    ,   -0.1  ,     -0.1'];

      /* static variables */

      /* some 13x13 2D arrays */
      this.c = new Array(13);
      this.cd = new Array(13);
      this.tc = new Array(13);
      this.dp = new Array(13);
      this.k = new Array(13);
      for (var i = 0; i < 13; i++) {
        this.c[i] = new Array(13);
        this.cd[i] = new Array(13);
        this.tc[i] = new Array(13);
        this.dp[i] = new Array(13);
        this.k[i] = new Array(13);
      }

      /* some 1D arrays */
      this.snorm = new Array(169);
      this.sp = new Array(13);
      this.cp = new Array(13);
      this.fn = new Array(13);
      this.fm = new Array(13);
      this.pp = new Array(13);

      /* locals */

      const maxdeg = 12;
      let maxord;
      var i;
      let j;
      let D1;
      let D2;
      let n;
      let m;
      let gnm;
      let hnm;
      let dgnm;
      let dhnm;
      let flnmj;
      let c_str;
      let c_flds;

      /* INITIALIZE CONSTANTS */

      maxord = maxdeg;
      this.sp[0] = 0.0;
      this.cp[0] = this.snorm[0] = this.pp[0] = 1.0;
      this.dp[0][0] = 0.0;

      /* READ WORLD MAGNETIC MODEL SPHERICAL HARMONIC COEFFICIENTS */
      this.c[0][0] = 0.0;
      this.cd[0][0] = 0.0;
      for (i = 0; i < this.coff.length; i++) {
        c_str = this.coff[i];
        c_flds = c_str.split(',');
        n = parseInt(c_flds[0], 10);
        m = parseInt(c_flds[1], 10);
        gnm = parseFloat(c_flds[2]);
        hnm = parseFloat(c_flds[3]);
        dgnm = parseFloat(c_flds[4]);
        dhnm = parseFloat(c_flds[5]);
        if (m <= n) {
          this.c[m][n] = gnm;
          this.cd[m][n] = dgnm;
          if (m != 0) {
            this.c[n][m - 1] = hnm;
            this.cd[n][m - 1] = dhnm;
          }
        }
      }

      /* CONVERT SCHMIDT NORMALIZED GAUSS COEFFICIENTS TO UNNORMALIZED */

      this.snorm[0] = 1.0;
      for (n = 1; n <= maxord; n++) {
        this.snorm[n] = this.snorm[n - 1] * (2 * n - 1) / n;
        j = 2;
        for (m = 0, D1 = 1, D2 = (n - m + D1) / D1; D2 > 0; D2--, m += D1) {
          this.k[m][n] = ((n - 1) * (n - 1) - m * m) / ((2 * n - 1) * (2 * n - 3));
          if (m > 0) {
            flnmj = (n - m + 1) * j / (n + m);
            this.snorm[n + m * 13] = this.snorm[n + (m - 1) * 13] * Math.sqrt(flnmj);
            j = 1;
            this.c[n][m - 1] = this.snorm[n + m * 13] * this.c[n][m - 1];
            this.cd[n][m - 1] = this.snorm[n + m * 13] * this.cd[n][m - 1];
          }
          this.c[m][n] = this.snorm[n + m * 13] * this.c[m][n];
          this.cd[m][n] = this.snorm[n + m * 13] * this.cd[m][n];
        }
        this.fn[n] = n + 1;
        this.fm[n] = n;
      }
      this.k[1][1] = 0.0;
      this.fm[0] = 0.0; // !!!!!! WMM C and Fortran both have a bug in that fm[0] is not initialised
    }

    WorldMagneticModel.prototype.declination = function (altitudeKm, latitudeDegrees, longitudeDegrees, yearFloat) {
      /* locals */

      const a = 6378.137;
      const b = 6356.7523142;
      const re = 6371.2;
      const a2 = a * a;
      const b2 = b * b;
      const c2 = a2 - b2;
      const a4 = a2 * a2;
      const b4 = b2 * b2;
      const c4 = a4 - b4;
      let D3;
      let D4;
      let dec;
      let n;
      let m;
      let pi;
      let dt;
      let rlon;
      let rlat;
      let srlon;
      let srlat;
      let crlon;
      let crlat;
      let srlat2;
      let crlat2;
      let q;
      let q1;
      let q2;
      let ct;
      let d;
      let aor;
      let ar;
      let br;
      let r;
      let r2;
      let bpp;
      let par;
      let temp1;
      let parp;
      let temp2;
      let bx;
      let by;
      let dtr;
      let bp;
      let bt;
      let st;
      let ca;
      let sa;
      const maxord = 12;
      const alt = altitudeKm;
      const glon = longitudeDegrees;
      const glat = latitudeDegrees;

      /** ********************************************************************** */

      dt = yearFloat - 2020.0;
      // if more then 5 years has passed since last epoch update then return invalid
      if (dt < 0.0 || dt > 5.0) return -999;
      pi = 3.14159265359;
      dtr = pi / 180.0;
      rlon = glon * dtr;
      rlat = glat * dtr;
      srlon = Math.sin(rlon);
      srlat = Math.sin(rlat);
      crlon = Math.cos(rlon);
      crlat = Math.cos(rlat);
      srlat2 = srlat * srlat;
      crlat2 = crlat * crlat;
      this.sp[1] = srlon;
      this.cp[1] = crlon;

      /* CONVERT FROM GEODETIC COORDS. TO SPHERICAL COORDS. */

      q = Math.sqrt(a2 - c2 * srlat2);
      q1 = alt * q;
      q2 = (q1 + a2) / (q1 + b2) * ((q1 + a2) / (q1 + b2));
      ct = srlat / Math.sqrt(q2 * crlat2 + srlat2);
      st = Math.sqrt(1.0 - ct * ct);
      r2 = alt * alt + 2.0 * q1 + (a4 - c4 * srlat2) / (q * q);
      r = Math.sqrt(r2);
      d = Math.sqrt(a2 * crlat2 + b2 * srlat2);
      ca = (alt + d) / r;
      sa = c2 * crlat * srlat / (r * d);
      for (m = 2; m <= maxord; m++) {
        this.sp[m] = this.sp[1] * this.cp[m - 1] + this.cp[1] * this.sp[m - 1];
        this.cp[m] = this.cp[1] * this.cp[m - 1] - this.sp[1] * this.sp[m - 1];
      }
      aor = re / r;
      ar = aor * aor;
      br = bt = bp = bpp = 0.0;
      for (n = 1; n <= maxord; n++) {
        ar *= aor;
        for (m = 0, D3 = 1, D4 = (n + m + D3) / D3; D4 > 0; D4--, m += D3) {
          /*
           COMPUTE UNNORMALIZED ASSOCIATED LEGENDRE POLYNOMIALS
           AND DERIVATIVES VIA RECURSION RELATIONS
          */

          if (n == m) {
            this.snorm[n + m * 13] = st * this.snorm[n - 1 + (m - 1) * 13];
            this.dp[m][n] = st * this.dp[m - 1][n - 1] + ct * this.snorm[n - 1 + (m - 1) * 13];
          } else if (n == 1 && m == 0) {
            this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13];
            this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13];
          } else if (n > 1 && n != m) {
            if (m > n - 2) this.snorm[n - 2 + m * 13] = 0.0;
            if (m > n - 2) this.dp[m][n - 2] = 0.0;
            this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.snorm[n - 2 + m * 13];
            this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.dp[m][n - 2];
          }

          /*
          TIME ADJUST THE GAUSS COEFFICIENTS
          */
          this.tc[m][n] = this.c[m][n] + dt * this.cd[m][n];
          if (m != 0) this.tc[n][m - 1] = this.c[n][m - 1] + dt * this.cd[n][m - 1];

          /*
          ACCUMULATE TERMS OF THE SPHERICAL HARMONIC EXPANSIONS
          */
          par = ar * this.snorm[n + m * 13];
          if (m == 0) {
            temp1 = this.tc[m][n] * this.cp[m];
            temp2 = this.tc[m][n] * this.sp[m];
          } else {
            temp1 = this.tc[m][n] * this.cp[m] + this.tc[n][m - 1] * this.sp[m];
            temp2 = this.tc[m][n] * this.sp[m] - this.tc[n][m - 1] * this.cp[m];
          }
          bt -= ar * temp1 * this.dp[m][n];
          bp += this.fm[m] * temp2 * par;
          br += this.fn[n] * temp1 * par;
          /*
          SPECIAL CASE:  NORTH/SOUTH GEOGRAPHIC POLES
          */
          if (st == 0.0 && m == 1) {
            if (n == 1) this.pp[n] = this.pp[n - 1];else this.pp[n] = this.ct * this.pp[n - 1] - this.k[m][n] * this.pp[n - 2];
            parp = ar * this.pp[n];
            bpp += this.fm[m] * temp2 * parp;
          }
        }
      }
      if (st == 0.0) bp = bpp;else bp /= st;

      /*
        ROTATE MAGNETIC VECTOR COMPONENTS FROM SPHERICAL TO
        GEODETIC COORDINATES
      */
      bx = -bt * ca - br * sa;
      by = bp;
      dec = Math.atan2(by, bx) / dtr;
      return dec;
    };
    WorldMagneticModel.prototype.knownAnswerTest = function () {
      /* http://www.ngdc.noaa.gov/geomag/WMM WMM2010testvalues.pdf */

      /* Lat	Lon Dec	    */
      /* Lon 240 = 120W, Lon 300 = 60W */

      /* Alt 0 km */
      const kat2010 = ['80.00	,0.00	 ,-6.13	    ', '0.00	,120.00	 ,0.97	    ', '-80.00	,240.00	 ,70.21	    '];
      const kat2012p5 = ['80.00	,0.00	 ,-5.21	    ', '0.00	,120.00	 ,0.88	    ', '-80.00	,240.00	 ,70.04	    '];
      let maxErr = 0.0;
      for (var i = 0; i < kat2010.length; i++) {
        var c_str = kat2010[i];
        var c_flds = c_str.split(',');
        var lat = parseFloat(c_flds[0]);
        var lon = parseFloat(c_flds[1]);
        var exp = parseFloat(c_flds[2]);
        var maxExp;
        var dec = this.declination(0, lat, lon, 2010.0);
        if (Math.abs(dec - exp) > maxErr) {
          maxErr = Math.abs(dec - exp);
          maxExp = exp;
        }
      }
      for (var i = 0; i < kat2012p5.length; i++) {
        var c_str = kat2012p5[i];
        var c_flds = c_str.split(',');
        var lat = parseFloat(c_flds[0]);
        var lon = parseFloat(c_flds[1]);
        var exp = parseFloat(c_flds[2]);
        var maxExp;
        var dec = this.declination(0, lat, lon, 2012.5);
        if (Math.abs(dec - exp) > maxErr) {
          maxErr = Math.abs(dec - exp);
          maxExp = exp;
        }
      }
      return maxErr * 100 / maxExp; // max % error
    };

    /*

      C***********************************************************************
      C
      C
      C     SUBROUTINE GEOMAG (GEOMAGNETIC FIELD COMPUTATION)
      C
      C
      C***********************************************************************
      C
      C     GEOMAG IS A NATIONAL GEOSPATIAL INTELLIGENCE AGENCY (NGA) STANDARD
      C     PRODUCT.  IT IS COVERED UNDER NGA MILITARY SPECIFICATION:
      C     MIL-W-89500 (1993).
      C
      C***********************************************************************
      C     Contact Information
      C
      C     Software and Model Support
      C     	National Geophysical Data Center
      C     	NOAA EGC/2
      C     	325 Broadway
      C     	Boulder, CO 80303 USA
      C     	Attn: Susan McLean or Stefan Maus
      C     	Phone:  (303) 497-6478 or -6522
      C     	Email:  Susan.McLean@noaa.gov or Stefan.Maus@noaa.gov
      C		Web: http://www.ngdc.noaa.gov/seg/WMM/
      C
      C     Sponsoring Government Agency
      C	   National Geospatial-Intelligence Agency
      C    	   PRG / CSAT, M.S. L-41
      C    	   3838 Vogel Road
      C    	   Arnold, MO 63010
      C    	   Attn: Craig Rollins
      C    	   Phone:  (314) 263-4186
      C    	   Email:  Craig.M.Rollins@Nga.Mil
      C
      C      Original Program By:
      C        Dr. John Quinn
      C        FLEET PRODUCTS DIVISION, CODE N342
      C        NAVAL OCEANOGRAPHIC OFFICE (NAVOCEANO)
      C        STENNIS SPACE CENTER (SSC), MS 39522-5001
      C
      C***********************************************************************
      C
      C     PURPOSE:  THIS ROUTINE COMPUTES THE DECLINATION (DEC),
      C               INCLINATION (DIP), TOTAL INTENSITY (TI) AND
      C               GRID VARIATION (GV - POLAR REGIONS ONLY, REFERENCED
      C               TO GRID NORTH OF A STEREOGRAPHIC PROJECTION) OF THE
      C               EARTH'S MAGNETIC FIELD IN GEODETIC COORDINATES
      C               FROM THE COEFFICIENTS OF THE CURRENT OFFICIAL
      C               DEPARTMENT OF DEFENSE (DOD) SPHERICAL HARMONIC WORLD
      C               MAGNETIC MODEL (WMM.COF).  THE WMM SERIES OF MODELS IS
      C               UPDATED EVERY 5 YEARS ON JANUARY 1ST OF THOSE YEARS
      C               WHICH ARE DIVISIBLE BY 5 (I.E. 2000, 2005, 2010 ETC.)
      C               BY NOAA'S NATIONAL GEOPHYSICAL DATA CENTER IN
      C               COOPERATION WITH THE BRITISH GEOLOGICAL SURVEY (BGS).
      C               THE MODEL IS BASED ON GEOMAGNETIC FIELD MEASUREMENTS
      C               FROM SATELLITE AND GROUND OBSERVATORIES.
      C
      C***********************************************************************
      C
      C     MODEL:  THE WMM SERIES GEOMAGNETIC MODELS ARE COMPOSED
      C             OF TWO PARTS:  THE MAIN FIELD MODEL, WHICH IS
      C             VALID AT THE BASE EPOCH OF THE CURRENT MODEL AND
      C             A SECULAR VARIATION MODEL, WHICH ACCOUNTS FOR SLOW
      C             TEMPORAL VARIATIONS IN THE MAIN GEOMAGNETIC FIELD
      C             FROM THE BASE EPOCH TO A MAXIMUM OF 5 YEARS BEYOND
      C             THE BASE EPOCH.  FOR EXAMPLE, THE BASE EPOCH OF
      C             THE WMM-2005 MODEL IS 2005.0.  THIS MODEL IS THEREFORE
      C             CONSIDERED VALID BETWEEN 2005.0 AND 2010.0. THE
      C             COMPUTED MAGNETIC PARAMETERS ARE REFERENCED TO THE
      C             WGS-84 ELLIPSOID.
      C
      C***********************************************************************
      C
      C     ACCURACY:  IN OCEAN AREAS AT THE EARTH'S SURFACE OVER THE
      C                ENTIRE 5 YEAR LIFE OF THE DEGREE AND ORDER 12
      C                SPHERICAL HARMONIC MODEL WMM-2005, THE ESTIMATED
      C                MAXIMUM RMS ERRORS FOR THE VARIOUS MAGNETIC COMPONENTS
      C                ARE:
      C
      C                DEC  -   0.5 Degrees
      C                DIP  -   0.5 Degrees
      C                TI   - 280.0 nanoTeslas (nT)
      C                GV   -   0.5 Degrees
      C
      C                OTHER MAGNETIC COMPONENTS THAT CAN BE DERIVED FROM
      C                THESE FOUR BY SIMPLE TRIGONOMETRIC RELATIONS WILL
      C                HAVE THE FOLLOWING APPROXIMATE ERRORS OVER OCEAN AREAS:
      C
      C                X    - 140 nT (North)
      C                Y    - 140 nT (East)
      C                Z    - 200 nT (Vertical) Positive is down
      C                H    - 200 nT (Horizontal)
      C
      C                OVER LAND THE MAXIMUM RMS ERRORS ARE EXPECTED TO BE
      C                HIGHER, ALTHOUGH THE RMS ERRORS FOR DEC, DIP, AND GV
      C                ARE STILL ESTIMATED TO BE LESS THAN 1.0 DEGREE, FOR
      C                THE ENTIRE 5-YEAR LIFE OF THE MODEL AT THE EARTH's
      C                SURFACE.  THE OTHER COMPONENT ERRORS OVER LAND ARE
      C                MORE DIFFICULT TO ESTIMATE AND SO ARE NOT GIVEN.
      C
      C                THE ACCURACY AT ANY GIVEN TIME FOR ALL OF THESE
      C                GEOMAGNETIC PARAMETERS DEPENDS ON THE GEOMAGNETIC
      C                LATITUDE.  THE ERRORS ARE LEAST FROM THE EQUATOR TO
      C                MID-LATITUDES AND GREATEST NEAR THE MAGNETIC POLES.
      C
      C                IT IS VERY IMPORTANT TO NOTE THAT A DEGREE AND
      C                ORDER 12 MODEL, SUCH AS WMM-2005, DESCRIBES ONLY
      C                THE LONG WAVELENGTH SPATIAL MAGNETIC FLUCTUATIONS
      C                DUE TO EARTH'S CORE.  NOT INCLUDED IN THE WMM SERIES
      C                MODELS ARE INTERMEDIATE AND SHORT WAVELENGTH
      C                SPATIAL FLUCTUATIONS OF THE GEOMAGNETIC FIELD
      C                WHICH ORIGINATE IN THE EARTH'S MANTLE AND CRUST.
      C                CONSEQUENTLY, ISOLATED ANGULAR ERRORS AT VARIOUS
      C                POSITIONS ON THE SURFACE (PRIMARILY OVER LAND, IN
      C                CONTINENTAL MARGINS AND OVER OCEANIC SEAMOUNTS,
      C                RIDGES AND TRENCHES) OF SEVERAL DEGREES MAY BE
      C                EXPECTED. ALSO NOT INCLUDED IN THE MODEL ARE
      C                NONSECULAR TEMPORAL FLUCTUATIONS OF THE GEOMAGNETIC
      C                FIELD OF MAGNETOSPHERIC AND IONOSPHERIC ORIGIN.
      C                DURING MAGNETIC STORMS, TEMPORAL FLUCTUATIONS CAN
      C                CAUSE SUBSTANTIAL DEVIATIONS OF THE GEOMAGNETIC
      C                FIELD FROM MODEL VALUES.  IN ARCTIC AND ANTARCTIC
      C                REGIONS, AS WELL AS IN EQUATORIAL REGIONS, DEVIATIONS
      C                FROM MODEL VALUES ARE BOTH FREQUENT AND PERSISTENT.
      C
      C                IF THE REQUIRED DECLINATION ACCURACY IS MORE
      C                STRINGENT THAN THE WMM SERIES OF MODELS PROVIDE, THEN
      C                THE USER IS ADVISED TO REQUEST SPECIAL (REGIONAL OR
      C                LOCAL) SURVEYS BE PERFORMED AND MODELS PREPARED.
      C                REQUESTS OF THIS NATURE SHOULD BE MADE TO NIMA
      C                AT THE ADDRESS ABOVE.
      C
      C***********************************************************************
      C
      C     USAGE:  THIS ROUTINE IS BROKEN UP INTO TWO PARTS:
      C
      C             A) AN INITIALIZATION MODULE, WHICH IS CALLED ONLY
      C                ONCE AT THE BEGINNING OF THE MAIN (CALLING)
      C                PROGRAM
      C             B) A PROCESSING MODULE, WHICH COMPUTES THE MAGNETIC
      C                FIELD PARAMETERS FOR EACH SPECIFIED GEODETIC
      C                POSITION (ALTITUDE, LATITUDE, LONGITUDE) AND TIME
      C
      C             INITIALIZATION IS MADE VIA A SINGLE CALL TO THE MAIN
      C             ENTRY POINT (GEOMAG), WHILE SUBSEQUENT PROCESSING
      C             CALLS ARE MADE THROUGH THE SECOND ENTRY POINT (GEOMG1).
      C             ONE CALL TO THE PROCESSING MODULE IS REQUIRED FOR EACH
      C             POSITION AND TIME.
      C
      C             THE VARIABLE MAXDEG IN THE INITIALIZATION CALL IS THE
      C             MAXIMUM DEGREE TO WHICH THE SPHERICAL HARMONIC MODEL
      C             IS TO BE COMPUTED.  IT MUST BE SPECIFIED BY THE USER
      C             IN THE CALLING ROUTINE.  NORMALLY IT IS 12 BUT IT MAY
      C             BE SET LESS THAN 12 TO INCREASE COMPUTATIONAL SPEED AT
      C             THE EXPENSE OF REDUCED ACCURACY.
      C
      C             THE PC VERSION OF THIS SUBROUTINE MUST BE COMPILED
      C             WITH A FORTRAN 77 COMPATIBLE COMPILER SUCH AS THE
      C             MICROSOFT OPTIMIZING FORTRAN COMPILER VERSION 4.1
      C             OR LATER.
      C
      C**********************************************************************
      C
      C     REFERENCES:
      C
      C       JOHN M. QUINN, DAVID J. KERRIDGE AND DAVID R. BARRACLOUGH,
      C            WORLD MAGNETIC CHARTS FOR 1985 - SPHERICAL HARMONIC
      C            MODELS OF THE GEOMAGNETIC FIELD AND ITS SECULAR
      C            VARIATION, GEOPHYS. J. R. ASTR. SOC. (1986) 87,
      C            PP 1143-1157
      C
      C       DEFENSE MAPPING AGENCY TECHNICAL REPORT, TR 8350.2:
      C            DEPARTMENT OF DEFENSE WORLD GEODETIC SYSTEM 1984,
      C            SEPT. 30 (1987)
      C
      C       JOHN M. QUINN, RACHEL J. COLEMAN, MICHAEL R. PECK, AND
      C            STEPHEN E. LAUBER; THE JOINT US/UK 1990 EPOCH
      C            WORLD MAGNETIC MODEL, TECHNICAL REPORT NO. 304,
      C            NAVAL OCEANOGRAPHIC OFFICE (1991)
      C
      C       JOHN M. QUINN, RACHEL J. COLEMAN, DONALD L. SHIEL, AND
      C            JOHN M. NIGRO; THE JOINT US/UK 1995 EPOCH WORLD
      C            MAGNETIC MODEL, TECHNICAL REPORT NO. 314, NAVAL
      C            OCEANOGRAPHIC OFFICE (1995)
      C
      C            SUSAN AMCMILLAN, DAVID R. BARRACLOUGH, JOHN M. QUINN, AND
      C            RACHEL J. COLEMAN;  THE 1995 REVISION OF THE JOINT US/UK
      C            GEOMAGNETIC FIELD MODELS - I. SECULAR VARIATION, JOURNAL OF
      C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 229-243
      C            (1997)
      C
      C            JOHN M. QUINN, RACHEL J. COELMAN, SUSAM MACMILLAN, AND
      C            DAVID R. BARRACLOUGH;  THE 1995 REVISION OF THE JOINT
      C            US/UK GEOMAGNETIC FIELD MODELS: II. MAIN FIELD,JOURNAL OF
      C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 245 - 261
      C            (1997)
      C
      C***********************************************************************
      C
      C     PARAMETER DESCRIPTIONS:
      C
      C       A      - SEMIMAJOR AXIS OF WGS-84 ELLIPSOID (KM)
      C       B      - SEMIMINOR AXIS OF WGS-84 ELLIPSOID (KM)
      C       RE     - MEAN RADIUS OF IAU-66 ELLIPSOID (KM)
      C       SNORM  - SCHMIDT NORMALIZATION FACTORS
      C       C      - GAUSS COEFFICIENTS OF MAIN GEOMAGNETIC MODEL (NT)
      C       CD     - GAUSS COEFFICIENTS OF SECULAR GEOMAGNETIC MODEL (NT/YR)
      C       TC     - TIME ADJUSTED GEOMAGNETIC GAUSS COEFFICIENTS (NT)
      C       OTIME  - TIME ON PREVIOUS CALL TO GEOMAG (YRS)
      C       OALT   - GEODETIC ALTITUDE ON PREVIOUS CALL TO GEOMAG (YRS)
      C       OLAT   - GEODETIC LATITUDE ON PREVIOUS CALL TO GEOMAG (DEG.)
      C       TIME   - COMPUTATION TIME (YRS)                        (INPUT)
      C                (EG. 1 JULY 1995 = 1995.500)
      C       ALT    - GEODETIC ALTITUDE (KM)                        (INPUT)
      C       GLAT   - GEODETIC LATITUDE (DEG.)                      (INPUT)
      C       GLON   - GEODETIC LONGITUDE (DEG.)                     (INPUT)
      C       EPOCH  - BASE TIME OF GEOMAGNETIC MODEL (YRS)
      C       DTR    - DEGREE TO RADIAN CONVERSION
      C       SP(M)  - SINE OF (M*SPHERICAL COORD. LONGITUDE)
      C       CP(M)  - COSINE OF (M*SPHERICAL COORD. LONGITUDE)
      C       ST     - SINE OF (SPHERICAL COORD. LATITUDE)
      C       CT     - COSINE OF (SPHERICAL COORD. LATITUDE)
      C       R      - SPHERICAL COORDINATE RADIAL POSITION (KM)
      C       CA     - COSINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
      C       SA     - SINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
      C       BR     - RADIAL COMPONENT OF GEOMAGNETIC FIELD (NT)
      C       BT     - THETA COMPONENT OF GEOMAGNETIC FIELD (NT)
      C       BP     - PHI COMPONENT OF GEOMAGNETIC FIELD (NT)
      C       P(N,M) - ASSOCIATED LEGENDRE POLYNOMIALS (UNNORMALIZED)
      C       PP(N)  - ASSOCIATED LEGENDRE POLYNOMIALS FOR M=1 (UNNORMALIZED)
      C       DP(N,M)- THETA DERIVATIVE OF P(N,M) (UNNORMALIZED)
      C       BX     - NORTH GEOMAGNETIC COMPONENT (NT)
      C       BY     - EAST GEOMAGNETIC COMPONENT (NT)
      C       BZ     - VERTICALLY DOWN GEOMAGNETIC COMPONENT (NT)
      C       BH     - HORIZONTAL GEOMAGNETIC COMPONENT (NT)
      C       DEC    - GEOMAGNETIC DECLINATION (DEG.)                (OUTPUT)
      C                  EAST=POSITIVE ANGLES
      C                  WEST=NEGATIVE ANGLES
      C       DIP    - GEOMAGNETIC INCLINATION (DEG.)                (OUTPUT)
      C                  DOWN=POSITIVE ANGLES
      C                    UP=NEGATIVE ANGLES
      C       TI     - GEOMAGNETIC TOTAL INTENSITY (NT)              (OUTPUT)
      C       GV     - GEOMAGNETIC GRID VARIATION (DEG.)             (OUTPUT)
      C                REFERENCED TO GRID NORTH
      C                GRID NORTH REFERENCED TO 0 MERIDIAN
      C                OF A POLAR STEREOGRAPHIC PROJECTION
      C                (ARCTIC/ANTARCTIC ONLY)
      C       MAXDEG - MAXIMUM DEGREE OF SPHERICAL HARMONIC MODEL    (INPUT)
      C       MOXORD - MAXIMUM ORDER OF SPHERICAL HARMONIC MODEL
      C
      C***********************************************************************
      C
      C     NOTE:  THIS VERSION OF GEOMAG USES A WMM SERIES GEOMAGNETIC
      C            FIELS MODEL REFERENCED TO THE WGS-84 GRAVITY MODEL
      C            ELLIPSOID
      C

      */

    /** A class for geographical mathematics. */
    class GeoMath {
      /**
       * Gets coordinates at a relative bearing and distance from a set of coordinates.
       * @param course The course, in degrees, from the reference coordinates.
       * @param distanceInNM The distance, in nautical miles, from the reference coordinates.
       * @param referenceCoordinates The reference coordinates to calculate from.
       * @returns The calculated coordinates.
       */
      static relativeBearingDistanceToCoords(course, distanceInNM, referenceCoordinates) {
        const courseRadians = course * Avionics.Utils.DEG2RAD;
        const distanceRadians = Math.PI / (180 * 60) * distanceInNM;
        const refLat = referenceCoordinates.lat * Avionics.Utils.DEG2RAD;
        const refLon = -(referenceCoordinates.long * Avionics.Utils.DEG2RAD);
        const lat = Math.asin(Math.sin(refLat) * Math.cos(distanceRadians) + Math.cos(refLat) * Math.sin(distanceRadians) * Math.cos(courseRadians));
        const dlon = Math.atan2(Math.sin(courseRadians) * Math.sin(distanceRadians) * Math.cos(refLat), Math.cos(distanceRadians) - Math.sin(refLat) * Math.sin(lat));
        const lon = Avionics.Utils.fmod(refLon - dlon + Math.PI, 2 * Math.PI) - Math.PI;
        return new LatLongAlt(lat * Avionics.Utils.RAD2DEG, -(lon * Avionics.Utils.RAD2DEG));
      }

      /**
       * Gets a magnetic heading given a true course and a magnetic variation.
       * @param trueCourse The true course to correct.
       * @param magneticVariation The measured magnetic variation.
       * @returns The magnetic heading, corrected for magnetic variation.
       */
      static correctMagvar(trueCourse, magneticVariation) {
        return trueCourse - GeoMath.normalizeMagVar(magneticVariation);
      }

      /**
       * Gets a true course given a magnetic heading and a magnetic variation.
       * @param headingMagnetic The magnetic heading to correct.
       * @param magneticVariation The measured magnetic variation.
       * @returns The true course, corrected for magnetic variation.
       */
      static removeMagvar(headingMagnetic, magneticVariation) {
        return headingMagnetic + GeoMath.normalizeMagVar(magneticVariation);
      }

      /**
       * Gets a magnetic variation difference in 0-360 degrees.
       * @param magneticVariation The magnetic variation to normalize.
       * @returns A normalized magnetic variation.
       */
      static normalizeMagVar(magneticVariation) {
        let normalizedMagVar;
        if (magneticVariation <= 180) {
          normalizedMagVar = magneticVariation;
        } else {
          normalizedMagVar = magneticVariation - 360;
        }
        return normalizedMagVar;
      }

      /**
       * Gets the magnetic variation for a given latitude and longitude.
       * @param lat The latitude to get a magvar for.
       * @param lon The longitude to get a magvar for.
       * @returns The magnetic variation at the specific latitude and longitude.
       */
      static getMagvar(lat, lon) {
        return GeoMath.magneticModel.declination(0, lat, lon, 2020);
      }
      static directedDistanceToGo(from, to, acDirectedLineBearing) {
        const absDtg = Avionics.Utils.computeGreatCircleDistance(from, to);

        // @todo should be abeam distance
        if (acDirectedLineBearing >= 90 && acDirectedLineBearing <= 270) {
          // Since a line perpendicular to the leg is formed by two 90 degree angles, an aircraftLegBearing outside
          // (North - 90) and (North + 90) is in the lower quadrants of a plane centered at the TO fix. This means
          // the aircraft is NOT past the TO fix, and DTG must be positive.

          return absDtg;
        }
        return -absDtg;
      }
    }
    _defineProperty$2(GeoMath, "magneticModel", new WorldMagneticModel());

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    /**
     * A class for mapping raw facility data to WayPoints.
     */
    class RawDataMapper {
      /**
       * Maps a raw facility record to a WayPoint.
       * @param facility The facility record to map.
       * @param instrument The instrument to attach to the WayPoint.
       * @returns The mapped waypoint.
       */
      static toWaypoint(facility, instrument) {
        const waypoint = new WayPoint(instrument);
        waypoint.ident = WayPoint.formatIdentFromIcao(facility.icao);
        waypoint.icao = facility.icao;
        waypoint.type = facility.icao[0];
        let alt = 0;
        switch (waypoint.type) {
          case 'A':
            {
              const info = new AirportInfo(instrument);
              info.CopyBaseInfosFrom(waypoint);
              info.UpdateNamedFrequencies();
              alt = 3.28084 * facility.runways.reduce((sum, r) => sum + r.elevation, 0) / facility.runways.length;
              info.approaches = facility.approaches;
              info.approaches.forEach(approach => approach.name = normaliseApproachName(approach.name));
              info.approaches.forEach(approach => approach.transitions.forEach(trans => trans.name.trim().length === 0 && (trans.name = WayPoint.formatIdentFromIcao(trans.legs[0].fixIcao))));
              info.approaches.forEach(approach => approach.runway = approach.runway.trim());
              info.departures = facility.departures;
              info.departures.forEach(departure => departure.runwayTransitions.forEach(trans => trans.name = RawDataMapper.generateRunwayTransitionName(trans)));
              info.departures.forEach(departure => departure.enRouteTransitions.forEach(trans => trans.name.trim().length === 0 && (trans.name = RawDataMapper.generateDepartureEnRouteTransitionName(trans))));
              info.arrivals = facility.arrivals;
              info.arrivals.forEach(arrival => arrival.runwayTransitions.forEach(trans => trans.name = RawDataMapper.generateRunwayTransitionName(trans)));
              info.arrivals.forEach(arrival => arrival.enRouteTransitions.forEach(trans => trans.name.trim().length === 0 && (trans.name = RawDataMapper.generateArrivalTransitionName(trans))));
              info.runways = facility.runways;
              info.oneWayRunways = [];
              facility.runways.forEach(runway => info.oneWayRunways.push(...Object.assign(new Runway(), runway).splitIfTwoWays()));
              info.oneWayRunways.sort(RawDataMapper.sortRunways);
              waypoint.infos = info;
            }
            break;
          case 'V':
            waypoint.infos = new VORInfo(instrument);
            break;
          case 'N':
            waypoint.infos = new NDBInfo(instrument);
            break;
          case 'W':
            waypoint.infos = new IntersectionInfo(instrument);
            break;
          default:
            waypoint.infos = new WayPointInfo(instrument);
            break;
        }
        if (waypoint.type !== 'A') {
          waypoint.infos.CopyBaseInfosFrom(waypoint);
          waypoint.infos.routes = facility.routes;
        }
        waypoint.infos.coordinates = new LatLongAlt(facility.lat, facility.lon, alt);
        waypoint.additionalData = {};
        return waypoint;
      }

      /**
       * A comparer for sorting runways by number, and then by L, C, and R.
       * @param r1 The first runway to compare.
       * @param r2 The second runway to compare.
       * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
       */
      static sortRunways(r1, r2) {
        if (parseInt(r1.designation) === parseInt(r2.designation)) {
          let v1 = 0;
          if (r1.designation.indexOf('L') !== -1) {
            v1 = 1;
          } else if (r1.designation.indexOf('C') !== -1) {
            v1 = 2;
          } else if (r1.designation.indexOf('R') !== -1) {
            v1 = 3;
          }
          let v2 = 0;
          if (r2.designation.indexOf('L') !== -1) {
            v2 = 1;
          } else if (r2.designation.indexOf('C') !== -1) {
            v2 = 2;
          } else if (r2.designation.indexOf('R') !== -1) {
            v2 = 3;
          }
          return v1 - v2;
        }
        return parseInt(r1.designation) - parseInt(r2.designation);
      }

      /**
       * Generates a runway transition name from the designated runway in the transition data.
       * @param runwayTransition The runway transition to generate the name for.
       * @returns The runway transition name.
       */
      static generateRunwayTransitionName(runwayTransition) {
        let name = "RW".concat(runwayTransition.runwayNumber);
        switch (runwayTransition.runwayDesignation) {
          case 1:
            name += 'L';
            break;
          case 2:
            name += 'R';
            break;
          case 3:
            name += 'C';
            break;
        }
        return name;
      }

      /**
       * Generates an arrival transition name from a provided arrival enroute transition.
       * @param enrouteTransition The enroute transition to generate a name for.
       * @returns The generated transition name.
       */
      static generateArrivalTransitionName(enrouteTransition) {
        return WayPoint.formatIdentFromIcao(enrouteTransition.legs[0].fixIcao);
      }

      /**
       * Generates a departure transition name from a provided departure enroute transition.
       * @param enrouteTransition The enroute transition to generate a name for.
       * @returns The generated transition name.
       */
      static generateDepartureEnRouteTransitionName(enrouteTransition) {
        return WayPoint.formatIdentFromIcao(enrouteTransition.legs[enrouteTransition.legs.length - 1].fixIcao);
      }
    }

    /**
     * Creates a collection of waypoints from a legs procedure.
     */
    class LegsProcedure {
      /** The current index in the procedure. */

      /** Whether or not there is a discontinuity pending to be mapped. */

      /** A collection of the loaded facilities needed for this procedure. */

      /** Whether or not the facilities have completed loading. */

      /** The collection of facility promises to await on first load. */

      /** Whether or not a non initial-fix procedure start has been added to the procedure. */

      /** A normalization factor for calculating distances from triangular ratios. */

      /** A collection of filtering rules for filtering ICAO data to pre-load for the procedure. */

      /**
       * Creates an instance of a LegsProcedure.
       * @param legs The legs that are part of the procedure.
       * @param startingPoint The starting point for the procedure.
       * @param instrument The instrument that is attached to the flight plan.
       * @param approachType The approach type if this is an approach procedure
       */
      constructor(_legs, _previousFix, _instrument, airportMagVar, approachType, legAnnotations) {
        this._legs = _legs;
        this._previousFix = _previousFix;
        this._instrument = _instrument;
        this.airportMagVar = airportMagVar;
        this.approachType = approachType;
        this.legAnnotations = legAnnotations;
        _defineProperty$2(this, "_currentIndex", 0);
        _defineProperty$2(this, "_isDiscontinuityPending", false);
        _defineProperty$2(this, "_facilities", new Map());
        _defineProperty$2(this, "_facilitiesLoaded", false);
        _defineProperty$2(this, "_facilitiesToLoad", new Map());
        _defineProperty$2(this, "_addedProcedureStart", false);
        _defineProperty$2(this, "legFilteringRules", [icao => icao.trim() !== '',
        // Icao is not empty
        icao => icao[0] !== 'R',
        // Icao is not runway icao, which is not searchable
        icao => icao[0] !== 'A',
        // Icao is not airport icao, which can be skipped
        icao => !this._facilitiesToLoad.has(icao) // Icao is not already being loaded
        ]);

        for (const leg of this._legs) {
          if (this.isIcaoValid(leg.fixIcao)) {
            this._facilitiesToLoad.set(leg.fixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.fixIcao, 2000, true));
          }
          if (this.isIcaoValid(leg.originIcao)) {
            this._facilitiesToLoad.set(leg.originIcao, this._instrument.facilityLoader.getFacilityRaw(leg.originIcao, 2000, true));
          }
          if (this.isIcaoValid(leg.arcCenterFixIcao)) {
            this._facilitiesToLoad.set(leg.arcCenterFixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.arcCenterFixIcao, 2000, true));
          }
        }
      }

      /**
       * Checks whether or not there are any legs remaining in the procedure.
       * @returns True if there is a next leg, false otherwise.
       */
      hasNext() {
        return this._currentIndex < this._legs.length || this._isDiscontinuityPending;
      }
      async ensureFacilitiesLoaded() {
        if (!this._facilitiesLoaded) {
          const facilityResults = await Promise.all(this._facilitiesToLoad.values());
          for (const facility of facilityResults.filter(f => f !== undefined)) {
            this._facilities.set(facility.icao, facility);
          }
          this._facilitiesLoaded = true;
        }
      }

      /**
       * Gets the next mapped leg from the procedure.
       * @returns The mapped waypoint from the leg of the procedure.
       */
      async getNext() {
        let isLegMappable = false;
        let mappedLeg;
        await this.ensureFacilitiesLoaded();
        while (!isLegMappable && this._currentIndex < this._legs.length) {
          const currentLeg = this._legs[this._currentIndex];
          const currentAnnotation = this.legAnnotations[this._currentIndex];
          isLegMappable = true;

          // Some procedures don't start with 15 (initial fix) but instead start with a heading and distance from
          // a fix: the procedure then starts with the fix exactly
          if (this._currentIndex === 0 && currentLeg.type === 10 && !this._addedProcedureStart) {
            mappedLeg = this.mapExactFix(currentLeg);
            this._addedProcedureStart = true;
          } else {
            try {
              switch (currentLeg.type) {
                case LegType.AF:
                case LegType.PI:
                  mappedLeg = this.mapExactFix(currentLeg);
                  break;
                case LegType.CD:
                case LegType.VD:
                  mappedLeg = this.mapHeadingUntilDistanceFromOrigin(currentLeg, this._previousFix);
                  break;
                case LegType.CF:
                  // Only map if the fix is itself not a runway fix to avoid double
                  // adding runway fixes
                  if (currentLeg.fixIcao === '' || currentLeg.fixIcao[0] !== 'R') {
                    mappedLeg = this.mapOriginRadialForDistance(currentLeg, this._previousFix);
                  } else {
                    isLegMappable = false;
                  }
                  break;
                case LegType.CI:
                case LegType.VI:
                  mappedLeg = this.mapHeadingToInterceptNextLeg(currentLeg, this._previousFix, this._legs[this._currentIndex + 1]);
                  break;
                case LegType.CR:
                case LegType.VR:
                  mappedLeg = this.mapHeadingUntilRadialCrossing(currentLeg, this._previousFix);
                  break;
                case LegType.FC:
                case LegType.FD:
                  mappedLeg = this.mapBearingAndDistanceFromOrigin(currentLeg);
                  break;
                case LegType.FM:
                case LegType.VM:
                  mappedLeg = this.mapVectors(currentLeg, this._previousFix);
                  break;
                case LegType.IF:
                  if (currentLeg.fixIcao[0] !== 'A') {
                    const leg = this.mapExactFix(currentLeg);
                    const prevLeg = this._previousFix;

                    // If a type 15 (initial fix) comes up in the middle of a plan
                    if (leg.icao === prevLeg.icao && leg.infos.coordinates.lat === prevLeg.infos.coordinates.lat && leg.infos.coordinates.long === prevLeg.infos.coordinates.long) {
                      isLegMappable = false;
                    } else {
                      mappedLeg = leg;
                    }
                  } else {
                    // If type 15 is an airport itself, we don't need to map it (and the data is generally wrong)
                    isLegMappable = false;
                  }
                  break;
                case LegType.DF:
                case LegType.TF:
                  // Only map if the fix is itself not a runway fix to avoid double
                  // adding runway fixes
                  if (currentLeg.fixIcao === '' || currentLeg.fixIcao[0] !== 'R') {
                    mappedLeg = this.mapExactFix(currentLeg);
                  } else {
                    isLegMappable = false;
                  }
                  break;
                case LegType.RF:
                  mappedLeg = this.mapRadiusToFix(currentLeg);
                  break;
                case LegType.CA:
                case LegType.VA:
                  mappedLeg = this.mapHeadingUntilAltitude(currentLeg, this._previousFix);
                  break;
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                  mappedLeg = this.mapHold(currentLeg);
                  break;
                default:
                  isLegMappable = false;
                  break;
              }
            } catch (err) {
              console.log("LegsProcedure: Unexpected unmappable leg: ".concat(err));
            }
            if (mappedLeg !== undefined) {
              const magCorrection = this.getMagCorrection(currentLeg);
              if (this.approachType === ApproachType.APPROACH_TYPE_ILS && (currentLeg.fixTypeFlags & FixTypeFlags.FAF) > 0) {
                if (currentLeg.altDesc === AltitudeDescriptor.At) {
                  mappedLeg.legAltitudeDescription = AltitudeDescriptor.G;
                } else {
                  mappedLeg.legAltitudeDescription = AltitudeDescriptor.H;
                }
              } else {
                mappedLeg.legAltitudeDescription = currentLeg.altDesc;
              }
              mappedLeg.legAltitude1 = currentLeg.altitude1 * 3.28084;
              mappedLeg.legAltitude2 = currentLeg.altitude2 * 3.28084;
              mappedLeg.speedConstraint = currentLeg.speedRestriction;
              mappedLeg.turnDirection = currentLeg.turnDirection;
              const recNavaid = this._facilities.get(currentLeg.originIcao);
              mappedLeg.additionalData.legType = currentLeg.type;
              mappedLeg.additionalData.overfly = currentLeg.flyOver;
              mappedLeg.additionalData.fixTypeFlags = currentLeg.fixTypeFlags;
              mappedLeg.additionalData.distance = currentLeg.distanceMinutes ? undefined : currentLeg.distance / 1852;
              mappedLeg.additionalData.distanceInMinutes = currentLeg.distanceMinutes ? currentLeg.distance : undefined;
              mappedLeg.additionalData.course = currentLeg.trueDegrees ? currentLeg.course : B77HS_Util.magneticToTrue(currentLeg.course, magCorrection);
              mappedLeg.additionalData.recommendedIcao = currentLeg.originIcao.trim().length > 0 ? currentLeg.originIcao : undefined;
              mappedLeg.additionalData.recommendedFrequency = recNavaid ? recNavaid.freqMHz : undefined;
              mappedLeg.additionalData.recommendedLocation = recNavaid ? {
                lat: recNavaid.lat,
                long: recNavaid.lon
              } : undefined;
              mappedLeg.additionalData.rho = currentLeg.rho / 1852;
              mappedLeg.additionalData.theta = currentLeg.theta;
              mappedLeg.additionalData.thetaTrue = B77HS_Util.magneticToTrue(currentLeg.theta, magCorrection);
              mappedLeg.additionalData.annotation = currentAnnotation;
              mappedLeg.additionalData.verticalAngle = currentLeg.verticalAngle ? currentLeg.verticalAngle - 360 : undefined;
            }
            this._currentIndex++;
          }
        }
        if (mappedLeg !== undefined) {
          this._previousFix = mappedLeg;
          return mappedLeg;
        }
        return undefined;
      }
      getMagCorrection(currentLeg) {
        // we try to interpret PANS OPs as accurately as possible within the limits of available data

        // magnetic tracks to/from a VOR always use VOR station declination
        if (currentLeg.fixIcao.charAt(0) === 'V') {
          const vor = this.getLoadedFacility(currentLeg.fixIcao);
          if (!vor || vor.magneticVariation === undefined) {
            console.warn('Leg coded incorrectly (missing vor fix or station declination)', currentLeg, vor);
            return this.airportMagVar;
          }
          return 360 - vor.magneticVariation;
        }

        // we use station declination for VOR/DME approaches
        if (this.approachType === ApproachType.APPROACH_TYPE_VORDME) {
          // find a leg with the reference navaid for the procedure
          for (let i = this._legs.length - 1; i >= 0; i--) {
            if (this._legs[i].originIcao.trim().length > 0) {
              const recNavaid = this.getLoadedFacility(this._legs[i].originIcao);
              if (recNavaid && recNavaid.magneticVariation !== undefined) {
                return 360 - recNavaid.magneticVariation;
              }
            }
          }
          console.warn('VOR/DME approach coded incorrectly (missing recommended navaid or station declination)', currentLeg);
          return this.airportMagVar;
        }

        // for RNAV procedures use recommended navaid station declination for these leg types
        let useStationDeclination = currentLeg.type === LegType.CF || currentLeg.type === LegType.FA || currentLeg.type === LegType.FM;

        // for localiser bearings (i.e. at or beyond FACF), always use airport value
        if (this.approachType === ApproachType.APPROACH_TYPE_ILS || this.approachType === ApproachType.APPROACH_TYPE_LOCALIZER) {
          useStationDeclination = useStationDeclination && this._legs.indexOf(currentLeg) < this.getFacfIndex();
        }
        if (useStationDeclination) {
          const recNavaid = this.getLoadedFacility(currentLeg.originIcao);
          if (!recNavaid || recNavaid.magneticVariation === undefined) {
            console.warn('Leg coded incorrectly (missing recommended navaid or station declination)', currentLeg, recNavaid);
            return this.airportMagVar;
          }
          return 360 - recNavaid.magneticVariation;
        }

        // for all other terminal procedure legs we use airport magnetic variation
        return this.airportMagVar;
      }
      getLoadedFacility(icao) {
        const facility = this._facilities.get(icao);
        if (!facility) {
          throw new Error("Failed to load facility: ".concat(icao));
        }
        return facility;
      }
      getFacfIndex() {
        if (this.approachType !== undefined) {
          for (let i = this._legs.length - 1; i >= 0; i--) {
            if (this._legs[i].fixTypeFlags & FixTypeFlags.IF) {
              return i;
            }
          }
        }
        return undefined;
      }

      /**
       * Maps a heading until distance from origin leg.
       * @param leg The procedure leg to map.
       * @param prevLeg The previously mapped waypoint in the procedure.
       * @returns The mapped leg.
       */
      mapHeadingUntilDistanceFromOrigin(leg, prevLeg) {
        const origin = this.getLoadedFacility(leg.originIcao);
        const originIdent = origin.icao.substring(7, 12).trim();
        const bearingToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
        const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon)) / LegsProcedure.distanceNormalFactorNM;
        const deltaAngle = this.deltaAngleRadians(bearingToOrigin, leg.course);
        const targetDistance = leg.distance / 1852 / LegsProcedure.distanceNormalFactorNM;
        const distanceAngle = Math.asin(Math.sin(distanceToOrigin) * Math.sin(deltaAngle) / Math.sin(targetDistance));
        const inverseDistanceAngle = Math.PI - distanceAngle;
        const legDistance1 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + distanceAngle)) / Math.sin(0.5 * (deltaAngle - distanceAngle))));
        const legDistance2 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + inverseDistanceAngle)) / Math.sin(0.5 * (deltaAngle - inverseDistanceAngle))));
        const legDistance = targetDistance > distanceToOrigin ? legDistance1 : Math.min(legDistance1, legDistance2);
        const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, legDistance * LegsProcedure.distanceNormalFactorNM, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const waypoint = this.buildWaypoint("".concat(originIdent.substring(0, 3), "/").concat(Math.round(leg.distance / 1852).toString().padStart(2, '0')), coordinates);
        return waypoint;
      }

      /**
       * Maps an FC or FD leg in the procedure.
       * @note FC and FD legs are mapped to CF legs in the real FMS
       * @todo move the code into the CF leg (maybe static functions fromFc and fromFd to construct the leg)
       * @todo FD should overfly the termination... needs a messy refactor to do that
       * @param leg The procedure leg to map.
       * @returns The mapped leg.
       */
      mapBearingAndDistanceFromOrigin(leg) {
        const origin = this.getLoadedFacility(leg.fixIcao);
        const originIdent = origin.icao.substring(7, 12).trim();
        const course = leg.trueDegrees ? leg.course : B77HS_Util.magneticToTrue(leg.course, Facilities.getMagVar(origin.lat, origin.lon));
        // this is the leg length for FC, and the DME distance for FD
        const refDistance = leg.distance / 1852;
        let termPoint;
        let legLength;
        if (leg.type === LegType.FD) {
          const recNavaid = this.getLoadedFacility(leg.originIcao);
          termPoint = firstSmallCircleIntersection({
            lat: recNavaid.lat,
            long: recNavaid.lon
          }, refDistance, {
            lat: origin.lat,
            long: origin.lon
          }, course);
          legLength = Avionics.Utils.computeGreatCircleDistance({
            lat: origin.lat,
            long: origin.lon
          }, termPoint);
        } else {
          // FC
          termPoint = Avionics.Utils.bearingDistanceToCoordinates(course, refDistance, origin.lat, origin.lon);
          legLength = refDistance;
        }
        return this.buildWaypoint("".concat(originIdent.substring(0, 3), "/").concat(Math.round(legLength).toString().padStart(2, '0')), termPoint);
      }

      /**
       * Maps a radial on the origin for a specified distance leg in the procedure.
       * @param leg The procedure leg to map.
       * @param prevLeg The previously mapped leg.
       * @returns The mapped leg.
       */
      mapOriginRadialForDistance(leg, prevLeg) {
        if (leg.fixIcao.trim() !== '') {
          return this.mapExactFix(leg);
        }
        const origin = this.getLoadedFacility(leg.originIcao);
        const originIdent = origin.icao.substring(7, 12).trim();
        const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, leg.distance / 1852, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const distanceFromOrigin = Avionics.Utils.computeGreatCircleDistance(new LatLongAlt(origin.lat, origin.lon), coordinates);
        return this.buildWaypoint("".concat(originIdent).concat(Math.trunc(distanceFromOrigin / 1852)), coordinates);
      }

      /**
       * Maps a heading turn to intercept the next leg in the procedure.
       * @param leg The procedure leg to map.
       * @param prevLeg The previously mapped leg.
       * @param nextLeg The next leg in the procedure to intercept.
       * @returns The mapped leg.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      mapHeadingToInterceptNextLeg(leg, prevLeg, nextLeg) {
        const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const course = leg.trueDegrees ? leg.course : B77HS_Util.magneticToTrue(leg.course, magVar);
        const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
        const waypoint = this.buildWaypoint(FixNamingScheme.courseToIntercept(course), coordinates, prevLeg.infos.magneticVariation);
        return waypoint;
      }

      /**
       * Maps flying a heading until crossing a radial of a reference fix.
       * @param leg The procedure leg to map.
       * @param prevLeg The previously mapped leg.
       * @returns The mapped leg.
       */
      mapHeadingUntilRadialCrossing(leg, prevLeg) {
        const origin = this.getLoadedFacility(leg.originIcao);
        const originCoordinates = new LatLongAlt(origin.lat, origin.lon);
        const originToCoordinates = Avionics.Utils.computeGreatCircleHeading(originCoordinates, prevLeg.infos.coordinates);
        const coordinatesToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
        const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, originCoordinates) / LegsProcedure.distanceNormalFactorNM;
        const alpha = this.deltaAngleRadians(coordinatesToOrigin, leg.course);
        const beta = this.deltaAngleRadians(originToCoordinates, leg.theta);
        const gamma = Math.acos(Math.sin(alpha) * Math.sin(beta) * Math.cos(distanceToOrigin) - Math.cos(alpha) * Math.cos(beta));
        const legDistance = Math.acos((Math.cos(beta) + Math.cos(alpha) * Math.cos(gamma)) / (Math.sin(alpha) * Math.sin(gamma)));
        const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const course = leg.trueDegrees ? leg.course : B77HS_Util.magneticToTrue(leg.course, magVar);
        const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, legDistance * LegsProcedure.distanceNormalFactorNM, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const waypoint = this.buildWaypoint("".concat(this.getIdent(origin.icao)).concat(leg.theta), coordinates);
        return waypoint;
      }

      /**
       * Maps flying a heading until a proscribed altitude.
       * @param leg The procedure leg to map.
       * @param prevLeg The previous leg in the procedure.
       * @returns The mapped leg.
       */
      mapHeadingUntilAltitude(leg, prevLeg) {
        const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const course = leg.trueDegrees ? leg.course : B77HS_Util.magneticToTrue(leg.course, magVar);
        // const heading = leg.trueDegrees ? B77HS_Util.trueToMagnetic(leg.course, magVar) : leg.course;
        const altitudeFeet = leg.altitude1 * 3.2808399;
        const distanceInNM = altitudeFeet / 500.0;
        const coordinates = GeoMath.relativeBearingDistanceToCoords(course, distanceInNM, prevLeg.infos.coordinates);
        const waypoint = this.buildWaypoint(FixNamingScheme.headingUntilAltitude(altitudeFeet), coordinates, prevLeg.infos.magneticVariation);
        waypoint.additionalData.vectorsAltitude = altitudeFeet;
        return waypoint;
      }

      /**
       * Maps a vectors instruction.
       * @param leg The procedure leg to map.
       * @param prevLeg The previous leg in the procedure.
       * @returns The mapped leg.
       */
      mapVectors(leg, prevLeg) {
        const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
        const course = leg.trueDegrees ? leg.course : B77HS_Util.magneticToTrue(leg.course, magVar);
        // const heading = leg.trueDegrees ? B77HS_Util.trueToMagnetic(leg.course, magVar) : leg.course;
        const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
        const waypoint = this.buildWaypoint(FixNamingScheme.vector(), coordinates);
        waypoint.isVectors = true;
        waypoint.endsInDiscontinuity = true;
        waypoint.discontinuityCanBeCleared = false;
        return waypoint;
      }

      /**
       * Maps an exact fix leg in the procedure.
       * @param leg The procedure leg to map.
       * @returns The mapped leg.
       */
      mapExactFix(leg) {
        const facility = this.getLoadedFacility(leg.fixIcao);
        return RawDataMapper.toWaypoint(facility, this._instrument);
      }

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      mapArcToFix(leg, prevLeg) {
        const toFix = this.getLoadedFacility(leg.fixIcao);
        const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
        return waypoint;
      }
      mapRadiusToFix(leg) {
        const arcCentreFix = this.getLoadedFacility(leg.arcCenterFixIcao);
        const arcCenterCoordinates = new LatLongAlt(arcCentreFix.lat, arcCentreFix.lon, 0);
        const toFix = this.getLoadedFacility(leg.fixIcao);
        const toCoordinates = new LatLongAlt(toFix.lat, toFix.lon, 0);
        const radius = Avionics.Utils.computeGreatCircleDistance(arcCenterCoordinates, toCoordinates);
        const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
        waypoint.additionalData.radius = radius;
        waypoint.additionalData.center = arcCenterCoordinates;
        return waypoint;
      }
      mapHold(leg) {
        const facility = this.getLoadedFacility(leg.fixIcao);
        const waypoint = RawDataMapper.toWaypoint(facility, this._instrument);
        const magVar = Facilities.getMagVar(facility.lat, facility.lon);
        waypoint.additionalData.defaultHold = {
          inboundMagneticCourse: leg.trueDegrees ? B77HS_Util.trueToMagnetic(leg.course, magVar) : leg.course,
          turnDirection: leg.turnDirection,
          distance: leg.distanceMinutes ? undefined : leg.distance / 1852,
          time: leg.distanceMinutes ? leg.distance : undefined,
          type: HoldType.Database
        };
        waypoint.additionalData.modifiedHold = {};
        return waypoint;
      }

      /**
       * Gets the difference between two headings in zero north normalized radians.
       * @param a The degrees of heading a.
       * @param b The degrees of heading b.
       * @returns The difference between the two headings in zero north normalized radians.
       */
      deltaAngleRadians(a, b) {
        return Math.abs((Avionics.Utils.fmod(a - b + 180, 360) - 180) * Avionics.Utils.DEG2RAD);
      }

      /**
       * Gets an ident from an ICAO.
       * @param icao The icao to pull the ident from.
       * @returns The parsed ident.
       */
      getIdent(icao) {
        return icao.substring(7, 12).trim();
      }

      /**
       * Checks if an ICAO is valid to load.
       * @param icao The icao to check.
       * @returns Whether or not the ICAO is valid.
       */
      isIcaoValid(icao) {
        for (const rule of this.legFilteringRules) {
          if (!rule(icao)) {
            return false;
          }
        }
        return true;
      }

      /**
       * Builds a WayPoint from basic data.
       * @param ident The ident of the waypoint.
       * @param coordinates The coordinates of the waypoint.
       * @param magneticVariation The magnetic variation of the waypoint, if any.
       * @returns The built waypoint.
       */
      buildWaypoint(ident, coordinates, magneticVariation) {
        const waypoint = new WayPoint(this._instrument);
        waypoint.type = 'W';
        waypoint.infos = new IntersectionInfo(this._instrument);
        waypoint.infos.coordinates = coordinates;
        waypoint.infos.magneticVariation = magneticVariation;
        waypoint.ident = ident;
        waypoint.infos.ident = ident;
        waypoint.additionalData = {};
        return waypoint;
      }
    }
    _defineProperty$2(LegsProcedure, "distanceNormalFactorNM", 21639 / 2 * Math.PI);

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    /**
     * The details of procedures selected in the flight plan.
     */
    class ProcedureDetails {
      constructor() {
        _defineProperty$2(this, "originRunwayIndex", -1);
        _defineProperty$2(this, "departureIndex", -1);
        _defineProperty$2(this, "departureTransitionIndex", -1);
        _defineProperty$2(this, "departureRunwayIndex", -1);
        _defineProperty$2(this, "arrivalIndex", -1);
        _defineProperty$2(this, "arrivalTransitionIndex", -1);
        _defineProperty$2(this, "arrivalRunwayIndex", -1);
        _defineProperty$2(this, "approachIndex", -1);
        _defineProperty$2(this, "approachTransitionIndex", -1);
        _defineProperty$2(this, "destinationRunwayIndex", -1);
        _defineProperty$2(this, "destinationRunwayExtension", -1);
        _defineProperty$2(this, "approachType", void 0);
      }
    }

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    /**
     * Creating a new waypoint to be added to a flight plan.
     */
    class WaypointBuilder {
      /**
      * Builds a WayPoint from basic data.
      * @param ident The ident of the waypoint to be created.
      * @param coordinates The coordinates of the waypoint.
      * @param instrument The base instrument instance.
      * @returns The built waypoint.
      */
      static fromCoordinates(ident, coordinates, instrument, additionalData, icao) {
        const waypoint = new WayPoint(instrument);
        waypoint.type = 'W';
        waypoint.infos = new IntersectionInfo(instrument);
        waypoint.infos.coordinates = coordinates;
        waypoint.ident = ident;
        waypoint.infos.ident = ident;
        waypoint.icao = icao !== null && icao !== void 0 ? icao : "W      ".concat(ident);
        waypoint.infos.icao = waypoint.icao;
        waypoint.additionalData = additionalData !== null && additionalData !== void 0 ? additionalData : {};
        return waypoint;
      }

      /**
      * Builds a WayPoint from a refrence waypoint.
      * @param ident The ident of the waypoint to be created.
      * @param placeCoordinates The coordinates of the reference waypoint.
      * @param bearing The bearing from the reference waypoint.
      * @param distance The distance from the reference waypoint.
      * @param instrument The base instrument instance.
      * @returns The built waypoint.
      */
      static fromPlaceBearingDistance(ident, placeCoordinates, bearing, distance, instrument) {
        let magneticBearing = bearing + GeoMath.getMagvar(placeCoordinates.lat, placeCoordinates.long);
        magneticBearing = magneticBearing < 0 ? 360 + magneticBearing : magneticBearing;
        const coordinates = Avionics.Utils.bearingDistanceToCoordinates(magneticBearing, distance, placeCoordinates.lat, placeCoordinates.long);
        return WaypointBuilder.fromCoordinates(ident, coordinates, instrument);
      }

      /**
      * Builds a WayPoint at a distance from an existing waypoint along the flight plan.
      * @param ident The ident of the waypoint to be created.
      * @param placeIndex The index of the reference waypoint in the flight plan.
      * @param distance The distance from the reference waypoint.
      * @param instrument The base instrument instance.
      * @param fpm The flightplanmanager instance.
      * @returns The built waypoint.
      */
      static fromPlaceAlongFlightPlan(ident, placeIndex, distance, instrument, fpm) {
        console.log('running fromPlaceAlongFlightPlan');
        console.log("destination? ".concat(fpm.getDestination()) ? 'True' : 'False');
        const destinationDistanceInFlightplan = fpm.getDestination().cumulativeDistanceInFP;
        console.log("destinationDistanceInFlightplan ".concat(destinationDistanceInFlightplan));
        const placeDistanceFromDestination = fpm.getWaypoint(placeIndex, 0, true).cumulativeDistanceInFP;
        console.log("placeDistanceFromDestination ".concat(placeDistanceFromDestination));
        const distanceFromDestination = destinationDistanceInFlightplan - placeDistanceFromDestination - distance;
        console.log("distanceFromDestination ".concat(distanceFromDestination));
        const coordinates = fpm.getCoordinatesAtNMFromDestinationAlongFlightPlan(distanceFromDestination);
        return WaypointBuilder.fromCoordinates(ident, coordinates, instrument);
      }
      static fromWaypointManualHold(waypoint, holdDirection, inboundCourse, holdLength, holdTime, instrument) {
        const newWaypoint = WaypointBuilder.fromCoordinates(waypoint.ident, waypoint.infos.coordinates, instrument);
        newWaypoint.icao = waypoint.icao;
        newWaypoint.infos = waypoint.infos;
        newWaypoint.additionalData.legType = LegType.HM;
        newWaypoint.turnDirection = holdDirection;
        newWaypoint.additionalData.course = inboundCourse;
        newWaypoint.additionalData.distance = holdLength;
        newWaypoint.additionalData.distanceInMinutes = holdTime;
        newWaypoint.speedConstraint = waypoint.speedConstraint;
        newWaypoint.legAltitudeDescription = waypoint.legAltitudeDescription;
        newWaypoint.legAltitude1 = waypoint.legAltitude1;
        newWaypoint.legAltitude2 = waypoint.legAltitude2;
        newWaypoint.additionalData.constraintType = waypoint.additionalData.constraintType;
        return newWaypoint;
      }
    }

    /**
     * A flight plan managed by the FlightPlanManager.
     */
    class ManagedFlightPlan {
      constructor() {
        _defineProperty$2(this, "originAirfield", void 0);
        _defineProperty$2(this, "persistentOriginAirfield", void 0);
        _defineProperty$2(this, "originTransitionAltitudeDb", void 0);
        _defineProperty$2(this, "originTransitionAltitudePilot", void 0);
        _defineProperty$2(this, "destinationAirfield", void 0);
        _defineProperty$2(this, "destinationTransitionLevelDb", void 0);
        _defineProperty$2(this, "destinationTransitionLevelPilot", void 0);
        _defineProperty$2(this, "cruiseAltitude", 0);
        _defineProperty$2(this, "activeWaypointIndex", 0);
        _defineProperty$2(this, "procedureDetails", new ProcedureDetails());
        _defineProperty$2(this, "directTo", new DirectTo());
        _defineProperty$2(this, "turningPointIndex", 0);
        _defineProperty$2(this, "_parentInstrument", void 0);
        _defineProperty$2(this, "_segments", [new FlightPlanSegment(SegmentType.Enroute, 0, [])]);
      }
      /** The departure segment of the flight plan. */
      get departure() {
        return this.getSegment(SegmentType.Departure);
      }

      /** The enroute segment of the flight plan. */
      get enroute() {
        return this.getSegment(SegmentType.Enroute);
      }

      /** The arrival segment of the flight plan. */
      get arrival() {
        return this.getSegment(SegmentType.Arrival);
      }

      /** The approach segment of the flight plan. */
      get approach() {
        return this.getSegment(SegmentType.Approach);
      }

      /** The approach segment of the flight plan. */
      get missed() {
        return this.getSegment(SegmentType.Missed);
      }

      /** Whether the flight plan has an origin airfield. */
      get hasOrigin() {
        return this.originAirfield;
      }

      /** Whether the flight plan has a persistent origin airfield. */
      get hasPersistentOrigin() {
        return this.persistentOriginAirfield;
      }

      /** Whether the flight plan has a destination airfield. */
      get hasDestination() {
        return this.destinationAirfield;
      }

      /** The currently active waypoint. */
      get activeWaypoint() {
        return this.waypoints[this.activeWaypointIndex];
      }

      /**
       * Returns a list of {@link WaypointStats} for the waypoints in the flight plan
       *
       * @return {WaypointStats[]} array of statistics for the waypoints in the flight plan, with matching indices to
       *                           flight plan waypoints
       */
      computeWaypointStatistics(ppos) {
        // TODO this should be moved into its own dedicated module

        const stats = new Map();
        const firstData = this.computeActiveWaypointStatistics(ppos);
        stats.set(this.activeWaypointIndex, firstData);
        this.waypoints.slice(0).forEach((waypoint, index) => {
          var _firstData$distanceFr, _this$activeWaypoint$, _this$activeWaypoint;
          // TODO redo when we have a better solution for vector legs
          const firstDistFromPpos = (_firstData$distanceFr = firstData === null || firstData === void 0 ? void 0 : firstData.distanceFromPpos) !== null && _firstData$distanceFr !== void 0 ? _firstData$distanceFr : 0;
          const activeWpCumulativeDist = (_this$activeWaypoint$ = (_this$activeWaypoint = this.activeWaypoint) === null || _this$activeWaypoint === void 0 ? void 0 : _this$activeWaypoint.cumulativeDistanceInFP) !== null && _this$activeWaypoint$ !== void 0 ? _this$activeWaypoint$ : 0;
          const distPpos = waypoint.isVectors ? 1 : waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos;
          const data = {
            ident: waypoint.ident,
            bearingInFp: waypoint.bearingInFP,
            distanceInFP: waypoint.distanceInFP,
            distanceFromPpos: distPpos,
            timeFromPpos: this.computeWaypointTime(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos),
            etaFromPpos: this.computeWaypointEta(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos)
          };
          stats.set(index, data);
        });
        return stats;
      }

      /**
       * Returns info for the currently active waypoint, to be displayed by the Navigation Display
       */
      computeActiveWaypointStatistics(ppos) {
        // TODO this should be moved into its own dedicated module

        if (!this.activeWaypoint) {
          return undefined;
        }
        const bearingInFp = Avionics.Utils.computeGreatCircleHeading(ppos, this.activeWaypoint.infos.coordinates);
        let distanceFromPpos;
        if (Number.isNaN(ppos.lat) || Number.isNaN(ppos.long)) {
          distanceFromPpos = this.activeWaypoint.distanceInFP;
        } else if (this.activeWaypoint.isVectors) {
          // TODO redo when we have a better solution for vector legs
          distanceFromPpos = 1;
        } else {
          distanceFromPpos = Avionics.Utils.computeGreatCircleDistance(ppos, this.activeWaypoint.infos.coordinates);
        }
        const timeFromPpos = this.computeWaypointTime(distanceFromPpos);
        const etaFromPpos = this.computeWaypointEta(distanceFromPpos, timeFromPpos);
        return {
          ident: this.activeWaypoint.ident,
          bearingInFp,
          distanceInFP: this.activeWaypoint.distanceInFP,
          distanceFromPpos,
          timeFromPpos,
          etaFromPpos,
          magneticVariation: GeoMath.getMagvar(this.activeWaypoint.infos.coordinates.lat, this.activeWaypoint.infos.coordinates.long)
        };
      }

      // TODO is this accurate? Logic is same like in the old FPM
      computeWaypointTime(distance) {
        const groundSpeed = Simplane.getGroundSpeed();
        if (groundSpeed < 100) {
          return distance / 400 * 3600;
        }
        return distance / groundSpeed * 3600;
      }
      computeWaypointEta(distance, preComputedTime) {
        const eta = preComputedTime !== null && preComputedTime !== void 0 ? preComputedTime : this.computeWaypointTime(distance);
        const utcTime = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds');
        return eta + utcTime;
      }

      /** The parent instrument this flight plan is attached to locally. */

      /** The waypoints of the flight plan. */
      get waypoints() {
        const waypoints = [];
        if (this.originAirfield) {
          waypoints.push(this.originAirfield);
        }
        for (const segment of this._segments) {
          waypoints.push(...segment.waypoints);
        }
        if (this.destinationAirfield) {
          waypoints.push(this.destinationAirfield);
        }
        return waypoints;
      }

      /**
       * Gets all the waypoints that are currently visible and part of the routing.
       *
       * This is used to obtain the list of waypoints to display after a DIRECT TO.
       */
      get visibleWaypoints() {
        const allWaypoints = this.waypoints;
        if (this.directTo.isActive) {
          const directToWaypointIndex = this.directTo.planWaypointIndex;
          return allWaypoints.slice(Math.max(this.activeWaypointIndex - 1, directToWaypointIndex), allWaypoints.length - 1);
        }
        return allWaypoints.slice(this.activeWaypointIndex - 1, allWaypoints.length);
      }
      get activeVisibleWaypointIndex() {
        if (this.directTo.isActive) {
          const directToWaypointIndex = this.directTo.planWaypointIndex;
          return this.activeWaypointIndex - 1 > directToWaypointIndex ? 1 : 0;
        }
        return 1;
      }
      get segments() {
        return this._segments;
      }

      /** The length of the flight plan. */
      get length() {
        const lastSeg = this._segments[this._segments.length - 1];
        return lastSeg.offset + lastSeg.waypoints.length + (this.hasDestination ? 1 : 0);
      }
      get checksum() {
        let checksum = 0;
        const {
          waypoints
        } = this;
        for (let i = 0; i < waypoints.length; i++) checksum += waypoints[i].infos.coordinates.lat;
        return checksum;
      }

      /** The non-approach waypoints of the flight plan. */
      get nonApproachWaypoints() {
        const waypoints = [];
        if (this.originAirfield) {
          waypoints.push(this.originAirfield);
        }
        for (const segment of this._segments.filter(s => s.type < SegmentType.Approach)) {
          waypoints.push(...segment.waypoints);
        }
        if (this.destinationAirfield) {
          waypoints.push(this.destinationAirfield);
        }
        return waypoints;
      }

      /**
       * Sets the parent instrument that the flight plan is attached to locally.
       * @param instrument The instrument that the flight plan is attached to.
       */
      setParentInstrument(instrument) {
        this._parentInstrument = instrument;
      }

      /**
       * Clears the flight plan.
       */
      async clearPlan() {
        this.originAirfield = undefined;
        this.originTransitionAltitudeDb = undefined;
        this.originTransitionAltitudePilot = undefined;
        this.persistentOriginAirfield = undefined;
        this.destinationAirfield = undefined;
        this.destinationTransitionLevelDb = undefined;
        this.destinationTransitionLevelPilot = undefined;
        this.cruiseAltitude = 0;
        this.activeWaypointIndex = 0;
        this.procedureDetails = new ProcedureDetails();
        this.directTo = new DirectTo();
        await GPS.clearPlan().catch(console.error);
        this._segments = [new FlightPlanSegment(SegmentType.Enroute, 0, [])];
      }

      /**
       * Syncs the flight plan to FS9GPS.
       */
      async syncToGPS() {
        await GPS.clearPlan().catch(console.error);
        for (let i = 0; i < this.waypoints.length; i++) {
          const waypoint = this.waypoints[i];
          if (waypoint.icao && waypoint.icao.trim() !== '') {
            GPS.addIcaoWaypoint(waypoint.icao, i).catch(console.error);
          } else {
            GPS.addUserWaypoint(waypoint.infos.coordinates.lat, waypoint.infos.coordinates.long, i, waypoint.ident).catch(console.error);
          }
          if (waypoint.endsInDiscontinuity) {
            break;
          }
        }
        await GPS.setActiveWaypoint(this.activeWaypointIndex).catch(console.error);
        await GPS.logCurrentPlan().catch(console.error);
      }

      /**
       * Adds a waypoint to the flight plan.
       *
       * @param waypoint    The waypoint to add
       *
       * @param index       The index to add the waypoint at. If omitted the waypoint will
       *                    be appended to the end of the flight plan.
       *
       * @param segmentType The type of segment to add the waypoint to
       * @returns The index the waypoint was actually inserted at
       */
      addWaypoint(waypoint, index, segmentType) {
        console.log("addWaypoint ".concat(waypoint.icao, ", ").concat(index, ", ").concat(SegmentType[segmentType]), waypoint);
        const mappedWaypoint = waypoint instanceof WayPoint ? waypoint : RawDataMapper.toWaypoint(waypoint, this._parentInstrument);
        if (mappedWaypoint.type === 'A' && index === 0) {
          mappedWaypoint.endsInDiscontinuity = true;
          mappedWaypoint.discontinuityCanBeCleared = true;
          this.originAirfield = mappedWaypoint;
          this.persistentOriginAirfield = mappedWaypoint;
          this.procedureDetails.departureIndex = -1;
          this.procedureDetails.departureRunwayIndex = -1;
          this.procedureDetails.departureTransitionIndex = -1;
          this.procedureDetails.originRunwayIndex = -1;
          this.reflowSegments();
          this.reflowDistances();
        } else if (mappedWaypoint.type === 'A' && index === undefined) {
          this.destinationAirfield = mappedWaypoint;
          this.procedureDetails.arrivalIndex = -1;
          this.procedureDetails.arrivalRunwayIndex = -1;
          this.procedureDetails.arrivalTransitionIndex = -1;
          this.procedureDetails.approachIndex = -1;
          this.procedureDetails.approachTransitionIndex = -1;
          const previousWp = this.waypoints[this.waypoints.length - 2];
          if (previousWp) {
            previousWp.endsInDiscontinuity = true;
            previousWp.discontinuityCanBeCleared = true;
          }
          this.reflowSegments();
          this.reflowDistances();
        } else {
          let segment;
          if (segmentType !== undefined) {
            segment = this.getSegment(segmentType);
            if (segment === FlightPlanSegment.Empty) {
              segment = this.addSegment(segmentType);
            }
          } else {
            segment = this.findSegmentByWaypointIndex(index);
            if (segment === FlightPlanSegment.Empty) {
              throw new Error('ManagedFlightPlan::addWaypoint: no segment found!');
            }
          }

          // hitting first waypoint in segment > enroute
          if (segment.type > SegmentType.Enroute && index === segment.offset) {
            const segIdx = this._segments.findIndex(seg => seg.type === segment.type);
            // is prev segment enroute?
            const prevSeg = this._segments[segIdx - 1];
            if (prevSeg.type === SegmentType.Enroute) {
              segment = prevSeg;
            }
          }
          if (segment) {
            if (index > this.length) {
              index = undefined;
            }
            if (mappedWaypoint.additionalData.legType === undefined) {
              if (segment.waypoints.length < 1) {
                mappedWaypoint.additionalData.legType = LegType.IF;
              } else {
                mappedWaypoint.additionalData.legType = LegType.TF;
              }
            }
            if (index !== undefined) {
              const segmentIndex = index - segment.offset;
              if (segmentIndex < segment.waypoints.length) {
                segment.waypoints.splice(segmentIndex, 0, mappedWaypoint);
              } else {
                segment.waypoints.push(mappedWaypoint);
              }
            } else {
              segment.waypoints.push(mappedWaypoint);
            }
            this.reflowSegments();
            this.reflowDistances();
            const finalIndex = this.waypoints.indexOf(mappedWaypoint);
            const previousWp = finalIndex > 0 ? this.waypoints[finalIndex - 1] : undefined;

            // Transfer discontinuity forwards if previous waypoint has one and it can be cleared,
            // AND the new waypoint isn't the T-P of a direct to
            if (previousWp && previousWp.endsInDiscontinuity && !mappedWaypoint.isTurningPoint) {
              if (previousWp.discontinuityCanBeCleared === undefined || previousWp.discontinuityCanBeCleared) {
                previousWp.endsInDiscontinuity = false;
                previousWp.discontinuityCanBeCleared = undefined;

                // Don't mark the mapped waypoint's discontinuity as clearable if this is a MANUAL
                // TODO maybe extract this logic since we also use it when building a LegsProcedure
                mappedWaypoint.endsInDiscontinuity = true;
                if (!mappedWaypoint.isVectors) {
                  mappedWaypoint.discontinuityCanBeCleared = true;
                }
              }
            }
            if (this.activeWaypointIndex === 0 && this.length > 1) {
              this.activeWaypointIndex = 1;
            } else if (this.activeWaypointIndex === 1 && waypoint.isRunway && segment.type === SegmentType.Departure) {
              this.activeWaypointIndex = 2;
            }
            return finalIndex;
          }
        }
        return -1;
      }

      /**
       * Removes a waypoint from the flight plan.
       * @param index The index of the waypoint to remove.
       */
      removeWaypoint(index) {
        let noDiscontinuity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (this.originAirfield && index === 0) {
          this.originAirfield = undefined;
          this.reflowSegments();
          this.reflowDistances();
        } else if (this.destinationAirfield && index === this.length - 1) {
          this.destinationAirfield = undefined;
        } else {
          const segment = this.findSegmentByWaypointIndex(index);
          if (segment) {
            const spliced = segment.waypoints.splice(index - segment.offset, 1);
            console.log("removing waypoint ".concat(spliced[0].icao, " from segment ").concat(segment.type));
            if (segment.waypoints.length === 0 && segment.type !== SegmentType.Enroute) {
              console.log("removing segment ".concat(segment.type, " as length is 0"));
              this.removeSegment(segment.type);
            }
            this.reflowSegments();
            this.reflowDistances();
          }
        }

        // transfer a potential discontinuity backward
        const beforeRemoved = this.waypoints[index - 1];
        if (!noDiscontinuity && beforeRemoved && !beforeRemoved.endsInDiscontinuity) {
          beforeRemoved.endsInDiscontinuity = true;
          beforeRemoved.discontinuityCanBeCleared = true;
        }
        if (index < this.activeWaypointIndex || this.activeWaypointIndex === this.waypoints.length) {
          this.activeWaypointIndex--;
        }
      }

      /**
       * Gets a waypoint by index from the flight plan.
       * @param index The index of the waypoint to get.
       */
      getWaypoint(index) {
        if (this.originAirfield && index === 0) {
          return this.originAirfield;
        }
        if (this.destinationAirfield && index === this.length - 1) {
          return this.destinationAirfield;
        }
        const segment = this.findSegmentByWaypointIndex(index);
        if (segment) {
          return segment.waypoints[index - segment.offset];
        }
        return null;
      }
      setWaypointOverfly(index, value) {
        // FIXME origin airfield isn't necessarily index 0
        if (this.originAirfield && index === 0) {
          return;
        }

        // FIXME origin airfield isn't necessarily last index (never will be with missed approach)
        if (this.destinationAirfield && index === this.length - 1) {
          return;
        }
        const segment = this.findSegmentByWaypointIndex(index);
        if (segment) {
          segment.waypoints[index - segment.offset].additionalData.overfly = value;
        }
      }
      addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
        const atWaypoint = this.getWaypoint(index);
        if (!atWaypoint) {
          return 0;
        }
        const magVar = Facilities.getMagVar(atWaypoint.infos.coordinates.lat, atWaypoint.infos.coordinates.long);
        const trueCourse = B77HS_Util.magneticToTrue(desiredHold.inboundMagneticCourse, magVar);
        if (atWaypoint.additionalData.legType === LegType.HA || atWaypoint.additionalData.legType === LegType.HF || atWaypoint.additionalData.legType === LegType.HM) {
          atWaypoint.additionalData.legType = LegType.HM;
          atWaypoint.turnDirection = desiredHold.turnDirection;
          atWaypoint.additionalData.course = trueCourse;
          atWaypoint.additionalData.distance = desiredHold.distance;
          atWaypoint.additionalData.distanceInMinutes = desiredHold.time;
          atWaypoint.additionalData.modifiedHold = modifiedHold;
          if (atWaypoint.additionalData.defaultHold === undefined) {
            atWaypoint.additionalData.defaultHold = defaultHold;
          }
          return index;
        }
        const manualHoldWaypoint = WaypointBuilder.fromWaypointManualHold(atWaypoint, desiredHold.turnDirection, trueCourse, desiredHold.distance, desiredHold.time, this._parentInstrument);
        manualHoldWaypoint.additionalData.modifiedHold = modifiedHold;
        manualHoldWaypoint.additionalData.defaultHold = defaultHold;
        this.addWaypoint(manualHoldWaypoint, index + 1);
        return index + 1;
      }

      /**
       * Adds a plan segment to the flight plan.
       * @param type The type of the segment to add.
       */
      addSegment(type) {
        const segment = new FlightPlanSegment(type, 0, []);
        this._segments.push(segment);
        this._segments.sort((a, b) => a.type - b.type);
        this.reflowSegments();
        return segment;
      }

      /**
       * Removes a plan segment from the flight plan.
       * @param type The type of plan segment to remove.
       */
      removeSegment(type) {
        const segmentIndex = this._segments.findIndex(s => s.type === type);
        if (segmentIndex > -1) {
          this._segments.splice(segmentIndex, 1);
        }
      }

      /**
       * Reflows waypoint index offsets accross plans segments.
       */
      reflowSegments() {
        let index = 0;
        if (this.originAirfield) {
          index = 1;
        }
        for (const segment of this._segments) {
          segment.offset = index;
          index += segment.waypoints.length;
        }
      }

      /**
       * Gets a flight plan segment of the specified type.
       * @param type The type of flight plan segment to get.
       * @returns The found segment, or FlightPlanSegment.Empty if not found.
       */
      getSegment(type) {
        const segment = this._segments.find(s => s.type === type);
        return segment !== undefined ? segment : FlightPlanSegment.Empty;
      }

      /**
       * Finds a flight plan segment by waypoint index.
       * @param index The index of the waypoint to find the segment for.
       * @returns The located segment, if any.
       */
      findSegmentByWaypointIndex(index) {
        for (let i = 0; i < this._segments.length; i++) {
          const segMaxIdx = this._segments[i].offset + this._segments[i].waypoints.length;
          if (segMaxIdx > index) {
            return this._segments[i];
          }
        }
        return this._segments[this._segments.length - 1];
      }
      isLastWaypointInSegment(fpIndex) {
        const segment = this.findSegmentByWaypointIndex(fpIndex);
        if (fpIndex >= this.waypoints.length) {
          return false;
        }
        if (fpIndex === segment.offset + segment.waypoints.length - 1) {
          return true;
        }
        return false;
      }

      /**
       * Recalculates all waypoint bearings and distances in the flight plan.
       */
      reflowDistances() {
        let cumulativeDistance = 0;
        const {
          waypoints
        } = this;
        for (let i = 0; i < waypoints.length; i++) {
          if (i > 0) {
            // If there's an approach selected and this is the last approach waypoint, use the destination waypoint for coordinates
            // Runway waypoints do not have coordinates
            const referenceWaypoint = waypoints[i];
            const prevWaypoint = waypoints[i - 1];
            const trueCourseToWaypoint = Avionics.Utils.computeGreatCircleHeading(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
            referenceWaypoint.bearingInFP = trueCourseToWaypoint - GeoMath.getMagvar(prevWaypoint.infos.coordinates.lat, prevWaypoint.infos.coordinates.long);
            referenceWaypoint.bearingInFP = referenceWaypoint.bearingInFP < 0 ? 360 + referenceWaypoint.bearingInFP : referenceWaypoint.bearingInFP;
            if (prevWaypoint.endsInDiscontinuity && !prevWaypoint.discontinuityCanBeCleared) {
              referenceWaypoint.distanceInFP = 0;
            } else if (referenceWaypoint.additionalData) {
              switch (referenceWaypoint.additionalData.legType) {
                case 11:
                case 22:
                  referenceWaypoint.distanceInFP = 1;
                  break;
                default:
                  referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
                  break;
              }
            } else {
              referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
            }
            cumulativeDistance += referenceWaypoint.distanceInFP;
            referenceWaypoint.cumulativeDistanceInFP = cumulativeDistance;
          }
        }
      }

      /**
       * Copies a sanitized version of the flight plan for shared data storage.
       * @returns The sanitized flight plan.
       */
      serialize() {
        var _planCopy$directTo$in;
        const planCopy = new ManagedFlightPlan();
        const copyWaypoint = waypoint => ({
          icao: waypoint.icao,
          ident: waypoint.ident,
          type: waypoint.type,
          legAltitudeDescription: waypoint.legAltitudeDescription,
          legAltitude1: waypoint.legAltitude1,
          legAltitude2: waypoint.legAltitude2,
          speedConstraint: waypoint.speedConstraint,
          turnDirection: waypoint.turnDirection,
          isVectors: waypoint.isVectors,
          endsInDiscontinuity: waypoint.endsInDiscontinuity,
          discontinuityCanBeCleared: waypoint.discontinuityCanBeCleared,
          distanceInFP: waypoint.distanceInFP,
          cumulativeDistanceInFP: waypoint.cumulativeDistanceInFP,
          isRunway: waypoint.isRunway,
          additionalData: waypoint.additionalData,
          infos: {
            icao: waypoint.infos.icao,
            ident: waypoint.infos.ident,
            airwayIn: waypoint.infos.airwayIn,
            airwayOut: waypoint.infos.airwayOut,
            routes: waypoint.infos.routes,
            coordinates: {
              lat: waypoint.infos.coordinates.lat,
              long: waypoint.infos.coordinates.long,
              alt: waypoint.infos.coordinates.alt
            }
          }
        });
        const copyAirfield = airfield => {
          const copy = Object.assign(new WayPoint(undefined), airfield);
          copy.infos = Object.assign(new AirportInfo(undefined), copy.infos);
          delete copy.instrument;
          delete copy.infos.instrument;
          delete copy._svgElements;
          delete copy.infos._svgElements;
          return copy;
        };
        planCopy.activeWaypointIndex = this.activeWaypointIndex;
        planCopy.destinationAirfield = this.destinationAirfield && copyAirfield(this.destinationAirfield);
        planCopy.originAirfield = this.originAirfield && copyAirfield(this.originAirfield);
        planCopy.persistentOriginAirfield = this.persistentOriginAirfield && copyAirfield(this.persistentOriginAirfield);
        planCopy.procedureDetails = _objectSpread2({}, this.procedureDetails);
        planCopy.directTo = _objectSpread2({}, this.directTo);
        planCopy.directTo.interceptPoints = (_planCopy$directTo$in = planCopy.directTo.interceptPoints) === null || _planCopy$directTo$in === void 0 ? void 0 : _planCopy$directTo$in.map(w => copyWaypoint(w));
        const copySegments = [];
        for (const segment of this._segments) {
          const copySegment = new FlightPlanSegment(segment.type, segment.offset, []);
          for (const waypoint of segment.waypoints) {
            copySegment.waypoints.push(copyWaypoint(waypoint));
          }
          copySegments.push(copySegment);
        }
        planCopy._segments = copySegments;
        return planCopy;
      }

      /**
       * Copies the flight plan.
       * @returns The copied flight plan.
       */
      copy() {
        const newFlightPlan = Object.assign(new ManagedFlightPlan(), this);
        newFlightPlan.setParentInstrument(this._parentInstrument);
        newFlightPlan._segments = [];
        for (let i = 0; i < this._segments.length; i++) {
          const seg = this._segments[i];
          newFlightPlan._segments[i] = Object.assign(new FlightPlanSegment(seg.type, seg.offset, []), seg);
          newFlightPlan._segments[i].waypoints = [...seg.waypoints.map(wp => {
            const clone = new wp.constructor();
            Object.assign(clone, wp);
            clone.additionalData = _objectSpread2({}, wp.additionalData);
            return clone;
          })];
        }
        newFlightPlan.procedureDetails = Object.assign(new ProcedureDetails(), this.procedureDetails);
        newFlightPlan.directTo = Object.assign(new DirectTo(), this.directTo);
        newFlightPlan.directTo.interceptPoints = this.directTo.interceptPoints !== undefined ? [...this.directTo.interceptPoints] : undefined;
        return newFlightPlan;
      }

      /**
       * Reverses the flight plan.
       */
      reverse() {
        // TODO: Fix flight plan indexes after reversal
        // this._waypoints.reverse();
      }

      /**
       * Goes direct to the specified waypoint index in the flight plan.
       *
       * @param waypoint The waypoint to go direct to
       */
      async addDirectTo(waypoint) {
        // TODO Replace with aims pos
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
        const oldToWp = this.waypoints[this.activeWaypointIndex];
        const turningPoint = WaypointBuilder.fromCoordinates('T-P', new LatLongAlt(lat, long), this._parentInstrument, {
          legType: LegType.CF,
          course: trueTrack,
          dynamicPpos: true
        }, this.getTurningPointIcao());
        turningPoint.isTurningPoint = true;
        const waypointIndex = this.waypoints.findIndex((w, idx) => idx >= this.activeWaypointIndex && w.icao === waypoint.icao);
        if (waypointIndex === -1) {
          // in this case the waypoint is not already in the flight plan
          // we string it to the start of the flight plan, add a discontinuity after, and then the existing flight plan
          waypoint.endsInDiscontinuity = true;
          waypoint.discontinuityCanBeCleared = true;
          waypoint.additionalData.legType = LegType.DF;
          this.addWaypoint(waypoint, this.activeWaypointIndex);
          this.activeWaypointIndex = this.addWaypoint(turningPoint, this.activeWaypointIndex) + 1;

          // fix up the old leg that's now after the discont
          if (ManagedFlightPlan.isXfLeg(oldToWp)) {
            oldToWp.additionalData.legType = LegType.IF;
          }
        } else {
          // in this case the waypoint is already in the flight plan...
          // we can skip all the legs before it, and add our dir to
          const toWp = this.waypoints[waypointIndex];
          toWp.additionalData.legType = LegType.DF;
          toWp.turnDirection = 0;
          this.addWaypoint(turningPoint, waypointIndex);
          this.activeWaypointIndex = waypointIndex + 1;
        }
      }

      /**
       *
       * @param force force updating a turning point even if it's not marked dynamic
       */
      updateTurningPoint() {
        var _wp$additionalData;
        let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        const wp = this.getWaypoint(this.activeWaypointIndex - 1);
        if (wp !== null && wp !== void 0 && (_wp$additionalData = wp.additionalData) !== null && _wp$additionalData !== void 0 && _wp$additionalData.dynamicPpos || force && wp !== null && wp !== void 0 && wp.isTurningPoint) {
          wp.infos.coordinates.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
          wp.infos.coordinates.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
          wp.additionalData.course = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
          wp.icao = this.getTurningPointIcao();
          wp.infos.icao = wp.icao;
          console.log('updated T-P:', force, wp.additionalData, wp.infos.coordinates);
          return true;
        }
        return false;
      }
      getTurningPointIcao() {
        this.turningPointIndex = (this.turningPointIndex + 1) % 1000;
        return "WXX    TP".concat(this.turningPointIndex.toFixed(0).padStart(3, '0'));
      }

      /**
       * Builds a departure into the flight plan from indexes in the departure airport information.
       */
      async buildDeparture() {
        const legs = [];
        const legAnnotations = [];
        const origin = this.originAirfield;
        const {
          departureIndex
        } = this.procedureDetails;
        const runwayIndex = this.procedureDetails.departureRunwayIndex;
        const transitionIndex = this.procedureDetails.departureTransitionIndex;
        const selectedOriginRunwayIndex = this.procedureDetails.originRunwayIndex;
        const airportInfo = origin.infos;
        const airportMagVar = Facilities.getMagVar(airportInfo.coordinates.lat, airportInfo.coordinates.long);

        // Make origin fix an IF leg
        if (origin) {
          origin.additionalData.legType = LegType.IF;
          origin.endsInDiscontinuity = true;
          origin.discontinuityCanBeCleared = true;
          const departure = airportInfo.departures[departureIndex];
          if (departure) {
            origin.additionalData.annotation = departure.name;
          } else {
            origin.additionalData.annotation = '';
          }
        }

        // Set origin fix coordinates to runway beginning coordinates
        if (origin && selectedOriginRunwayIndex >= 0) {
          origin.infos.coordinates = airportInfo.oneWayRunways[selectedOriginRunwayIndex].beginningCoordinates;
          origin.additionalData.runwayElevation = airportInfo.oneWayRunways[selectedOriginRunwayIndex].elevation * 3.2808399;
          origin.additionalData.runwayLength = airportInfo.oneWayRunways[selectedOriginRunwayIndex].length;
        }
        if (departureIndex >= 0 && runwayIndex >= 0) {
          const runwayTransition = airportInfo.departures[departureIndex].runwayTransitions[runwayIndex];
          const departure = airportInfo.departures[departureIndex];
          if (runwayTransition) {
            legs.push(...runwayTransition.legs);
            legAnnotations.push(...runwayTransition.legs.map(_ => departure.name));
            origin.endsInDiscontinuity = false;
            origin.discontinuityCanBeCleared = undefined;
          }
        }
        if (departureIndex >= 0) {
          const departure = airportInfo.departures[departureIndex];
          legs.push(...departure.commonLegs);
          legAnnotations.push(...departure.commonLegs.map(_ => departure.name));
        }
        if (transitionIndex >= 0 && departureIndex >= 0) {
          if (airportInfo.departures[departureIndex].enRouteTransitions.length > 0) {
            const transition = airportInfo.departures[departureIndex].enRouteTransitions[transitionIndex];
            legs.push(...transition.legs);
            legAnnotations.push(...transition.legs.map(_ => transition.name));
          }
        }
        let segment = this.departure;
        if (segment !== FlightPlanSegment.Empty) {
          for (let i = 0; i < segment.waypoints.length; i++) {
            this.removeWaypoint(segment.offset);
          }
          this.removeSegment(segment.type);
        }
        if (legs.length > 0 || selectedOriginRunwayIndex >= 0 || departureIndex >= 0 && runwayIndex >= 0) {
          segment = this.addSegment(SegmentType.Departure);
          const procedure = new LegsProcedure(legs, origin, this._parentInstrument, airportMagVar, undefined, legAnnotations);
          const runway = this.getOriginRunway();
          if (runway) {
            // console.error('bruh');
            // Reference : AMM - 22-71-00 PB001, Page 4
            if (departureIndex < 0 && transitionIndex < 0) {
              const TEMPORARY_VERTICAL_SPEED = 2000.0; // ft/min
              const TEMPORARY_GROUND_SPEED = 160; // knots

              const altitudeFeet = runway.elevation * 3.2808399 + 1500;
              const distanceInNM = altitudeFeet / TEMPORARY_VERTICAL_SPEED * (TEMPORARY_GROUND_SPEED / 60);
              const coordinates = GeoMath.relativeBearingDistanceToCoords(runway.direction, distanceInNM, runway.endCoordinates);
              const faLeg = procedure.buildWaypoint("".concat(Math.round(altitudeFeet)), coordinates);
              // TODO should this check for unclr discont? (probs not)
              faLeg.endsInDiscontinuity = true;
              faLeg.discontinuityCanBeCleared = true;
              this.addWaypoint(faLeg, undefined, segment.type);
            }
          }
          let waypointIndex = segment.offset;
          while (procedure.hasNext()) {
            // eslint-disable-next-line no-await-in-loop
            const waypoint = await procedure.getNext();
            if (waypoint !== undefined) {
              waypoint.additionalData.constraintType = WaypointConstraintType.CLB;
              this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
            }
          }
        }
        this.restringSegmentBoundaries(SegmentType.Departure, SegmentType.Enroute);
      }

      /**
       * Rebuilds the arrival and approach segment after a change of procedure
       */
      async rebuildArrivalApproach() {
        // remove all legs from these segments to prevent weird stuff
        this.truncateSegment(SegmentType.Arrival);
        this.truncateSegment(SegmentType.Approach);
        this.truncateSegment(SegmentType.Missed);
        await this.buildArrival().catch(console.error);
        await this.buildApproach().catch(console.error);
      }

      /**
       * Builds an arrival into the flight plan from indexes in the arrival airport information.
       */
      async buildArrival() {
        const legs = [];
        const legAnnotations = [];
        const destination = this.destinationAirfield;
        const {
          arrivalIndex
        } = this.procedureDetails;
        // const { approachTransitionIndex } = this.procedureDetails;
        const {
          arrivalRunwayIndex
        } = this.procedureDetails;
        const {
          arrivalTransitionIndex
        } = this.procedureDetails;
        const destinationInfo = destination.infos;
        const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);
        if (arrivalIndex >= 0 && arrivalTransitionIndex >= 0) {
          const transition = destinationInfo.arrivals[arrivalIndex].enRouteTransitions[arrivalTransitionIndex];
          if (transition !== undefined) {
            legs.push(...transition.legs);
            legAnnotations.push(...transition.legs.map(_ => transition.name));
            // console.log('MFP: buildArrival - pushing transition legs ->', legs);
          }
        }

        if (arrivalIndex >= 0) {
          // string the common legs in the middle of the STAR
          const arrival = destinationInfo.arrivals[arrivalIndex];
          legs.push(...arrival.commonLegs);
          legAnnotations.push(...arrival.commonLegs.map(_ => arrival.name));
          // console.log('MFP: buildArrival - pushing STAR legs ->', legs);

          // if no runway is selected at all (non-runway-specific approach)
          // and the selected STAR only has runway transition legs... string them
          // TODO research IRL behaviour
          const starHasOneRunwayTrans = arrival.commonLegs.length === 0 && arrival.runwayTransitions.length === 1;
          const approachIsRunwaySpecific = this.procedureDetails.destinationRunwayIndex >= 0;
          const runwayTransIndex = arrivalRunwayIndex < 0 && starHasOneRunwayTrans && !approachIsRunwaySpecific ? 0 : arrivalRunwayIndex;
          const runwayTransition = arrival.runwayTransitions[runwayTransIndex];
          if (runwayTransition) {
            legs.push(...runwayTransition.legs);
            legAnnotations.push(...runwayTransition.legs.map(_ => arrival.name));
          }
        }
        let {
          _startIndex,
          segment
        } = this.truncateSegment(SegmentType.Arrival);
        if (legs.length > 0) {
          if (segment === FlightPlanSegment.Empty) {
            segment = this.addSegment(SegmentType.Arrival);
            _startIndex = segment.offset;
          }
          const procedure = new LegsProcedure(legs, this.getWaypoint(segment.offset - 1), this._parentInstrument, airportMagVar, undefined, legAnnotations);
          let waypointIndex = segment.offset;
          // console.log('MFP: buildArrival - ADDING WAYPOINTS ------------------------');
          while (procedure.hasNext()) {
            // eslint-disable-next-line no-await-in-loop
            const waypoint = await procedure.getNext();
            if (waypoint) {
              waypoint.additionalData.constraintType = WaypointConstraintType.DES;

              // console.log('  ---- MFP: buildArrival: added waypoint ', waypoint.ident, ' to segment ', segment);
              this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
            }
          }
        }
        this.restringSegmentBoundaries(SegmentType.Enroute, SegmentType.Arrival);
        this.restringSegmentBoundaries(SegmentType.Arrival, SegmentType.Approach);
      }

      /**
       * Builds an approach into the flight plan from indexes in the arrival airport information.
       */
      async buildApproach() {
        const legs = [];
        const legAnnotations = [];
        const missedLegs = [];
        const destination = this.destinationAirfield;
        this.procedureDetails.approachType = undefined;
        const {
          approachIndex
        } = this.procedureDetails;
        const {
          approachTransitionIndex
        } = this.procedureDetails;
        const {
          destinationRunwayIndex
        } = this.procedureDetails;
        const destinationInfo = destination.infos;
        const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);
        const approach = destinationInfo.approaches[approachIndex];
        const approachName = approach && approach.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN ? approach.name : '';
        if (approachIndex >= 0 && approachTransitionIndex >= 0) {
          const transition = destinationInfo.approaches[approachIndex].transitions[approachTransitionIndex];
          legs.push(...transition.legs);
          legAnnotations.push(...transition.legs.map(_ => transition.name));
          // console.log('MFP: buildApproach - pushing approachTransition legs ->', legs);
        }

        if (approachIndex >= 0) {
          var _legs, _finalLegs$;
          const finalLegs = [...approach.finalLegs];
          // PI legs can only occur in approach vias
          // if the via ends in one, we must omit the IF leg at the start of the approach
          const viaLastLegType = (_legs = legs[legs.length - 1]) === null || _legs === void 0 ? void 0 : _legs.type;
          if (viaLastLegType === LegType.PI && ((_finalLegs$ = finalLegs[0]) === null || _finalLegs$ === void 0 ? void 0 : _finalLegs$.type) === LegType.IF) {
            var _finalLegs$2;
            finalLegs.splice(0, 1);
            // @ts-expect-error (ts compiler doesn't see that splice mutates finalLegs)
            if (((_finalLegs$2 = finalLegs[0]) === null || _finalLegs$2 === void 0 ? void 0 : _finalLegs$2.type) !== LegType.CF) {
              console.error('PI must be followed by CF!');
            }
          }
          this.procedureDetails.approachType = approach.approachType;
          legs.push(...finalLegs);
          legAnnotations.push(...finalLegs.map(_ => approachName));
          missedLegs.push(...approach.missedLegs);
        }
        let {
          _startIndex,
          segment
        } = this.truncateSegment(SegmentType.Approach);
        if (legs.length > 0 || approachIndex >= 0 || destinationRunwayIndex >= 0) {
          if (segment === FlightPlanSegment.Empty) {
            segment = this.addSegment(SegmentType.Approach);
            _startIndex = segment.offset;
            const prevWaypointIndex = segment.offset - 1;
            if (prevWaypointIndex > 0) {
              const prevWaypoint = this.getWaypoint(segment.offset - 1);
              if (!prevWaypoint.endsInDiscontinuity) {
                prevWaypoint.endsInDiscontinuity = true;
                prevWaypoint.discontinuityCanBeCleared = true;
              }
            }
          }
          const runway = this.getDestinationRunway();
          const procedure = new LegsProcedure(legs, this.getWaypoint(_startIndex - 1), this._parentInstrument, airportMagVar, this.procedureDetails.approachType, legAnnotations);
          let waypointIndex = _startIndex;
          // console.log('MFP: buildApproach - ADDING WAYPOINTS ------------------------');
          while (procedure.hasNext()) {
            // eslint-disable-next-line no-await-in-loop
            const waypoint = await procedure.getNext();
            if (waypoint !== undefined) {
              waypoint.additionalData.constraintType = WaypointConstraintType.DES;

              // console.log('  ---- MFP: buildApproach: added waypoint', waypoint.ident, ' to segment ', segment);
              this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
            }
          }
          if (runway) {
            // const selectedRunwayMod = runway.designation.slice(-1);
            // let selectedRunwayOutput;
            // if (selectedRunwayMod === 'L' || selectedRunwayMod === 'C' || selectedRunwayMod === 'R') {
            //     if (runway.designation.length === 2) {
            //         selectedRunwayOutput = `0${runway.designation}`;
            //     } else {
            //         selectedRunwayOutput = runway.designation;
            //     }
            // } else if (runway.designation.length === 2) {
            //     selectedRunwayOutput = runway.designation;
            // } else {
            //     selectedRunwayOutput = `0${runway.designation}`;
            // }

            // When adding approach, edit destination waypoint
            this.destinationAirfield.infos.coordinates = runway.beginningCoordinates;
            this.destinationAirfield.legAltitudeDescription = 1;
            this.destinationAirfield.legAltitude1 = Math.round((runway.elevation * 3.28084 + 50) / 10) * 10;
            this.destinationAirfield.isRunway = true;
            if (approachIndex >= 0) {
              const lastLeg = approach.finalLegs[approach.finalLegs.length - 1];
              if (lastLeg.type === LegType.CF) {
                const magCourse = lastLeg.trueDegrees ? B77HS_Util.trueToMagnetic(lastLeg.course, Facilities.getMagVar(runway.beginningCoordinates.lat, runway.beginningCoordinates.long)) : lastLeg.course;
                this.destinationAirfield.additionalData.annotation = "C".concat(magCourse.toFixed(0).padStart(3, '0'), "\xB0");
              } else {
                this.destinationAirfield.additionalData.annotation = approachName;
              }
            }

            // Clear discontinuity before destination, if any
            const wpBeforeDestIdx = this.waypoints.indexOf(this.destinationAirfield) - 1;
            if (wpBeforeDestIdx >= 0) {
              const wpBeforeDest = this.getWaypoint(wpBeforeDestIdx);
              if (wpBeforeDest.endsInDiscontinuity && wpBeforeDest.discontinuityCanBeCleared) {
                wpBeforeDest.endsInDiscontinuity = false;
              }
            }
          }
        }
        this.restringSegmentBoundaries(SegmentType.Arrival, SegmentType.Approach);

        /* if (missedLegs.length > 0) {
            let { _startIndex, segment } = this.truncateSegment(SegmentType.Missed);
              if (segment === FlightPlanSegment.Empty) {
                segment = this.addSegment(SegmentType.Missed);
                _startIndex = segment.offset;
            }
              let waypointIndex = _startIndex;
              const missedProcedure = new LegsProcedure(missedLegs, this.getWaypoint(_startIndex - 1), this._parentInstrument, airportMagVar);
            while (missedProcedure.hasNext()) {
                // eslint-disable-next-line no-await-in-loop
                const waypoint = await missedProcedure.getNext().catch(console.error);
                  if (waypoint !== undefined) {
                    // console.log('  ---- MFP: buildApproach: added waypoint', waypoint.ident, ' to segment ', segment);
                    this.addWaypoint(waypoint, ++waypointIndex, segment.type);
                }
            }
        } */
      }

      static isXfLeg(leg) {
        var _leg$additionalData;
        switch (leg === null || leg === void 0 ? void 0 : (_leg$additionalData = leg.additionalData) === null || _leg$additionalData === void 0 ? void 0 : _leg$additionalData.legType) {
          case LegType.CF:
          case LegType.DF:
          case LegType.IF:
          case LegType.RF:
          case LegType.TF:
            return true;
          default:
            return false;
        }
      }
      static isFxLeg(leg) {
        var _leg$additionalData2;
        switch (leg === null || leg === void 0 ? void 0 : (_leg$additionalData2 = leg.additionalData) === null || _leg$additionalData2 === void 0 ? void 0 : _leg$additionalData2.legType) {
          case LegType.FA:
          case LegType.FC:
          case LegType.FD:
          case LegType.FM:
            return true;
          default:
            return false;
        }
      }
      static legsStartOrEndAtSameFix(legA, legB) {
        return legA.icao === legB.icao && (ManagedFlightPlan.isXfLeg(legA) && ManagedFlightPlan.isXfLeg(legB) || ManagedFlightPlan.isFxLeg(legA) && ManagedFlightPlan.isFxLeg(legB));
      }
      static climbConstraint(leg) {
        switch (leg.legAltitudeDescription) {
          case AltitudeDescriptor.At:
          case AltitudeDescriptor.AtOrBelow:
            return leg.legAltitude1;
          case AltitudeDescriptor.Between:
            return leg.legAltitude2;
        }
        return Infinity;
      }
      static descentConstraint(leg) {
        switch (leg.legAltitudeDescription) {
          case AltitudeDescriptor.At:
          case AltitudeDescriptor.AtOrAbove:
          case AltitudeDescriptor.Between:
            return leg.legAltitude1;
        }
        return -Infinity;
      }
      static mergeConstraints(legA, legB) {
        let legAltitudeDescription = AltitudeDescriptor.Empty;
        let legAltitude1 = 0;
        let legAltitude2 = 0;
        if (legA.legAltitudeDescription === AltitudeDescriptor.At) {
          legAltitudeDescription = AltitudeDescriptor.At;
          if (legB.legAltitudeDescription === AltitudeDescriptor.At) {
            legAltitude1 = Math.min(legA.legAltitude1, legB.legAltitude1);
          } else {
            legAltitude1 = legA.legAltitude1;
          }
        } else if (legB.legAltitudeDescription === AltitudeDescriptor.At) {
          legAltitudeDescription = AltitudeDescriptor.At;
          legAltitude1 = legB.legAltitude1;
        } else if (legA.legAltitudeDescription > 0 || legB.legAltitudeDescription > 0) {
          const maxAlt = Math.min(ManagedFlightPlan.climbConstraint(legA), ManagedFlightPlan.climbConstraint(legB));
          const minAlt = Math.max(ManagedFlightPlan.descentConstraint(legA), ManagedFlightPlan.descentConstraint(legB));
          if (Number.isFinite(maxAlt)) {
            if (Number.isFinite(minAlt)) {
              if (Math.abs(minAlt - maxAlt) < 1) {
                legAltitudeDescription = AltitudeDescriptor.At;
                legAltitude1 = minAlt;
              } else {
                legAltitudeDescription = AltitudeDescriptor.Between;
                legAltitude1 = minAlt;
                legAltitude2 = maxAlt;
              }
            } else {
              legAltitudeDescription = AltitudeDescriptor.AtOrBelow;
              legAltitude1 = maxAlt;
            }
          } else if (Number.isFinite(minAlt)) {
            legAltitudeDescription = AltitudeDescriptor.AtOrAbove;
            legAltitude1 = minAlt;
          }
        }
        const speed = Math.min(legA.speedConstraint > 0 ? legA.speedConstraint : Infinity, legB.speedConstraint > 0 ? legB.speedConstraint : Infinity);
        return {
          legAltitudeDescription,
          legAltitude1,
          legAltitude2,
          speedConstraint: Number.isFinite(speed) ? speed : 0
        };
      }

      /**
       * Check for common waypoints at the boundaries of segments, and merge them if found
       * segmentA must be before segmentB in the plan!
       */
      restringSegmentBoundaries(segmentTypeA, segmentTypeB) {
        if (segmentTypeB < segmentTypeA) {
          throw new Error('restringSegmentBoundaries: segmentTypeA must be before segmentTypeB');
        }
        const segmentA = this.getSegment(segmentTypeA);
        const segmentB = this.getSegment(segmentTypeB);
        if ((segmentA === null || segmentA === void 0 ? void 0 : segmentA.waypoints.length) < 1 || (segmentB === null || segmentB === void 0 ? void 0 : segmentB.waypoints.length) < 1) {
          return;
        }
        const lastLegIndexA = segmentA.offset + segmentA.waypoints.length - 1;
        const lastLegA = segmentA.waypoints[segmentA.waypoints.length - 1];
        const firstLegIndexB = segmentB.offset;
        const firstLegB = segmentB.waypoints[0];
        if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, firstLegB)) {
          const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);
          if (segmentA.type === SegmentType.Departure) {
            this.removeWaypoint(firstLegIndexB, true);
            Object.assign(lastLegA, constraints);
            lastLegA.endsInDiscontinuity = false;
            lastLegA.discontinuityCanBeCleared = undefined;
          } else {
            this.removeWaypoint(lastLegIndexA, true);
            Object.assign(firstLegB, constraints);
            firstLegB.endsInDiscontinuity = false;
            firstLegB.discontinuityCanBeCleared = undefined;
          }
        } else if (segmentTypeA === SegmentType.Arrival && segmentTypeB === SegmentType.Approach) {
          let toDeleteFromB = 0;
          for (let i = 0; i < segmentB.waypoints.length; i++) {
            if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, segmentB.waypoints[i])) {
              const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);
              Object.assign(lastLegA, constraints);
              toDeleteFromB = i + 1;
              break;
            }
          }
          for (let i = 0; i < toDeleteFromB; i++) {
            this.removeWaypoint(segmentB.offset, true);
          }
          if (toDeleteFromB === 0 && firstLegB.additionalData.legType === LegType.IF) {
            lastLegA.endsInDiscontinuity = true;
            lastLegA.discontinuityCanBeCleared = true;
          }
        }
      }

      /**
       * Truncates a flight plan segment. If the active waypoint index is current in the segment,
       * a discontinuity will be added at the end of the active waypoint and the startIndex will
       * point to the next waypoint in the segment after the active.
       * @param type The type of segment to truncate.
       * @returns A segment to add to and a starting waypoint index.
       */
      truncateSegment(type) {
        let segment = this.getSegment(type);
        // const startIndex = this.findSegmentByWaypointIndex(this.activeWaypointIndex) === segment
        //     ? this.activeWaypointIndex + 1
        //     : segment.offset;
        const startIndex = segment.offset;
        if (segment !== FlightPlanSegment.Empty) {
          const finalIndex = segment.offset + segment.waypoints.length;
          if (startIndex < finalIndex) {
            for (let i = startIndex; i < finalIndex; i++) {
              // console.log(' MFP ---> truncateSegment: removing waypoint ', this.getWaypoint(startIndex).ident);
              this.removeWaypoint(startIndex);
            }
          }
        }
        if (segment.waypoints.length === 0) {
          this.removeSegment(segment.type);
          segment = FlightPlanSegment.Empty;
        } else {
          const waypoint = segment.waypoints[Math.max(startIndex - 1 - segment.offset, 0)];
          waypoint.endsInDiscontinuity = true;
          waypoint.discontinuityCanBeCleared = true;
        }
        return {
          _startIndex: startIndex,
          segment
        };
      }

      /**
       * Converts a plain object into a ManagedFlightPlan.
       * @param flightPlanObject The object to convert.
       * @param parentInstrument The parent instrument attached to this flight plan.
       * @returns The converted ManagedFlightPlan.
       */
      static fromObject(flightPlanObject, parentInstrument) {
        const plan = Object.assign(new ManagedFlightPlan(), flightPlanObject);
        plan.setParentInstrument(parentInstrument);
        plan.directTo = Object.assign(new DirectTo(), plan.directTo);
        const mapObject = (obj, parentType) => {
          if (obj && obj.infos) {
            obj = Object.assign(new WayPoint(parentInstrument), obj);
          }
          if (obj && obj.coordinates) {
            switch (parentType) {
              case 'A':
                obj = Object.assign(new AirportInfo(parentInstrument), obj);
                break;
              case 'W':
                obj = Object.assign(new IntersectionInfo(parentInstrument), obj);
                break;
              case 'V':
                obj = Object.assign(new VORInfo(parentInstrument), obj);
                break;
              case 'N':
                obj = Object.assign(new NDBInfo(parentInstrument), obj);
                break;
              default:
                obj = Object.assign(new WayPointInfo(parentInstrument), obj);
            }
            obj.coordinates = Object.assign(new LatLongAlt(), obj.coordinates);
          }
          return obj;
        };
        const visitObject = obj => {
          for (const key in obj) {
            if (typeof obj[key] === 'object' && obj[key] && obj[key].scroll === undefined) {
              if (Array.isArray(obj[key])) {
                visitArray(obj[key]);
              } else {
                visitObject(obj[key]);
              }
              obj[key] = mapObject(obj[key], obj.type);
            }
          }
        };
        const visitArray = array => {
          array.forEach((item, index) => {
            if (Array.isArray(item)) {
              visitArray(item);
            } else if (typeof item === 'object') {
              visitObject(item);
            }
            array[index] = mapObject(item);
          });
        };
        visitObject(plan);
        return plan;
      }
      legDataMatches(a, b, fields) {
        return fields.every(field => a.additionalData[field] === b.additionalData[field]);
      }
      isLegDuplicate(a, b) {
        if (a.additionalData.legType === b.additionalData.legType) {
          switch (a.additionalData.legType) {
            case LegType.AF:
            case LegType.CR:
            case LegType.VR:
              return this.legDataMatches(a, b, ['course', 'theta', 'recommendedIcao']);
            case LegType.CA:
            case LegType.VA:
              return this.legDataMatches(a, b, ['course']) && a.legAltitude1 === b.legAltitude1;
            case LegType.CD:
            case LegType.VD:
              return this.legDataMatches(a, b, ['course', 'distance', 'recommendedIcao']);
            case LegType.CF:
              return this.legDataMatches(a, b, ['course']) && a.icao === b.icao;
            case LegType.CI:
            case LegType.VI:
            case LegType.VM:
              return this.legDataMatches(a, b, ['course']);
            case LegType.DF:
            case LegType.IF:
            case LegType.TF:
              return a.icao === b.icao;
            case LegType.FA:
              return a.icao === b.icao && a.legAltitude1 === b.legAltitude1;
            case LegType.FC:
              return this.legDataMatches(a, b, ['course', 'distance']) && a.icao === b.icao;
            case LegType.FD:
              return this.legDataMatches(a, b, ['course', 'distance', 'recommendedIcao']) && a.icao === b.icao;
            case LegType.FM:
              return this.legDataMatches(a, b, ['course']) && a.icao === b.icao;
            case LegType.HA:
              return this.legDataMatches(a, b, ['course', 'distance', 'distanceInMinutes']) && a.icao === b.icao && a.legAltitude1 === b.legAltitude1;
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
              return this.legDataMatches(a, b, ['course', 'distance', 'distanceInMinutes']) && a.icao === b.icao;
            case LegType.RF:
              return this.legDataMatches(a, b, ['center', 'radius']) && a.icao === b.icao;
          }
        } else if (ManagedFlightPlan.isXfLeg(a) && ManagedFlightPlan.isXfLeg(b) || ManagedFlightPlan.isFxLeg(a) && ManagedFlightPlan.isFxLeg(b)) {
          return a.icao === b.icao;
        }
        return false;
      }
      addWaypointAvoidingDuplicates(waypoint, waypointIndex, segment) {
        const index = this.waypoints.findIndex(wp => this.isLegDuplicate(waypoint, wp));

        // FIXME this should collapse any legs between the old position and the newly inserted position
        const wptDist = Math.abs(index - waypointIndex);
        if (index !== -1 && wptDist <= 2) {
          // console.log('  -------> MFP: addWaypointAvoidingDuplicates: removing duplicate waypoint ', this.getWaypoint(index).ident);
          const removedWp = this.getWaypoint(index);
          if (waypoint.legAltitudeDescription === AltitudeDescriptor.Empty && removedWp.legAltitudeDescription !== AltitudeDescriptor.Empty) {
            waypoint.legAltitudeDescription = removedWp.legAltitudeDescription;
            waypoint.legAltitude1 = removedWp.legAltitude1;
            waypoint.legAltitude2 = removedWp.legAltitude2;
          }
          if (waypoint.speedConstraint <= 0 && removedWp.speedConstraint > 0) {
            waypoint.speedConstraint = removedWp.speedConstraint;
          }
          this.removeWaypoint(index);
        }
        this.addWaypoint(waypoint, waypointIndex, segment.type);
      }
      getOriginRunway() {
        if (this.originAirfield) {
          if (this.procedureDetails.originRunwayIndex >= 0) {
            return this.originAirfield.infos.oneWayRunways[this.procedureDetails.originRunwayIndex];
          }
        }
        return null;
      }
      getDestinationRunway() {
        if (this.destinationAirfield) {
          if (this.procedureDetails.destinationRunwayIndex >= 0) {
            return this.destinationAirfield.infos.oneWayRunways[this.procedureDetails.destinationRunwayIndex];
          }
        }
        return null;
      }
      get manualHoldActive() {
        var _this$waypoints$this$, _this$waypoints$this$2;
        return ((_this$waypoints$this$ = this.waypoints[this.activeWaypointIndex]) === null || _this$waypoints$this$ === void 0 ? void 0 : (_this$waypoints$this$2 = _this$waypoints$this$.additionalData) === null || _this$waypoints$this$2 === void 0 ? void 0 : _this$waypoints$this$2.legType) === LegType.HM;
      }
      get glideslopeIntercept() {
        const appr = this.getSegment(SegmentType.Approach);
        for (const wp of appr.waypoints) {
          if (wp.additionalData.fixTypeFlags & FixTypeFlags.FAF && (wp.legAltitudeDescription === AltitudeDescriptor.G || wp.legAltitudeDescription === AltitudeDescriptor.H)) {
            return wp.legAltitude1;
          }
        }
        return undefined;
      }
      get destinationIndex() {
        const appr = this.getSegment(SegmentType.Approach);
        const index = appr.offset + appr.waypoints.length;
        if (this.destinationAirfield) {
          return index + 1;
        }
        return -1;
      }
      get finalApproachActive() {
        const appr = this.getSegment(SegmentType.Approach);
        if (appr === FlightPlanSegment.Empty) {
          return false;
        }
        const offset = this.activeWaypointIndex - appr.offset;
        if (offset >= 0 && offset < appr.waypoints.length) {
          for (const [index, wp] of appr.waypoints.entries()) {
            if (wp.additionalData.fixTypeFlags & FixTypeFlags.FAF) {
              return offset >= index;
            }
          }
        }
        return false;
      }
    }

    /*
     * MIT License
     *
     * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    /** A class for syncing a flight plan with the game */
    class FlightPlanAsoboSync {
      static init() {
        if (!this.fpListenerInitialized) {
          RegisterViewListener('JS_LISTENER_FLIGHTPLAN');
          this.fpListenerInitialized = true;
        }
      }
      static async LoadFromGame(fpln) {
        return new Promise(resolve => {
          this.init();
          setTimeout(() => {
            Coherent.call('LOAD_CURRENT_GAME_FLIGHT').catch(console.error);
            Coherent.call('LOAD_CURRENT_ATC_FLIGHTPLAN').catch(console.error);
            setTimeout(() => {
              Coherent.call('GET_FLIGHTPLAN').then(async data => {
                console.log('COHERENT GET_FLIGHTPLAN received:');
                console.log('Data from MSFS flight plan:', data);

                // Purpose unclear
                // TODO: talk to matt about dirto
                const {
                  isDirectTo
                } = data;
                if (isDirectTo) {
                  return;
                }

                // Mid air flight plan loading not yet supported - return if first waypoint is not an airport
                // TODO FIXME: better handling of mid-air spawning and syncing fpln
                if (data.waypoints.length === 0 || data.waypoints[0].icao[0] !== 'A') {
                  fpln.resumeSync();
                  resolve();
                  return;
                }

                // result dismissed - why??
                // assumption: counter timeout issues when reading facility from MSFS?
                await fpln._parentInstrument.facilityLoader.getFacilityRaw(data.waypoints[0].icao, 10000).catch(e => {
                  console.error('[FP LOAD] Error getting first wp data');
                  console.error(e);
                });

                // set origin
                await fpln.setOrigin(data.waypoints[0].icao).catch(e => {
                  console.error('[FP LOAD] Error setting origin');
                  console.error(e);
                });

                // set dest
                await fpln.setDestination(data.waypoints[data.waypoints.length - 1].icao).catch(e => {
                  console.error('[FP LOAD] Error setting Destination');
                  console.error(e);
                });

                // set route
                const enrouteStart = data.departureWaypointsSize === -1 ? 1 : data.departureWaypointsSize;
                // Find out first approach waypoint, - 1 to skip destination
                const enrouteEnd = data.waypoints.length - (data.arrivalWaypointsSize === -1 ? 0 : data.arrivalWaypointsSize) - 1;
                const enroute = data.waypoints.slice(enrouteStart, enrouteEnd);
                for (let i = 0; i < enroute.length; i++) {
                  const wpt = enroute[i];
                  if (wpt.icao.trim() !== '') {
                    // Without the 'await' the order of import is undefined and the flight plan waypoints
                    // are not in the correct order
                    // eslint-disable-next-line no-await-in-loop
                    await fpln.addWaypoint(wpt.icao, Infinity, () => {
                      // console.log(`[FP LOAD] Adding [${wpt.icao}]... SUCCESS`);
                    }).catch(console.error);
                  }
                }

                // set departure
                //  rwy index
                await fpln.setDepartureRunwayIndex(data.departureRunwayIndex)
                // .then(() => console.log(`[FP LOAD] Setting Departure Runway ${data.departureRunwayIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Departure Runway ".concat(data.departureRunwayIndex, " ... FAILED"));
                  console.error(e);
                });
                // proc index
                await fpln.setDepartureProcIndex(data.departureProcIndex)
                // .then(() => console.log(`[FP LOAD] Setting Departure Procedure  ${data.departureProcIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Departure Procedure ".concat(data.departureProcIndex, " ... FAILED"));
                  console.error(e);
                });
                // origin runway
                if (data.originRunwayIndex !== -1) {
                  await fpln.setOriginRunwayIndex(data.originRunwayIndex)
                  // .then(() => console.log(`[FP LOAD] Setting Origin  ${data.originRunwayIndex} ... SUCCESS`))
                  .catch(e => {
                    console.error("[FP LOAD] Setting Origin ".concat(data.originRunwayIndex, " ... FAILED"));
                    console.error(e);
                  });
                } else if (data.departureRunwayIndex !== -1 && data.departureProcIndex !== -1) {
                  await fpln.setOriginRunwayIndexFromDeparture()
                  // .then(() => console.log(`[FP LOAD] Setting Origin using ${data.departureProcIndex}/${data.departureRunwayIndex}... SUCCESS`))
                  .catch(e => {
                    console.error("[FP LOAD] Setting Origin using ".concat(data.departureProcIndex, "/").concat(data.departureRunwayIndex, " ... FAILED"));
                    console.error(e);
                  });
                }
                //  enroutetrans index
                await fpln.setDepartureEnRouteTransitionIndex(data.departureEnRouteTransitionIndex)
                // .then(() => console.log(`[FP LOAD] Setting Departure En Route Transition ${data.departureEnRouteTransitionIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Departure En Route Transition ".concat(data.departureEnRouteTransitionIndex, " ... FAILED"));
                  console.error(e);
                });
                // set approach
                //  rwy index
                await fpln.setArrivalRunwayIndex(data.arrivalRunwayIndex)
                // .then(() => console.log(`[FP LOAD] Setting Arrival Runway ${data.arrivalRunwayIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Arrival Runway ".concat(data.arrivalRunwayIndex, " ... FAILED"));
                  console.error(e);
                });
                //  approach index
                await fpln.setApproachIndex(data.approachIndex)
                // .then(() => console.log(`[FP LOAD] Setting Approach ${data.approachIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Approach ".concat(data.approachIndex, " ... FAILED"));
                  console.error(e);
                });
                //  approachtrans index
                await fpln.setApproachTransitionIndex(data.approachTransitionIndex)
                // .then(() => console.log(`[FP LOAD] Setting Approach Transition ${data.approachTransitionIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Approach Transition ".concat(data.approachTransitionIndex, " ... FAILED"));
                  console.error(e);
                });

                // set arrival
                //  arrivalproc index
                await fpln.setArrivalProcIndex(data.arrivalProcIndex)
                // .then(() => console.log(`[FP LOAD] Setting Arrival Procedure ${data.arrivalProcIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Arrival Procedure ".concat(data.arrivalProcIndex, " ... FAILED"));
                  console.error(e);
                });
                //  arrivaltrans index
                await fpln.setArrivalEnRouteTransitionIndex(data.arrivalEnRouteTransitionIndex)
                // .then(() => console.log(`[FP LOAD] Setting En Route Transition ${data.arrivalEnRouteTransitionIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting En Route Transition ".concat(data.arrivalEnRouteTransitionIndex, " ... FAILED"));
                  console.error(e);
                });
                await fpln.setDestinationRunwayIndexFromApproach()
                // .then(() => console.log(`[FP LOAD] Setting Destination Runway using ${data.approachIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Destination Runway using ".concat(data.approachIndex, " ... FAILED"));
                  console.error(e);
                });
                fpln.resumeSync();
                this.fpChecksum = fpln.getCurrentFlightPlan().checksum;

                // Potential CTD source?
                Coherent.call('SET_ACTIVE_WAYPOINT_INDEX', 0).catch(e => console.error('[FP LOAD] Error when setting Active WP', e));
                Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX').catch(e => console.error('[FP LOAD] Error when recomputing Active WP', e));
                resolve();
                console.log('Resulting aircraft flight plan: ', fpln);
              }).catch(console.error);
            }, 500);
          }, 200);
        });
      }
      static async SaveToGame(fpln) {
        return __awaiter(this, 0, 0, function* () {
          return new Promise(() => __awaiter(this, 0, 0, function* () {
            FlightPlanAsoboSync.init();
            const plan = fpln.getCurrentFlightPlan();
            if (plan.checksum !== this.fpChecksum) {
              // await Coherent.call("CREATE_NEW_FLIGHTPLAN").catch(console.error);
              yield Coherent.call('SET_CURRENT_FLIGHTPLAN_INDEX', 0, false).catch(console.error);
              yield Coherent.call('CLEAR_CURRENT_FLIGHT_PLAN').catch(console.error);
              if (plan.hasPersistentOrigin && plan.hasDestination) {
                yield Coherent.call('SET_ORIGIN', plan.persistentOriginAirfield.icao, false).catch(console.error);
                // .then(() => console.log('[FP SAVE] Setting Origin Airfield... SUCCESS'));
                yield Coherent.call('SET_DESTINATION', plan.destinationAirfield.icao, false).catch(console.error);
                // .then(() => console.log('[FP SAVE] Setting Destination Airfield... SUCCESS'));
                let coIndex = 1;
                for (let i = 0; i < plan.enroute.waypoints.length; i++) {
                  const wpt = plan.enroute.waypoints[i];
                  if (wpt.icao.trim() !== '') {
                    yield Coherent.call('ADD_WAYPOINT', wpt.icao, coIndex, false).catch(console.error);
                    // .then(() => console.log(`[FP SAVE] Adding Waypoint [${wpt.icao}]... SUCCESS`));
                    coIndex++;
                  }
                }
                yield Coherent.call('SET_ORIGIN_RUNWAY_INDEX', plan.procedureDetails.originRunwayIndex)
                // .then(() => console.log(`[FP SAVE] Setting Origin Runway ${plan.procedureDetails.originRunwayIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting Origin Runway ".concat(plan.procedureDetails.originRunwayIndex, " ... FAILED"));
                  console.error(e);
                });
                yield Coherent.call('SET_DEPARTURE_RUNWAY_INDEX', plan.procedureDetails.departureRunwayIndex)
                // .then(() => console.log(`[FP SAVE] Setting Departure Runway ${plan.procedureDetails.departureRunwayIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting Departure Runway ".concat(plan.procedureDetails.departureRunwayIndex, " ... FAILED"));
                  console.error(e);
                });
                yield Coherent.call('SET_DEPARTURE_PROC_INDEX', plan.procedureDetails.departureIndex)
                // .then(() => console.log(`[FP SAVE] Setting Departure Procedure ${plan.procedureDetails.departureIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting Departure Procedure ".concat(plan.procedureDetails.departureIndex, " ... FAILED"));
                  console.error(e);
                });
                yield Coherent.call('SET_DEPARTURE_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.departureTransitionIndex)
                // .then(() => console.log(`[FP SAVE] Setting Departure Transition ${plan.procedureDetails.departureTransitionIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting Departure Transition ".concat(plan.procedureDetails.departureTransitionIndex, " ... FAILED"));
                  console.error(e);
                });
                yield Coherent.call('SET_ARRIVAL_RUNWAY_INDEX', plan.procedureDetails.arrivalRunwayIndex)
                // .then(() => console.log(`[FP SAVE] Setting Arrival Runway ${plan.procedureDetails.arrivalRunwayIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting  Arrival Runway ".concat(plan.procedureDetails.arrivalRunwayIndex, " ... FAILED"));
                  console.error(e);
                });
                yield Coherent.call('SET_ARRIVAL_PROC_INDEX', plan.procedureDetails.arrivalIndex)
                // .then(() => console.log(`[FP SAVE] Setting Arrival Procedure ${plan.procedureDetails.arrivalIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting Arrival Procedure ".concat(plan.procedureDetails.arrivalIndex, " ... FAILED"));
                  console.error(e);
                });
                yield Coherent.call('SET_ARRIVAL_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.arrivalTransitionIndex)
                // .then(() => console.log(`[FP SAVE] Setting Arrival En Route Transition ${plan.procedureDetails.arrivalTransitionIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting Arrival En Route Transition ".concat(plan.procedureDetails.arrivalTransitionIndex, " ... FAILED"));
                  console.error(e);
                });
                yield Coherent.call('SET_APPROACH_INDEX', plan.procedureDetails.approachIndex).then(() => {
                  // console.log(`[FP SAVE] Setting Approach ${plan.procedureDetails.approachIndex} ... SUCCESS`);
                  Coherent.call('SET_APPROACH_TRANSITION_INDEX', plan.procedureDetails.approachTransitionIndex)
                  // .then(() => console.log(`[FP SAVE] Setting Approach Transition ${plan.procedureDetails.approachTransitionIndex} ... SUCCESS`))
                  .catch(e => {
                    console.error("[FP SAVE] Setting Approach Transition ".concat(plan.procedureDetails.approachTransitionIndex, " ... FAILED"));
                    console.error(e);
                  });
                }).catch(e => {
                  console.error("[FP SAVE] Setting Approach ".concat(plan.procedureDetails.approachIndex, " ... FAILED"));
                  console.error(e);
                });
              }
              this.fpChecksum = plan.checksum;
            }
            Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX')
            // .then(() => console.log('[FP SAVE] Setting Active Waypoint... SUCCESS'))
            .catch(e => console.log('[FP SAVE] Setting Active Waypoint... FAILED: ', e));
          }));
        });
      }
    }
    _defineProperty$2(FlightPlanAsoboSync, "fpChecksum", 0);
    _defineProperty$2(FlightPlanAsoboSync, "fpListenerInitialized", false);
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(resolve => {
          resolve(value);
        });
      }
      return new (P || (P = Promise))((resolve, reject) => {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    // Copyright (c) 2021 FlyByWire Simulations
    // SPDX-License-Identifier: GPL-3.0

    class FixInfo {
      constructor(flightPlanManager) {
        _defineProperty$2(this, "flightPlanManager", void 0);
        _defineProperty$2(this, "refFix", void 0);
        _defineProperty$2(this, "radials", []);
        _defineProperty$2(this, "radius", void 0);
        _defineProperty$2(this, "abeam", false);
        this.flightPlanManager = flightPlanManager;
      }
      setRefFix(fix) {
        this.radials.length = 0;
        this.radius = undefined;
        this.abeam = false;
        this.refFix = fix;
        this.flightPlanManager.updateFlightPlanVersion();
      }
      getRefFix() {
        return this.refFix;
      }
      getRefFixIdent() {
        var _this$refFix;
        return (_this$refFix = this.refFix) === null || _this$refFix === void 0 ? void 0 : _this$refFix.ident;
      }
      setRadial(index, magneticBearing) {
        if (magneticBearing !== undefined) {
          const trueBearing = Avionics.Utils.clampAngle(magneticBearing + Facilities.getMagVar(this.refFix.infos.coordinates.lat, this.refFix.infos.coordinates.long));
          this.radials[index] = {
            magneticBearing,
            trueBearing
          };
        } else {
          this.radials.splice(index, 1);
        }
        // TODO calculate flight plan intercepts
        this.flightPlanManager.updateFlightPlanVersion();
      }
      getRadial(index) {
        return this.radials[index];
      }
      getRadialTrueBearings() {
        return this.radials.map(r => r.trueBearing);
      }
      setRadius(radius) {
        if (radius !== undefined) {
          this.radius = {
            radius
          };
        } else {
          this.radius = undefined;
        }
        // TODO calculate flight plan intercepts
        this.flightPlanManager.updateFlightPlanVersion();
      }
      getRadius() {
        return this.radius;
      }
      getRadiusValue() {
        var _this$radius;
        return (_this$radius = this.radius) === null || _this$radius === void 0 ? void 0 : _this$radius.radius;
      }
    }

    let WaypointConstraintType;
    (function (WaypointConstraintType) {
      WaypointConstraintType[WaypointConstraintType["CLB"] = 1] = "CLB";
      WaypointConstraintType[WaypointConstraintType["DES"] = 2] = "DES";
    })(WaypointConstraintType || (WaypointConstraintType = {}));
    let FlightPlans;

    /**
     * Navigation flight areas defined in the OPC database
     */
    (function (FlightPlans) {
      FlightPlans[FlightPlans["Active"] = 0] = "Active";
      FlightPlans[FlightPlans["Temporary"] = 1] = "Temporary";
    })(FlightPlans || (FlightPlans = {}));
    let FlightArea;

    /**
     * A system for managing flight plan data used by various instruments.
     */
    (function (FlightArea) {
      FlightArea[FlightArea["Terminal"] = 0] = "Terminal";
      FlightArea[FlightArea["Takeoff"] = 1] = "Takeoff";
      FlightArea[FlightArea["Enroute"] = 2] = "Enroute";
      FlightArea[FlightArea["Oceanic"] = 3] = "Oceanic";
      FlightArea[FlightArea["VorApproach"] = 4] = "VorApproach";
      FlightArea[FlightArea["GpsApproach"] = 5] = "GpsApproach";
      FlightArea[FlightArea["PrecisionApproach"] = 6] = "PrecisionApproach";
      FlightArea[FlightArea["NonPrecisionApproach"] = 7] = "NonPrecisionApproach";
    })(FlightArea || (FlightArea = {}));
    class FlightPlanManager {
      /**
       * The current stored flight plan data.
       * @type ManagedFlightPlan[]
       */

      /**
       * Constructs an instance of the FlightPlanManager with the provided
       * parent instrument attached.
       * @param parentInstrument The parent instrument attached to this FlightPlanManager.
       */
      constructor(_parentInstrument) {
        this._parentInstrument = _parentInstrument;
        _defineProperty$2(this, "_isRegistered", false);
        _defineProperty$2(this, "_isMaster", false);
        _defineProperty$2(this, "_isSyncPaused", false);
        _defineProperty$2(this, "_currentFlightPlanVersion", 0);
        _defineProperty$2(this, "__currentFlightPlanIndex", 0);
        _defineProperty$2(this, "activeArea", FlightArea.Terminal);
        _defineProperty$2(this, "_flightPlans", []);
        _defineProperty$2(this, "_fixInfos", []);
        _defineProperty$2(this, "updateThrottler", new B77HS_Util.UpdateThrottler(2000));
        this._currentFlightPlanVersion = SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number');
        this._loadFlightPlans();
        if (_parentInstrument.instrumentIdentifier === 'A320_Neo_CDU') {
          this._isMaster = true;
          _parentInstrument.addEventListener('FlightStart', async () => {
            const plan = new ManagedFlightPlan();
            plan.setParentInstrument(_parentInstrument);
            this._flightPlans = [];
            this._flightPlans.push(plan);
            if (NXDataStore.get('FP_SYNC', 'LOAD') !== 'NONE') {
              this.pauseSync();
              await FlightPlanAsoboSync.LoadFromGame(this).catch(console.error);
            }
            this.resumeSync();
          });
          for (let i = 0; i < 4; i++) {
            this._fixInfos.push(new FixInfo(this));
          }
        }
        FlightPlanManager.DEBUG_INSTANCE = this;
      }
      get _currentFlightPlanIndex() {
        return this.__currentFlightPlanIndex;
      }
      set _currentFlightPlanIndex(value) {
        this.__currentFlightPlanIndex = value;
      }
      update(deltaTime) {
        if (this.updateThrottler.canUpdate(deltaTime) !== -1) {
          const tmpy = this._flightPlans[FlightPlans.Temporary];
          if (tmpy && this.__currentFlightPlanIndex === FlightPlans.Temporary) {
            if (tmpy.updateTurningPoint()) {
              this.updateFlightPlanVersion();
            }
          }
        }
        this.updateActiveArea();
      }
      onCurrentGameFlightLoaded(_callback) {
        _callback();
      }
      registerListener() {
        // empty
      }

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addHardCodedConstraints(wp) {
        // empty
      }

      /**
       * Loads sim flight plan data into WayPoint objects for consumption.
       * @param data The flight plan data to load.
       * @param currentWaypoints The waypoints array to modify with the data loaded.
       * @param callback A callback to call when the data has completed loading.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _loadWaypoints(data, currentWaypoints, callback) {
        // empty
      }

      /**
       * Updates the current active waypoint index from the sim.
       */
      async updateWaypointIndex() {
        // const waypointIndex = await Coherent.call("GET_ACTIVE_WAYPOINT_INDEX");
        // this._activeWaypointIndex = waypointIndex;
      }

      /**
       * Scans for updates to the synchronized flight plan and loads them into the flight plan
       * manager if the flight plan is out of date.
       * @param {() => void} callback A callback to call when the update has completed.
       * @param {Boolean} log Whether or not to log the loaded flight plan value.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      updateFlightPlan() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
        let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        const flightPlanVersion = SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number');
        if (flightPlanVersion !== this._currentFlightPlanVersion || force) {
          this._loadFlightPlans();
          this._currentFlightPlanVersion = flightPlanVersion;
        }
        callback();
      }

      /**
       * Loads the flight plans from data storage.
       */
      _loadFlightPlans() {
        this._getFlightPlan();
        if (this._flightPlans.length === 0) {
          const newFpln = new ManagedFlightPlan();
          newFpln.setParentInstrument(this._parentInstrument);
          this._flightPlans.push(new ManagedFlightPlan());
        } else {
          this._flightPlans = this._flightPlans.map(fp => ManagedFlightPlan.fromObject(fp, this._parentInstrument));
        }
      }

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      updateCurrentApproach() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
        callback();
      }
      get cruisingAltitude() {
        return 0;
      }
      isCurrentFlightPlanTemporary() {
        return this.getCurrentFlightPlanIndex() === 1;
      }

      /**
       * Gets the index of the currently active flight plan.
       */
      getCurrentFlightPlanIndex() {
        return this._currentFlightPlanIndex;
      }

      /**
       * Switches the active flight plan index to the supplied index.
       * @param index The index to now use for the active flight plan.
       * @param callback A callback to call when the operation has completed.
       */
      setCurrentFlightPlanIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Boolean;
        if (index >= 0 && index < this._flightPlans.length) {
          this._currentFlightPlanIndex = index;
          callback(true);
        } else {
          callback(false);
        }
      }

      /**
       * Creates a new flight plan.
       * @param callback A callback to call when the operation has completed.
       */
      createNewFlightPlan() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
        const newFlightPlan = new ManagedFlightPlan();
        newFlightPlan.setParentInstrument(this._parentInstrument);
        this._flightPlans.push(newFlightPlan);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Copies the currently active flight plan into the specified flight plan index.
       * @param index The index to copy the currently active flight plan into.
       * @param callback A callback to call when the operation has completed.
       */
      async copyCurrentFlightPlanInto(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
        const copiedFlightPlan = this._flightPlans[this._currentFlightPlanIndex].copy();
        const {
          activeWaypointIndex
        } = copiedFlightPlan;
        if (this._currentFlightPlanIndex === FlightPlans.Temporary && index === FlightPlans.Active) {
          copiedFlightPlan.waypoints.forEach(wp => delete wp.additionalData.dynamicPpos);
        }
        this._flightPlans[index] = copiedFlightPlan;
        if (index === 0) {
          await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
        }
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Copies the flight plan at the specified index to the currently active flight plan index.
       * @param index The index to copy into the currently active flight plan.
       * @param callback A callback to call when the operation has completed.
       */
      async copyFlightPlanIntoCurrent(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
        const copiedFlightPlan = this._flightPlans[index].copy();
        const {
          activeWaypointIndex
        } = copiedFlightPlan;
        this._flightPlans[this._currentFlightPlanIndex] = copiedFlightPlan;
        if (this._currentFlightPlanIndex === 0) {
          await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
        }
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Clears the currently active flight plan.
       * @param callback A callback to call when the operation has completed.
       */
      async clearFlightPlan() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
        await this._flightPlans[this._currentFlightPlanIndex].clearPlan().catch(console.error);
        for (const fixInfo of this._fixInfos) {
          fixInfo.setRefFix();
        }
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }
      async deleteFlightPlan(flightPlanIndex) {
        if (this._flightPlans[flightPlanIndex]) {
          delete this._flightPlans[flightPlanIndex];
        }
      }

      /**
       * Gets the origin of the currently active flight plan.
       */
      getOrigin() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        return this._flightPlans[flightPlanIndex].originAirfield;
      }

      /**
       * Gets the origin of the currently active flight plan, even after it has been cleared for a direct-to.
       */
      getPersistentOrigin() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        return this._flightPlans[flightPlanIndex].persistentOriginAirfield;
      }

      /**
       * Sets the origin in the currently active flight plan.
       * @param icao The ICAO designation of the origin airport.
       * @param callback A callback to call when the operation has completed.
       */
      async setOrigin(icao) {
        var _this$getOrigin;
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const sameAirport = ((_this$getOrigin = this.getOrigin()) === null || _this$getOrigin === void 0 ? void 0 : _this$getOrigin.ident) === icao;
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const airport = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch(console.error);
        if (airport) {
          airport.additionalData = {};
          airport.additionalData.legType = LegType.IF;
          await currentFlightPlan.clearPlan().catch(console.error);
          await currentFlightPlan.addWaypoint(airport, 0);
          // clear pilot trans alt
          this.setOriginTransitionAltitude(undefined, false);
          // TODO get origin trans alt from database
          // until then, don't erase the database value from ATSU if same airport as before
          if (!sameAirport) {
            this.setOriginTransitionAltitude(undefined, true);
          }
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Gets the index of the active waypoint in the flight plan.
       * @param forceSimVarCall Unused
       * @param useCorrection Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getActiveWaypointIndex() {
        var _this$_flightPlans$fl, _this$_flightPlans$fl2;
        let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
        if (Number.isNaN(flightPlanIndex)) {
          return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
        }
        return (_this$_flightPlans$fl = (_this$_flightPlans$fl2 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl2 === void 0 ? void 0 : _this$_flightPlans$fl2.activeWaypointIndex) !== null && _this$_flightPlans$fl !== void 0 ? _this$_flightPlans$fl : -1;
      }

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      isActiveWaypointAtEnd() {
        let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
        if (Number.isNaN(flightPlanIndex)) {
          return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex + 1 === this.getWaypointsCount(this._currentFlightPlanIndex) - 1;
        }
        return this._flightPlans[flightPlanIndex].activeWaypointIndex === this.getWaypointsCount(flightPlanIndex) - 1;
      }

      /**
       * Sets the index of the active waypoint in the flight plan.
       * @param index The index to make active in the flight plan.
       * @param callback A callback to call when the operation has completed.
       * @param fplnIndex The index of the flight plan
       */
      setActiveWaypointIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
        let fplnIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[fplnIndex];
        // we allow the last leg to be sequenced therefore the index can be 1 past the end of the plan length
        if (index >= 0 && index <= currentFlightPlan.length) {
          currentFlightPlan.activeWaypointIndex = index;
          Coherent.call('SET_ACTIVE_WAYPOINT_INDEX', index + 1).catch(console.error);
          if (currentFlightPlan.directTo.isActive && currentFlightPlan.directTo.waypointIsInFlightPlan && currentFlightPlan.activeWaypointIndex > currentFlightPlan.directTo.planWaypointIndex) {
            currentFlightPlan.directTo.isActive = false;
          }
        }
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /** Unknown */
      recomputeActiveWaypointIndex() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
        callback();
      }

      /**
       * Gets the index of the waypoint prior to the currently active waypoint.
       * @param forceSimVarCall Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getPreviousActiveWaypoint() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const previousWaypointIndex = currentFlightPlan.activeWaypointIndex - 1;
        return currentFlightPlan.getWaypoint(previousWaypointIndex);
      }

      /**
       * Gets the ident of the active waypoint.
       * @param forceSimVarCall Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getActiveWaypointIdent() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.activeWaypoint) {
          return currentFlightPlan.activeWaypoint.ident;
        }
        return '';
      }

      /**
       * Gets the active waypoint index from fs9gps. Currently unimplemented.
       * @param forceSimVarCall Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getGPSActiveWaypointIndex() {
        return this.getActiveWaypointIndex();
      }

      /**
       * Gets the active waypoint.
       * @param forceSimVarCall Unused
       * @param useCorrection Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getActiveWaypoint() {
        let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
        if (Number.isNaN(flightPlanIndex)) {
          flightPlanIndex = this._currentFlightPlanIndex;
        }
        return this._flightPlans[flightPlanIndex].activeWaypoint;
      }

      /**
       * Gets the next waypoint following the active waypoint.
       * @param forceSimVarCall Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getNextActiveWaypoint() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const nextWaypointIndex = currentFlightPlan.activeWaypointIndex + 1;
        return currentFlightPlan.getWaypoint(nextWaypointIndex);
      }

      /**
       * Gets the distance, in NM, to the active waypoint.
       */
      getDistanceToActiveWaypoint() {
        // TODO Replace with ADIRS getLatitude() getLongitude()
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        const ll = new LatLongAlt(lat, long);
        const waypoint = this.getActiveWaypoint();
        if (waypoint && waypoint.infos) {
          return Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
        }
        return 0;
      }

      /**
       *
       * @param fplnIndex index of the flight plan of interest, default active fp
       * @returns distance in NM, or -1 on error
       */
      getDistanceToDestination() {
        var _stats$get$distanceFr, _stats$get;
        let fplnIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
        if (fplnIndex < 0) {
          fplnIndex = this._currentFlightPlanIndex;
        }
        const destIndex = this.getDestinationIndex();
        if (destIndex < 0) {
          return -1;
        }

        // TODO get proper pos from aims
        const fmPos = {
          lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
          long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
        };
        const fpln = this._flightPlans[fplnIndex];
        const stats = fpln.computeWaypointStatistics(fmPos);
        return (_stats$get$distanceFr = (_stats$get = stats.get(destIndex)) === null || _stats$get === void 0 ? void 0 : _stats$get.distanceFromPpos) !== null && _stats$get$distanceFr !== void 0 ? _stats$get$distanceFr : -1;
      }
      getApproachStats() {
        var _this$getApproach;
        const name = (_this$getApproach = this.getApproach(FlightPlans.Active)) === null || _this$getApproach === void 0 ? void 0 : _this$getApproach.name;
        if (!name) {
          return undefined;
        }
        const distanceFromPpos = this.getDistanceToDestination(FlightPlans.Active);
        return {
          name,
          distanceFromPpos
        };
      }

      /**
       * Gets the bearing, in degrees, to the active waypoint.
       */
      getBearingToActiveWaypoint() {
        // TODO Replace with ADIRS getLatitude() getLongitude()
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        const ll = new LatLongAlt(lat, long);
        const waypoint = this.getActiveWaypoint();
        if (waypoint && waypoint.infos) {
          return Avionics.Utils.computeGreatCircleHeading(ll, waypoint.infos.coordinates);
        }
        return 0;
      }

      /**
       * Gets the estimated time enroute to the active waypoint.
       */
      getETEToActiveWaypoint() {
        // TODO Replace with ADIRS getLatitude() getLongitude()
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        const ll = new LatLongAlt(lat, long);
        const waypoint = this.getActiveWaypoint();
        if (waypoint && waypoint.infos) {
          const dist = Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
          let groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');
          if (groundSpeed < 50) {
            groundSpeed = 50;
          }
          if (groundSpeed > 0.1) {
            return dist / groundSpeed * 3600;
          }
        }
        return 0;
      }

      /**
       * Gets the destination airfield of the current flight plan, if any.
       */
      getDestination() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        return this._flightPlans[flightPlanIndex].destinationAirfield;
      }

      /**
       * Gets the index of the destination airfield in the current flight plan, if any
       * @param flightPlanIndex flight plan index
       * @returns Index of destination
       */
      getDestinationIndex() {
        if (this.getDestination()) {
          return this.getWaypointsCount() - 1;
        }
        return -1;
      }

      /**
       * Gets the currently selected departure information for the current flight plan.
       */
      getDeparture() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;
        const origin = this.getOrigin();
        if (Number.isNaN(flightPlanIndex)) {
          flightPlanIndex = this._currentFlightPlanIndex;
        }
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        if (origin) {
          const originInfos = origin.infos;
          if (originInfos.departures !== undefined && currentFlightPlan.procedureDetails.departureIndex >= 0) {
            return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex];
          }
        }
        return undefined;
      }

      /**
       * Gets the currently selected departure information for the current flight plan, even after a direct-to.
       */
      getDepartureName() {
        const origin = this.getPersistentOrigin();
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (origin) {
          const originInfos = origin.infos;
          if (originInfos.departures !== undefined && currentFlightPlan.procedureDetails.departureIndex >= 0) {
            return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex].name;
          }
        }
        return undefined;
      }

      /**
       * Gets the currently selected arrival information for the current flight plan.
       */
      getArrival() {
        const destination = this.getDestination();
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (destination) {
          const originInfos = destination.infos;
          if (originInfos.arrivals !== undefined && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
            return originInfos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex];
          }
        }
        return undefined;
      }

      /**
       * Gets the currently selected approach information for the current flight plan.
       */
      getAirportApproach() {
        const destination = this.getDestination();
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (destination) {
          const originInfos = destination.infos;
          if (originInfos.approaches !== undefined && currentFlightPlan.procedureDetails.approachIndex >= 0) {
            return originInfos.approaches[currentFlightPlan.procedureDetails.approachIndex];
          }
        }
        return undefined;
      }

      /**
       * Gets the departure waypoints for the current flight plan.
       */
      getDepartureWaypoints() {
        return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
      }

      /**
       * Gets a map of the departure waypoints (?)
       */
      getDepartureWaypointsMap() {
        return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
      }

      /**
       * Gets the enroute waypoints for the current flight plan.
       * @param outFPIndex An array of waypoint indexes to be pushed to.
       */
      getEnRouteWaypoints(outFPIndex) {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const enrouteSegment = currentFlightPlan.enroute;
        if (enrouteSegment !== FlightPlanSegment.Empty) {
          for (let i = 0; i < enrouteSegment.waypoints.length; i++) {
            outFPIndex.push(enrouteSegment.offset + i);
          }
        }
        return enrouteSegment.waypoints;
      }

      /**
       * Gets the index of the last waypoint in the enroute segment of the current flight plan.
       */
      getEnRouteWaypointsFirstIndex() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        const enrouteSegment = currentFlightPlan === null || currentFlightPlan === void 0 ? void 0 : currentFlightPlan.enroute;
        return enrouteSegment === null || enrouteSegment === void 0 ? void 0 : enrouteSegment.offset;
      }

      /**
       * Gets the index of the last waypoint in the enroute segment of the current flight plan.
       */
      getEnRouteWaypointsLastIndex() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        const enrouteSegment = currentFlightPlan === null || currentFlightPlan === void 0 ? void 0 : currentFlightPlan.enroute;
        return enrouteSegment ? enrouteSegment.offset + (enrouteSegment.waypoints.length - 1) : null;
      }

      /**
       * Gets the arrival waypoints for the current flight plan.
       */
      getArrivalWaypoints() {
        return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
      }

      /**
       * Gets the arrival waypoints for the current flight plan as a map. (?)
       */
      getArrivalWaypointsMap() {
        return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
      }

      /**
       * Gets the waypoints for the current flight plan with altitude constraints.
       */
      getWaypointsWithAltitudeConstraints() {
        return this._flightPlans[this._currentFlightPlanIndex].waypoints;
      }

      /**
       * Gets the flight plan segment for a flight plan waypoint.
       * @param waypoint The waypoint we want to find the segment for.
       */
      getSegmentFromWaypoint(waypoint) {
        let flightPlanIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
        if (Number.isNaN(flightPlanIndex)) {
          flightPlanIndex = this._currentFlightPlanIndex;
        }
        const index = waypoint === undefined ? this.getActiveWaypointIndex() : this.indexOfWaypoint(waypoint);
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        return currentFlightPlan.findSegmentByWaypointIndex(index);
      }

      /**
       * Sets the destination for the current flight plan.
       * @param icao The ICAO designation for the destination airfield.
       * @param callback A callback to call once the operation completes.
       */
      async setDestination(icao) {
        var _this$getDestination;
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const sameAirport = ((_this$getDestination = this.getDestination()) === null || _this$getDestination === void 0 ? void 0 : _this$getDestination.ident) === icao;
        const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao);
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const destinationIndex = currentFlightPlan.length - 1;
        if (currentFlightPlan.hasDestination) {
          currentFlightPlan.removeWaypoint(destinationIndex);
        }
        currentFlightPlan.addWaypoint(waypoint);

        // make the waypoint before a discontinuity
        /*
        const { waypoints } = currentFlightPlan;
        if (waypoints.length > 0 && destinationIndex > 0) {
            const previous = currentFlightPlan.waypoints[destinationIndex - 1];
            // ensure we do not overwrite a possible discontinuityCanBeCleared
            if (!previous.endsInDiscontinuity) {
                previous.endsInDiscontinuity = true;
                previous.discontinuityCanBeCleared = true;
            }
        }
        */

        // clear pilot trans level
        this.setDestinationTransitionLevel(undefined, false);
        // TODO get destination trans level from database
        // until then, don't erase the database value from ATSU if same airport as before
        if (!sameAirport) {
          this.setDestinationTransitionLevel(undefined, true);
        }
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Adds a waypoint to the current flight plan.
       * @param icao The ICAO designation for the waypoint.
       * @param index The index of the waypoint to add.
       * @param callback A callback to call once the operation completes.
       * @param setActive Whether or not to set the added waypoint as active immediately.
       */
      async addWaypoint(icao) {
        let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch(e => {
          console.log("addWaypoint: [".concat(icao, "] Error"));
          console.error(e);
        });
        if (waypoint) {
          currentFlightPlan.addWaypoint(waypoint, index);
          this.updateFlightPlanVersion().catch(console.error);
          callback();
        }
      }

      /**
       * Adds a user waypoint to the current flight plan.
       * @param waypoint The user waypoint to add.
       * @param index The index to add the waypoint at in the flight plan.
       * @param callback A callback to call once the operation completes.
       */
      async addUserWaypoint(waypoint) {
        let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        currentFlightPlan.addWaypoint(waypoint, index);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }
      setLegAltitudeDescription(waypoint, code) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        if (waypoint) {
          waypoint.legAltitudeDescription = code;
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Sets the altitude constraint for a waypoint in the current flight plan.
       * @param altitude The altitude to set for the waypoint.
       * @param index The index of the waypoint to set.
       * @param callback A callback to call once the operation is complete.
       * @param isDescentConstraint For enroute waypoints, indicates whether constraint is a descent or climb constraint
       */
      setWaypointAltitude(altitude, index) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        let isDescentConstraint = arguments.length > 3 ? arguments[3] : undefined;
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const waypoint = currentFlightPlan.getWaypoint(index);
        if (waypoint) {
          waypoint.legAltitude1 = altitude;
          if (isDescentConstraint !== undefined && !waypoint.additionalData.constraintType) {
            // this propagates through intermediate waypoints
            if (isDescentConstraint) {
              this.setFirstDesConstraintWaypoint(index);
            } else {
              this.setLastClbConstraintWaypoint(index);
            }
          }
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Sets the speed constraint for a waypoint in the current flight plan.
       * @param speed The speed to set for the waypoint.
       * @param index The index of the waypoint to set.
       * @param callback A callback to call once the operation is complete.
       * @param isDescentConstraint For enroute waypoints, indicates whether constraint is a descent or climb constraint
       */
      setWaypointSpeed(speed, index) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        let isDescentConstraint = arguments.length > 3 ? arguments[3] : undefined;
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const waypoint = currentFlightPlan.getWaypoint(index);
        if (waypoint) {
          waypoint.speedConstraint = speed;
          // this propagates through intermediate waypoints
          if (isDescentConstraint) {
            this.setFirstDesConstraintWaypoint(index);
          } else {
            this.setLastClbConstraintWaypoint(index);
          }
          this.updateFlightPlanVersion();
        }
        callback();
      }
      setLastClbConstraintWaypoint(index) {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        for (let i = index; i >= 0; i--) {
          const waypoint = currentFlightPlan.getWaypoint(i);
          if (waypoint) {
            waypoint.additionalData.constraintType = WaypointConstraintType.CLB;
          }
        }
      }
      setFirstDesConstraintWaypoint(index) {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        for (let i = index; i < this.getWaypointsCount(); i++) {
          const waypoint = currentFlightPlan.getWaypoint(i);
          if (waypoint) {
            waypoint.additionalData.constraintType = WaypointConstraintType.DES;
          }
        }
      }

      /**
       * Sets additional data on a waypoint in the current flight plan.
       * @param index The index of the waypoint to set additional data for.
       * @param key The key of the data.
       * @param value The value of the data.
       * @param callback A callback to call once the operation is complete.
       */
      setWaypointAdditionalData(index, key, value) {
        let callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const waypoint = currentFlightPlan.getWaypoint(index);
        if (waypoint) {
          waypoint.additionalData[key] = value;
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Gets additional data on a waypoint in the current flight plan.
       * @param index The index of the waypoint to set additional data for.
       * @param key The key of the data.
       * @param callback A callback to call with the value once the operation is complete.
       */
      getWaypointAdditionalData(index, key) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const waypoint = currentFlightPlan.getWaypoint(index);
        if (waypoint) {
          callback(waypoint.additionalData[key]);
        } else {
          callback(undefined);
        }
      }

      /**
       * Reverses the currently active flight plan.
       * @param {() => void} callback A callback to call when the operation is complete.
       */
      invertActiveFlightPlan() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
        this._flightPlans[this._currentFlightPlanIndex].reverse();
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Not sure what this is supposed to do.
       * @param callback Stuff?
       */
      getApproachIfIcao() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
        callback(this.getApproach());
      }

      /**
       * Unused
       * @param {*} _callback Unused
       */
      addFlightPlanUpdateCallback(_callback) {
        // empty
      }

      /**
       * Adds a waypoint to the currently active flight plan by ident(?)
       * @param ident The ident of the waypoint.
       * @param index The index to add the waypoint at.
       * @param callback A callback to call when the operation finishes.
       */
      addWaypointByIdent(ident, index) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EmptyCallback.Void;
        this.addWaypoint(ident, index, callback).catch(console.error);
      }

      /**
       * Removes a waypoint from the currently active flight plan.
       * @param index The index of the waypoint to remove.
       * @param noDiscontinuity Don't create a discontinuity
       * @param callback A callback to call when the operation finishes.
       */
      removeWaypoint(index) {
        let noDiscontinuity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        this._flightPlans[this._currentFlightPlanIndex].removeWaypoint(index, noDiscontinuity);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addWaypointOverfly(index) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, true);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      removeWaypointOverfly(index) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, false);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }
      addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
        const holdIndex = this._flightPlans[this._currentFlightPlanIndex].addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold);
        this.updateFlightPlanVersion().catch(console.error);
        return holdIndex;
      }

      /**
       * Truncates a flight plan after a specific waypoint.
       * @param index The index of the first waypoint to remove.
       * @param callback A callback to call when the operation finishes.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      truncateWaypoints(index) {
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        const fp = this._flightPlans[this._currentFlightPlanIndex];
        for (let i = fp.length; i >= index; i--) {
          fp.removeWaypoint(index);
        }
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Gets the index of a given waypoint in the current flight plan.
       * @param waypoint The waypoint to get the index of.
       */
      indexOfWaypoint(waypoint) {
        return this._flightPlans[this._currentFlightPlanIndex].waypoints.indexOf(waypoint);
      }

      /**
       * Gets the number of waypoints in a flight plan.
       * @param flightPlanIndex The index of the flight plan. If omitted, will get the current flight plan.
       */
      getWaypointsCount() {
        var _this$_flightPlans$fl3, _this$_flightPlans$fl4;
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;
        if (Number.isNaN(flightPlanIndex)) {
          var _this$_flightPlans$th, _this$_flightPlans$th2;
          return (_this$_flightPlans$th = (_this$_flightPlans$th2 = this._flightPlans[this._currentFlightPlanIndex]) === null || _this$_flightPlans$th2 === void 0 ? void 0 : _this$_flightPlans$th2.length) !== null && _this$_flightPlans$th !== void 0 ? _this$_flightPlans$th : 0;
        }
        return (_this$_flightPlans$fl3 = (_this$_flightPlans$fl4 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl4 === void 0 ? void 0 : _this$_flightPlans$fl4.length) !== null && _this$_flightPlans$fl3 !== void 0 ? _this$_flightPlans$fl3 : 0;
      }

      /**
       * Gets a count of the number of departure waypoints in the current flight plan.
       */
      getDepartureWaypointsCount() {
        return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints.length;
      }

      /**
       * Gets a count of the number of arrival waypoints in the current flight plan.
       */
      getArrivalWaypointsCount() {
        return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints.length;
      }

      /**
       * Gets a waypoint from a flight plan.
       * @param index The index of the waypoint to get.
       * @param flightPlanIndex The index of the flight plan to get the waypoint from. If omitted, will get from the current flight plan.
       * @param considerApproachWaypoints Whether or not to consider approach waypoints.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getWaypoint(index) {
        var _this$_flightPlans$fl5;
        let flightPlanIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
        if (Number.isNaN(flightPlanIndex)) {
          flightPlanIndex = this._currentFlightPlanIndex;
        }
        return (_this$_flightPlans$fl5 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl5 === void 0 ? void 0 : _this$_flightPlans$fl5.getWaypoint(index);
      }

      /**
       * Gets all non-approach waypoints from a flight plan.
       *
       * @param flightPlanIndex The index of the flight plan to get the waypoints from. If omitted, will get from the current flight plan.
       */
      getWaypoints() {
        var _this$_flightPlans$fl6, _this$_flightPlans$fl7;
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;
        if (Number.isNaN(flightPlanIndex)) {
          flightPlanIndex = this._currentFlightPlanIndex;
        }
        return (_this$_flightPlans$fl6 = (_this$_flightPlans$fl7 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl7 === void 0 ? void 0 : _this$_flightPlans$fl7.nonApproachWaypoints) !== null && _this$_flightPlans$fl6 !== void 0 ? _this$_flightPlans$fl6 : [];
      }

      /**
       * Gets all waypoints from a flight plan.
       * @param flightPlanIndex The index of the flight plan to get the waypoints from. If omitted, will get from the current flight plan.
       */
      getAllWaypoints(flightPlanIndex) {
        if (flightPlanIndex === undefined) {
          flightPlanIndex = this._currentFlightPlanIndex;
        }
        return this._flightPlans[flightPlanIndex].waypoints;
      }

      /**
       * Gets the departure runway index, based on the departure in a flight plan.
       */
      getDepartureRunwayIndex() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.hasOrigin) {
          return currentFlightPlan.procedureDetails.departureRunwayIndex;
        }
        return -1;
      }

      /**
       * Gets the index value of the origin runway (oneWayRunways) in a flight plan.
       */
      getOriginRunwayIndex() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.procedureDetails.originRunwayIndex >= 0 && currentFlightPlan.originAirfield) {
          return currentFlightPlan.procedureDetails.originRunwayIndex;
        }
        return -1;
      }

      /**
       * Gets the string value of the departure runway in the current flight plan.
       */
      getOriginRunway() {
        const runwayIndex = this.getOriginRunwayIndex();
        if (runwayIndex >= 0) {
          return this.getOrigin().infos.oneWayRunways[runwayIndex];
        }
        return undefined;
      }

      /**
       * Gets the best runway based on the current plane heading.
       */
      getDetectedCurrentRunway() {
        const origin = this.getOrigin();
        if (origin && origin.infos instanceof AirportInfo) {
          const runways = origin.infos.oneWayRunways;
          if (runways && runways.length > 0) {
            const direction = Simplane.getHeadingMagnetic();
            let bestRunway = runways[0];
            let bestDeltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, bestRunway.direction));
            for (let i = 1; i < runways.length; i++) {
              const deltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, runways[i].direction));
              if (deltaAngle < bestDeltaAngle) {
                bestDeltaAngle = deltaAngle;
                bestRunway = runways[i];
              }
            }
            return bestRunway;
          }
        }
        return undefined;
      }

      /**
       * Gets the departure procedure index for the current flight plan.
       */
      getDepartureProcIndex() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        return currentFlightPlan.procedureDetails.departureIndex;
      }

      /**
       * Sets the departure procedure index for the current flight plan.
       * @param index The index of the departure procedure in the origin airport departures information.
       * @param callback A callback to call when the operation completes.
       */
      async setDepartureProcIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.procedureDetails.departureIndex !== index) {
          currentFlightPlan.procedureDetails.departureIndex = index;
          await currentFlightPlan.buildDeparture().catch(console.error);
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Sets the departure runway index for the current flight plan.
       * @param index The index of the runway in the origin airport runway information.
       * @param callback A callback to call when the operation completes.
       */
      async setDepartureRunwayIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.procedureDetails.departureRunwayIndex !== index) {
          currentFlightPlan.procedureDetails.departureRunwayIndex = index;
          await currentFlightPlan.buildDeparture().catch(console.error);
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Sets the origin runway index for the current flight plan.
       * @param index The index of the runway in the origin airport runway information.
       * @param callback A callback to call when the operation completes.
       */
      async setOriginRunwayIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.procedureDetails.originRunwayIndex !== index) {
          currentFlightPlan.procedureDetails.originRunwayIndex = index;
          await currentFlightPlan.buildDeparture().catch(console.error);
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }
      async setOriginRunwayIndexFromDeparture() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.hasOrigin && currentFlightPlan.procedureDetails.departureRunwayIndex >= 0 && currentFlightPlan.procedureDetails.departureIndex >= 0 && currentFlightPlan.originAirfield) {
          const transition = currentFlightPlan.originAirfield.infos.departures[currentFlightPlan.procedureDetails.departureIndex].runwayTransitions[currentFlightPlan.procedureDetails.departureRunwayIndex];
          const runways = currentFlightPlan.originAirfield.infos.oneWayRunways;
          await this.setOriginRunwayIndex(runways.findIndex(r => r.number === transition.runwayNumber && r.designator === transition.runwayDesignation));
        }
      }

      /**
       * Gets the departure transition index for the current flight plan.
       */
      getDepartureEnRouteTransitionIndex() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        return currentFlightPlan.procedureDetails.departureTransitionIndex;
      }

      /**
       * Sets the departure transition index for the current flight plan.
       * @param index The index of the departure transition to select.
       * @param callback A callback to call when the operation completes.
       */
      async setDepartureEnRouteTransitionIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.procedureDetails.departureTransitionIndex !== index) {
          currentFlightPlan.procedureDetails.departureTransitionIndex = index;
          await currentFlightPlan.buildDeparture().catch(console.error);
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Unused
       */
      getDepartureDiscontinuity() {
        // empty
      }

      /**
       * Unused
       * @param callback A callback to call when the operation completes.
       */
      clearDepartureDiscontinuity() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
        callback();
      }

      /**
       * Removes the departure from the currently active flight plan.
       * @param callback A callback to call when the operation completes.
       */
      async removeDeparture() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        currentFlightPlan.procedureDetails.departureIndex = -1;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Gets the arrival procedure index in the currenly active flight plan.
       */
      getArrivalProcIndex() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
          return currentFlightPlan.procedureDetails.arrivalIndex;
        }
        return -1;
      }

      /**
       * Gets the arrival transition procedure index in the currently active flight plan.
       */
      getArrivalTransitionIndex() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        return currentFlightPlan.procedureDetails.arrivalTransitionIndex;
      }

      /**
       * Sets the arrival procedure index for the current flight plan.
       * @param {Number} index The index of the arrival procedure to select.
       * @param {() => void} callback A callback to call when the operation completes.
       */
      async setArrivalProcIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.procedureDetails.arrivalIndex !== index) {
          // console.log('FPM: setArrivalProcIndex: SET STAR ', currentFlightPlan.destinationAirfield.infos.arrivals[index].name);
          currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
          currentFlightPlan.procedureDetails.arrivalIndex = index;
          currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
          await currentFlightPlan.rebuildArrivalApproach();
          this.updateFlightPlanVersion().catch(console.error);
        }

        // TODO check for transition level coded in procedure...
        // pick higher of procedure or destination airfield trans fl

        callback();
      }

      /**
       * Unused
       */
      getArrivalDiscontinuity() {
        // empty
      }

      /**
       * Unused
       * @param {*} callback
       */
      clearArrivalDiscontinuity() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
        callback();
      }

      /**
       * Clears a discontinuity from the end of a waypoint.
       * @param index
       */
      clearDiscontinuity(index) {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        const waypoint = currentFlightPlan.getWaypoint(index);
        const nextWaypoint = currentFlightPlan.getWaypoint(index + 1);
        if (waypoint !== undefined && nextWaypoint !== undefined && waypoint.discontinuityCanBeCleared) {
          waypoint.endsInDiscontinuity = false;
          switch (nextWaypoint.additionalData.legType) {
            case LegType.FA:
            case LegType.FC:
            case LegType.FD:
            case LegType.FM:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
              this.addWaypointByIdent(nextWaypoint.icao, index + 1, () => this.updateFlightPlanVersion().catch(console.error));
              break;
            default:
              this.updateFlightPlanVersion().catch(console.error);
          }
          return true;
        }
        this.updateFlightPlanVersion().catch(console.error);
        return false;
      }

      /**
       * Sets the arrival transition index for the current flight plan.
       * @param {Number} index The index of the arrival transition to select.
       * @param {() => void} callback A callback to call when the operation completes.
       */
      async setArrivalEnRouteTransitionIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        // console.log('FPM: setArrivalEnRouteTransitionIndex: SET TRANSITION - ARRIVAL',
        // currentFlightPlan.destinationAirfield.infos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex].enRouteTransitions[index].name);

        if (currentFlightPlan.procedureDetails.arrivalTransitionIndex !== index) {
          currentFlightPlan.procedureDetails.arrivalTransitionIndex = index;
          await currentFlightPlan.rebuildArrivalApproach();
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Sets the arrival runway index in the currently active flight plan.
       * @param {Number} index The index of the runway to select.
       * @param {() => void} callback A callback to call when the operation completes.
       */
      async setArrivalRunwayIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.procedureDetails.arrivalRunwayIndex !== index) {
          /* if (currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
              console.log(`setArrivalRunwayIndex: Finishing at
              ${currentFlightPlan.destinationAirfield.infos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex].runwayTransitions[index].name}`);
          } else {
              console.log('setArrivalRunwayIndex: Finishing at none');
          } */
          currentFlightPlan.procedureDetails.arrivalRunwayIndex = index;
          await currentFlightPlan.rebuildArrivalApproach();
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Sets the destination runway index in the currently active flight plan.
       * @param index The index of the runway to select.
       * @param runwayExtension The length of the runway extension fix to create, or -1 if none.
       * @param callback A callback to call when the operation completes.
       */
      async setDestinationRunwayIndex(index) {
        let runwayExtension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
        let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        // console.log('setDestinationRunwayIndex - APPROACH');

        if (currentFlightPlan.procedureDetails.destinationRunwayIndex !== index || currentFlightPlan.procedureDetails.destinationRunwayExtension !== runwayExtension) {
          currentFlightPlan.procedureDetails.destinationRunwayIndex = index;
          currentFlightPlan.procedureDetails.destinationRunwayExtension = runwayExtension;
          await currentFlightPlan.buildApproach().catch(console.error);
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Sets the destination runway index using the current selected approach
       */
      async setDestinationRunwayIndexFromApproach() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
          const approach = currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
          const destRunways = currentFlightPlan.destinationAirfield.infos.oneWayRunways;
          await this.setDestinationRunwayIndex(destRunways.findIndex(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator));
        }
      }

      /**
       * Gets the index of the approach in the currently active flight plan.
       */
      getApproachIndex() {
        return this._flightPlans[this._currentFlightPlanIndex].procedureDetails.approachIndex;
      }

      /**
       * Sets the approach index in the currently active flight plan.
       * @param index The index of the approach in the destination airport information.
       * @param callback A callback to call when the operation has completed.
       * @param transition The approach transition index to set in the approach information.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async setApproachIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        // console.log(currentFlightPlan);

        if (currentFlightPlan.procedureDetails.approachIndex !== index) {
          // console.log('FPM: setApproachIndex - APPROACH', currentFlightPlan.destinationAirfield.infos.approaches[index].name);
          currentFlightPlan.procedureDetails.approachIndex = index;
          currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
          currentFlightPlan.procedureDetails.arrivalIndex = -1;
          currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
          await currentFlightPlan.rebuildArrivalApproach();
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Whether or not an approach is loaded in the current flight plan.
       * @param forceSimVarCall Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      isLoadedApproach() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        return currentFlightPlan.procedureDetails.approachIndex >= 0;
      }

      /**
       * Whether or not the approach is active in the current flight plan.
       * @param forceSimVarCall Unused
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      isActiveApproach() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        return currentFlightPlan.approach.waypoints.length > 0 && currentFlightPlan.activeWaypointIndex >= currentFlightPlan.approach.offset;
      }

      /**
       * Activates the approach segment in the current flight plan.
       * @param {() => void} callback
       */
      async activateApproach() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (!this.isActiveApproach() && currentFlightPlan.approach.offset >= 0) {
          await GPS.setActiveWaypoint(currentFlightPlan.approach.offset).catch(console.error);
        }
        callback();
      }

      /**
       * Deactivates the approach segments in the current flight plan.
       */
      deactivateApproach() {
        // empty
      }

      /**
       * Attemptes to auto-activate the approach in the current flight plan.
       */
      tryAutoActivateApproach() {
        // empty
      }

      /**
       * Gets the index of the active waypoint on the approach in the current flight plan.
       */
      getApproachActiveWaypointIndex() {
        return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
      }

      /**
       * Gets the approach procedure from the current flight plan destination airport procedure information.
       */
      getApproach() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
          return currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
        }
        return undefined;
      }

      /**
       * Gets the index of the approach transition in the current flight plan.
       */
      getApproachTransitionIndex() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        return currentFlightPlan.procedureDetails.approachTransitionIndex;
      }

      /**
       * Gets the last waypoint index before the start of the approach segment in
       * the current flight plan.
       */
      getLastIndexBeforeApproach() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        // TODO: if we have an approach return last index
        if (currentFlightPlan.approach !== FlightPlanSegment.Empty) {
          return currentFlightPlan.approach.offset - 1;
        }
        return this.getWaypointsCount();
      }

      /**
       * Gets the destination runway from the current flight plan.
       */
      getDestinationRunway() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const flightPlan = this._flightPlans[flightPlanIndex];
        const runwayIndex = this.getDestinationRunwayIndex(flightPlanIndex);
        if (runwayIndex >= 0) {
          return flightPlan.destinationAirfield.infos.oneWayRunways[runwayIndex];
        }
        return undefined;
      }

      /**
       * Gets the destination runway index (oneWayRunways) from the current flight plan.
       */
      getDestinationRunwayIndex() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const flightPlan = this._flightPlans[flightPlanIndex];
        if (flightPlan.procedureDetails.destinationRunwayIndex >= 0 && flightPlan.destinationAirfield) {
          return flightPlan.procedureDetails.destinationRunwayIndex;
        }
        if (flightPlan.hasDestination && flightPlan.procedureDetails.approachIndex >= 0) {
          console.error('Destination runway index is -1 with valid STAR');
          const approach = flightPlan.destinationAirfield.infos.approaches[flightPlan.procedureDetails.approachIndex];
          const runways = flightPlan.destinationAirfield.infos.oneWayRunways;
          return runways.findIndex(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
        }
        return -1;
      }

      /**
       * Gets the approach waypoints for the current flight plan.
       */
      getApproachWaypoints() {
        return this._flightPlans[this._currentFlightPlanIndex].approach.waypoints;
      }

      /**
       * Sets the approach transition index for the current flight plan.
       * @param index The index of the transition in the destination airport approach information.
       * @param callback A callback to call when the operation completes.
       */
      async setApproachTransitionIndex(index) {
        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        // console.log('setApproachTransitionIndex - APPROACH');

        if (currentFlightPlan.procedureDetails.approachTransitionIndex !== index) {
          // console.log(`setApproachIndex: APPR TRANS ${currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex].transitions[index].name}`);
          currentFlightPlan.procedureDetails.approachTransitionIndex = index;
          await currentFlightPlan.rebuildArrivalApproach();
          this.updateFlightPlanVersion().catch(console.error);
        }
        callback();
      }

      /**
       * Removes the arrival segment from the current flight plan.
       * @param callback A callback to call when the operation completes.
       */
      async removeArrival() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        // console.log('remove arrival - ARRIVAL');

        currentFlightPlan.procedureDetails.arrivalIndex = -1;
        currentFlightPlan.procedureDetails.arrivalRunwayIndex = -1;
        currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
        await currentFlightPlan.buildArrival().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }

      /**
       * Inserts direct-to an ICAO designated fix.
       *
       * @param icao The ICAO designation for the fix to fly direct-to.
       */
      async insertDirectTo(waypoint) {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        await currentFlightPlan.addDirectTo(waypoint);
        this.updateFlightPlanVersion().catch(console.error);
      }

      /**
       * Cancels the current direct-to and proceeds back along the flight plan.
       * @param callback A callback to call when the operation completes.
       */
      cancelDirectTo() {
        let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
        // const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        // currentFlightPlan.directTo.cancel();

        callback();
      }

      /**
       * Gets whether or not the flight plan is current in a direct-to procedure.
       */
      getIsDirectTo() {
        return this._flightPlans[this._currentFlightPlanIndex].directTo.isActive;
      }

      /**
       * Gets the target of the direct-to procedure in the current flight plan.
       */
      getDirectToTarget() {
        const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
        if (currentFlightPlan.directTo.waypointIsInFlightPlan) {
          return currentFlightPlan.waypoints[currentFlightPlan.directTo.planWaypointIndex];
        }
        return currentFlightPlan.directTo.waypoint;
      }

      /**
       * Gets the origin/start waypoint of the direct-to procedure in the current flight plan.
       */
      getDirecToOrigin() {
        return this._flightPlans[this._currentFlightPlanIndex].directTo.interceptPoints[0];
      }
      getCoordinatesHeadingAtDistanceAlongFlightPlan(_distance) {
        // empty
      }

      /**
       * Gets the coordinates of a point that is a specific distance from the destination along the flight plan.
       * @param distance The distance from destination we want the coordinates for.
       */
      getCoordinatesAtNMFromDestinationAlongFlightPlan(distance) {
        const allWaypoints = this.getAllWaypoints();
        const destination = this.getDestination();
        if (destination) {
          const fromStartDistance = destination.cumulativeDistanceInFP - distance;
          let prev;
          let next;
          for (let i = 0; i < allWaypoints.length - 1; i++) {
            prev = allWaypoints[i];
            next = allWaypoints[i + 1];
            if (prev.cumulativeDistanceInFP < fromStartDistance && next.cumulativeDistanceInFP > fromStartDistance) {
              break;
            }
          }
          const prevCD = prev.cumulativeDistanceInFP;
          const nextCD = next.cumulativeDistanceInFP;
          const d = (fromStartDistance - prevCD) / (nextCD - prevCD);
          const output = new LatLongAlt();
          output.lat = Avionics.Utils.lerpAngle(prev.infos.coordinates.lat, next.infos.coordinates.lat, d);
          output.long = Avionics.Utils.lerpAngle(prev.infos.coordinates.long, next.infos.coordinates.long, d);
          return output;
        }
        return null;
      }

      /**
       * Gets the current stored flight plan
       */
      _getFlightPlan() {
        {
          return;
        }
      }
      getCurrentFlightPlan() {
        return this._flightPlans[this._currentFlightPlanIndex];
      }
      getFlightPlan(index) {
        return this._flightPlans[index];
      }

      /**
       * Updates the synchronized flight plan version and saves it to shared storage.
       */
      async updateFlightPlanVersion() {
        if (this._isSyncPaused) {
          return;
        }
        SimVar.SetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number', ++this._currentFlightPlanVersion);
        if (NXDataStore.get('FP_SYNC', 'LOAD') === 'SAVE') {
          FlightPlanAsoboSync.SaveToGame(this).catch(console.error);
        }
      }
      pauseSync() {
        this._isSyncPaused = true;
        console.log('FlightPlan Sync Paused');
      }
      resumeSync() {
        this._isSyncPaused = false;
        this.updateFlightPlanVersion().catch(console.error);
        console.log('FlightPlan Sync Resume');
      }
      get currentFlightPlanVersion() {
        return this._currentFlightPlanVersion;
      }
      getOriginTransitionAltitude() {
        var _currentFlightPlan$or;
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        return (_currentFlightPlan$or = currentFlightPlan.originTransitionAltitudePilot) !== null && _currentFlightPlan$or !== void 0 ? _currentFlightPlan$or : currentFlightPlan.originTransitionAltitudeDb;
      }

      /**
       * The transition altitude for the origin in the *active* flight plan
       */
      get originTransitionAltitude() {
        return this.getOriginTransitionAltitude(0);
      }
      getOriginTransitionAltitudeIsFromDb() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        return currentFlightPlan.originTransitionAltitudePilot === undefined;
      }

      /**
       * Is the transition altitude for the origin in the *active* flight plan from the database?
       */
      get originTransitionAltitudeIsFromDb() {
        return this.getOriginTransitionAltitudeIsFromDb(0);
      }

      /**
       * Set the transition altitude for the origin
       * @param altitude transition altitude
       * @param database is this value from the database, or pilot?
       * @param flightPlanIndex index of flight plan to be edited, defaults to current plan being edited (not active!)
       */
      setOriginTransitionAltitude(altitude) {
        let database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        if (database) {
          currentFlightPlan.originTransitionAltitudeDb = altitude;
        } else {
          currentFlightPlan.originTransitionAltitudePilot = altitude;
        }
        this.updateFlightPlanVersion();
      }
      getDestinationTransitionLevel() {
        var _currentFlightPlan$de;
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        return (_currentFlightPlan$de = currentFlightPlan.destinationTransitionLevelPilot) !== null && _currentFlightPlan$de !== void 0 ? _currentFlightPlan$de : currentFlightPlan.destinationTransitionLevelDb;
      }

      /**
       * The transition level for the destination in the *active* flight plan
       */
      get destinationTransitionLevel() {
        return this.getDestinationTransitionLevel(0);
      }
      getDestinationTransitionLevelIsFromDb() {
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        return currentFlightPlan.destinationTransitionLevelPilot === undefined;
      }

      /**
       * Is the transition level for the destination in the *active* flight plan from the database?
       */
      get destinationTransitionLevelIsFromDb() {
        return this.getDestinationTransitionLevelIsFromDb(0);
      }

      /**
       * Set the transition level for the destination
       * @param flightLevel transition level
       * @param database is this value from the database, or pilot?
       * @param flightPlanIndex index of flight plan to be edited, defaults to current plan being edited (not active!)
       */
      setDestinationTransitionLevel(flightLevel) {
        let database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
        const currentFlightPlan = this._flightPlans[flightPlanIndex];
        if (database) {
          currentFlightPlan.destinationTransitionLevelDb = flightLevel;
        } else {
          currentFlightPlan.destinationTransitionLevelPilot = flightLevel;
        }
        this.updateFlightPlanVersion();
      }
      getFixInfo(index) {
        return this._fixInfos[index];
      }
      isWaypointInUse(icao) {
        for (const fp of this._flightPlans) {
          for (let i = 0; i < (fp === null || fp === void 0 ? void 0 : fp.waypoints.length); i++) {
            if (fp.getWaypoint(i).icao === icao) {
              return true;
            }
          }
        }
        for (const fixInfo of this._fixInfos) {
          var _fixInfo$getRefFix;
          if ((fixInfo === null || fixInfo === void 0 ? void 0 : (_fixInfo$getRefFix = fixInfo.getRefFix()) === null || _fixInfo$getRefFix === void 0 ? void 0 : _fixInfo$getRefFix.infos.icao) === icao) {
            return true;
          }
        }
        return false;
      }
      get activeFlightPlan() {
        return this._flightPlans[FlightPlans.Active];
      }
      getApproachType() {
        var _fp$procedureDetails$;
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const fp = this._flightPlans[flightPlanIndex];
        return (_fp$procedureDetails$ = fp === null || fp === void 0 ? void 0 : fp.procedureDetails.approachType) !== null && _fp$procedureDetails$ !== void 0 ? _fp$procedureDetails$ : undefined;
      }
      getGlideslopeIntercept() {
        var _fp$glideslopeInterce;
        let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
        const fp = this._flightPlans[flightPlanIndex];
        return (_fp$glideslopeInterce = fp === null || fp === void 0 ? void 0 : fp.glideslopeIntercept) !== null && _fp$glideslopeInterce !== void 0 ? _fp$glideslopeInterce : undefined;
      }
      updateActiveArea() {
        const activeFp = this._flightPlans[FlightPlans.Active];
        if (!activeFp) {
          this.activeArea = FlightArea.Terminal;
          return;
        }
        this.activeArea = this.calculateActiveArea(activeFp);
      }
      calculateActiveArea(activeFp) {
        const activeIndex = activeFp.activeWaypointIndex;
        const appr = activeFp.getSegment(SegmentType.Approach);
        const arrival = activeFp.getSegment(SegmentType.Arrival);
        const departure = activeFp.getSegment(SegmentType.Departure);
        if (departure !== FlightPlanSegment.Empty && activeIndex < departure.offset + departure.waypoints.length) {
          return FlightArea.Terminal;
        }
        if (arrival !== FlightPlanSegment.Empty && activeIndex >= arrival.offset && activeIndex < arrival.offset + arrival.waypoints.length) {
          return FlightArea.Terminal;
        }
        if (appr !== FlightPlanSegment.Empty && activeIndex >= appr.offset && activeIndex < appr.offset + appr.waypoints.length && activeFp.finalApproachActive) {
          const apprType = activeFp.procedureDetails.approachType;
          switch (apprType) {
            case ApproachType.APPROACH_TYPE_ILS:
              return FlightArea.PrecisionApproach;
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
              return FlightArea.GpsApproach;
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
              return FlightArea.VorApproach;
            default:
              return FlightArea.NonPrecisionApproach;
          }
        }
        return FlightArea.Enroute;
      }
    }
    _defineProperty$2(FlightPlanManager, "DEBUG_INSTANCE", void 0);
    _defineProperty$2(FlightPlanManager, "FlightPlanKey", 'B77HS.FlightPlan');
    _defineProperty$2(FlightPlanManager, "FlightPlanCompressedKey", 'B77HS.FlightPlan.Compressed');
    _defineProperty$2(FlightPlanManager, "FlightPlanVersionKey", 'L:B77HS.FlightPlan.Version');

    // Copyright (c) 2021-2022 FlyByWire Simulations
    // Copyright (c) 2021-2022 Synaptic Simulations
    //
    // SPDX-License-Identifier: GPL-3.0

    /**
     * This enum represents a Control Law selected by the guidance system.
     */
    let ControlLaw;
    (function (ControlLaw) {
      ControlLaw[ControlLaw["HEADING"] = 1] = "HEADING";
      ControlLaw[ControlLaw["TRACK"] = 2] = "TRACK";
      ControlLaw[ControlLaw["LATERAL_PATH"] = 3] = "LATERAL_PATH";
    })(ControlLaw || (ControlLaw = {}));
    let RequestedVerticalMode;
    (function (RequestedVerticalMode) {
      RequestedVerticalMode[RequestedVerticalMode["None"] = 0] = "None";
      RequestedVerticalMode[RequestedVerticalMode["SpeedThrust"] = 1] = "SpeedThrust";
      RequestedVerticalMode[RequestedVerticalMode["VpathThrust"] = 2] = "VpathThrust";
      RequestedVerticalMode[RequestedVerticalMode["VpathSpeed"] = 3] = "VpathSpeed";
      RequestedVerticalMode[RequestedVerticalMode["FpaSpeed"] = 4] = "FpaSpeed";
      RequestedVerticalMode[RequestedVerticalMode["VsSpeed"] = 5] = "VsSpeed";
    })(RequestedVerticalMode || (RequestedVerticalMode = {}));

    var LateralMode;
    (function (LateralMode) {
      LateralMode[LateralMode["NONE"] = 0] = "NONE";
      LateralMode[LateralMode["HDG"] = 10] = "HDG";
      LateralMode[LateralMode["TRACK"] = 11] = "TRACK";
      LateralMode[LateralMode["NAV"] = 20] = "NAV";
      LateralMode[LateralMode["LOC_CPT"] = 30] = "LOC_CPT";
      LateralMode[LateralMode["LOC_TRACK"] = 31] = "LOC_TRACK";
      LateralMode[LateralMode["LAND"] = 32] = "LAND";
      LateralMode[LateralMode["FLARE"] = 33] = "FLARE";
      LateralMode[LateralMode["ROLL_OUT"] = 34] = "ROLL_OUT";
      LateralMode[LateralMode["RWY"] = 40] = "RWY";
      LateralMode[LateralMode["RWY_TRACK"] = 41] = "RWY_TRACK";
      LateralMode[LateralMode["GA_TRACK"] = 50] = "GA_TRACK";
    })(LateralMode || (LateralMode = {}));
    var ArmedLateralMode;
    (function (ArmedLateralMode) {
      ArmedLateralMode[ArmedLateralMode["NAV"] = 0] = "NAV";
      ArmedLateralMode[ArmedLateralMode["LOC"] = 1] = "LOC";
    })(ArmedLateralMode || (ArmedLateralMode = {}));
    var VerticalMode;
    (function (VerticalMode) {
      VerticalMode[VerticalMode["NONE"] = 0] = "NONE";
      VerticalMode[VerticalMode["ALT"] = 10] = "ALT";
      VerticalMode[VerticalMode["ALT_CPT"] = 11] = "ALT_CPT";
      VerticalMode[VerticalMode["OP_CLB"] = 12] = "OP_CLB";
      VerticalMode[VerticalMode["OP_DES"] = 13] = "OP_DES";
      VerticalMode[VerticalMode["VS"] = 14] = "VS";
      VerticalMode[VerticalMode["FPA"] = 15] = "FPA";
      VerticalMode[VerticalMode["ALT_CST"] = 20] = "ALT_CST";
      VerticalMode[VerticalMode["ALT_CST_CPT"] = 21] = "ALT_CST_CPT";
      VerticalMode[VerticalMode["CLB"] = 22] = "CLB";
      VerticalMode[VerticalMode["DES"] = 23] = "DES";
      VerticalMode[VerticalMode["FINAL"] = 24] = "FINAL";
      VerticalMode[VerticalMode["GS_CPT"] = 30] = "GS_CPT";
      VerticalMode[VerticalMode["GS_TRACK"] = 31] = "GS_TRACK";
      VerticalMode[VerticalMode["LAND"] = 32] = "LAND";
      VerticalMode[VerticalMode["FLARE"] = 33] = "FLARE";
      VerticalMode[VerticalMode["ROLL_OUT"] = 34] = "ROLL_OUT";
      VerticalMode[VerticalMode["SRS"] = 40] = "SRS";
      VerticalMode[VerticalMode["SRS_GA"] = 41] = "SRS_GA";
      VerticalMode[VerticalMode["TCAS"] = 50] = "TCAS";
    })(VerticalMode || (VerticalMode = {}));
    var ArmedVerticalMode;
    (function (ArmedVerticalMode) {
      ArmedVerticalMode[ArmedVerticalMode["ALT"] = 0] = "ALT";
      ArmedVerticalMode[ArmedVerticalMode["ALT_CST"] = 1] = "ALT_CST";
      ArmedVerticalMode[ArmedVerticalMode["CLB"] = 2] = "CLB";
      ArmedVerticalMode[ArmedVerticalMode["DES"] = 3] = "DES";
      ArmedVerticalMode[ArmedVerticalMode["GS"] = 4] = "GS";
      ArmedVerticalMode[ArmedVerticalMode["FINAL"] = 5] = "FINAL";
      ArmedVerticalMode[ArmedVerticalMode["TCAS"] = 6] = "TCAS";
    })(ArmedVerticalMode || (ArmedVerticalMode = {}));
    function isArmed(bitmask, armedBit) {
      return (bitmask >> armedBit & 1) === 1;
    }

    let AimsFlightPhase;
    (function (AimsFlightPhase) {
      AimsFlightPhase[AimsFlightPhase["Preflight"] = 0] = "Preflight";
      AimsFlightPhase[AimsFlightPhase["Takeoff"] = 1] = "Takeoff";
      AimsFlightPhase[AimsFlightPhase["Climb"] = 2] = "Climb";
      AimsFlightPhase[AimsFlightPhase["Cruise"] = 3] = "Cruise";
      AimsFlightPhase[AimsFlightPhase["Descent"] = 4] = "Descent";
      AimsFlightPhase[AimsFlightPhase["Approach"] = 5] = "Approach";
      AimsFlightPhase[AimsFlightPhase["GoAround"] = 6] = "GoAround";
      AimsFlightPhase[AimsFlightPhase["Done"] = 7] = "Done";
    })(AimsFlightPhase || (AimsFlightPhase = {}));
    function isReady() {
      return SimVar.GetSimVarValue('L:B77HS_IS_READY', 'number') === 1;
    }
    function isSlewActive() {
      return SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
    }
    function isOnGround() {
      return SimVar.GetSimVarValue('L:B77HS_LGCIU_1_NOSE_GEAR_COMPRESSED', 'bool') || SimVar.GetSimVarValue('L:B77HS_LGCIU_2_NOSE_GEAR_COMPRESSED', 'bool');
    }
    function isEngineOn(index) {
      return SimVar.GetSimVarValue("L:B77HS_ENGINE_N2:".concat(index), 'number') > 20;
    }
    function isEngineOnTakeOffThrust(index) {
      return SimVar.GetSimVarValue("L:B77HS_ENGINE_N1:".concat(index), 'number') >= 70;
    }
    function isAnEngineOn() {
      return isEngineOn(1) || isEngineOn(2);
    }
    function isAllEngineOn() {
      return isEngineOn(1) && isEngineOn(2);
    }
    function getAutopilotVerticalMode() {
      return SimVar.GetSimVarValue('L:B77HS_FMA_VERTICAL_MODE', 'Enum');
    }
    function conditionTakeOff() {
      return getAutopilotVerticalMode() === VerticalMode.SRS && isEngineOnTakeOffThrust(1) && isEngineOnTakeOffThrust(2) || Math.abs(Simplane.getGroundSpeed()) > 90;
    }

    class ConfirmationNode {
      constructor(triggerTime) {
        this.triggerTime = triggerTime;
        _defineProperty$2(this, "lastInput", false);
        _defineProperty$2(this, "input", false);
        _defineProperty$2(this, "output", false);
        _defineProperty$2(this, "timer", 0.0);
      }
      update(deltaTime) {
        // State change - reset timer
        if (this.lastInput !== this.input) {
          this.lastInput = this.input;
          this.output = false;
          this.timer = 0.0;
          return;
        }
        this.lastInput = this.input;
        if (this.input) {
          this.timer += deltaTime;
        }
        if (this.timer > this.triggerTime) {
          this.output = true;
        }
      }
    }
    class Trigger {
      constructor(risingEdge) {
        this.risingEdge = risingEdge;
        _defineProperty$2(this, "lastInput", false);
        _defineProperty$2(this, "input", false);
        _defineProperty$2(this, "output", false);
      }
      update(_) {
        // State change - set output
        if (this.lastInput !== this.input) {
          if (this.risingEdge && this.input) {
            this.output = true;
          } else if (!this.risingEdge && this.input) {
            this.output = false;
          }
        } else {
          this.output = false;
        }
        this.lastInput = this.input;
      }
    }

    class Phase {
      constructor() {
        _defineProperty$2(this, "nextPhase", void 0);
      }
      // eslint-disable-next-line no-empty-function
      init() {/* prototype function */}
    }
    class PreFlightPhase extends Phase {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "takeoffConfirmation", new ConfirmationNode(0.2 * 1000));
      }
      init() {
        this.nextPhase = AimsFlightPhase.Takeoff;
      }
      shouldActivateNextPhase(_deltaTime) {
        this.takeoffConfirmation.input = conditionTakeOff();
        this.takeoffConfirmation.update(_deltaTime);
        return this.takeoffConfirmation.output;
      }
    }
    class TakeOffPhase extends Phase {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "accelerationAltitudeMsl", void 0);
        _defineProperty$2(this, "accelerationAltitudeMslEo", void 0);
      }
      init() {
        this.nextPhase = AimsFlightPhase.Climb;
        SimVar.SetSimVarValue('L:B77HS_COLD_AND_DARK_SPAWN', 'Bool', false);
        const accAlt = SimVar.GetSimVarValue('L:AIRLINER_ACC_ALT', 'Number');
        const thrRedAlt = SimVar.GetSimVarValue('L:AIRLINER_THR_RED_ALT', 'Number');
        this.accelerationAltitudeMsl = accAlt || thrRedAlt;
        this.accelerationAltitudeMslEo = SimVar.GetSimVarValue('L:B77HS_ENG_OUT_ACC_ALT', 'feet');
      }
      shouldActivateNextPhase(_deltaTime) {
        return Simplane.getAltitude() > (isAllEngineOn() ? this.accelerationAltitudeMsl : this.accelerationAltitudeMslEo);
      }
    }
    class ClimbPhase extends Phase {
      init() {
        this.nextPhase = AimsFlightPhase.Cruise;
      }
      shouldActivateNextPhase(_deltaTime) {
        const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;
        const fl = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
        return fl >= cruiseFl;
      }
    }
    class CruisePhase extends Phase {
      init() {
        // switch out of cruise phase is handled in FlightPhaseManager
        this.nextPhase = AimsFlightPhase.Cruise;
      }
      shouldActivateNextPhase(_deltaTime) {
        return false;
      }
    }
    class DescentPhase extends Phase {
      init() {
        this.nextPhase = AimsFlightPhase.Approach;
      }
      shouldActivateNextPhase(_deltaTime) {
        const fl = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
        const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue('feet') / 100;
        const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;
        if (fl === cruiseFl && fcuSelFl === fl) {
          this.nextPhase = AimsFlightPhase.Cruise;
          return true;
        }

        // APPROACH phase from DECEL pseudo waypoint case. This is decided by the new TS FMS.
        return !!SimVar.GetSimVarValue('L:B77HS_FM_ENABLE_APPROACH_PHASE', 'Bool');
      }
    }
    class ApproachPhase extends Phase {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "landingConfirmation", new ConfirmationNode(30 * 1000));
      }
      init() {
        SimVar.SetSimVarValue('L:AIRLINER_TO_FLEX_TEMP', 'Number', 0);
        this.nextPhase = AimsFlightPhase.Done;
      }
      shouldActivateNextPhase(_deltaTime) {
        if (getAutopilotVerticalMode() === VerticalMode.SRS_GA) {
          this.nextPhase = AimsFlightPhase.GoAround;
          return true;
        }
        this.landingConfirmation.input = isOnGround();
        this.landingConfirmation.update(_deltaTime);
        return this.landingConfirmation.output || !isAnEngineOn();
      }
    }
    class GoAroundPhase extends Phase {
      init() {
        SimVar.SetSimVarValue('L:AIRLINER_TO_FLEX_TEMP', 'Number', 0);
        this.nextPhase = AimsFlightPhase.GoAround;
      }
      shouldActivateNextPhase(_deltaTime) {
        // there is no automatic switch from this phase
        return false;
      }
    }
    class DonePhase extends Phase {
      init() {
        SimVar.SetSimVarValue('L:AIRLINER_TO_FLEX_TEMP', 'Number', 0);
        this.nextPhase = AimsFlightPhase.Done;
      }
      shouldActivateNextPhase(_deltaTime) {
        // there is no automatic switch from this phase
        return false;
      }
    }

    function canInitiateDes(distanceToDestination) {
      const fl = Math.round(Simplane.getAltitude() / 100);
      const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue('feet') / 100;
      const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;

      // Can initiate descent? OR Can initiate early descent?
      return (distanceToDestination < 200 || fl < 200) && fcuSelFl < cruiseFl && fcuSelFl < fl || distanceToDestination >= 200 && fl > 200 && fcuSelFl <= 200;
    }
    class FlightPhaseManager {
      constructor() {
        _defineProperty$2(this, "onGroundConfirmationNode", new ConfirmationNode(30 * 1000));
        _defineProperty$2(this, "activePhase", this.initialPhase || AimsFlightPhase.Preflight);
        _defineProperty$2(this, "phases", {
          [AimsFlightPhase.Preflight]: new PreFlightPhase(),
          [AimsFlightPhase.Takeoff]: new TakeOffPhase(),
          [AimsFlightPhase.Climb]: new ClimbPhase(),
          [AimsFlightPhase.Cruise]: new CruisePhase(),
          [AimsFlightPhase.Descent]: new DescentPhase(),
          [AimsFlightPhase.Approach]: new ApproachPhase(),
          [AimsFlightPhase.GoAround]: new GoAroundPhase(),
          [AimsFlightPhase.Done]: new DonePhase()
        });
        _defineProperty$2(this, "phaseChangeListeners", []);
      }
      get phase() {
        return this.activePhase;
      }
      get initialPhase() {
        return SimVar.GetSimVarValue('L:B77HS_INITIAL_FLIGHT_PHASE', 'number');
      }
      init() {
        console.log("Aims Flight Phase: ".concat(this.phase));
        this.phases[this.phase].init();
        this.changePhase(this.activePhase);
      }
      shouldActivateNextPhase(_deltaTime) {
        // process transitions only when plane is ready
        if (isReady() && !isSlewActive()) {
          if (this.shouldActivateDonePhase(_deltaTime)) {
            this.changePhase(AimsFlightPhase.Done);
          } else if (this.phases[this.phase].shouldActivateNextPhase(_deltaTime)) {
            this.changePhase(this.phases[this.phase].nextPhase);
          }
        } else if (isReady() && isSlewActive()) {
          this.handleSlewSituation(_deltaTime);
        } else if (this.activePhase !== this.initialPhase) {
          // ensure correct init of phase
          this.activePhase = this.initialPhase;
          this.changePhase(this.initialPhase);
        }
      }
      addOnPhaseChanged(cb) {
        this.phaseChangeListeners.push(cb);
      }
      handleFcuAltKnobPushPull(distanceToDestination) {
        switch (this.phase) {
          case AimsFlightPhase.Takeoff:
            this.changePhase(AimsFlightPhase.Climb);
            break;
          case AimsFlightPhase.Climb:
          case AimsFlightPhase.Cruise:
            if (canInitiateDes(distanceToDestination)) {
              this.changePhase(AimsFlightPhase.Descent);
            }
            break;
        }
      }
      handleFcuAltKnobTurn(distanceToDestination) {
        if (this.phase === AimsFlightPhase.Cruise) {
          const activeVerticalMode = SimVar.GetSimVarValue('L:B77HS_FMA_VERTICAL_MODE', 'Enum');
          const VS = SimVar.GetSimVarValue('L:B77HS_AUTOPILOT_VS_SELECTED', 'feet per minute');
          const FPA = SimVar.GetSimVarValue('L:B77HS_AUTOPILOT_FPA_SELECTED', 'Degrees');
          if ((activeVerticalMode === VerticalMode.OP_DES || activeVerticalMode === VerticalMode.VS && VS < 0 || activeVerticalMode === VerticalMode.FPA && FPA < 0 || activeVerticalMode === VerticalMode.DES) && canInitiateDes(distanceToDestination)) {
            this.changePhase(AimsFlightPhase.Descent);
          }
        }
      }
      handleFcuVSKnob(distanceToDestination, onStepClimbDescent) {
        if (this.phase === AimsFlightPhase.Climb || this.phase === AimsFlightPhase.Cruise) {
          /** a timeout of 100ms is required in order to receive the updated autopilot vertical mode */
          setTimeout(() => {
            const activeVerticalMode = SimVar.GetSimVarValue('L:B77HS_FMA_VERTICAL_MODE', 'Enum');
            const VS = SimVar.GetSimVarValue('L:B77HS_AUTOPILOT_VS_SELECTED', 'feet per minute');
            const FPA = SimVar.GetSimVarValue('L:B77HS_AUTOPILOT_FPA_SELECTED', 'Degrees');
            if (activeVerticalMode === VerticalMode.VS && VS < 0 || activeVerticalMode === VerticalMode.FPA && FPA < 0) {
              if (canInitiateDes(distanceToDestination)) {
                this.changePhase(AimsFlightPhase.Descent);
              } else {
                onStepClimbDescent();
              }
            }
          }, 100);
        }
      }
      handleNewCruiseAltitudeEntered(newCruiseFlightLevel) {
        const currentFlightLevel = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
        if (this.activePhase === AimsFlightPhase.Approach) {
          this.changePhase(AimsFlightPhase.Climb);
        } else if (currentFlightLevel < newCruiseFlightLevel && this.activePhase === AimsFlightPhase.Descent) {
          this.changePhase(AimsFlightPhase.Climb);
        } else if (currentFlightLevel > newCruiseFlightLevel && (this.activePhase === AimsFlightPhase.Climb || this.activePhase === AimsFlightPhase.Descent)) {
          this.changePhase(AimsFlightPhase.Cruise);
        }
      }
      handleNewDestinationAirportEntered() {
        if (this.activePhase === AimsFlightPhase.GoAround) {
          const accAlt = SimVar.GetSimVarValue('L:AIRLINER_ACC_ALT_GOAROUND', 'Number');
          if (Simplane.getAltitude() > accAlt) {
            this.changePhase(AimsFlightPhase.Climb);
          }
        }
      }
      changePhase(newPhase) {
        const prevPhase = this.phase;
        console.log("Aims Flight Phase: ".concat(prevPhase, " => ").concat(newPhase));
        this.activePhase = newPhase;
        SimVar.SetSimVarValue('L:B77HS_Aims_FLIGHT_PHASE', 'number', newPhase);
        // Updating old SimVar to ensure backwards compatibility
        SimVar.SetSimVarValue('L:AIRLINER_FLIGHT_PHASE', 'number', newPhase < AimsFlightPhase.Takeoff ? AimsFlightPhase.Preflight : newPhase + 1);
        this.phases[this.phase].init();
        for (const pcl of this.phaseChangeListeners) {
          pcl(prevPhase, newPhase);
        }
        this.shouldActivateNextPhase(0);
      }
      tryGoInApproachPhase() {
        if (this.phase === AimsFlightPhase.Preflight || this.phase === AimsFlightPhase.Takeoff || this.phase === AimsFlightPhase.Done) {
          return false;
        }
        if (this.phase !== AimsFlightPhase.Approach) {
          this.changePhase(AimsFlightPhase.Approach);
        }
        return true;
      }
      shouldActivateDonePhase(_deltaTime) {
        this.onGroundConfirmationNode.input = isOnGround();
        this.onGroundConfirmationNode.update(_deltaTime);
        return this.onGroundConfirmationNode.output && !isAnEngineOn() && this.phase !== AimsFlightPhase.Done && this.phase !== AimsFlightPhase.Preflight;
      }
      handleSlewSituation(_deltaTime) {
        switch (this.phase) {
          case AimsFlightPhase.Preflight:
          case AimsFlightPhase.Takeoff:
          case AimsFlightPhase.Done:
            if (Simplane.getAltitudeAboveGround() >= 1500) {
              this.changePhase(AimsFlightPhase.Climb);
            }
            break;
        }
      }
    }

    const flightPhaseManager = new FlightPhaseManager();
    function getFlightPhaseManager() {
      return flightPhaseManager;
    }

    class MathUtils {
      static fastToFixed(val, fraction) {
        if (fraction <= 0) {
          return Math.round(val).toString();
        }
        let coefficient = MathUtils.optiPow10[fraction];
        if (!coefficient || Number.isNaN(coefficient)) {
          coefficient = 10 ** fraction;
          MathUtils.optiPow10[fraction] = coefficient;
        }
        return (Math.round(val * coefficient) / coefficient).toString();
      }
      static fastToFixedNum(val, fraction) {
        if (fraction <= 0) {
          return Math.round(val);
        }
        let coefficient = MathUtils.optiPow10[fraction];
        if (!coefficient || Number.isNaN(coefficient)) {
          coefficient = 10 ** fraction;
          MathUtils.optiPow10[fraction] = coefficient;
        }
        return Math.round(val * coefficient) / coefficient;
      }

      /**
        * Adds two angles with wrap around to result in 0-360°
        * @param a - positive or negative angle
        * @param b - positive or negative angle
        */
      static angleAdd(a, b) {
        let r = a + b;
        while (r > 360) {
          r -= 360;
        }
        while (r < 0) {
          r += 360;
        }
        return r;
      }
      static diffAngle(a, b, direction) {
        let diff = b - a;
        while (diff > 180) {
          diff -= 360;
        }
        while (diff <= -180) {
          diff += 360;
        }
        if (diff < 0 && direction === TurnDirection.Right) {
          diff += 360;
        }
        if (diff > 0 && direction === TurnDirection.Left) {
          diff -= 360;
        }
        return diff;
      }
      static adjustAngleForTurnDirection(angle, turnDirection) {
        let ret = angle;
        if (angle < 0 && turnDirection === TurnDirection.Right) {
          ret += 360;
        }
        if (angle > 0 && turnDirection === TurnDirection.Left) {
          ret -= 360;
        }
        return ret;
      }

      /**
       * Calculates the inner angle of the small triangle formed by two intersecting lines
       *
       * This effectively returns the angle XYZ in the figure shown below:
       *
       * ```
       * * Y
       * |\
       * | \
       * |  \
       * |   \
       * |    \
       * |     \
       * |      \
       * * X     * Z
       * ```
       *
       * @param xyAngle {number} bearing of line XY
       * @param zyAngle {number} bearing of line ZY
       */
      static smallCrossingAngle(xyAngle, zyAngle) {
        // Rotate frame of reference to 0deg
        let correctedXyBearing = xyAngle - zyAngle;
        if (correctedXyBearing < 0) {
          correctedXyBearing = 360 + correctedXyBearing;
        }
        let xyzAngle = 180 - correctedXyBearing;
        if (xyzAngle < 0) {
          // correctedXyBearing was > 180

          xyzAngle = 360 + xyzAngle;
        }
        return xyzAngle;
      }
      static mod(x, n) {
        return x - Math.floor(x / n) * n;
      }
      static highestPower2(n) {
        let res = 0;
        for (let i = n; i >= 1; i--) {
          if ((i & i - 1) === 0) {
            res = i;
            break;
          }
        }
        return res;
      }
      static unpackPowers(n) {
        const res = [];
        let x = n;
        while (x > 0) {
          const pow = MathUtils.highestPower2(x);
          res.push(pow);
          x -= pow;
        }
        return res;
      }
      static packPowers(ns) {
        if (ns.some(it => it === 0 || (it & it - 1) !== 0)) {
          throw new Error('Cannot pack number which is not a power of 2 or is equal to zero.');
        }
        return ns.reduce((acc, v) => acc + v);
      }

      /**
        * Convert degrees Celsius into Kelvin
        * @param celsius degrees Celsius
        * @returns degrees Kelvin
        */
      static convertCtoK(celsius) {
        return celsius + 273.15;
      }

      /**
        * Convert Mach to True Air Speed
        * @param mach Mach
        * @param oat Kelvin
        * @returns True Air Speed
        */
      static convertMachToKTas(mach, oat) {
        return mach * 661.4786 * Math.sqrt(oat / 288.15);
      }

      /**
        * Convert TAS to Mach
        * @param tas TAS
        * @param oat Kelvin
        * @returns True Air Speed
        */
      static convertKTASToMach(tas, oat) {
        return tas / 661.4786 / Math.sqrt(oat / 288.15);
      }

      /**
        * Convert TAS to Calibrated Air Speed
        * @param tas velocity true air speed
        * @param oat current temperature Kelvin
        * @param pressure current pressure hpa
        * @returns Calibrated Air Speed
        */
      static convertTasToKCas(tas, oat, pressure) {
        return 1479.1 * Math.sqrt((pressure / 1013 * ((1 + 1 / (oat / 288.15) * (tas / 1479.1) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1);
      }

      /**
        * Convert KCAS to KTAS
        * @param kcas velocity true air speed
        * @param oat current temperature Kelvin
        * @param pressure current pressure hpa
        * @returns True Air Speed
        */
      static convertKCasToKTAS(kcas, oat, pressure) {
        return 1479.1 * Math.sqrt(oat / 288.15 * ((1 / (pressure / 1013) * ((1 + 0.2 * (kcas / 661.4786) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1));
      }

      /**
        * Convert Mach to Calibrated Air Speed
        * @param mach Mach
        * @param oat Kelvin
        * @param pressure current pressure hpa
        * @returns Calibrated Air Speed
        */
      static convertMachToKCas(mach, oat, pressure) {
        return MathUtils.convertTasToKCas(MathUtils.convertMachToKTas(mach, oat), oat, pressure);
      }

      /**
        * Gets the horizontal distance between 2 points, given in lat/lon
        * @param pos0Lat {number} Position 0 lat
        * @param pos0Lon {number} Position 0 lon
        * @param pos1Lat {number} Position 1 lat
        * @param pos1Lon {number} Position 1 lon
        * @return {number} distance in nautical miles
        */
      static computeGreatCircleDistance(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
        const lat0 = pos0Lat * MathUtils.DEGREES_TO_RADIANS;
        const lon0 = pos0Lon * MathUtils.DEGREES_TO_RADIANS;
        const lat1 = pos1Lat * MathUtils.DEGREES_TO_RADIANS;
        const lon1 = pos1Lon * MathUtils.DEGREES_TO_RADIANS;
        const dlon = lon1 - lon0;
        const cosLat0 = Math.cos(lat0);
        const cosLat1 = Math.cos(lat1);
        const a1 = Math.sin((lat1 - lat0) / 2);
        const a2 = Math.sin(dlon / 2);
        return Math.asin(Math.sqrt(a1 * a1 + cosLat0 * cosLat1 * a2 * a2)) * 6880.126;
      }

      /**
        * Gets the heading between 2 points, given in lat/lon
        * @param pos0Lat {number} Position 0 lat
        * @param pos0Lon {number} Position 0 lon
        * @param pos1Lat {number} Position 1 lat
        * @param pos1Lon {number} Position 1 lon
        * @return {number} distance in nautical miles
        */
      static computeGreatCircleHeading(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
        const lat0 = pos0Lat * MathUtils.DEGREES_TO_RADIANS;
        const lon0 = pos0Lon * MathUtils.DEGREES_TO_RADIANS;
        const lat1 = pos1Lat * MathUtils.DEGREES_TO_RADIANS;
        const lon1 = pos1Lon * MathUtils.DEGREES_TO_RADIANS;
        const dlon = lon1 - lon0;
        const cosLat1 = Math.cos(lat1);
        let x = Math.sin(lat1 - lat0);
        const sinLon2 = Math.sin(dlon / 2.0);
        x += sinLon2 * sinLon2 * 2.0 * Math.sin(lat0) * cosLat1;
        let heading = Math.atan2(cosLat1 * Math.sin(dlon), x);
        if (heading < 0) {
          heading += 2 * Math.PI;
        }
        return heading * MathUtils.RADIANS_TO_DEGREES;
      }

      /**
        * Gets the distance between 2 points, given in lat/lon/alt above sea level
        * @param pos0Lat {number} Position 0 lat
        * @param pos0Lon {number} Position 0 lon
        * @param pos0alt {number} Position 0 alt (feet)
        * @param pos1Lat {number} Position 1 lat
        * @param pos1Lon {number} Position 1 lon
        * @param pos1alt {number} Position 1 alt (feet)
        * @return {number} distance in nautical miles
        */
      static computeDistance3D(pos0Lat, pos0Lon, pos0alt, pos1Lat, pos1Lon, pos1alt) {
        const earthRadius = 3440.065; // earth radius in nautcal miles
        const deg2rad = Math.PI / 180;
        const radius1 = pos0alt / 6076 + earthRadius;
        const radius2 = pos1alt / 6076 + earthRadius;
        const x1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.cos(deg2rad * (pos0Lon + 180));
        const y1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.sin(deg2rad * (pos0Lon + 180));
        const z1 = radius1 * Math.cos(deg2rad * (pos0Lat + 90));
        const x2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.cos(deg2rad * (pos1Lon + 180));
        const y2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.sin(deg2rad * (pos1Lon + 180));
        const z2 = radius2 * Math.cos(deg2rad * (pos1Lat + 90));
        return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
      }

      /**
        * Check if point is inside a given ellipse
        *
        * @param {number} xPos x value of point
        * @param {number} yPos y value of point
        * @param {number} xLimPos +ve xLimit of ellipse
        * @param {number} xLimNeg -ve xLimit of ellipse
        * @param {number} yLimPos +ve yLimit of ellipse
        * @param {number} yLimNeg -ve yLimit of ellipse
        * @return {boolean} Whether the point is in the ellipse
        *
        */
      static pointInEllipse(xPos, yPos, xLimPos, yLimPos) {
        let xLimNeg = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : xLimPos;
        let yLimNeg = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : yLimPos;
        return xPos ** 2 / (xPos >= 0 ? xLimPos : xLimNeg) ** 2 + yPos ** 2 / (yPos >= 0 ? yLimPos : yLimNeg) ** 2 <= 1;
      }

      /**
        * Performs the even-odd-rule Algorithm (a raycasting algorithm) to find out whether a point is in a given polygon.
        * This runs in O(n) where n is the number of edges of the polygon.
        *
        * @param {Array} polygon an array representation of the polygon where polygon[i][0] is the x Value of the i-th point and polygon[i][1] is the y Value.
        * @param {number} xPos  x value of point
        * @param {number} yPos y value of point
        * @return {boolean} Whether the point is in the polygon (not on the edge, just turn < into <= and > into >= for that)
        */
      static pointInPolygon(xPos, yPos, polygon) {
        // A point is in a polygon if a line from the point to infinity crosses the polygon an odd number of times
        let odd = false;
        // For each edge (In this case for each point of the polygon and the previous one)
        for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
          // If a line from the point into infinity crosses this edge
          if (polygon[i][1] > yPos !== polygon[j][1] > yPos // One point needs to be above, one below our y coordinate
          // ...and the edge doesn't cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)
          && xPos < (polygon[j][0] - polygon[i][0]) * (yPos - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]) {
            // Invert odd
            odd = !odd;
          }
          j = i;
        }
        // If the number of crossings was odd, the point is in the polygon
        return odd;
      }

      /**
        * Line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
        * Determine the intersection point of two line segments
        * Return null if the lines don't intersect
        *
        * @param {number} x1 line0 x origin
        * @param {number} y1 line0 y origin
        * @param {number} x2 line0 x end
        * @param {number} y2 line0 y end
        * @param {number} x3 line1 x origin
        * @param {number} y3 line1 y origin
        * @param {number} x4 line1 x end
        * @param {number} y4 line1 y end
        *
        * @return {[number, number] | null} [x,y] of intercept, null if no intercept.
        */
      static intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        // Check if none of the lines are of length 0
        if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) {
          return null;
        }
        const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

        // Lines are parallel
        if (denominator === 0) {
          return null;
        }
        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

        // is the intersection along the segments
        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
          return null;
        }

        // Return a object with the x and y coordinates of the intersection
        const x = x1 + ua * (x2 - x1);
        const y = y1 + ua * (y2 - y1);
        return [x, y];
      }

      // Find intersect with polygon
      static intersectWithPolygon(x1, y1, x2, y2, polygon) {
        let ret = null;
        polygon.forEach((xy, index, polygon) => {
          if (ret) return;
          if (index + 1 >= polygon.length) {
            return;
          }
          const x3 = xy[0];
          const y3 = xy[1];
          const x4 = polygon[index + 1][0];
          const y4 = polygon[index + 1][1];
          ret = MathUtils.intersect(x1, y1, x2, y2, x3, y3, x4, y4);
        });
        return ret;
      }

      /**
        * Returns the given value if the value is >=lower or <= upper. Otherwise returns the boundary value.
        * @param value the value to be clamped
        * @param lower lowest boundary value
        * @param upper highest boundary value
        */
      static clamp(value, lower, upper) {
        return Math.min(Math.max(value, lower), upper);
      }

      /**
        * Returns a value rounded to the given number of decimal precission.
        * @param value
        * @param decimalPrecision
        */
      static round(value, decimalPrecision) {
        const shift = 10 ** decimalPrecision;
        return Math.round((value + Number.EPSILON) * shift) / shift;
      }
    }
    _defineProperty$2(MathUtils, "DEGREES_TO_RADIANS", Math.PI / 180);
    _defineProperty$2(MathUtils, "RADIANS_TO_DEGREES", 180 / Math.PI);
    _defineProperty$2(MathUtils, "optiPow10", []);

    let Constants;
    (function (Constants) {
      Constants[Constants["G"] = 9.81] = "G";
      Constants[Constants["EARTH_RADIUS_NM"] = 3440.1] = "EARTH_RADIUS_NM";
    })(Constants || (Constants = {}));

    // Copyright (c) 2021-2022 FlyByWire Simulations

    /**
     * Compute the remaining distance around an arc
     * This is only valid once past the itp
     * @param ppos       current aircraft position
     * @param itp        current aircraft track
     * @param centreFix  centre of the arc
     * @param sweepAngle angle swept around the arc, +ve for clockwise
     * @returns
     */
    function arcDistanceToGo(ppos, itp, centreFix, sweepAngle) {
      const itpBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, itp);
      const pposBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ppos);
      const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
      const refFrameOffset = Avionics.Utils.diffAngle(0, itpBearing);
      const pposAngle = sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - pposBearing) : Avionics.Utils.clampAngle(pposBearing - refFrameOffset);

      // before the arc... this implies max sweep angle is <340, arinc allows less than that anyway
      if (pposAngle >= 340) {
        return radius * Math.PI * Math.abs(sweepAngle) / 180;
      }
      if (pposAngle >= Math.abs(sweepAngle)) {
        return 0;
      }
      return radius * Math.PI * (Math.abs(sweepAngle) - pposAngle) / 180;
    }

    /**
     * Compute guidance parameters for an arc path
     *
     * @param ppos       current aircraft position
     * @param trueTrack  current aircraft track
     * @param itp        initial turning point for the arc
     * @param centreFix  centre of the arc
     * @param sweepAngle angle swept around the arc, +ve for clockwise
     *
     * @returns lateral path law params
     */
    function arcGuidance(ppos, trueTrack, itp, centreFix, sweepAngle) {
      const bearingPpos = Avionics.Utils.computeGreatCircleHeading(centreFix, ppos);
      const desiredTrack = sweepAngle > 0 ? Avionics.Utils.clampAngle(bearingPpos + 90) : Avionics.Utils.clampAngle(bearingPpos - 90);
      const trackAngleError = Avionics.Utils.diffAngle(trueTrack, desiredTrack);
      const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
      const distanceFromCenter = Avionics.Utils.computeGreatCircleDistance(centreFix, ppos);
      const crossTrackError = sweepAngle > 0 ? distanceFromCenter - radius : radius - distanceFromCenter;
      const groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'meters per second');
      const radiusInMetre = radius * 1852;
      const phiCommand = (sweepAngle > 0 ? 1 : -1) * Math.atan(groundSpeed * groundSpeed / (radiusInMetre * 9.81)) * (180 / Math.PI);
      return {
        law: ControlLaw.LATERAL_PATH,
        trackAngleError,
        crossTrackError,
        phiCommand
      };
    }

    /**
     * Computes a point along a course to a fix
     *
     * @param distanceFromEnd distance before end of line
     * @param course          course of the line to the fix
     * @param fix             self-explanatory
     */
    function pointOnCourseToFix(distanceFromEnd, course, fix) {
      return Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(course + 180), distanceFromEnd, fix.lat, fix.long);
    }

    /**
     * Computes a point along an arc at a distance before its termination
     *
     * @param distanceFromFtp distance before end of arc
     * @param ftp             arc exit point
     * @param centreFix       arc centre fix
     * @param sweepAngle      angle swept around the arc, +ve for clockwise
     */
    function pointOnArc(distanceFromFtp, ftp, centreFix, sweepAngle) {
      const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, ftp);
      const distanceRatio = distanceFromFtp / arcLength(radius, sweepAngle);
      const angleFromFtp = -distanceRatio * sweepAngle;
      const centerToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ftp);
      return Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(centerToTerminationBearing + angleFromFtp), radius, centreFix.lat, centreFix.long);
    }
    function minBank(segment) {
      return segment === SegmentType.Enroute ? 5 : 10;
    }

    /**
     *
     * @param tas
     * @param pathCapture true when the turn is to capture a path or heading, or for curved legs
     * @returns
     */
    function maxBank(tas, pathCapture) {
      /*
      TODO
      if (engineOut) {
          return 15;
      }
      */

      if (pathCapture) {
        // roll limit 2 from honeywell doc
        if (tas < 100) {
          return 15 + tas / 10;
        }
        if (tas > 350) {
          return 19 + Math.max(0, (450 - tas) * 6 / 100);
        }
        return 25;
      }
      // roll limit 1
      if (tas < 150) {
        return 15 + tas / 10;
      }
      if (tas > 300) {
        return 19 + Math.max(0, (450 - tas) * 11 / 150);
      }
      return 30;
    }

    /**
     * Returns the largest acceptable turn anticipation distance for a given true air speed
     *
     * @param tas the current or predicted true airspeed
     */
    function maxTad(tas) {
      if (tas === undefined) {
        return 10;
      }
      if (tas <= 100) {
        return 4;
      }
      if (tas >= 100 && tas <= 400) {
        return tas / 100 * 4;
      }
      return 16;
    }
    function courseToFixDistanceToGo(ppos, course, fix) {
      const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
      const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
      const pposToFixAngle = Avionics.Utils.diffAngle(pposToFixBearing, course);
      return Math.max(0, pposToFixDist * Math.cos(pposToFixAngle * Math.PI / 180));
    }
    function courseToFixGuidance(ppos, trueTrack, course, fix) {
      const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
      const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
      const pposToFixAngle = Avionics.Utils.diffAngle(course, pposToFixBearing);
      const crossTrackError = pposToFixDist * Math.sin(pposToFixAngle * Math.PI / 180);
      const trackAngleError = Avionics.Utils.diffAngle(trueTrack, course);
      return {
        law: ControlLaw.LATERAL_PATH,
        trackAngleError,
        crossTrackError,
        phiCommand: 0
      };
    }
    let PointSide;

    /**
     * Returns the side of a fix (considering a course inbound to that fix) a point is lying on, assuming they lie on the same
     * great circle.
     *
     * @param fix    destination fix
     * @param course course to the fix
     * @param point  point to compare with
     *
     * @returns `-1` if the point is before the fix, `1` if the point is after the fix
     */
    (function (PointSide) {
      PointSide[PointSide["Before"] = 0] = "Before";
      PointSide[PointSide["After"] = 1] = "After";
    })(PointSide || (PointSide = {}));
    function sideOfPointOnCourseToFix(fix, course, point) {
      const bearingFixPoint = bearingTo(fix, point);
      const onOtherSide = Math.abs(MathUtils.diffAngle(bearingFixPoint, course)) < 3;
      if (onOtherSide) {
        return PointSide.After;
      }
      return PointSide.Before;
    }
    function getAlongTrackDistanceTo(start, end, ppos) {
      const R = Constants.EARTH_RADIUS_NM;
      const d13 = Avionics.Utils.computeGreatCircleDistance(start, ppos) / R;
      const Theta13 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, ppos);
      const Theta12 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, end);
      const deltaXt = Math.asin(Math.sin(d13) * Math.sin(Theta13 - Theta12));
      const deltaAt = Math.acos(Math.cos(d13) / Math.abs(Math.cos(deltaXt)));
      return deltaAt * Math.sign(Math.cos(Theta12 - Theta13)) * R;
    }
    function getIntermediatePoint(start, end, fraction) {
      const Phi1 = start.lat * Avionics.Utils.DEG2RAD;
      const Gamma1 = start.long * Avionics.Utils.DEG2RAD;
      const Phi2 = end.lat * Avionics.Utils.DEG2RAD;
      const Gamma2 = end.long * Avionics.Utils.DEG2RAD;
      const deltaPhi = Phi2 - Phi1;
      const deltaGamma = Gamma2 - Gamma1;
      const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(Phi1) * Math.cos(Phi2) * Math.sin(deltaGamma / 2) * Math.sin(deltaGamma / 2);
      const delta = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const A = Math.sin((1 - fraction) * delta) / Math.sin(delta);
      const B = Math.sin(fraction * delta) / Math.sin(delta);
      const x = A * Math.cos(Phi1) * Math.cos(Gamma1) + B * Math.cos(Phi2) * Math.cos(Gamma2);
      const y = A * Math.cos(Phi1) * Math.sin(Gamma1) + B * Math.cos(Phi2) * Math.sin(Gamma2);
      const z = A * Math.sin(Phi1) + B * Math.sin(Phi2);
      const Phi3 = Math.atan2(z, Math.sqrt(x * x + y * y));
      const Gamma3 = Math.atan2(y, x);
      return {
        lat: Phi3 * Avionics.Utils.RAD2DEG,
        long: Gamma3 * Avionics.Utils.RAD2DEG
      };
    }
    function fixToFixGuidance(ppos, trueTrack, from, to) {
      // Track angle error
      const totalTrackDistance = Avionics.Utils.computeGreatCircleDistance(from, to);
      const alongTrackDistance = getAlongTrackDistanceTo(from, to, ppos);
      const intermediatePoint = getIntermediatePoint(from, to, Math.min(Math.max(alongTrackDistance / totalTrackDistance, 0.05), 0.95));
      const desiredTrack = Avionics.Utils.computeGreatCircleHeading(intermediatePoint, to);
      const trackAngleError = MathUtils.mod(desiredTrack - trueTrack + 180, 360) - 180;

      // Cross track error
      const bearingAC = Avionics.Utils.computeGreatCircleHeading(from, ppos);
      const bearingAB = Avionics.Utils.computeGreatCircleHeading(from, to);
      const distanceAC = Avionics.Utils.computeDistance(from, ppos);
      const desiredOffset = 0;
      const actualOffset = Math.asin(Math.sin(Avionics.Utils.DEG2RAD * (distanceAC / Constants.EARTH_RADIUS_NM)) * Math.sin(Avionics.Utils.DEG2RAD * (bearingAC - bearingAB))) * Avionics.Utils.RAD2DEG * Constants.EARTH_RADIUS_NM;
      const crossTrackError = desiredOffset - actualOffset;
      return {
        law: ControlLaw.LATERAL_PATH,
        trackAngleError,
        crossTrackError,
        phiCommand: 0
      };
    }
    function arcLength(radius, sweepAngle) {
      const circumference = 2 * Math.PI * radius;
      return circumference / 360 * Math.abs(sweepAngle);
    }
    function reciprocal(course) {
      return Avionics.Utils.clampAngle(course + 180);
    }

    let PathVectorType;
    (function (PathVectorType) {
      PathVectorType[PathVectorType["Line"] = 0] = "Line";
      PathVectorType[PathVectorType["Arc"] = 1] = "Arc";
      PathVectorType[PathVectorType["DebugPoint"] = 2] = "DebugPoint";
    })(PathVectorType || (PathVectorType = {}));
    let DebugPointColour;
    (function (DebugPointColour) {
      DebugPointColour[DebugPointColour["White"] = 0] = "White";
      DebugPointColour[DebugPointColour["Green"] = 1] = "Green";
      DebugPointColour[DebugPointColour["Yellow"] = 2] = "Yellow";
      DebugPointColour[DebugPointColour["Cyan"] = 3] = "Cyan";
      DebugPointColour[DebugPointColour["Magenta"] = 4] = "Magenta";
    })(DebugPointColour || (DebugPointColour = {}));
    function pathVectorLength(vector) {
      if (vector.type === PathVectorType.Line) {
        return Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.endPoint);
      }
      if (vector.type === PathVectorType.Arc) {
        const radius = Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.centrePoint);
        return arcLength(radius, vector.sweepAngle);
      }
      return 0;
    }
    function pathVectorValid(vector) {
      var _vector$startPoint, _vector$endPoint, _vector$endPoint2, _vector$centrePoint, _vector$startPoint2;
      switch (vector.type) {
        case PathVectorType.Line:
          return !!((_vector$startPoint = vector.startPoint) !== null && _vector$startPoint !== void 0 && _vector$startPoint.lat && (_vector$endPoint = vector.endPoint) !== null && _vector$endPoint !== void 0 && _vector$endPoint.lat);
        case PathVectorType.Arc:
          return !!((_vector$endPoint2 = vector.endPoint) !== null && _vector$endPoint2 !== void 0 && _vector$endPoint2.lat && (_vector$centrePoint = vector.centrePoint) !== null && _vector$centrePoint !== void 0 && _vector$centrePoint.lat && vector.sweepAngle);
        case PathVectorType.DebugPoint:
          return !!((_vector$startPoint2 = vector.startPoint) !== null && _vector$startPoint2 !== void 0 && _vector$startPoint2.lat);
        default:
          return true;
      }
    }
    function pathVectorPoint(vector, distanceFromEnd) {
      if (vector.type === PathVectorType.Line) {
        return pointOnCourseToFix(distanceFromEnd, Avionics.Utils.computeGreatCircleHeading(vector.startPoint, vector.endPoint), vector.endPoint);
      }
      if (vector.type === PathVectorType.Arc) {
        return pointOnArc(distanceFromEnd, vector.endPoint, vector.centrePoint, vector.sweepAngle);
      }
      return undefined;
    }

    /**
     * A `Guidable` is a part of an LNAV path. It can be either a leg or a transition.
     */
    class Guidable {
      /**
       * Whether the guidable should be considered for map display, guidance and sequencing
       *
       * For a transition, this indicates that the transition between the legs is selected but has no geometry.
       * For a leg, this indicates that geometry conditions cause the leg to be skipped.
       */

      /**
       * The first valid guidable that precedes this one. This takes into account the `isNull` property, meaning other
       * guidables can exist before this one but would not be referred to by this property if they were to be null.
       */

      /**
       * The first valid guidable that succeeds this one. This takes into account the `isNull` property, meaning other
       * guidables can exist after this one but would not be referred to by this property if they were to be null.
       */

      constructor() {
        _defineProperty$2(this, "isNull", false);
        _defineProperty$2(this, "inboundGuidable", void 0);
        _defineProperty$2(this, "outboundGuidable", void 0);
        _defineProperty$2(this, "isComputed", false);
      }

      /**
       * Used to update the {@link inboundGuidable} and {@link outboundGuidable} properties.
       */
      setNeighboringGuidables(inbound, outbound) {
        this.inboundGuidable = inbound;
        this.outboundGuidable = outbound;
      }
      getPathEndPoint() {
        if (this.isNull) {
          return this.inboundGuidable.getPathEndPoint();
        }
        if (this.predictedPath) {
          for (let i = this.predictedPath.length - 1; i >= 0; i--) {
            const vector = this.predictedPath[i];
            if (vector.type === PathVectorType.DebugPoint) {
              continue;
            }
            if (vector.endPoint) {
              return vector.endPoint;
            }
          }
        }
        return undefined;
      }
      /**
       * Obtains the location of a pseudo-waypoint on the guidable (does NOT include inbound or outbound
       * transitions for legs; see {@link PseudoWaypoints.pointFromEndOfPath} for a function that includes those).
       *
       * @param distanceBeforeTerminator
       */
      getPseudoWaypointLocation(distanceBeforeTerminator) {
        for (const vector of [...this.predictedPath].reverse()) {
          const length = pathVectorLength(vector);
          if (length > distanceBeforeTerminator) {
            return pathVectorPoint(vector, distanceBeforeTerminator);
          }
        }
        return undefined;
      }

      /**
       * Path vectors for the predicted path.
       *
       * This path always represents what is being drawn on the ND, and is used for the vast majority of prediction computations. It is
       * however not always representative of guidance, for example in case of path capture or course capture transitions or CX/VX legs.
       */

      /**
       * Whether the path ends in a curved arc - for entry roll anticipation
       */
      get startsInCircularArc() {
        return false;
      }

      /**
       * Whether the path ends in a curved arc - for exit roll anticipation
       */
      get endsInCircularArc() {
        return false;
      }

      /**
       * Obtain the nominal roll angle for the curved portion of the path
       */
    }

    let TransitionState;
    (function (TransitionState) {
      TransitionState[TransitionState["UPCOMING"] = 0] = "UPCOMING";
      TransitionState[TransitionState["OUT_OF_ACTIVE_LEG"] = 1] = "OUT_OF_ACTIVE_LEG";
      TransitionState[TransitionState["ACTIVE"] = 2] = "ACTIVE";
      TransitionState[TransitionState["INTO_ACTIVE_LEG"] = 3] = "INTO_ACTIVE_LEG";
      TransitionState[TransitionState["PASSED"] = 4] = "PASSED";
    })(TransitionState || (TransitionState = {}));
    class Transition extends Guidable {
      constructor(previousLeg, nextLeg) {
        super();
        this.previousLeg = previousLeg;
        this.nextLeg = nextLeg;
        _defineProperty$2(this, "isFrozen", false);
        this.inboundGuidable = previousLeg;
        this.outboundGuidable = nextLeg;
      }
      freeze() {
        this.isFrozen = true;
      }

      /**
       * Used to update the {@link previousLeg} and {@link nextLeg} properties.
       */
      setNeighboringLegs(previous, next) {
        this.previousLeg = previous;
        this.nextLeg = next;
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        // Default impl.
      }
    }

    var es = {};

    var computeDestinationPoint$1 = {};

    var getLatitude$1 = {};

    var constants = {};

    Object.defineProperty(constants, "__esModule", {
      value: true
    });
    constants.areaConversion = constants.timeConversion = constants.distanceConversion = constants.altitudeKeys = constants.latitudeKeys = constants.longitudeKeys = constants.MAXLON = constants.MINLON = constants.MAXLAT = constants.MINLAT = constants.earthRadius = constants.sexagesimalPattern = void 0;
    var sexagesimalPattern = /^([0-9]{1,3})°\s*([0-9]{1,3}(?:\.(?:[0-9]{1,}))?)['′]\s*(([0-9]{1,3}(\.([0-9]{1,}))?)["″]\s*)?([NEOSW]?)$/;
    constants.sexagesimalPattern = sexagesimalPattern;
    var earthRadius = 6378137;
    constants.earthRadius = earthRadius;
    var MINLAT = -90;
    constants.MINLAT = MINLAT;
    var MAXLAT = 90;
    constants.MAXLAT = MAXLAT;
    var MINLON = -180;
    constants.MINLON = MINLON;
    var MAXLON = 180;
    constants.MAXLON = MAXLON;
    var longitudeKeys = ["lng", "lon", "longitude", 0];
    constants.longitudeKeys = longitudeKeys;
    var latitudeKeys = ["lat", "latitude", 1];
    constants.latitudeKeys = latitudeKeys;
    var altitudeKeys = ["alt", "altitude", "elevation", "elev", 2];
    constants.altitudeKeys = altitudeKeys;
    var distanceConversion = {
      m: 1,
      km: 0.001,
      cm: 100,
      mm: 1000,
      mi: 1 / 1609.344,
      sm: 1 / 1852.216,
      ft: 100 / 30.48,
      in: 100 / 2.54,
      yd: 1 / 0.9144
    };
    constants.distanceConversion = distanceConversion;
    var timeConversion = {
      m: 60,
      h: 3600,
      d: 86400
    };
    constants.timeConversion = timeConversion;
    var areaConversion = {
      m2: 1,
      km2: 0.000001,
      ha: 0.0001,
      a: 0.01,
      ft2: 10.763911,
      yd2: 1.19599,
      in2: 1550.0031
    };
    constants.areaConversion = areaConversion;
    areaConversion.sqm = areaConversion.m2;
    areaConversion.sqkm = areaConversion.km2;
    areaConversion.sqft = areaConversion.ft2;
    areaConversion.sqyd = areaConversion.yd2;
    areaConversion.sqin = areaConversion.in2;

    var getCoordinateKey$1 = {};

    Object.defineProperty(getCoordinateKey$1, "__esModule", {
      value: true
    });
    getCoordinateKey$1.default = void 0;
    var getCoordinateKey = function getCoordinateKey(point, keysToLookup) {
      return keysToLookup.reduce(function (foundKey, key) {
        if (typeof point === "undefined" || point === null) {
          throw new Error("'".concat(point, "' is no valid coordinate."));
        }
        if (Object.prototype.hasOwnProperty.call(point, key) && typeof key !== "undefined" && typeof foundKey === "undefined") {
          foundKey = key;
          return key;
        }
        return foundKey;
      }, undefined);
    };
    var _default$D = getCoordinateKey;
    getCoordinateKey$1.default = _default$D;

    var toDecimal$1 = {};

    var isDecimal$1 = {};

    Object.defineProperty(isDecimal$1, "__esModule", {
      value: true
    });
    isDecimal$1.default = void 0;
    var isDecimal = function isDecimal(value) {
      var checkedValue = value.toString().trim();
      if (isNaN(parseFloat(checkedValue))) {
        return false;
      }
      return parseFloat(checkedValue) === Number(checkedValue);
    };
    var _default$C = isDecimal;
    isDecimal$1.default = _default$C;

    var isSexagesimal$1 = {};

    Object.defineProperty(isSexagesimal$1, "__esModule", {
      value: true
    });
    isSexagesimal$1.default = void 0;
    var _constants$e = constants;
    var isSexagesimal = function isSexagesimal(value) {
      return _constants$e.sexagesimalPattern.test(value.toString().trim());
    };
    var _default$B = isSexagesimal;
    isSexagesimal$1.default = _default$B;

    var sexagesimalToDecimal$1 = {};

    Object.defineProperty(sexagesimalToDecimal$1, "__esModule", {
      value: true
    });
    sexagesimalToDecimal$1.default = void 0;
    var _constants$d = constants;
    var sexagesimalToDecimal = function sexagesimalToDecimal(sexagesimal) {
      var data = new RegExp(_constants$d.sexagesimalPattern).exec(sexagesimal.toString().trim());
      if (typeof data === "undefined" || data === null) {
        throw new Error("Given value is not in sexagesimal format");
      }
      var min = Number(data[2]) / 60 || 0;
      var sec = Number(data[4]) / 3600 || 0;
      var decimal = parseFloat(data[1]) + min + sec;
      return ["S", "W"].includes(data[7]) ? -decimal : decimal;
    };
    var _default$A = sexagesimalToDecimal;
    sexagesimalToDecimal$1.default = _default$A;

    var isValidCoordinate$1 = {};

    var getCoordinateKeys$1 = {};

    Object.defineProperty(getCoordinateKeys$1, "__esModule", {
      value: true
    });
    getCoordinateKeys$1.default = void 0;
    var _constants$c = constants;
    var _getCoordinateKey$2 = _interopRequireDefault$q(getCoordinateKey$1);
    function _interopRequireDefault$q(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function ownKeys$1(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread$1(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys$1(Object(source), true).forEach(function (key) {
            _defineProperty$1(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys$1(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var getCoordinateKeys = function getCoordinateKeys(point) {
      var keysToLookup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        longitude: _constants$c.longitudeKeys,
        latitude: _constants$c.latitudeKeys,
        altitude: _constants$c.altitudeKeys
      };
      var longitude = (0, _getCoordinateKey$2.default)(point, keysToLookup.longitude);
      var latitude = (0, _getCoordinateKey$2.default)(point, keysToLookup.latitude);
      var altitude = (0, _getCoordinateKey$2.default)(point, keysToLookup.altitude);
      return _objectSpread$1({
        latitude: latitude,
        longitude: longitude
      }, altitude ? {
        altitude: altitude
      } : {});
    };
    var _default$z = getCoordinateKeys;
    getCoordinateKeys$1.default = _default$z;

    var isValidLatitude$1 = {};

    Object.defineProperty(isValidLatitude$1, "__esModule", {
      value: true
    });
    isValidLatitude$1.default = void 0;
    var _isDecimal$2 = _interopRequireDefault$p(isDecimal$1);
    var _isSexagesimal$2 = _interopRequireDefault$p(isSexagesimal$1);
    var _sexagesimalToDecimal$2 = _interopRequireDefault$p(sexagesimalToDecimal$1);
    var _constants$b = constants;
    function _interopRequireDefault$p(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isValidLatitude = function isValidLatitude(value) {
      if ((0, _isDecimal$2.default)(value)) {
        if (parseFloat(value) > _constants$b.MAXLAT || value < _constants$b.MINLAT) {
          return false;
        }
        return true;
      }
      if ((0, _isSexagesimal$2.default)(value)) {
        return isValidLatitude((0, _sexagesimalToDecimal$2.default)(value));
      }
      return false;
    };
    var _default$y = isValidLatitude;
    isValidLatitude$1.default = _default$y;

    var isValidLongitude$1 = {};

    Object.defineProperty(isValidLongitude$1, "__esModule", {
      value: true
    });
    isValidLongitude$1.default = void 0;
    var _isDecimal$1 = _interopRequireDefault$o(isDecimal$1);
    var _isSexagesimal$1 = _interopRequireDefault$o(isSexagesimal$1);
    var _sexagesimalToDecimal$1 = _interopRequireDefault$o(sexagesimalToDecimal$1);
    var _constants$a = constants;
    function _interopRequireDefault$o(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isValidLongitude = function isValidLongitude(value) {
      if ((0, _isDecimal$1.default)(value)) {
        if (parseFloat(value) > _constants$a.MAXLON || value < _constants$a.MINLON) {
          return false;
        }
        return true;
      }
      if ((0, _isSexagesimal$1.default)(value)) {
        return isValidLongitude((0, _sexagesimalToDecimal$1.default)(value));
      }
      return false;
    };
    var _default$x = isValidLongitude;
    isValidLongitude$1.default = _default$x;

    Object.defineProperty(isValidCoordinate$1, "__esModule", {
      value: true
    });
    isValidCoordinate$1.default = void 0;
    var _getCoordinateKeys2 = _interopRequireDefault$n(getCoordinateKeys$1);
    var _isValidLatitude = _interopRequireDefault$n(isValidLatitude$1);
    var _isValidLongitude = _interopRequireDefault$n(isValidLongitude$1);
    function _interopRequireDefault$n(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isValidCoordinate = function isValidCoordinate(point) {
      var _getCoordinateKeys = (0, _getCoordinateKeys2.default)(point),
        latitude = _getCoordinateKeys.latitude,
        longitude = _getCoordinateKeys.longitude;
      if (Array.isArray(point) && point.length >= 2) {
        return (0, _isValidLongitude.default)(point[0]) && (0, _isValidLatitude.default)(point[1]);
      }
      if (typeof latitude === "undefined" || typeof longitude === "undefined") {
        return false;
      }
      var lon = point[longitude];
      var lat = point[latitude];
      if (typeof lat === "undefined" || typeof lon === "undefined") {
        return false;
      }
      if ((0, _isValidLatitude.default)(lat) === false || (0, _isValidLongitude.default)(lon) === false) {
        return false;
      }
      return true;
    };
    var _default$w = isValidCoordinate;
    isValidCoordinate$1.default = _default$w;

    Object.defineProperty(toDecimal$1, "__esModule", {
      value: true
    });
    toDecimal$1.default = void 0;
    var _isDecimal = _interopRequireDefault$m(isDecimal$1);
    var _isSexagesimal = _interopRequireDefault$m(isSexagesimal$1);
    var _sexagesimalToDecimal = _interopRequireDefault$m(sexagesimalToDecimal$1);
    var _isValidCoordinate = _interopRequireDefault$m(isValidCoordinate$1);
    var _getCoordinateKeys = _interopRequireDefault$m(getCoordinateKeys$1);
    function _interopRequireDefault$m(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var toDecimal = function toDecimal(value) {
      if ((0, _isDecimal.default)(value)) {
        return Number(value);
      }
      if ((0, _isSexagesimal.default)(value)) {
        return (0, _sexagesimalToDecimal.default)(value);
      }
      if ((0, _isValidCoordinate.default)(value)) {
        var keys = (0, _getCoordinateKeys.default)(value);
        if (Array.isArray(value)) {
          return value.map(function (v, index) {
            return [0, 1].includes(index) ? toDecimal(v) : v;
          });
        }
        return _objectSpread(_objectSpread(_objectSpread({}, value), keys.latitude && _defineProperty({}, keys.latitude, toDecimal(value[keys.latitude]))), keys.longitude && _defineProperty({}, keys.longitude, toDecimal(value[keys.longitude])));
      }
      if (Array.isArray(value)) {
        return value.map(function (point) {
          return (0, _isValidCoordinate.default)(point) ? toDecimal(point) : point;
        });
      }
      return value;
    };
    var _default$v = toDecimal;
    toDecimal$1.default = _default$v;

    Object.defineProperty(getLatitude$1, "__esModule", {
      value: true
    });
    getLatitude$1.default = void 0;
    var _constants$9 = constants;
    var _getCoordinateKey$1 = _interopRequireDefault$l(getCoordinateKey$1);
    var _toDecimal$1 = _interopRequireDefault$l(toDecimal$1);
    function _interopRequireDefault$l(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getLatitude = function getLatitude(point, raw) {
      var latKey = (0, _getCoordinateKey$1.default)(point, _constants$9.latitudeKeys);
      if (typeof latKey === "undefined" || latKey === null) {
        return;
      }
      var value = point[latKey];
      return raw === true ? value : (0, _toDecimal$1.default)(value);
    };
    var _default$u = getLatitude;
    getLatitude$1.default = _default$u;

    var getLongitude$1 = {};

    Object.defineProperty(getLongitude$1, "__esModule", {
      value: true
    });
    getLongitude$1.default = void 0;
    var _constants$8 = constants;
    var _getCoordinateKey = _interopRequireDefault$k(getCoordinateKey$1);
    var _toDecimal = _interopRequireDefault$k(toDecimal$1);
    function _interopRequireDefault$k(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getLongitude = function getLongitude(point, raw) {
      var latKey = (0, _getCoordinateKey.default)(point, _constants$8.longitudeKeys);
      if (typeof latKey === "undefined" || latKey === null) {
        return;
      }
      var value = point[latKey];
      return raw === true ? value : (0, _toDecimal.default)(value);
    };
    var _default$t = getLongitude;
    getLongitude$1.default = _default$t;

    var toRad$1 = {};

    Object.defineProperty(toRad$1, "__esModule", {
      value: true
    });
    toRad$1.default = void 0;
    var toRad = function toRad(value) {
      return value * Math.PI / 180;
    };
    var _default$s = toRad;
    toRad$1.default = _default$s;

    var toDeg$1 = {};

    Object.defineProperty(toDeg$1, "__esModule", {
      value: true
    });
    toDeg$1.default = void 0;
    var toDeg = function toDeg(value) {
      return value * 180 / Math.PI;
    };
    var _default$r = toDeg;
    toDeg$1.default = _default$r;

    Object.defineProperty(computeDestinationPoint$1, "__esModule", {
      value: true
    });
    computeDestinationPoint$1.default = void 0;
    var _getLatitude$9 = _interopRequireDefault$j(getLatitude$1);
    var _getLongitude$9 = _interopRequireDefault$j(getLongitude$1);
    var _toRad$7 = _interopRequireDefault$j(toRad$1);
    var _toDeg$4 = _interopRequireDefault$j(toDeg$1);
    var _constants$7 = constants;
    function _interopRequireDefault$j(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var computeDestinationPoint = function computeDestinationPoint(start, distance, bearing) {
      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371000;
      var lat = (0, _getLatitude$9.default)(start);
      var lng = (0, _getLongitude$9.default)(start);
      var delta = distance / radius;
      var theta = (0, _toRad$7.default)(bearing);
      var phi1 = (0, _toRad$7.default)(lat);
      var lambda1 = (0, _toRad$7.default)(lng);
      var phi2 = Math.asin(Math.sin(phi1) * Math.cos(delta) + Math.cos(phi1) * Math.sin(delta) * Math.cos(theta));
      var lambda2 = lambda1 + Math.atan2(Math.sin(theta) * Math.sin(delta) * Math.cos(phi1), Math.cos(delta) - Math.sin(phi1) * Math.sin(phi2));
      var longitude = (0, _toDeg$4.default)(lambda2);
      if (longitude < _constants$7.MINLON || longitude > _constants$7.MAXLON) {
        lambda2 = (lambda2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
        longitude = (0, _toDeg$4.default)(lambda2);
      }
      return {
        latitude: (0, _toDeg$4.default)(phi2),
        longitude: longitude
      };
    };
    var _default$q = computeDestinationPoint;
    computeDestinationPoint$1.default = _default$q;

    var convertArea$1 = {};

    Object.defineProperty(convertArea$1, "__esModule", {
      value: true
    });
    convertArea$1.default = void 0;
    var _constants$6 = constants;
    var convertArea = function convertArea(squareMeters) {
      var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";
      var factor = _constants$6.areaConversion[targetUnit];
      if (factor) {
        return squareMeters * factor;
      }
      throw new Error("Invalid unit used for area conversion.");
    };
    var _default$p = convertArea;
    convertArea$1.default = _default$p;

    var convertDistance$1 = {};

    Object.defineProperty(convertDistance$1, "__esModule", {
      value: true
    });
    convertDistance$1.default = void 0;
    var _constants$5 = constants;
    var convertDistance = function convertDistance(meters) {
      var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";
      var factor = _constants$5.distanceConversion[targetUnit];
      if (factor) {
        return meters * factor;
      }
      throw new Error("Invalid unit used for distance conversion.");
    };
    var _default$o = convertDistance;
    convertDistance$1.default = _default$o;

    var convertSpeed$1 = {};

    Object.defineProperty(convertSpeed$1, "__esModule", {
      value: true
    });
    convertSpeed$1.default = void 0;
    var _constants$4 = constants;
    var convertSpeed = function convertSpeed(metersPerSecond) {
      var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "kmh";
      switch (targetUnit) {
        case "kmh":
          return metersPerSecond * _constants$4.timeConversion.h * _constants$4.distanceConversion.km;
        case "mph":
          return metersPerSecond * _constants$4.timeConversion.h * _constants$4.distanceConversion.mi;
        default:
          return metersPerSecond;
      }
    };
    var _default$n = convertSpeed;
    convertSpeed$1.default = _default$n;

    var decimalToSexagesimal = {};

    Object.defineProperty(decimalToSexagesimal, "__esModule", {
      value: true
    });
    decimalToSexagesimal.default = void 0;
    function _slicedToArray$1(arr, i) {
      return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
    }
    function _nonIterableRest$1() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit$1(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles$1(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var imprecise = function imprecise(number) {
      var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
      var factor = Math.pow(10, decimals);
      return Math.round(number * factor) / factor;
    };
    var decimal2sexagesimalNext = function decimal2sexagesimalNext(decimal) {
      var _decimal$toString$spl = decimal.toString().split("."),
        _decimal$toString$spl2 = _slicedToArray$1(_decimal$toString$spl, 2),
        pre = _decimal$toString$spl2[0],
        post = _decimal$toString$spl2[1];
      var deg = Math.abs(Number(pre));
      var min0 = Number("0." + (post || 0)) * 60;
      var sec0 = min0.toString().split(".");
      var min = Math.floor(min0);
      var sec = imprecise(Number("0." + (sec0[1] || 0)) * 60).toString();
      var _sec$split = sec.split("."),
        _sec$split2 = _slicedToArray$1(_sec$split, 2),
        secPreDec = _sec$split2[0],
        _sec$split2$ = _sec$split2[1],
        secDec = _sec$split2$ === void 0 ? "0" : _sec$split2$;
      return deg + "\xB0 " + min.toString().padStart(2, "0") + "' " + secPreDec.padStart(2, "0") + "." + secDec.padEnd(1, "0") + "\"";
    };
    var _default$m = decimal2sexagesimalNext;
    decimalToSexagesimal.default = _default$m;

    var findNearest$1 = {};

    var orderByDistance$1 = {};

    var getDistance$2 = {};

    var robustAcos$1 = {};

    Object.defineProperty(robustAcos$1, "__esModule", {
      value: true
    });
    robustAcos$1.default = void 0;
    var robustAcos = function robustAcos(value) {
      if (value > 1) {
        return 1;
      }
      if (value < -1) {
        return -1;
      }
      return value;
    };
    var _default$l = robustAcos;
    robustAcos$1.default = _default$l;

    Object.defineProperty(getDistance$2, "__esModule", {
      value: true
    });
    getDistance$2.default = void 0;
    var _getLatitude$8 = _interopRequireDefault$i(getLatitude$1);
    var _getLongitude$8 = _interopRequireDefault$i(getLongitude$1);
    var _toRad$6 = _interopRequireDefault$i(toRad$1);
    var _robustAcos$1 = _interopRequireDefault$i(robustAcos$1);
    var _constants$3 = constants;
    function _interopRequireDefault$i(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getDistance$1 = function getDistance(from, to) {
      var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
      var fromLat = (0, _getLatitude$8.default)(from);
      var fromLon = (0, _getLongitude$8.default)(from);
      var toLat = (0, _getLatitude$8.default)(to);
      var toLon = (0, _getLongitude$8.default)(to);
      var distance = Math.acos((0, _robustAcos$1.default)(Math.sin((0, _toRad$6.default)(toLat)) * Math.sin((0, _toRad$6.default)(fromLat)) + Math.cos((0, _toRad$6.default)(toLat)) * Math.cos((0, _toRad$6.default)(fromLat)) * Math.cos((0, _toRad$6.default)(fromLon) - (0, _toRad$6.default)(toLon)))) * _constants$3.earthRadius;
      return Math.round(distance / accuracy) * accuracy;
    };
    var _default$k = getDistance$1;
    getDistance$2.default = _default$k;

    Object.defineProperty(orderByDistance$1, "__esModule", {
      value: true
    });
    orderByDistance$1.default = void 0;
    var _getDistance$5 = _interopRequireDefault$h(getDistance$2);
    function _interopRequireDefault$h(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var orderByDistance = function orderByDistance(point, coords) {
      var distanceFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getDistance$5.default;
      distanceFn = typeof distanceFn === "function" ? distanceFn : _getDistance$5.default;
      return coords.slice().sort(function (a, b) {
        return distanceFn(point, a) - distanceFn(point, b);
      });
    };
    var _default$j = orderByDistance;
    orderByDistance$1.default = _default$j;

    Object.defineProperty(findNearest$1, "__esModule", {
      value: true
    });
    findNearest$1.default = void 0;
    var _orderByDistance = _interopRequireDefault$g(orderByDistance$1);
    function _interopRequireDefault$g(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var findNearest = function findNearest(point, coords) {
      return (0, _orderByDistance.default)(point, coords)[0];
    };
    var _default$i = findNearest;
    findNearest$1.default = _default$i;

    var getAreaOfPolygon$1 = {};

    Object.defineProperty(getAreaOfPolygon$1, "__esModule", {
      value: true
    });
    getAreaOfPolygon$1.default = void 0;
    var _toRad$5 = _interopRequireDefault$f(toRad$1);
    var _getLatitude$7 = _interopRequireDefault$f(getLatitude$1);
    var _getLongitude$7 = _interopRequireDefault$f(getLongitude$1);
    var _constants$2 = constants;
    function _interopRequireDefault$f(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getAreaOfPolygon = function getAreaOfPolygon(points) {
      var area = 0;
      if (points.length > 2) {
        var lowerIndex;
        var middleIndex;
        var upperIndex;
        for (var i = 0; i < points.length; i++) {
          if (i === points.length - 2) {
            lowerIndex = points.length - 2;
            middleIndex = points.length - 1;
            upperIndex = 0;
          } else if (i === points.length - 1) {
            lowerIndex = points.length - 1;
            middleIndex = 0;
            upperIndex = 1;
          } else {
            lowerIndex = i;
            middleIndex = i + 1;
            upperIndex = i + 2;
          }
          var p1lon = (0, _getLongitude$7.default)(points[lowerIndex]);
          var p2lat = (0, _getLatitude$7.default)(points[middleIndex]);
          var p3lon = (0, _getLongitude$7.default)(points[upperIndex]);
          area += ((0, _toRad$5.default)(p3lon) - (0, _toRad$5.default)(p1lon)) * Math.sin((0, _toRad$5.default)(p2lat));
        }
        area = area * _constants$2.earthRadius * _constants$2.earthRadius / 2;
      }
      return Math.abs(area);
    };
    var _default$h = getAreaOfPolygon;
    getAreaOfPolygon$1.default = _default$h;

    var getBounds$1 = {};

    Object.defineProperty(getBounds$1, "__esModule", {
      value: true
    });
    getBounds$1.default = void 0;
    var _getLatitude$6 = _interopRequireDefault$e(getLatitude$1);
    var _getLongitude$6 = _interopRequireDefault$e(getLongitude$1);
    function _interopRequireDefault$e(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getBounds = function getBounds(points) {
      if (Array.isArray(points) === false || points.length === 0) {
        throw new Error("No points were given.");
      }
      return points.reduce(function (stats, point) {
        var latitude = (0, _getLatitude$6.default)(point);
        var longitude = (0, _getLongitude$6.default)(point);
        return {
          maxLat: Math.max(latitude, stats.maxLat),
          minLat: Math.min(latitude, stats.minLat),
          maxLng: Math.max(longitude, stats.maxLng),
          minLng: Math.min(longitude, stats.minLng)
        };
      }, {
        maxLat: -Infinity,
        minLat: Infinity,
        maxLng: -Infinity,
        minLng: Infinity
      });
    };
    var _default$g = getBounds;
    getBounds$1.default = _default$g;

    var getBoundsOfDistance$1 = {};

    Object.defineProperty(getBoundsOfDistance$1, "__esModule", {
      value: true
    });
    getBoundsOfDistance$1.default = void 0;
    var _getLatitude$5 = _interopRequireDefault$d(getLatitude$1);
    var _getLongitude$5 = _interopRequireDefault$d(getLongitude$1);
    var _toRad$4 = _interopRequireDefault$d(toRad$1);
    var _toDeg$3 = _interopRequireDefault$d(toDeg$1);
    var _constants$1 = constants;
    function _interopRequireDefault$d(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getBoundsOfDistance = function getBoundsOfDistance(point, distance) {
      var latitude = (0, _getLatitude$5.default)(point);
      var longitude = (0, _getLongitude$5.default)(point);
      var radLat = (0, _toRad$4.default)(latitude);
      var radLon = (0, _toRad$4.default)(longitude);
      var radDist = distance / _constants$1.earthRadius;
      var minLat = radLat - radDist;
      var maxLat = radLat + radDist;
      var MAX_LAT_RAD = (0, _toRad$4.default)(_constants$1.MAXLAT);
      var MIN_LAT_RAD = (0, _toRad$4.default)(_constants$1.MINLAT);
      var MAX_LON_RAD = (0, _toRad$4.default)(_constants$1.MAXLON);
      var MIN_LON_RAD = (0, _toRad$4.default)(_constants$1.MINLON);
      var minLon;
      var maxLon;
      if (minLat > MIN_LAT_RAD && maxLat < MAX_LAT_RAD) {
        var deltaLon = Math.asin(Math.sin(radDist) / Math.cos(radLat));
        minLon = radLon - deltaLon;
        if (minLon < MIN_LON_RAD) {
          minLon += Math.PI * 2;
        }
        maxLon = radLon + deltaLon;
        if (maxLon > MAX_LON_RAD) {
          maxLon -= Math.PI * 2;
        }
      } else {
        minLat = Math.max(minLat, MIN_LAT_RAD);
        maxLat = Math.min(maxLat, MAX_LAT_RAD);
        minLon = MIN_LON_RAD;
        maxLon = MAX_LON_RAD;
      }
      return [{
        latitude: (0, _toDeg$3.default)(minLat),
        longitude: (0, _toDeg$3.default)(minLon)
      }, {
        latitude: (0, _toDeg$3.default)(maxLat),
        longitude: (0, _toDeg$3.default)(maxLon)
      }];
    };
    var _default$f = getBoundsOfDistance;
    getBoundsOfDistance$1.default = _default$f;

    var getCenter$1 = {};

    Object.defineProperty(getCenter$1, "__esModule", {
      value: true
    });
    getCenter$1.default = void 0;
    var _getLatitude$4 = _interopRequireDefault$c(getLatitude$1);
    var _getLongitude$4 = _interopRequireDefault$c(getLongitude$1);
    var _toRad$3 = _interopRequireDefault$c(toRad$1);
    var _toDeg$2 = _interopRequireDefault$c(toDeg$1);
    function _interopRequireDefault$c(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getCenter = function getCenter(points) {
      if (Array.isArray(points) === false || points.length === 0) {
        return false;
      }
      var numberOfPoints = points.length;
      var sum = points.reduce(function (acc, point) {
        var pointLat = (0, _toRad$3.default)((0, _getLatitude$4.default)(point));
        var pointLon = (0, _toRad$3.default)((0, _getLongitude$4.default)(point));
        return {
          X: acc.X + Math.cos(pointLat) * Math.cos(pointLon),
          Y: acc.Y + Math.cos(pointLat) * Math.sin(pointLon),
          Z: acc.Z + Math.sin(pointLat)
        };
      }, {
        X: 0,
        Y: 0,
        Z: 0
      });
      var X = sum.X / numberOfPoints;
      var Y = sum.Y / numberOfPoints;
      var Z = sum.Z / numberOfPoints;
      return {
        longitude: (0, _toDeg$2.default)(Math.atan2(Y, X)),
        latitude: (0, _toDeg$2.default)(Math.atan2(Z, Math.sqrt(X * X + Y * Y)))
      };
    };
    var _default$e = getCenter;
    getCenter$1.default = _default$e;

    var getCenterOfBounds$1 = {};

    Object.defineProperty(getCenterOfBounds$1, "__esModule", {
      value: true
    });
    getCenterOfBounds$1.default = void 0;
    var _getBounds = _interopRequireDefault$b(getBounds$1);
    function _interopRequireDefault$b(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getCenterOfBounds = function getCenterOfBounds(coords) {
      var bounds = (0, _getBounds.default)(coords);
      var latitude = bounds.minLat + (bounds.maxLat - bounds.minLat) / 2;
      var longitude = bounds.minLng + (bounds.maxLng - bounds.minLng) / 2;
      return {
        latitude: parseFloat(latitude.toFixed(6)),
        longitude: parseFloat(longitude.toFixed(6))
      };
    };
    var _default$d = getCenterOfBounds;
    getCenterOfBounds$1.default = _default$d;

    var getCompassDirection$1 = {};

    var getRhumbLineBearing$1 = {};

    Object.defineProperty(getRhumbLineBearing$1, "__esModule", {
      value: true
    });
    getRhumbLineBearing$1.default = void 0;
    var _getLatitude$3 = _interopRequireDefault$a(getLatitude$1);
    var _getLongitude$3 = _interopRequireDefault$a(getLongitude$1);
    var _toRad$2 = _interopRequireDefault$a(toRad$1);
    var _toDeg$1 = _interopRequireDefault$a(toDeg$1);
    function _interopRequireDefault$a(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getRhumbLineBearing = function getRhumbLineBearing(origin, dest) {
      var diffLon = (0, _toRad$2.default)((0, _getLongitude$3.default)(dest)) - (0, _toRad$2.default)((0, _getLongitude$3.default)(origin));
      var diffPhi = Math.log(Math.tan((0, _toRad$2.default)((0, _getLatitude$3.default)(dest)) / 2 + Math.PI / 4) / Math.tan((0, _toRad$2.default)((0, _getLatitude$3.default)(origin)) / 2 + Math.PI / 4));
      if (Math.abs(diffLon) > Math.PI) {
        if (diffLon > 0) {
          diffLon = (Math.PI * 2 - diffLon) * -1;
        } else {
          diffLon = Math.PI * 2 + diffLon;
        }
      }
      return ((0, _toDeg$1.default)(Math.atan2(diffLon, diffPhi)) + 360) % 360;
    };
    var _default$c = getRhumbLineBearing;
    getRhumbLineBearing$1.default = _default$c;

    Object.defineProperty(getCompassDirection$1, "__esModule", {
      value: true
    });
    getCompassDirection$1.default = void 0;
    var _getRhumbLineBearing = _interopRequireDefault$9(getRhumbLineBearing$1);
    function _interopRequireDefault$9(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getCompassDirection = function getCompassDirection(origin, dest) {
      var bearingFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getRhumbLineBearing.default;
      var bearing = typeof bearingFn === "function" ? bearingFn(origin, dest) : (0, _getRhumbLineBearing.default)(origin, dest);
      if (isNaN(bearing)) {
        throw new Error("Could not calculate bearing for given points. Check your bearing function");
      }
      switch (Math.round(bearing / 22.5)) {
        case 1:
          return "NNE";
        case 2:
          return "NE";
        case 3:
          return "ENE";
        case 4:
          return "E";
        case 5:
          return "ESE";
        case 6:
          return "SE";
        case 7:
          return "SSE";
        case 8:
          return "S";
        case 9:
          return "SSW";
        case 10:
          return "SW";
        case 11:
          return "WSW";
        case 12:
          return "W";
        case 13:
          return "WNW";
        case 14:
          return "NW";
        case 15:
          return "NNW";
        default:
          return "N";
      }
    };
    var _default$b = getCompassDirection;
    getCompassDirection$1.default = _default$b;

    var getDistanceFromLine$1 = {};

    Object.defineProperty(getDistanceFromLine$1, "__esModule", {
      value: true
    });
    getDistanceFromLine$1.default = void 0;
    var _getDistance$4 = _interopRequireDefault$8(getDistance$2);
    var _robustAcos = _interopRequireDefault$8(robustAcos$1);
    function _interopRequireDefault$8(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getDistanceFromLine = function getDistanceFromLine(point, lineStart, lineEnd) {
      var accuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var d1 = (0, _getDistance$4.default)(lineStart, point, accuracy);
      var d2 = (0, _getDistance$4.default)(point, lineEnd, accuracy);
      var d3 = (0, _getDistance$4.default)(lineStart, lineEnd, accuracy);
      var alpha = Math.acos((0, _robustAcos.default)((d1 * d1 + d3 * d3 - d2 * d2) / (2 * d1 * d3)));
      var beta = Math.acos((0, _robustAcos.default)((d2 * d2 + d3 * d3 - d1 * d1) / (2 * d2 * d3)));
      if (alpha > Math.PI / 2) {
        return d1;
      }
      if (beta > Math.PI / 2) {
        return d2;
      }
      return Math.sin(alpha) * d1;
    };
    var _default$a = getDistanceFromLine;
    getDistanceFromLine$1.default = _default$a;

    var getGreatCircleBearing$1 = {};

    Object.defineProperty(getGreatCircleBearing$1, "__esModule", {
      value: true
    });
    getGreatCircleBearing$1.default = void 0;
    var _getLatitude$2 = _interopRequireDefault$7(getLatitude$1);
    var _getLongitude$2 = _interopRequireDefault$7(getLongitude$1);
    var _toRad$1 = _interopRequireDefault$7(toRad$1);
    var _toDeg = _interopRequireDefault$7(toDeg$1);
    function _interopRequireDefault$7(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getGreatCircleBearing = function getGreatCircleBearing(origin, dest) {
      var destLat = (0, _getLatitude$2.default)(dest);
      var detLon = (0, _getLongitude$2.default)(dest);
      var originLat = (0, _getLatitude$2.default)(origin);
      var originLon = (0, _getLongitude$2.default)(origin);
      var bearing = ((0, _toDeg.default)(Math.atan2(Math.sin((0, _toRad$1.default)(detLon) - (0, _toRad$1.default)(originLon)) * Math.cos((0, _toRad$1.default)(destLat)), Math.cos((0, _toRad$1.default)(originLat)) * Math.sin((0, _toRad$1.default)(destLat)) - Math.sin((0, _toRad$1.default)(originLat)) * Math.cos((0, _toRad$1.default)(destLat)) * Math.cos((0, _toRad$1.default)(detLon) - (0, _toRad$1.default)(originLon)))) + 360) % 360;
      return bearing;
    };
    var _default$9 = getGreatCircleBearing;
    getGreatCircleBearing$1.default = _default$9;

    var getPathLength$1 = {};

    Object.defineProperty(getPathLength$1, "__esModule", {
      value: true
    });
    getPathLength$1.default = void 0;
    var _getDistance$3 = _interopRequireDefault$6(getDistance$2);
    function _interopRequireDefault$6(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof(obj);
    }
    var getPathLength = function getPathLength(points) {
      var distanceFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _getDistance$3.default;
      return points.reduce(function (acc, point) {
        if (_typeof(acc) === "object" && acc.last !== null) {
          acc.distance += distanceFn(point, acc.last);
        }
        acc.last = point;
        return acc;
      }, {
        last: null,
        distance: 0
      }).distance;
    };
    var _default$8 = getPathLength;
    getPathLength$1.default = _default$8;

    var getPreciseDistance = {};

    Object.defineProperty(getPreciseDistance, "__esModule", {
      value: true
    });
    getPreciseDistance.default = void 0;
    var _getLatitude$1 = _interopRequireDefault$5(getLatitude$1);
    var _getLongitude$1 = _interopRequireDefault$5(getLongitude$1);
    var _toRad = _interopRequireDefault$5(toRad$1);
    var _constants = constants;
    function _interopRequireDefault$5(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getDistance = function getDistance(start, end) {
      var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
      var startLat = (0, _getLatitude$1.default)(start);
      var startLon = (0, _getLongitude$1.default)(start);
      var endLat = (0, _getLatitude$1.default)(end);
      var endLon = (0, _getLongitude$1.default)(end);
      var b = 6356752.314245;
      var ellipsoidParams = 1 / 298.257223563;
      var L = (0, _toRad.default)(endLon - startLon);
      var cosSigma;
      var sigma;
      var sinAlpha;
      var cosSqAlpha;
      var cos2SigmaM;
      var sinSigma;
      var U1 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(startLat))));
      var U2 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(endLat))));
      var sinU1 = Math.sin(U1);
      var cosU1 = Math.cos(U1);
      var sinU2 = Math.sin(U2);
      var cosU2 = Math.cos(U2);
      var lambda = L;
      var lambdaP;
      var iterLimit = 100;
      do {
        var sinLambda = Math.sin(lambda);
        var cosLambda = Math.cos(lambda);
        sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
        if (sinSigma === 0) {
          return 0;
        }
        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
        sigma = Math.atan2(sinSigma, cosSigma);
        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
        cosSqAlpha = 1 - sinAlpha * sinAlpha;
        cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
        if (isNaN(cos2SigmaM)) {
          cos2SigmaM = 0;
        }
        var C = ellipsoidParams / 16 * cosSqAlpha * (4 + ellipsoidParams * (4 - 3 * cosSqAlpha));
        lambdaP = lambda;
        lambda = L + (1 - C) * ellipsoidParams * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
      } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
      if (iterLimit === 0) {
        return NaN;
      }
      var uSq = cosSqAlpha * (_constants.earthRadius * _constants.earthRadius - b * b) / (b * b);
      var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
      var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
      var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
      var distance = b * A * (sigma - deltaSigma);
      return Math.round(distance / accuracy) * accuracy;
    };
    var _default$7 = getDistance;
    getPreciseDistance.default = _default$7;

    var getRoughCompassDirection$1 = {};

    Object.defineProperty(getRoughCompassDirection$1, "__esModule", {
      value: true
    });
    getRoughCompassDirection$1.default = void 0;
    var getRoughCompassDirection = function getRoughCompassDirection(exact) {
      if (/^NNE|NE|NNW|N$/.test(exact)) {
        return "N";
      }
      if (/^ENE|E|ESE|SE$/.test(exact)) {
        return "E";
      }
      if (/^SSE|S|SSW|SW$/.test(exact)) {
        return "S";
      }
      if (/^WSW|W|WNW|NW$/.test(exact)) {
        return "W";
      }
    };
    var _default$6 = getRoughCompassDirection;
    getRoughCompassDirection$1.default = _default$6;

    var getSpeed$1 = {};

    Object.defineProperty(getSpeed$1, "__esModule", {
      value: true
    });
    getSpeed$1.default = void 0;
    var _getDistance$2 = _interopRequireDefault$4(getDistance$2);
    function _interopRequireDefault$4(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getSpeed = function getSpeed(start, end) {
      var distanceFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getDistance$2.default;
      var distance = distanceFn(start, end);
      var time = Number(end.time) - Number(start.time);
      var metersPerSecond = distance / time * 1000;
      return metersPerSecond;
    };
    var _default$5 = getSpeed;
    getSpeed$1.default = _default$5;

    var isPointInLine$1 = {};

    Object.defineProperty(isPointInLine$1, "__esModule", {
      value: true
    });
    isPointInLine$1.default = void 0;
    var _getDistance$1 = _interopRequireDefault$3(getDistance$2);
    function _interopRequireDefault$3(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointInLine = function isPointInLine(point, lineStart, lineEnd) {
      return (0, _getDistance$1.default)(lineStart, point) + (0, _getDistance$1.default)(point, lineEnd) === (0, _getDistance$1.default)(lineStart, lineEnd);
    };
    var _default$4 = isPointInLine;
    isPointInLine$1.default = _default$4;

    var isPointInPolygon$1 = {};

    Object.defineProperty(isPointInPolygon$1, "__esModule", {
      value: true
    });
    isPointInPolygon$1.default = void 0;
    var _getLatitude = _interopRequireDefault$2(getLatitude$1);
    var _getLongitude = _interopRequireDefault$2(getLongitude$1);
    function _interopRequireDefault$2(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointInPolygon = function isPointInPolygon(point, polygon) {
      var isInside = false;
      var totalPolys = polygon.length;
      for (var i = -1, j = totalPolys - 1; ++i < totalPolys; j = i) {
        if (((0, _getLongitude.default)(polygon[i]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[j]) || (0, _getLongitude.default)(polygon[j]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[i])) && (0, _getLatitude.default)(point) < ((0, _getLatitude.default)(polygon[j]) - (0, _getLatitude.default)(polygon[i])) * ((0, _getLongitude.default)(point) - (0, _getLongitude.default)(polygon[i])) / ((0, _getLongitude.default)(polygon[j]) - (0, _getLongitude.default)(polygon[i])) + (0, _getLatitude.default)(polygon[i])) {
          isInside = !isInside;
        }
      }
      return isInside;
    };
    var _default$3 = isPointInPolygon;
    isPointInPolygon$1.default = _default$3;

    var isPointNearLine$1 = {};

    Object.defineProperty(isPointNearLine$1, "__esModule", {
      value: true
    });
    isPointNearLine$1.default = void 0;
    var _getDistanceFromLine = _interopRequireDefault$1(getDistanceFromLine$1);
    function _interopRequireDefault$1(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointNearLine = function isPointNearLine(point, start, end, distance) {
      return (0, _getDistanceFromLine.default)(point, start, end) < distance;
    };
    var _default$2 = isPointNearLine;
    isPointNearLine$1.default = _default$2;

    var isPointWithinRadius$1 = {};

    Object.defineProperty(isPointWithinRadius$1, "__esModule", {
      value: true
    });
    isPointWithinRadius$1.default = void 0;
    var _getDistance = _interopRequireDefault(getDistance$2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointWithinRadius = function isPointWithinRadius(point, center, radius) {
      return (0, _getDistance.default)(point, center) < radius;
    };
    var _default$1 = isPointWithinRadius;
    isPointWithinRadius$1.default = _default$1;

    var wktToPolygon$1 = {};

    Object.defineProperty(wktToPolygon$1, "__esModule", {
      value: true
    });
    wktToPolygon$1.default = void 0;
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var wktToPolygon = function wktToPolygon(wkt) {
      if (!wkt.startsWith("POLYGON")) {
        throw new Error("Invalid wkt.");
      }
      var coordsText = wkt.slice(wkt.indexOf("(") + 2, wkt.indexOf(")")).split(", ");
      var polygon = coordsText.map(function (coordText) {
        var _coordText$split = coordText.split(" "),
          _coordText$split2 = _slicedToArray(_coordText$split, 2),
          longitude = _coordText$split2[0],
          latitude = _coordText$split2[1];
        return {
          longitude: parseFloat(longitude),
          latitude: parseFloat(latitude)
        };
      });
      return polygon;
    };
    var _default = wktToPolygon;
    wktToPolygon$1.default = _default;

    (function (exports) {

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _exportNames = {
        computeDestinationPoint: true,
        convertArea: true,
        convertDistance: true,
        convertSpeed: true,
        decimalToSexagesimal: true,
        findNearest: true,
        getAreaOfPolygon: true,
        getBounds: true,
        getBoundsOfDistance: true,
        getCenter: true,
        getCenterOfBounds: true,
        getCompassDirection: true,
        getCoordinateKey: true,
        getCoordinateKeys: true,
        getDistance: true,
        getDistanceFromLine: true,
        getGreatCircleBearing: true,
        getLatitude: true,
        getLongitude: true,
        getPathLength: true,
        getPreciseDistance: true,
        getRhumbLineBearing: true,
        getRoughCompassDirection: true,
        getSpeed: true,
        isDecimal: true,
        isPointInLine: true,
        isPointInPolygon: true,
        isPointNearLine: true,
        isPointWithinRadius: true,
        isSexagesimal: true,
        isValidCoordinate: true,
        isValidLatitude: true,
        isValidLongitude: true,
        orderByDistance: true,
        sexagesimalToDecimal: true,
        toDecimal: true,
        toRad: true,
        toDeg: true,
        wktToPolygon: true
      };
      Object.defineProperty(exports, "computeDestinationPoint", {
        enumerable: true,
        get: function get() {
          return _computeDestinationPoint.default;
        }
      });
      Object.defineProperty(exports, "convertArea", {
        enumerable: true,
        get: function get() {
          return _convertArea.default;
        }
      });
      Object.defineProperty(exports, "convertDistance", {
        enumerable: true,
        get: function get() {
          return _convertDistance.default;
        }
      });
      Object.defineProperty(exports, "convertSpeed", {
        enumerable: true,
        get: function get() {
          return _convertSpeed.default;
        }
      });
      Object.defineProperty(exports, "decimalToSexagesimal", {
        enumerable: true,
        get: function get() {
          return _decimalToSexagesimal.default;
        }
      });
      Object.defineProperty(exports, "findNearest", {
        enumerable: true,
        get: function get() {
          return _findNearest.default;
        }
      });
      Object.defineProperty(exports, "getAreaOfPolygon", {
        enumerable: true,
        get: function get() {
          return _getAreaOfPolygon.default;
        }
      });
      Object.defineProperty(exports, "getBounds", {
        enumerable: true,
        get: function get() {
          return _getBounds.default;
        }
      });
      Object.defineProperty(exports, "getBoundsOfDistance", {
        enumerable: true,
        get: function get() {
          return _getBoundsOfDistance.default;
        }
      });
      Object.defineProperty(exports, "getCenter", {
        enumerable: true,
        get: function get() {
          return _getCenter.default;
        }
      });
      Object.defineProperty(exports, "getCenterOfBounds", {
        enumerable: true,
        get: function get() {
          return _getCenterOfBounds.default;
        }
      });
      Object.defineProperty(exports, "getCompassDirection", {
        enumerable: true,
        get: function get() {
          return _getCompassDirection.default;
        }
      });
      Object.defineProperty(exports, "getCoordinateKey", {
        enumerable: true,
        get: function get() {
          return _getCoordinateKey.default;
        }
      });
      Object.defineProperty(exports, "getCoordinateKeys", {
        enumerable: true,
        get: function get() {
          return _getCoordinateKeys.default;
        }
      });
      Object.defineProperty(exports, "getDistance", {
        enumerable: true,
        get: function get() {
          return _getDistance.default;
        }
      });
      Object.defineProperty(exports, "getDistanceFromLine", {
        enumerable: true,
        get: function get() {
          return _getDistanceFromLine.default;
        }
      });
      Object.defineProperty(exports, "getGreatCircleBearing", {
        enumerable: true,
        get: function get() {
          return _getGreatCircleBearing.default;
        }
      });
      Object.defineProperty(exports, "getLatitude", {
        enumerable: true,
        get: function get() {
          return _getLatitude.default;
        }
      });
      Object.defineProperty(exports, "getLongitude", {
        enumerable: true,
        get: function get() {
          return _getLongitude.default;
        }
      });
      Object.defineProperty(exports, "getPathLength", {
        enumerable: true,
        get: function get() {
          return _getPathLength.default;
        }
      });
      Object.defineProperty(exports, "getPreciseDistance", {
        enumerable: true,
        get: function get() {
          return _getPreciseDistance.default;
        }
      });
      Object.defineProperty(exports, "getRhumbLineBearing", {
        enumerable: true,
        get: function get() {
          return _getRhumbLineBearing.default;
        }
      });
      Object.defineProperty(exports, "getRoughCompassDirection", {
        enumerable: true,
        get: function get() {
          return _getRoughCompassDirection.default;
        }
      });
      Object.defineProperty(exports, "getSpeed", {
        enumerable: true,
        get: function get() {
          return _getSpeed.default;
        }
      });
      Object.defineProperty(exports, "isDecimal", {
        enumerable: true,
        get: function get() {
          return _isDecimal.default;
        }
      });
      Object.defineProperty(exports, "isPointInLine", {
        enumerable: true,
        get: function get() {
          return _isPointInLine.default;
        }
      });
      Object.defineProperty(exports, "isPointInPolygon", {
        enumerable: true,
        get: function get() {
          return _isPointInPolygon.default;
        }
      });
      Object.defineProperty(exports, "isPointNearLine", {
        enumerable: true,
        get: function get() {
          return _isPointNearLine.default;
        }
      });
      Object.defineProperty(exports, "isPointWithinRadius", {
        enumerable: true,
        get: function get() {
          return _isPointWithinRadius.default;
        }
      });
      Object.defineProperty(exports, "isSexagesimal", {
        enumerable: true,
        get: function get() {
          return _isSexagesimal.default;
        }
      });
      Object.defineProperty(exports, "isValidCoordinate", {
        enumerable: true,
        get: function get() {
          return _isValidCoordinate.default;
        }
      });
      Object.defineProperty(exports, "isValidLatitude", {
        enumerable: true,
        get: function get() {
          return _isValidLatitude.default;
        }
      });
      Object.defineProperty(exports, "isValidLongitude", {
        enumerable: true,
        get: function get() {
          return _isValidLongitude.default;
        }
      });
      Object.defineProperty(exports, "orderByDistance", {
        enumerable: true,
        get: function get() {
          return _orderByDistance.default;
        }
      });
      Object.defineProperty(exports, "sexagesimalToDecimal", {
        enumerable: true,
        get: function get() {
          return _sexagesimalToDecimal.default;
        }
      });
      Object.defineProperty(exports, "toDecimal", {
        enumerable: true,
        get: function get() {
          return _toDecimal.default;
        }
      });
      Object.defineProperty(exports, "toRad", {
        enumerable: true,
        get: function get() {
          return _toRad.default;
        }
      });
      Object.defineProperty(exports, "toDeg", {
        enumerable: true,
        get: function get() {
          return _toDeg.default;
        }
      });
      Object.defineProperty(exports, "wktToPolygon", {
        enumerable: true,
        get: function get() {
          return _wktToPolygon.default;
        }
      });
      var _computeDestinationPoint = _interopRequireDefault(computeDestinationPoint$1);
      var _convertArea = _interopRequireDefault(convertArea$1);
      var _convertDistance = _interopRequireDefault(convertDistance$1);
      var _convertSpeed = _interopRequireDefault(convertSpeed$1);
      var _decimalToSexagesimal = _interopRequireDefault(decimalToSexagesimal);
      var _findNearest = _interopRequireDefault(findNearest$1);
      var _getAreaOfPolygon = _interopRequireDefault(getAreaOfPolygon$1);
      var _getBounds = _interopRequireDefault(getBounds$1);
      var _getBoundsOfDistance = _interopRequireDefault(getBoundsOfDistance$1);
      var _getCenter = _interopRequireDefault(getCenter$1);
      var _getCenterOfBounds = _interopRequireDefault(getCenterOfBounds$1);
      var _getCompassDirection = _interopRequireDefault(getCompassDirection$1);
      var _getCoordinateKey = _interopRequireDefault(getCoordinateKey$1);
      var _getCoordinateKeys = _interopRequireDefault(getCoordinateKeys$1);
      var _getDistance = _interopRequireDefault(getDistance$2);
      var _getDistanceFromLine = _interopRequireDefault(getDistanceFromLine$1);
      var _getGreatCircleBearing = _interopRequireDefault(getGreatCircleBearing$1);
      var _getLatitude = _interopRequireDefault(getLatitude$1);
      var _getLongitude = _interopRequireDefault(getLongitude$1);
      var _getPathLength = _interopRequireDefault(getPathLength$1);
      var _getPreciseDistance = _interopRequireDefault(getPreciseDistance);
      var _getRhumbLineBearing = _interopRequireDefault(getRhumbLineBearing$1);
      var _getRoughCompassDirection = _interopRequireDefault(getRoughCompassDirection$1);
      var _getSpeed = _interopRequireDefault(getSpeed$1);
      var _isDecimal = _interopRequireDefault(isDecimal$1);
      var _isPointInLine = _interopRequireDefault(isPointInLine$1);
      var _isPointInPolygon = _interopRequireDefault(isPointInPolygon$1);
      var _isPointNearLine = _interopRequireDefault(isPointNearLine$1);
      var _isPointWithinRadius = _interopRequireDefault(isPointWithinRadius$1);
      var _isSexagesimal = _interopRequireDefault(isSexagesimal$1);
      var _isValidCoordinate = _interopRequireDefault(isValidCoordinate$1);
      var _isValidLatitude = _interopRequireDefault(isValidLatitude$1);
      var _isValidLongitude = _interopRequireDefault(isValidLongitude$1);
      var _orderByDistance = _interopRequireDefault(orderByDistance$1);
      var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal$1);
      var _toDecimal = _interopRequireDefault(toDecimal$1);
      var _toRad = _interopRequireDefault(toRad$1);
      var _toDeg = _interopRequireDefault(toDeg$1);
      var _wktToPolygon = _interopRequireDefault(wktToPolygon$1);
      var _constants = constants;
      Object.keys(_constants).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _constants[key];
          }
        });
      });
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
    })(es);

    class Leg extends Guidable {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "segment", void 0);
        _defineProperty$2(this, "metadata", void 0);
        _defineProperty$2(this, "constrainedTurnDirection", void 0);
        _defineProperty$2(this, "isNull", false);
        _defineProperty$2(this, "displayedOnMap", true);
        _defineProperty$2(this, "predictedTas", void 0);
        _defineProperty$2(this, "predictedGs", void 0);
      }
      get disableAutomaticSequencing() {
        return false;
      }

      /** @inheritDoc */
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        // Default impl.
      }
      get distance() {
        try {
          return distanceTo(this.getPathStartPoint(), this.getPathEndPoint());
        } catch (_unused) {
          return 0;
        }
      }
      get overflyTermFix() {
        return false;
      }
      get initialLegTermPoint() {
        return this.getPathEndPoint();
      }
    }

    const tan$3 = input => Math.tan(input * (Math.PI / 180));
    class DmeArcTransition extends Transition {
      constructor(previousLeg, nextLeg) {
        super(previousLeg, nextLeg);
        this.previousLeg = previousLeg;
        this.nextLeg = nextLeg;
        _defineProperty$2(this, "predictedPath", []);
        _defineProperty$2(this, "radius", void 0);
        _defineProperty$2(this, "itp", void 0);
        _defineProperty$2(this, "centre", void 0);
        _defineProperty$2(this, "ftp", void 0);
        _defineProperty$2(this, "sweepAngle", void 0);
        _defineProperty$2(this, "clockwise", void 0);
      }
      getPathStartPoint() {
        return this.itp;
      }
      getPathEndPoint() {
        return this.ftp;
      }
      recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
        if (this.isFrozen) {
          return;
        }
        this.radius = gs ** 2 / (9.81 * tan$3(maxBank(tas, true))) / 6080.2;
        if (this.previousLeg instanceof AFLeg) {
          const turnDirection = Math.sign(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
          const nextLegReference = this.nextLeg.getPathStartPoint(); // FIXME FX legs
          const reference = placeBearingDistance(nextLegReference, this.nextLeg.inboundCourse + 90 * turnDirection, this.radius);
          const dme = this.previousLeg.centre;
          const turnCentre = closestSmallCircleIntersection(dme, this.previousLeg.radius + this.radius * turnDirection * -this.previousLeg.turnDirectionSign, reference, this.nextLeg.inboundCourse - 180);
          if (!turnCentre) {
            throw new Error('AFLeg did not intersect with previous leg offset reference');
          }
          this.centre = turnCentre;
          this.itp = placeBearingDistance(turnCentre, turnDirection * -this.previousLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
          this.ftp = placeBearingDistance(turnCentre, this.nextLeg.inboundCourse - 90 * turnDirection, this.radius);
          this.sweepAngle = MathUtils.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
          this.clockwise = this.sweepAngle > 0;
          this.predictedPath.length = 0;
          this.predictedPath.push({
            type: PathVectorType.Arc,
            startPoint: this.itp,
            centrePoint: turnCentre,
            endPoint: this.ftp,
            sweepAngle: this.sweepAngle
          });
          this.isComputed = true;
        } else if (this.nextLeg instanceof AFLeg) {
          const turnDirection = Math.sign(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
          const reference = placeBearingDistance(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse + 90 * turnDirection, this.radius);
          const dme = this.nextLeg.centre;
          let turnCentre;
          if (this.previousLeg instanceof XFLeg && !(this.previousLeg instanceof AFLeg)) {
            const intersection = closestSmallCircleIntersection(dme, this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign, reference, this.previousLeg.outboundCourse);
            if (intersection) {
              turnCentre = intersection;
              this.itp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse - 90 * turnDirection, this.radius);
              this.ftp = placeBearingDistance(turnCentre, turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
            } else {
              this.ftp = placeBearingDistance(dme, this.nextLeg.boundaryRadial, this.nextLeg.radius);
              const turnSign = turnDirection > 0 ? 1 : -1;
              turnCentre = placeBearingDistance(this.ftp, Avionics.Utils.clampAngle(this.nextLeg.boundaryRadial + (turnSign > 0 ? 180 : 0)), this.radius);
              this.itp = placeBearingDistance(turnCentre, Avionics.Utils.clampAngle(this.previousLeg.outboundCourse - turnSign * 90), this.radius);
            }
          } else {
            turnCentre = closestSmallCircleIntersection(dme, this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign, reference, this.previousLeg.outboundCourse);
            if (!turnCentre) {
              throw new Error('AFLeg did not intersect with previous leg offset reference');
            }
            this.itp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse - 90 * turnDirection, this.radius);
            this.ftp = placeBearingDistance(turnCentre, turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
          }
          this.centre = turnCentre;
          this.sweepAngle = MathUtils.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
          this.clockwise = this.sweepAngle > 0;
          this.predictedPath.length = 0;
          this.predictedPath.push({
            type: PathVectorType.Arc,
            startPoint: this.itp,
            centrePoint: turnCentre,
            endPoint: this.ftp,
            sweepAngle: this.sweepAngle
          });
          this.isComputed = true;
        }
      }
      addDebugPoints() {
        if (this.itp && this.centre && this.ftp) {
          this.predictedPath.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.itp,
            annotation: 'DME TRANS ITP'
          }, {
            type: PathVectorType.DebugPoint,
            startPoint: this.centre,
            annotation: 'DME TRANS C'
          }, {
            type: PathVectorType.DebugPoint,
            startPoint: this.ftp,
            annotation: 'DME TRANS FTP'
          });
        }
      }
      getTurningPoints() {
        return [this.itp, this.ftp];
      }
      get distance() {
        return pathVectorLength(this.predictedPath[0]); // FIXME HAX
      }

      get startsInCircularArc() {
        return true;
      }
      get endsInCircularArc() {
        return true;
      }
      getNominalRollAngle(gs) {
        const gsMs = gs * (463 / 900);
        return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
      }
      getGuidanceParameters(ppos, trueTrack) {
        return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
      }
      getDistanceToGo(ppos) {
        return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
      }
      isAbeam(ppos) {
        const turningPoints = this.getTurningPoints();
        if (!turningPoints) {
          return false;
        }
        const [inbound, outbound] = turningPoints;
        const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
        const inHeadingAc = Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
        const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
        const outHeadingAc = Math.abs(MathUtils.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
        return inHeadingAc <= 90 && outHeadingAc >= 90;
      }
      get repr() {
        return "DME(".concat(this.previousLeg.repr, ", ").concat(this.nextLeg.repr, ")");
      }
    }

    // Copyright (c) 2021-2022 FlyByWire Simulations
    class XFLeg extends Leg {
      constructor(fix) {
        super();
        this.fix = fix;
      }
      getPathEndPoint() {
        if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
          return this.outboundGuidable.getPathStartPoint();
        }
        if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
          return this.outboundGuidable.getPathStartPoint();
        }
        return this.fix.infos.coordinates;
      }
      get terminationWaypoint() {
        return this.fix;
      }
      get ident() {
        return this.fix.ident;
      }
      get overflyTermFix() {
        return this.metadata.isOverfly;
      }

      /**
       * Returns `true` if the inbound transition has overshot the leg
       */
      get overshot() {
        const side = sideOfPointOnCourseToFix(this.fix.infos.coordinates, this.outboundCourse, this.getPathStartPoint());
        return side === PointSide.After;
      }
      get distanceToTermination() {
        const startPoint = this.getPathStartPoint();
        if (this.overshot) {
          return 0;
        }
        return distanceTo(startPoint, this.fix.infos.coordinates);
      }
    }

    class AFLeg extends XFLeg {
      constructor(fix, navaid, rho, theta, boundaryRadial, metadata, segment) {
        super(fix);
        this.navaid = navaid;
        this.rho = rho;
        this.theta = theta;
        this.boundaryRadial = boundaryRadial;
        this.metadata = metadata;
        _defineProperty$2(this, "predictedPath", []);
        _defineProperty$2(this, "centre", void 0);
        _defineProperty$2(this, "terminationRadial", void 0);
        _defineProperty$2(this, "bearing", void 0);
        _defineProperty$2(this, "arcStartPoint", void 0);
        _defineProperty$2(this, "arcEndPoint", void 0);
        _defineProperty$2(this, "radius", void 0);
        _defineProperty$2(this, "sweepAngle", void 0);
        _defineProperty$2(this, "clockwise", void 0);
        _defineProperty$2(this, "inboundCourse", void 0);
        _defineProperty$2(this, "outboundCourse", void 0);
        this.segment = segment;
        this.centre = navaid;
        this.radius = distanceTo(navaid, this.fix.infos.coordinates);
        this.terminationRadial = this.theta;
        this.bearing = Avionics.Utils.clampAngle(bearingTo(this.centre, this.fix.infos.coordinates) + 90 * this.turnDirectionSign);
        this.arcStartPoint = placeBearingDistance(this.centre, this.boundaryRadial, this.radius);
        this.arcEndPoint = placeBearingDistance(this.centre, this.terminationRadial, this.radius);
        this.inboundCourse = this.boundaryRadial + 90 * this.turnDirectionSign;
        this.outboundCourse = this.terminationRadial + 90 * this.turnDirectionSign;
      }
      getPathStartPoint() {
        return this.inboundGuidable instanceof DmeArcTransition ? this.inboundGuidable.getPathEndPoint() : this.arcStartPoint;
      }
      getPathEndPoint() {
        if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
          return this.outboundGuidable.getPathStartPoint();
        }
        return this.arcEndPoint;
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        this.sweepAngle = MathUtils.diffAngle(bearingTo(this.centre, this.getPathStartPoint()), bearingTo(this.centre, this.getPathEndPoint()));
        this.clockwise = this.sweepAngle > 0;

        // We do not consider the path capture end point in this class' getPathEndPoint since that causes a race condition with the path capture
        // finding its intercept point onto this leg
        const startPoint = this.inboundGuidable instanceof PathCaptureTransition ? this.inboundGuidable.getPathEndPoint() : this.getPathStartPoint();
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: PathVectorType.Arc,
          startPoint,
          centrePoint: this.centre,
          endPoint: this.getPathEndPoint(),
          sweepAngle: this.sweepAngle
        });
      }
      get turnDirectionSign() {
        if (this.fix.turnDirection !== TurnDirection.Right && this.fix.turnDirection !== TurnDirection.Left) {
          throw new Error('AFLeg found without specific turnDirection');
        }
        return this.fix.turnDirection === TurnDirection.Left ? -1 : 1;
      }
      get startsInCircularArc() {
        return true;
      }
      get endsInCircularArc() {
        return true;
      }
      getNominalRollAngle(gs) {
        const gsMs = gs * (463 / 900);
        return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
      }
      getGuidanceParameters(ppos, trueTrack) {
        return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
      }
      getDistanceToGo(ppos) {
        return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
      }
      isAbeam(ppos) {
        const bearingPpos = Avionics.Utils.computeGreatCircleHeading(this.centre, ppos);
        const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.centre, this.getPathStartPoint());
        const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
        return trackAngleError >= 0;
      }
      get repr() {
        return "AF(".concat(this.radius.toFixed(1), "NM) TO ").concat(this.fix.ident);
      }
    }

    class TFLeg extends XFLeg {
      constructor(from, to, metadata, segment) {
        super(to);
        this.metadata = metadata;
        _defineProperty$2(this, "from", void 0);
        _defineProperty$2(this, "to", void 0);
        _defineProperty$2(this, "constraintType", void 0);
        _defineProperty$2(this, "course", void 0);
        _defineProperty$2(this, "computedPath", []);
        this.from = from;
        this.to = to;
        this.segment = segment;
        this.constraintType = to.constraintType;
        this.course = Avionics.Utils.computeGreatCircleHeading(this.from.infos.coordinates, this.to.infos.coordinates);
      }
      get inboundCourse() {
        return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
      }
      get outboundCourse() {
        return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
      }
      get predictedPath() {
        return this.computedPath;
      }
      getPathStartPoint() {
        var _this$inboundGuidable;
        return (_this$inboundGuidable = this.inboundGuidable) !== null && _this$inboundGuidable !== void 0 && _this$inboundGuidable.isComputed ? this.inboundGuidable.getPathEndPoint() : this.from.infos.coordinates;
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        const startPoint = this.getPathStartPoint();
        const endPoint = this.getPathEndPoint();
        this.computedPath.length = 0;
        if (this.overshot) {
          this.computedPath.push({
            type: PathVectorType.Line,
            startPoint: endPoint,
            endPoint
          });
        } else {
          this.computedPath.push({
            type: PathVectorType.Line,
            startPoint,
            endPoint
          });
        }
        this.isComputed = true;
      }
      getPseudoWaypointLocation(distanceBeforeTerminator) {
        return getIntermediatePoint(this.getPathStartPoint(), this.getPathEndPoint(), (this.distance - distanceBeforeTerminator) / this.distance);
      }
      getGuidanceParameters(ppos, trueTrack) {
        return fixToFixGuidance(ppos, trueTrack, this.from.infos.coordinates, this.to.infos.coordinates);
      }
      getNominalRollAngle(_gs) {
        return 0;
      }

      /**
       * Calculates the angle between the leg and the aircraft PPOS.
       *
       * This effectively returns the angle ABC in the figure shown below:
       *
       * ```
       * * A
       * |
       * * B (TO)
       * |\
       * | \
       * |  \
       * |   \
       * |    \
       * |     \
       * |      \
       * * FROM  * C (PPOS)
       * ```
       *
       * @param ppos {LatLong} the current position of the aircraft
       */
      getAircraftToLegBearing(ppos) {
        const aircraftToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(ppos, this.to.infos.coordinates);
        const aircraftLegBearing = MathUtils.smallCrossingAngle(this.outboundCourse, aircraftToTerminationBearing);
        return aircraftLegBearing;
      }
      getDistanceToGo(ppos) {
        return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      }
      isAbeam(ppos) {
        const bearingAC = Avionics.Utils.computeGreatCircleHeading(this.from.infos.coordinates, ppos);
        const headingAC = Math.abs(MathUtils.diffAngle(this.inboundCourse, bearingAC));
        if (headingAC > 90) {
          // if we're even not abeam of the starting point
          return false;
        }
        const distanceAC = Avionics.Utils.computeDistance(this.from.infos.coordinates, ppos);
        const distanceAX = Math.cos(headingAC * Avionics.Utils.DEG2RAD) * distanceAC;
        // if we're too far away from the starting point to be still abeam of the ending point
        return distanceAX <= this.distance;
      }
      get repr() {
        return "TF FROM ".concat(this.from.ident, " TO ").concat(this.to.ident);
      }
    }

    const sin = input => Math.sin(input * (Math.PI / 180));
    const asin = input => Math.asin(input) * (180 / Math.PI);
    class Geo {
      static computeDestinationPoint(start, distance, bearing) {
        let radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371000;
        // FIXME rm -f geolib ?
        const a = es.computeDestinationPoint(_objectSpread2(_objectSpread2({}, start), {}, {
          lon: start.long
        }), distance * 1852, bearing, radius);
        return {
          lat: a.latitude,
          long: a.longitude
        };
      }
      static distanceToLeg(from, leg) {
        const intersections1 = placeBearingIntersection(from, Avionics.Utils.clampAngle(leg.outboundCourse - 90), leg.initialLegTermPoint, Avionics.Utils.clampAngle(leg.outboundCourse - 180));
        const d1 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[0]);
        const d2 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[1]);
        let legStartReference;
        if (leg instanceof TFLeg) {
          legStartReference = leg.from.infos.coordinates;
        } else {
          legStartReference = leg.getPathStartPoint();
        }

        // We might call this on legs that do not have a defined start point yet, as it depends on their inbound transition, which is what is passing
        // them in to this function.
        // In that case, do not consider the second intersection set.
        if (!legStartReference) {
          return Math.min(d1, d2);
        }
        const intersections2 = placeBearingIntersection(from, Avionics.Utils.clampAngle(leg.outboundCourse - 90), legStartReference, Avionics.Utils.clampAngle(leg.outboundCourse - 180));
        const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
        const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
        return Math.min(d1, d2, d3, d4);
      }
      static legIntercept(from, bearing, leg) {
        if (leg instanceof AFLeg) {
          const intersections = smallCircleGreatCircleIntersection(leg.centre, leg.radius, from, bearing);
          const d1 = Avionics.Utils.computeGreatCircleDistance(from, intersections[0]);
          const d2 = Avionics.Utils.computeGreatCircleDistance(from, intersections[1]);
          return d1 > d2 ? intersections[1] : intersections[0];
        }
        if (leg.getPathEndPoint() === undefined || leg.outboundCourse === undefined) {
          throw new Error('[FMS/LNAV] Cannot compute leg intercept if leg end point or outbound course are undefined');
        }
        const intersections1 = placeBearingIntersection(from, Avionics.Utils.clampAngle(bearing), 'fix' in leg ? leg.fix.infos.coordinates : leg.getPathEndPoint(), Avionics.Utils.clampAngle(leg.outboundCourse - 180));
        const d1 = distanceTo(from, intersections1[0]);
        const d2 = distanceTo(from, intersections1[1]);

        // We might call this on legs that do not have a defined start point yet, as it depends on their inbound transition, which is what is passing
        // them in to this function.
        // In that case, do not consider the second intersection set.
        if (!leg.getPathStartPoint()) {
          return d1 > d2 ? intersections1[1] : intersections1[0];
        }
        const intersections2 = placeBearingIntersection(from, Avionics.Utils.clampAngle(bearing), leg.getPathStartPoint(), Avionics.Utils.clampAngle(leg.outboundCourse - 180));
        const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
        const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
        const smallest = Math.min(d1, d2, d3, d4);
        if (smallest === d1) {
          return intersections1[0];
        }
        if (smallest === d2) {
          return intersections1[1];
        }
        if (smallest === d3) {
          return intersections2[0];
        }
        return intersections2[1];
      }
      static placeBearingPlaceDistanceIntercept(bearingPoint, distancePoint, bearing, distance) {
        const relativeBearing = bearingTo(bearingPoint, distancePoint);
        const distanceBetween = distanceTo(bearingPoint, distancePoint);
        const angleA = Math.abs(MathUtils.diffAngle(relativeBearing, bearing));
        const angleC = angleA > 90 ? asin(distanceBetween * (sin(angleA) / distance)) : 180 - asin(distanceBetween * (sin(angleA) / distance));
        const angleB = 180 - angleA - angleC;
        return placeBearingDistance(bearingPoint, bearing, Math.abs(sin(angleB) * (distance / sin(angleA))));
      }
      static doublePlaceBearingIntercept(pointA, pointB, bearingA, bearingB) {
        return B77HS_Util.greatCircleIntersection(pointA, bearingA, pointB, bearingB);
      }
    }

    // Copyright (c) 2021-2022 FlyByWire Simulations
    // Copyright (c) 2021-2022 Synaptic Simulations
    //
    // SPDX-License-Identifier: GPL-3.0

    /**
     * Functions for figuring out an appropriate course change for leg captures
     */
    class CourseChange {
      static normal(turnDirection, turnCenterDistance, trackChange, radius) {
        if (turnDirection > 0) {
          if (turnCenterDistance >= radius) {
            return trackChange - 45;
          }
          return trackChange + 45;
        }
        if (-turnCenterDistance >= radius) {
          return trackChange + 45;
        }
        return trackChange - 45;
      }
      static reverse(turnDirection, turnCenterDistance, trackChange, radius) {
        if (trackChange > 0) {
          if (turnCenterDistance > 0) {
            if (turnCenterDistance > radius) {
              return trackChange - 45;
            }
            return trackChange + 45;
          }
          return trackChange + 45;
        }
        if (turnCenterDistance > 0) {
          return trackChange - 45;
        }
        if (-turnCenterDistance > radius) {
          return trackChange + 45;
        }
        return trackChange - 45;
      }
      static acuteFar(turnDirection, turnCenterDistance, trackChange) {
        return turnDirection * (45 - Math.abs(trackChange));
      }
      static acuteNear(turnDirection, turnCenterDistance, trackChange) {
        return trackChange + (turnDirection > 0 ? 45 : -45);
      }
    }

    // Copyright (c) 2021-2022 FlyByWire Simulations
    class IFLeg extends XFLeg {
      constructor(fix, metadata, segment) {
        super(fix);
        this.metadata = metadata;
        this.segment = segment;
      }
      get predictedPath() {
        return [];
      }
      getPathStartPoint() {
        return this.fix.infos.coordinates;
      }
      getPathEndPoint() {
        return this.fix.infos.coordinates;
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        this.isComputed = true;
      }

      /** @inheritdoc */
      setNeighboringGuidables(inbound, outbound) {
        if (outbound && !(outbound instanceof Leg) && outbound !== this.outboundGuidable) {
          console.error("IF outboundGuidable must be a leg (is ".concat(outbound === null || outbound === void 0 ? void 0 : outbound.constructor, ")"));
        }
        super.setNeighboringGuidables(inbound, outbound);
      }
      get inboundCourse() {
        return undefined;
      }
      get outboundCourse() {
        return undefined;
      }
      get distance() {
        return 0;
      }
      getDistanceToGo(_ppos) {
        return undefined;
      }
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        var _this$outboundGuidabl, _this$outboundGuidabl2;
        return (_this$outboundGuidabl = (_this$outboundGuidabl2 = this.outboundGuidable) === null || _this$outboundGuidabl2 === void 0 ? void 0 : _this$outboundGuidabl2.getGuidanceParameters(ppos, trueTrack, tas, gs)) !== null && _this$outboundGuidabl !== void 0 ? _this$outboundGuidabl : undefined;
      }
      getNominalRollAngle(_gs) {
        return undefined;
      }
      getPseudoWaypointLocation(_distanceBeforeTerminator) {
        return undefined;
      }
      isAbeam(_ppos) {
        return false;
      }
      get repr() {
        return "IF AT ".concat(this.fix.ident);
      }
    }

    class CFLeg extends XFLeg {
      constructor(fix, course, metadata, segment) {
        super(fix);
        this.course = course;
        this.metadata = metadata;
        _defineProperty$2(this, "computedPath", []);
        this.segment = segment;
      }
      getPathStartPoint() {
        if (this.inboundGuidable instanceof IFLeg) {
          return this.inboundGuidable.fix.infos.coordinates;
        }
        if (this.inboundGuidable instanceof Transition && this.inboundGuidable.isComputed) {
          return this.inboundGuidable.getPathEndPoint();
        }
        if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
          return this.outboundGuidable.getPathStartPoint();
        }

        // Estimate where we should start the leg
        return this.estimateStartWithoutInboundTransition();
      }

      /**
       * Based on FBW-22-07
       *
       * @private
       */
      estimateStartWithoutInboundTransition() {
        const inverseCourse = Avionics.Utils.clampAngle(this.course + 180);
        if (this.inboundGuidable && this.inboundGuidable.isComputed) {
          const prevLegTerm = this.inboundGuidable.getPathEndPoint();
          return Geo.doublePlaceBearingIntercept(this.getPathEndPoint(), prevLegTerm, inverseCourse, Avionics.Utils.clampAngle(inverseCourse + 90));
        }

        // We start the leg at (tad + 0.1) from the fix if we have a fixed radius transition outbound. This allows showing a better looking path after sequencing.
        let distance = 1;
        if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
          distance = this.outboundGuidable.tad + 0.1;
        }
        return Avionics.Utils.bearingDistanceToCoordinates(inverseCourse, distance, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
      }
      get predictedPath() {
        return this.computedPath;
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        // Is start point after the fix ?
        if (this.overshot) {
          this.computedPath = [{
            type: PathVectorType.Line,
            startPoint: this.getPathEndPoint(),
            endPoint: this.getPathEndPoint()
          }];
        } else {
          this.computedPath = [{
            type: PathVectorType.Line,
            startPoint: this.getPathStartPoint(),
            endPoint: this.getPathEndPoint()
          }];
        }
        this.isComputed = true;
      }
      get inboundCourse() {
        return this.course;
      }
      get outboundCourse() {
        return this.course;
      }
      getDistanceToGo(ppos) {
        return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      }
      getGuidanceParameters(ppos, trueTrack, _tas) {
        return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
      }
      getNominalRollAngle(_gs) {
        return 0;
      }
      isAbeam(ppos) {
        const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
        return dtg >= 0 && dtg <= this.distance;
      }
      get repr() {
        return "CF(".concat(this.course.toFixed(1), "T) TO ").concat(this.fix.ident);
      }
    }

    var PiState;
    (function (PiState) {
      PiState[PiState["Straight"] = 0] = "Straight";
      PiState[PiState["Turn1"] = 1] = "Turn1";
      PiState[PiState["Outbound"] = 2] = "Outbound";
      PiState[PiState["Turn2"] = 3] = "Turn2";
      PiState[PiState["Intercept"] = 4] = "Intercept";
    })(PiState || (PiState = {}));
    class PILeg extends Leg {
      constructor(fix, nextLeg, metadata, segment) {
        super();
        this.fix = fix;
        this.nextLeg = nextLeg;
        this.metadata = metadata;
        this.segment = segment;
        _defineProperty$2(this, "radius", 1);
        _defineProperty$2(this, "straight", {});
        _defineProperty$2(this, "turn1", {});
        _defineProperty$2(this, "outbound", {});
        _defineProperty$2(this, "turn2", {});
        _defineProperty$2(this, "intercept", {});
        _defineProperty$2(this, "state", PiState.Straight);
        _defineProperty$2(this, "debugPoints", []);
        this.recomputeWithParameters(false, 220, 220, {
          lat: 0,
          long: 0
        }, 0);
      }
      recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
        if (isActive) {
          return;
        }
        if (this.nextLeg && !(this.nextLeg instanceof CFLeg)) {
          throw new Error('PI must be followed by CF!');
        } else if (!this.nextLeg) {
          return;
        }
        this.debugPoints.length = 0;
        const turn1Sign = this.fix.turnDirection === TurnDirection.Left ? 1 : -1;
        const turn2Sign = -1 * turn1Sign;
        const gsMs = gs / 1.94384;
        this.radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(tas, true) * Math.PI / 180)) / 1852;
        const minStraightDist = this.radius * 2;
        const brgToCf = Avionics.Utils.computeGreatCircleHeading(this.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates);
        const distToCf = Avionics.Utils.computeGreatCircleDistance(this.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates);
        const cfInverseCrs = (this.nextLeg.course + 180) % 360;
        this.outbound.course = this.fix.additionalData.course;
        this.straight.itp = this.fix.infos.coordinates;
        this.straight.course = cfInverseCrs;
        let tp;
        if (Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, brgToCf)) < 90 && distToCf > minStraightDist) {
          tp = this.nextLeg.fix.infos.coordinates;
        } else {
          // find an intercept on the CF at min dist
          [tp] = smallCircleGreatCircleIntersection(this.fix.infos.coordinates, minStraightDist, this.nextLeg.fix.infos.coordinates, cfInverseCrs).filter(p => Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, bearingTo(this.nextLeg.fix.infos.coordinates, p))) < 90);
          this.straight.course = Avionics.Utils.computeGreatCircleHeading(this.fix.infos.coordinates, tp);
        }
        this.turn1.sweepAngle = turn1Sign * Math.abs(Avionics.Utils.diffAngle(this.straight.course, this.outbound.course));
        const tpT1FtpDist = this.radius * Math.tan(Math.abs(this.turn1.sweepAngle) * Math.PI / 360);
        this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outbound.course, tpT1FtpDist, tp.lat, tp.long);
        this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn1Sign * 90) % 360, this.radius, this.turn1.ftp.lat, this.turn1.ftp.long);
        this.turn1.itp = Avionics.Utils.bearingDistanceToCoordinates((this.straight.course + 180) % 360, this.radius * (1 - Math.cos(this.turn1.sweepAngle * Math.PI / 180)), tp.lat, tp.long);
        this.turn1.length = Math.abs(this.turn1.sweepAngle / 180 * this.radius);
        this.straight.ftp = this.turn1.itp;
        this.straight.length = Avionics.Utils.computeGreatCircleDistance(this.fix.infos.coordinates, this.turn1.itp);
        const theta = Math.abs(Avionics.Utils.diffAngle(this.outbound.course, (this.nextLeg.course + 180) % 360)) * Math.PI / 180;
        this.outbound.length = this.radius * (1 / Math.tan(theta / 2));
        this.outbound.itp = this.turn1.ftp;
        this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outbound.course, this.outbound.length + tpT1FtpDist, tp.lat, tp.long);
        this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn2Sign * 90) % 360, this.radius, this.turn2.itp.lat, this.turn2.itp.long);
        this.turn2.sweepAngle = turn2Sign * 180;
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn2Sign * 90) % 360, this.radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
        this.turn2.length = Math.abs(this.turn2.sweepAngle / 180 * this.radius);
        this.outbound.ftp = this.turn2.itp;
        this.intercept.itp = this.turn2.ftp;
        this.intercept.ftp = B77HS_Util.greatCircleIntersection(this.turn2.ftp, (this.outbound.course + 180) % 360, tp, cfInverseCrs);
        this.intercept.length = Avionics.Utils.computeGreatCircleDistance(this.intercept.itp, this.intercept.ftp);
        this.intercept.course = Avionics.Utils.computeGreatCircleHeading(this.intercept.itp, this.intercept.ftp);
        this.isComputed = true;
      }
      get initialLegTermPoint() {
        return this.turn1.itp;
      }
      get distanceToTermination() {
        return this.straight.length;
      }
      get distance() {
        return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + this.straight.length;
      }

      /**
       * Do we end up further away from the fix than the coded limit
       */
      get turnAreaExceeded() {
        if (!this.turn2) {
          return false;
        }
        const maxExcursion = distanceTo(this.fix.infos.coordinates, this.turn2.arcCentre) + this.radius;
        return maxExcursion > this.fix.additionalData.distance;
      }
      getDistanceToGo(ppos) {
        switch (this.state) {
          case PiState.Intercept:
            return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);
          case PiState.Turn2:
            return this.intercept.length + arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          case PiState.Outbound:
            return this.intercept.length + this.turn2.length + courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);
          case PiState.Turn1:
            return this.intercept.length + this.turn2.length + this.outbound.length + arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          case PiState.Straight:
            return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);
          default:
            return 1;
        }
      }
      dtgCurrentSegment(ppos) {
        switch (this.state) {
          case PiState.Intercept:
            return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);
          case PiState.Turn2:
            return arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          case PiState.Outbound:
            return courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);
          case PiState.Turn1:
            return arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          case PiState.Straight:
            return courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);
          default:
            return 0;
        }
      }
      radCurrentSegment(tas, gs) {
        const turn1Sign = this.fix.turnDirection === TurnDirection.Left ? 1 : -1;
        const turn2Sign = -1 * turn1Sign;
        let currentBank;
        let nextBank;
        switch (this.state) {
          case PiState.Turn1:
            currentBank = turn1Sign * maxBank(tas, true);
            nextBank = 0;
            break;
          case PiState.Turn2:
            currentBank = turn2Sign * maxBank(tas, true);
            nextBank = 0;
            break;
          case PiState.Straight:
            currentBank = 0;
            nextBank = turn1Sign * maxBank(tas, true);
            break;
          case PiState.Outbound:
            currentBank = 0;
            nextBank = turn2Sign * maxBank(tas, true);
            break;
          default:
            return [0, 0];
        }
        return [Geometry.getRollAnticipationDistance(gs, currentBank, nextBank), nextBank];
      }
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        var _this$nextLeg;
        let dtg = this.dtgCurrentSegment(ppos);
        if (dtg <= 0 && this.state < PiState.Intercept) {
          this.state++;
          dtg = this.dtgCurrentSegment(ppos);
        }
        let params;
        switch (this.state) {
          case PiState.Intercept:
            return (_this$nextLeg = this.nextLeg) === null || _this$nextLeg === void 0 ? void 0 : _this$nextLeg.getGuidanceParameters(ppos, trueTrack, tas);
          case PiState.Turn2:
            return arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          case PiState.Outbound:
            params = courseToFixGuidance(ppos, trueTrack, this.outbound.course, this.outbound.ftp);
            break;
          case PiState.Turn1:
            params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
            break;
          case PiState.Straight:
            params = courseToFixGuidance(ppos, trueTrack, this.straight.course, this.straight.ftp);
            break;
        }
        const [rad, nextBank] = this.radCurrentSegment(tas, gs);
        if (params && rad > 0 && dtg <= rad) {
          params.phiCommand = nextBank;
        }
        return params;
      }
      getNominalRollAngle(_gs) {
        return 0;
      }
      getPathStartPoint() {
        var _this$inboundGuidable;
        return (_this$inboundGuidable = this.inboundGuidable) !== null && _this$inboundGuidable !== void 0 && _this$inboundGuidable.isComputed ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates;
      }
      getPathEndPoint() {
        return this.intercept.ftp;
      }
      get terminationWaypoint() {
        return this.intercept.ftp;
      }
      get inboundCourse() {
        var _this$straight$course;
        return (_this$straight$course = this.straight.course) !== null && _this$straight$course !== void 0 ? _this$straight$course : 0;
      }
      get outboundCourse() {
        var _this$nextLeg$course, _this$nextLeg2;
        return (_this$nextLeg$course = (_this$nextLeg2 = this.nextLeg) === null || _this$nextLeg2 === void 0 ? void 0 : _this$nextLeg2.course) !== null && _this$nextLeg$course !== void 0 ? _this$nextLeg$course : 0;
      }
      isAbeam(_ppos) {
        return true; // TODO y needed
      }

      get predictedPath() {
        var _this$inboundGuidable2;
        return [{
          type: PathVectorType.Line,
          startPoint: (_this$inboundGuidable2 = this.inboundGuidable) !== null && _this$inboundGuidable2 !== void 0 && _this$inboundGuidable2.isComputed ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates,
          endPoint: this.turn1.itp
        }, {
          type: PathVectorType.Arc,
          startPoint: this.turn1.itp,
          centrePoint: this.turn1.arcCentre,
          endPoint: this.turn1.ftp,
          sweepAngle: this.turn1.sweepAngle
        }, {
          type: PathVectorType.Line,
          startPoint: this.turn1.ftp,
          endPoint: this.turn2.itp
        }, {
          type: PathVectorType.Arc,
          startPoint: this.turn2.itp,
          centrePoint: this.turn2.arcCentre,
          endPoint: this.turn2.ftp,
          sweepAngle: this.turn2.sweepAngle
        }, {
          type: PathVectorType.Line,
          startPoint: this.turn2.ftp,
          endPoint: this.intercept.ftp
        }, ...this.debugPoints];
      }
      get ident() {
        return 'INTCPT';
      }
      get repr() {
        return "PI ".concat(this.ident);
      }
    }

    let AltitudeConstraintType;

    // TODO at and atOrAbove do not exist in the airbus (former interpreted as atOrBelow, latter discarded)
    (function (AltitudeConstraintType) {
      AltitudeConstraintType[AltitudeConstraintType["at"] = 0] = "at";
      AltitudeConstraintType[AltitudeConstraintType["atOrAbove"] = 1] = "atOrAbove";
      AltitudeConstraintType[AltitudeConstraintType["atOrBelow"] = 2] = "atOrBelow";
      AltitudeConstraintType[AltitudeConstraintType["range"] = 3] = "range";
    })(AltitudeConstraintType || (AltitudeConstraintType = {}));
    let SpeedConstraintType;
    (function (SpeedConstraintType) {
      SpeedConstraintType[SpeedConstraintType["at"] = 0] = "at";
      SpeedConstraintType[SpeedConstraintType["atOrAbove"] = 1] = "atOrAbove";
      SpeedConstraintType[SpeedConstraintType["atOrBelow"] = 2] = "atOrBelow";
    })(SpeedConstraintType || (SpeedConstraintType = {}));
    function getAltitudeConstraintFromWaypoint(wp) {
      if (wp.legAltitudeDescription && wp.legAltitude1) {
        const ac = {};
        ac.altitude1 = wp.legAltitude1;
        ac.altitude2 = undefined;
        switch (wp.legAltitudeDescription) {
          case 1:
            ac.type = AltitudeConstraintType.at;
            break;
          case 2:
            ac.type = AltitudeConstraintType.atOrAbove;
            break;
          case 3:
            ac.type = AltitudeConstraintType.atOrBelow;
            break;
          case 4:
            ac.type = AltitudeConstraintType.range;
            ac.altitude2 = wp.legAltitude2;
            break;
        }
        return ac;
      }
      return undefined;
    }
    function getSpeedConstraintFromWaypoint(wp) {
      if (wp.speedConstraint) {
        const sc = {};
        sc.type = SpeedConstraintType.at;
        sc.speed = wp.speedConstraint;
        return sc;
      }
      return undefined;
    }
    function isHold(leg) {
      return leg instanceof HALeg || leg instanceof HFLeg || leg instanceof HMLeg;
    }
    function isCourseReversalLeg(leg) {
      return isHold(leg) || leg instanceof PILeg;
    }

    /**
     * Geometry and vertical constraints applicable to a leg
     */

    function legMetadataFromMsfsWaypoint(waypoint) {
      const altitudeConstraint = getAltitudeConstraintFromWaypoint(waypoint);
      const speedConstraint = getSpeedConstraintFromWaypoint(waypoint);
      return {
        turnDirection: waypoint.turnDirection,
        altitudeConstraint,
        speedConstraint,
        isOverfly: waypoint.additionalData.overfly
      };
    }

    const cos = input => Math.cos(input * (Math.PI / 180));
    const tan$2 = input => Math.tan(input * MathUtils.DEGREES_TO_RADIANS);
    const compareTurnDirections = (sign, data) => {
      if ((data === TurnDirection.Left || data === TurnDirection.Right) && (sign === -1 || sign === 1)) {
        return data === TurnDirection.Left && sign === -1 || data === TurnDirection.Right && sign === 1;
      }
      return true;
    };

    /**
     * A type II transition
     */
    class PathCaptureTransition extends Transition {
      constructor(previousLeg, nextLeg) {
        super(previousLeg, nextLeg);
        this.previousLeg = previousLeg;
        this.nextLeg = nextLeg;
        _defineProperty$2(this, "startWithTad", false);
        _defineProperty$2(this, "predictedPath", []);
        _defineProperty$2(this, "itp", void 0);
        _defineProperty$2(this, "ftp", void 0);
        _defineProperty$2(this, "tad", void 0);
        _defineProperty$2(this, "forcedTurnComplete", false);
        _defineProperty$2(this, "computedTurnDirection", TurnDirection.Either);
        _defineProperty$2(this, "computedTargetTrack", 0);
        _defineProperty$2(this, "distance", 0);
      }
      getPathStartPoint() {
        return this.itp;
      }
      get turnDirection() {
        return this.nextLeg.metadata.turnDirection;
      }
      get deltaTrack() {
        return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
      }
      recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
        if (this.isFrozen) {
          return;
        }
        if (!(this.inboundGuidable instanceof Leg)) {
          throw new Error('[FMS/Geometry/PathCapture] previousGuidable must be a leg');
        }
        const targetTrack = this.inboundGuidable.outboundCourse;
        const naturalTurnDirectionSign = Math.sign(MathUtils.diffAngle(targetTrack, this.nextLeg.inboundCourse));
        this.computedTurnDirection = TurnDirection.Either;
        this.computedTargetTrack = this.nextLeg.inboundCourse;
        let prevLegTermFix;
        if (this.previousLeg instanceof AFLeg) {
          prevLegTermFix = this.previousLeg.arcEndPoint;
        } else {
          prevLegTermFix = this.previousLeg.terminationWaypoint instanceof WayPoint ? this.previousLeg.terminationWaypoint.infos.coordinates : this.previousLeg.terminationWaypoint;
        }

        // Start the transition before the termination fix if we are reverted because of an overshoot
        let initialTurningPoint;
        if (this.startWithTad) {
          const prevLegDistanceToTerm = this.previousLeg.distanceToTermination;
          this.tad = Math.min(maxTad(tas), prevLegDistanceToTerm - 0.05);

          // If we are inbound of a TF leg, we use getIntermediatePoint in order to get more accurate results
          if ('from' in this.previousLeg) {
            const start = this.previousLeg.from.infos.coordinates;
            const end = this.previousLeg.to.infos.coordinates;
            const length = distanceTo(start, end);
            const ratio = (length - this.tad) / length;
            initialTurningPoint = getIntermediatePoint(start, end, ratio);
          } else {
            initialTurningPoint = placeBearingDistance(prevLegTermFix, reciprocal(this.previousLeg.outboundCourse), this.tad);
          }
        } else {
          this.tad = 0;
          initialTurningPoint = prevLegTermFix;
        }
        const distanceFromItp = Geo.distanceToLeg(initialTurningPoint, this.nextLeg);
        // for some legs the turn direction is not for forced turn onto the leg
        const desiredDirection = isCourseReversalLeg(this.nextLeg) ? TurnDirection.Either : this.nextLeg.metadata.turnDirection;
        const deltaTrack = MathUtils.diffAngle(targetTrack, this.nextLeg.inboundCourse, desiredDirection);
        this.predictedPath.length = 0;
        if (Math.abs(deltaTrack) < 3 && distanceFromItp < 0.1) {
          this.itp = this.previousLeg.getPathEndPoint();
          this.ftp = this.previousLeg.getPathEndPoint();
          this.predictedPath.push({
            type: PathVectorType.Line,
            startPoint: this.previousLeg.getPathEndPoint(),
            endPoint: this.previousLeg.getPathEndPoint()
          });
          this.isNull = true;
          this.distance = 0;
          this.isComputed = true;
          return;
        }
        this.isNull = false;

        // If track change is very similar to a 45 degree intercept, we do a direct intercept
        if (Math.abs(deltaTrack) > 42 && Math.abs(deltaTrack) < 48 && distanceFromItp > 0.01) {
          this.computeDirectIntercept();
          this.isComputed = true;
          return;
        }
        let turnDirection = Math.sign(deltaTrack);

        // Theta variable should be stored based on turn direction and max roll, but it is only used once in an absolute sense, so it is useless
        const radius = gs ** 2 / (Constants.G * tan$2(maxBank(tas, true)) * 6997.84) * LnavConfig.TURN_RADIUS_FACTOR;
        const distanceLimit = radius * cos(48);

        // TODO: Turn center is slightly off for some reason, fix
        let turnCenter = placeBearingDistance(initialTurningPoint, targetTrack + turnDirection * 90, radius);
        let turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
        let courseChange;
        if (Math.abs(deltaTrack) < 45) {
          if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
            turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
            turnDirection = -turnDirection;
            // Turn direction is to be flipped, FBW-22-05
            turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
            courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
          } else {
            courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
          }
        } else if (Math.abs(deltaTrack) >= 45 && !compareTurnDirections(turnDirection, this.nextLeg.metadata.turnDirection)) {
          turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
          turnDirection = -turnDirection;
          turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
        }

        // Omit 45 degree intercept segment if possible
        if (distanceLimit <= Math.abs(turnCenterDistance) && Math.abs(turnCenterDistance) < radius) {
          const radiusToLeg = radius - Math.abs(turnCenterDistance);
          let intercept;

          // If we are inbound of a TF leg, we use the TF leg ref fix for our small circle intersect in order to get
          // more accurate results
          if ('from' in this.nextLeg) {
            const intersects = smallCircleGreatCircleIntersection(turnCenter, radius, this.nextLeg.from.infos.coordinates, this.nextLeg.outboundCourse);
            if (intersects) {
              const [one, two] = intersects;
              if (distanceTo(initialTurningPoint, one) > distanceTo(initialTurningPoint, two)) {
                intercept = one;
              } else {
                intercept = two;
              }
            }
          } else {
            intercept = firstSmallCircleIntersection(turnCenter, radius, this.nextLeg.getPathEndPoint(), reciprocal(this.nextLeg.outboundCourse));
          }

          // If the difference between the radius and turnCenterDistance is very small, we might not find an intercept using the circle.
          // Do a direct intercept instead.
          if (!intercept && radiusToLeg < 0.1) {
            this.computeDirectIntercept();
            this.isComputed = true;
            return;
          }
          if (intercept && !Number.isNaN(intercept.lat)) {
            const bearingTcFtp = bearingTo(turnCenter, intercept);
            const angleToLeg = MathUtils.diffAngle(Avionics.Utils.clampAngle(bearingTcFtp - (turnDirection > 0 ? -90 : 90)), this.nextLeg.outboundCourse);
            if (Math.abs(angleToLeg) <= 48) {
              this.itp = initialTurningPoint;
              this.ftp = intercept;
              this.predictedPath.push({
                type: PathVectorType.Arc,
                startPoint: initialTurningPoint,
                endPoint: intercept,
                centrePoint: turnCenter,
                sweepAngle: Math.abs(deltaTrack) * turnDirection
              });
              this.distance = arcLength(radius, Math.abs(deltaTrack) * turnDirection);
              this.isComputed = true;
              return;
            }
          }
        }
        if (Math.abs(deltaTrack) < 45) {
          if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
            courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
          } else {
            courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
          }
        } else {
          const isReverse = !compareTurnDirections(naturalTurnDirectionSign, this.nextLeg.metadata.turnDirection);
          if (isReverse) {
            courseChange = CourseChange.reverse(turnDirection, turnCenterDistance, deltaTrack, radius);
            this.computedTurnDirection = this.nextLeg.metadata.turnDirection;
          } else {
            courseChange = CourseChange.normal(turnDirection, turnCenterDistance, deltaTrack, radius);
            this.computedTurnDirection = turnDirection < 0 ? TurnDirection.Left : TurnDirection.Right;
          }
        }
        this.computedTargetTrack = (360 + this.previousLeg.outboundCourse + courseChange) % 360;
        const finalTurningPoint = placeBearingDistance(turnCenter, targetTrack + courseChange - 90 * turnDirection, radius);
        let intercept;

        // If we are inbound of a TF leg, we use the TF leg FROM ref fix for our great circle intersect in order to get
        // more accurate results
        if ('from' in this.nextLeg) {
          const intersections = placeBearingIntersection(finalTurningPoint, Avionics.Utils.clampAngle(targetTrack + courseChange), this.nextLeg.from.infos.coordinates, this.nextLeg.outboundCourse);
          if (intersections) {
            const [one, two] = intersections;
            if (distanceTo(finalTurningPoint, one) < distanceTo(finalTurningPoint, two)) {
              intercept = one;
            } else {
              intercept = two;
            }
          }
        } else {
          intercept = Geo.legIntercept(finalTurningPoint, targetTrack + courseChange, this.nextLeg);
        }
        const overshot = sideOfPointOnCourseToFix(finalTurningPoint, targetTrack + courseChange, intercept) === PointSide.Before;
        this.itp = initialTurningPoint;
        this.ftp = finalTurningPoint;
        this.isComputed = true;
        this.predictedPath.push({
          type: PathVectorType.Arc,
          startPoint: initialTurningPoint,
          endPoint: finalTurningPoint,
          centrePoint: turnCenter,
          sweepAngle: courseChange
        });
        if (!overshot) {
          this.predictedPath.push({
            type: PathVectorType.Line,
            startPoint: finalTurningPoint,
            endPoint: intercept
          });
        }
        this.distance = arcLength(radius, courseChange) + (overshot ? 0 : distanceTo(finalTurningPoint, intercept));
      }

      /**
       * Computes the path capture as a direct leg intercept from the previous leg path end point to the next leg,
       * with previous leg outbound course
       *
       * @private
       */
      computeDirectIntercept() {
        const intercept = Geo.legIntercept(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse, this.nextLeg);
        this.itp = this.previousLeg.getPathEndPoint();
        this.ftp = intercept;
        this.predictedPath.push({
          type: PathVectorType.Line,
          startPoint: this.previousLeg.getPathEndPoint(),
          endPoint: intercept
        });
        this.distance = distanceTo(this.previousLeg.getPathEndPoint(), intercept);
      }
      get startsInCircularArc() {
        return false; // We don't want to do RAD for path captures
      }

      get endsInCircularArc() {
        return false; // We don't want to do RAD for path captures
      }

      isAbeam(ppos) {
        return !this.isNull && this.computedTurnDirection !== TurnDirection.Either && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
      }
      getTurningPoints() {
        return [this.itp, this.ftp];
      }
      getDistanceToGo(_ppos) {
        return 1;
      }
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        if (this.computedTurnDirection !== TurnDirection.Either) {
          const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
          let trackAngleError = this.computedTargetTrack - trueTrack;
          if (turnSign !== Math.sign(trackAngleError)) {
            trackAngleError += turnSign * 360;
          }
          if (Math.abs(trackAngleError) > 130) {
            const phiCommand = turnSign * maxBank(tas, true);
            return {
              law: ControlLaw.LATERAL_PATH,
              trackAngleError: 0,
              phiCommand,
              crossTrackError: 0
            };
          }
          this.forcedTurnComplete = true;
        }
        return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
      }
      getNominalRollAngle(_gs) {
        return 0;
      }
      get repr() {
        return "PATH CAPTURE(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
      }
    }

    class CILeg extends Leg {
      constructor(course, nextLeg, metadata, segment) {
        super();
        this.course = course;
        this.nextLeg = nextLeg;
        this.metadata = metadata;
        _defineProperty$2(this, "computedPath", []);
        _defineProperty$2(this, "intercept", undefined);
        this.segment = segment;
      }
      get terminationWaypoint() {
        return this.intercept;
      }
      get distanceToTermFix() {
        return Avionics.Utils.computeGreatCircleDistance(this.getPathStartPoint(), this.intercept);
      }
      get ident() {
        return 'INTCPT';
      }
      getPathStartPoint() {
        if (this.inboundGuidable instanceof IFLeg) {
          return this.inboundGuidable.fix.infos.coordinates;
        }
        if (this.inboundGuidable && this.inboundGuidable.isComputed) {
          return this.inboundGuidable.getPathEndPoint();
        }
        throw new Error('[CILeg] No computed inbound guidable.');
      }
      getPathEndPoint() {
        if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
          return this.outboundGuidable.getPathStartPoint();
        }
        if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
          return this.outboundGuidable.getPathStartPoint();
        }
        return this.intercept;
      }
      get predictedPath() {
        return this.computedPath;
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        this.intercept = Geo.legIntercept(this.getPathStartPoint(), this.course, this.nextLeg);
        const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
        const overshot = side === PointSide.After;
        if (this.intercept && !Number.isNaN(this.intercept.lat) && !overshot) {
          this.isNull = false;
          this.computedPath = [{
            type: PathVectorType.Line,
            startPoint: this.getPathStartPoint(),
            endPoint: this.getPathEndPoint()
          }];
          this.isComputed = true;
        } else {
          this.computedPath.length = 0;
          this.isNull = true;
          this.isComputed = true;
        }
      }
      get inboundCourse() {
        return this.course;
      }
      get outboundCourse() {
        return this.course;
      }
      get distanceToTermination() {
        const startPoint = this.getPathStartPoint();
        return distanceTo(startPoint, this.intercept);
      }
      getDistanceToGo(ppos) {
        return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      }
      getGuidanceParameters(_ppos, _trueTrack) {
        return {
          law: ControlLaw.TRACK,
          course: this.course
        };
      }
      getNominalRollAngle(_gs) {
        return 0;
      }
      getPseudoWaypointLocation(_distanceBeforeTerminator) {
        return undefined;
      }
      isAbeam(ppos) {
        const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
        return dtg >= 0 && dtg <= this.distance;
      }
      get repr() {
        return "CI(".concat(Math.trunc(this.course), "T)");
      }
    }

    const mod = (x, n) => x - Math.floor(x / n) * n;

    /**
     * A type I transition uses a fixed turn radius between two fix-referenced legs.
     */
    class FixedRadiusTransition extends Transition {
      constructor(previousLeg,
      // FIXME temporary
      nextLeg // FIXME temporary
      ) {
        super(previousLeg, nextLeg);
        this.previousLeg = previousLeg;
        this.nextLeg = nextLeg;
        _defineProperty$2(this, "radius", void 0);
        _defineProperty$2(this, "tad", void 0);
        _defineProperty$2(this, "clockwise", void 0);
        _defineProperty$2(this, "isFrozen", false);
        _defineProperty$2(this, "computedPath", []);
        _defineProperty$2(this, "sweepAngle", void 0);
        _defineProperty$2(this, "centre", undefined);
        _defineProperty$2(this, "revertTo", undefined);
        _defineProperty$2(this, "turningPoints", void 0);
      }
      get isReverted() {
        return this.revertTo !== undefined;
      }
      getPathStartPoint() {
        if (this.revertTo) {
          return this.revertTo.getPathStartPoint();
        }
        if (this.isComputed) {
          return this.turningPoints[0];
        }
        throw Error('?');
      }
      getPathEndPoint() {
        if (this.revertTo) {
          return this.revertTo.getPathEndPoint();
        }
        if (this.isComputed) {
          return this.turningPoints[1];
        }
        throw Error('?');
      }
      recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
        if (this.isFrozen) {
          return;
        }

        // Sweep angle
        this.sweepAngle = MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse);

        // Start with half the track change
        const bankAngle = Math.abs(this.sweepAngle) / 2;

        // apply limits
        const finalBankAngle = Math.max(Math.min(bankAngle, maxBank(tas, true)), minBank(this.nextLeg.segment));

        // Turn radius
        this.radius = tas ** 2 / (9.81 * Math.tan(finalBankAngle * Avionics.Utils.DEG2RAD)) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;

        // Turn anticipation distance
        this.tad = this.radius * Math.tan(Math.abs(this.sweepAngle / 2) * MathUtils.DEGREES_TO_RADIANS);

        // Check what the distance from the fix to the next leg is (to avoid being not lined up in some XF -> CF cases)
        const prevLegTermDistanceToNextLeg = Geo.distanceToLeg(this.previousLeg instanceof XFLeg ? this.previousLeg.fix.infos.coordinates : this.previousLeg.intercept, this.nextLeg);
        const defaultTurnDirection = this.sweepAngle >= 0 ? TurnDirection.Right : TurnDirection.Left;
        const forcedTurn = (this.nextLeg.metadata.turnDirection === TurnDirection.Left || this.nextLeg.metadata.turnDirection === TurnDirection.Right) && defaultTurnDirection !== this.nextLeg.metadata.turnDirection;
        const tooBigForPrevious = this.previousLeg.distanceToTermination < this.tad + 0.1;
        const tooBigForNext = 'from' in this.nextLeg ? distanceTo(this.nextLeg.from.infos.coordinates, this.nextLeg.to.infos.coordinates) < this.tad + 0.1 : false;
        const notLinedUp = Math.abs(prevLegTermDistanceToNextLeg) >= 0.25; // "reasonable" distance

        // in some circumstances we revert to a path capture transition where the fixed radius won't work well
        const shouldRevert = Math.abs(this.sweepAngle) <= 3 || Math.abs(this.sweepAngle) > 175 || this.previousLeg.overflyTermFix || forcedTurn || tooBigForPrevious || tooBigForNext || notLinedUp;

        // We do not revert to a path capture if the previous leg was overshot anyway - draw the normal fixed radius turn
        const previousLegOvershot = 'overshot' in this.previousLeg && this.previousLeg.overshot;
        if (shouldRevert && !previousLegOvershot) {
          const shouldHaveTad = !this.previousLeg.overflyTermFix && !notLinedUp && (tooBigForPrevious || tooBigForNext);
          if (!this.revertTo) {
            const reverted = new PathCaptureTransition(this.previousLeg, this.nextLeg);
            reverted.startWithTad = shouldHaveTad;
            reverted.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
            const reversionTad = reverted.tad;
            const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.tad;

            // See if there is enough space left for the reverted transition
            if (fixDtg > reversionTad) {
              this.revertTo = reverted;
              this.isComputed = this.revertTo.isComputed;
              return;
            }
          } else {
            this.revertTo.startWithTad = shouldHaveTad;
            this.revertTo.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
            this.isComputed = this.revertTo.isComputed;
            return;
          }
        }

        // Try to de-revert if needed
        if (this.revertTo) {
          // We assume we are inactive here
          const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.revertTo.tad;

          // Only de-revert if there is space for the fixed radius TAD
          if (fixDtg > this.tad + 0.05 || !isActive) {
            this.revertTo = undefined;
          }
        }

        // Turn direction
        this.clockwise = this.sweepAngle >= 0;

        // Turning points
        this.turningPoints = this.computeTurningPoints();
        this.computedPath.length = 0;
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.getTurningPoints()[0],
          centrePoint: this.centre,
          endPoint: this.getTurningPoints()[1],
          sweepAngle: this.sweepAngle
        });
        this.isComputed = true;
      }
      get startsInCircularArc() {
        return true;
      }
      get endsInCircularArc() {
        return true;
      }
      isAbeam(ppos) {
        if (this.revertTo !== undefined) {
          return this.revertTo.isAbeam(ppos);
        }
        const turningPoints = this.getTurningPoints();
        if (!turningPoints) {
          return false;
        }
        const [inbound, outbound] = turningPoints;
        const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
        const inHeadingAc = Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
        const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
        const outHeadingAc = Math.abs(MathUtils.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
        return inHeadingAc <= 90 && outHeadingAc >= 90;
      }
      get distance() {
        if (this.revertTo) {
          return this.revertTo.distance;
        }
        return arcLength(this.radius, this.sweepAngle);
      }

      /**
       * Returns the distance between the inbound turning point and the reference fix
       */
      get unflownDistance() {
        if (this.revertTo) {
          return 0;
        }
        if (!this.getTurningPoints()) {
          return 0;
        }
        return Avionics.Utils.computeGreatCircleDistance(this.previousLeg.getPathEndPoint(), this.getTurningPoints()[0]);
      }
      computeTurningPoints() {
        const {
          lat,
          long
        } = this.previousLeg instanceof CILeg ? this.previousLeg.intercept : this.previousLeg.fix.infos.coordinates;
        const inbound = Avionics.Utils.bearingDistanceToCoordinates(mod(this.previousLeg.outboundCourse + 180, 360), this.tad, lat, long);
        const outbound = Avionics.Utils.bearingDistanceToCoordinates(this.nextLeg.inboundCourse, this.tad, lat, long);
        this.centre = Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(this.previousLeg.outboundCourse + (this.clockwise ? 90 : -90)), this.radius, inbound.lat, inbound.long);
        return [inbound, outbound];
      }
      getTurningPoints() {
        if (this.revertTo) {
          return this.revertTo.getTurningPoints();
        }
        return this.turningPoints;
      }
      get predictedPath() {
        if (this.revertTo) {
          return this.revertTo.predictedPath;
        }
        return this.computedPath;
      }
      getDistanceToGo(ppos) {
        if (this.revertTo) {
          return this.revertTo.getDistanceToGo(ppos);
        }
        const [itp] = this.getTurningPoints();
        return arcDistanceToGo(ppos, itp, this.centre, this.sweepAngle);
      }
      getGuidanceParameters(ppos, trueTrack, tas) {
        if (this.revertTo) {
          return this.revertTo.getGuidanceParameters(ppos, trueTrack, tas);
        }
        const [itp] = this.getTurningPoints();
        return arcGuidance(ppos, trueTrack, itp, this.centre, this.sweepAngle);
      }
      getNominalRollAngle(gs) {
        if (this.revertTo) {
          return this.revertTo.getNominalRollAngle(gs);
        }
        return (this.clockwise ? 1 : -1) * Math.atan((gs * 463 / 900) ** 2 / (this.radius * 1852 * Constants.G)) * (180 / Math.PI);
      }
      get repr() {
        return "TYPE1(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
      }
    }

    const tan$1 = input => Math.tan(input * (Math.PI / 180));

    /**
     * A type I transition uses a fixed turn radius between two fix-referenced legs.
     */
    class CourseCaptureTransition extends Transition {
      constructor(previousLeg, nextLeg // FIXME temporary
      ) {
        super(previousLeg, nextLeg);
        this.previousLeg = previousLeg;
        this.nextLeg = nextLeg;
        _defineProperty$2(this, "terminator", void 0);
        _defineProperty$2(this, "isArc", void 0);
        _defineProperty$2(this, "startPoint", void 0);
        _defineProperty$2(this, "endPoint", void 0);
        _defineProperty$2(this, "center", void 0);
        _defineProperty$2(this, "sweepAngle", void 0);
        _defineProperty$2(this, "radius", void 0);
        _defineProperty$2(this, "clockwise", void 0);
        _defineProperty$2(this, "predictedPath", []);
        _defineProperty$2(this, "forcedTurnComplete", false);
        _defineProperty$2(this, "computedTurnDirection", TurnDirection.Either);
      }
      getPathStartPoint() {
        return this.previousLeg.getPathEndPoint();
      }
      getPathEndPoint() {
        return this.terminator;
      }
      get turnDirection() {
        return Math.sign(this.courseVariation) === -1 ? TurnDirection.Left : TurnDirection.Right;
      }
      get deltaTrack() {
        return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
      }
      get courseVariation() {
        return MathUtils.adjustAngleForTurnDirection(this.deltaTrack, this.nextLeg.metadata.turnDirection);
      }
      recomputeWithParameters(_isActive, tas, gs, ppos, _trueTrack) {
        const termFix = this.previousLeg.getPathEndPoint();
        this.computedTurnDirection = TurnDirection.Either;
        let courseChange;
        let initialTurningPoint;
        if (!this.inboundGuidable) {
          if (this.courseVariation <= 90) {
            courseChange = this.deltaTrack;
          } else if (Math.sign(this.courseVariation) === Math.sign(this.deltaTrack)) {
            courseChange = this.deltaTrack;
          } else {
            courseChange = Math.sign(this.courseVariation) * 360 + this.deltaTrack;
          }
          initialTurningPoint = ppos;
        } else {
          courseChange = this.courseVariation;
          initialTurningPoint = termFix;
        }

        // Course change and delta track?
        const radius = gs ** 2 / (Constants.G * tan$1(Math.abs(maxBank(tas, false)))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
        const turnCenter = Geo.computeDestinationPoint(initialTurningPoint, radius, this.previousLeg.outboundCourse + 90 * Math.sign(courseChange));
        const finalTurningPoint = Geo.computeDestinationPoint(turnCenter, radius, this.previousLeg.outboundCourse - 90 * Math.sign(courseChange) + courseChange);
        this.radius = radius;

        // Turn direction
        this.clockwise = courseChange >= 0;
        if (courseChange === 0) {
          this.isArc = false;
          this.startPoint = this.previousLeg.getPathEndPoint();
          this.endPoint = this.previousLeg.getPathEndPoint();
          this.terminator = this.endPoint;
          this.isComputed = true;
          this.predictedPath.length = 0;
          this.predictedPath.push({
            type: PathVectorType.Line,
            startPoint: this.startPoint,
            endPoint: this.endPoint
          });
          this.isNull = true;
          return;
        }
        this.computedTurnDirection = this.clockwise ? TurnDirection.Right : TurnDirection.Left;
        this.isNull = false;
        this.isArc = true;
        this.startPoint = initialTurningPoint;
        this.center = turnCenter;
        this.endPoint = finalTurningPoint;
        this.sweepAngle = courseChange;
        this.terminator = this.endPoint;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.startPoint,
          centrePoint: this.center,
          endPoint: this.endPoint,
          sweepAngle: this.sweepAngle
        });
        this.isComputed = true;
      }
      get startsInCircularArc() {
        return this.isArc;
      }
      get endsInCircularArc() {
        return this.isArc;
      }
      get angle() {
        return this.sweepAngle;
      }
      isAbeam(ppos) {
        return !this.isNull && this.computedTurnDirection !== TurnDirection.Either && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
      }
      get distance() {
        if (this.isNull) {
          return 0;
        }
        return arcLength(this.radius, this.angle);
      }
      getTurningPoints() {
        return [this.startPoint, this.endPoint];
      }
      getDistanceToGo(ppos) {
        const [itp] = this.getTurningPoints();
        return arcDistanceToGo(ppos, itp, this.center, this.clockwise ? this.angle : -this.angle);
      }
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        if (this.computedTurnDirection !== TurnDirection.Either) {
          const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
          let trackAngleError = this.nextLeg.inboundCourse - trueTrack;
          if (turnSign !== Math.sign(trackAngleError)) {
            trackAngleError += turnSign * 360;
          }
          if (Math.abs(trackAngleError) > 130) {
            const phiCommand = turnSign * maxBank(tas, false);
            return {
              law: ControlLaw.LATERAL_PATH,
              trackAngleError: 0,
              phiCommand,
              crossTrackError: 0
            };
          }
          this.forcedTurnComplete = true;
        }

        // FIXME PPOS guidance and all...
        return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
      }
      getNominalRollAngle(gs) {
        const gsMs = gs * (463 / 900);
        return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
      }
      get repr() {
        return "COURSE CAPTURE(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
      }
    }

    /* | FALeg | FMLeg */

    const tan = input => Math.tan(input * (Math.PI / 180));
    const acos = input => Math.acos(input) * (180 / Math.PI);
    let DirectToFixTransitionGuidanceState;

    /**
     * A type I transition uses a fixed turn radius between two fix-referenced legs.
     */
    (function (DirectToFixTransitionGuidanceState) {
      DirectToFixTransitionGuidanceState[DirectToFixTransitionGuidanceState["Straight"] = 0] = "Straight";
      DirectToFixTransitionGuidanceState[DirectToFixTransitionGuidanceState["Turn"] = 1] = "Turn";
    })(DirectToFixTransitionGuidanceState || (DirectToFixTransitionGuidanceState = {}));
    class DirectToFixTransition extends Transition {
      constructor(previousLeg, nextLeg) {
        super(previousLeg, nextLeg);
        this.previousLeg = previousLeg;
        this.nextLeg = nextLeg;
        _defineProperty$2(this, "state", DirectToFixTransitionGuidanceState.Straight);
        _defineProperty$2(this, "straightCourse", void 0);
        _defineProperty$2(this, "terminator", void 0);
        _defineProperty$2(this, "hasArc", void 0);
        _defineProperty$2(this, "center", void 0);
        _defineProperty$2(this, "radius", void 0);
        _defineProperty$2(this, "clockwise", void 0);
        _defineProperty$2(this, "lineStartPoint", void 0);
        _defineProperty$2(this, "lineEndPoint", void 0);
        _defineProperty$2(this, "arcStartPoint", void 0);
        _defineProperty$2(this, "arcCentrePoint", void 0);
        _defineProperty$2(this, "arcEndPoint", void 0);
        _defineProperty$2(this, "arcSweepAngle", void 0);
        _defineProperty$2(this, "computedPath", []);
      }
      getPathStartPoint() {
        return this.previousLeg.getPathEndPoint();
      }
      get turnDirection() {
        return Math.sign(this.deltaTrack);
      }
      get deltaTrack() {
        return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
      }
      get courseVariation() {
        // TODO reverse turn direction
        return this.deltaTrack;
      }
      get predictedPath() {
        return this.computedPath;
      }
      recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
        if (this.isFrozen) {
          return;
        }
        const termFix = this.previousLeg.getPathEndPoint();

        // FIXME fix for FX legs
        const nextFix = this.nextLeg.fix.infos.coordinates;
        this.radius = gs ** 2 / (Constants.G * tan(maxBank(tas, true))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
        let trackChange = MathUtils.diffAngle(this.previousLeg.outboundCourse, bearingTo(this.previousLeg.getPathEndPoint(), nextFix), this.nextLeg.metadata.turnDirection);
        if (Math.abs(trackChange) < 3 || !Number.isFinite(trackChange)) {
          this.isNull = true;
          this.isComputed = true;
          return;
        }
        const turnDirectionSign = trackChange > 0 ? 1 : -1;
        const turnDirection = turnDirectionSign > 0 ? TurnDirection.Right : TurnDirection.Left;
        const currentRollAngle = isActive ? -SimVar.GetSimVarValue('PLANE BANK DEGREES', 'degrees') : 0;
        const rollAngleChange = Math.abs(turnDirectionSign * maxBank(tas, true) - currentRollAngle);
        const rollAnticipationDistance = Geometry.getRollAnticipationDistance(gs, 0, rollAngleChange);
        let itp = rollAnticipationDistance >= 0.05 ? placeBearingDistance(termFix, this.previousLeg.outboundCourse, rollAnticipationDistance) : termFix;
        let turnCentre = placeBearingDistance(itp, this.previousLeg.outboundCourse + turnDirectionSign * 90, this.radius);
        let distanceToFix = distanceTo(turnCentre, nextFix);
        if (distanceToFix < this.radius) {
          if (Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, bearingTo(termFix, nextFix), this.nextLeg.metadata.turnDirection)) < 60) {
            this.hasArc = false;
            this.lineStartPoint = termFix;
            this.lineEndPoint = termFix;
            this.terminator = this.lineEndPoint;
            this.predictedPath.length = 0;
            this.predictedPath.push({
              type: PathVectorType.Line,
              startPoint: this.lineStartPoint,
              endPoint: this.lineEndPoint
            });
            this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
            this.isNull = true;
            this.isComputed = true;
            return;
          }
          const tcFixBearing = bearingTo(turnCentre, nextFix);
          const extendDist = Math.sqrt(this.radius ** 2 - distanceToFix ** 2 * Math.sin((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) ** 2) + distanceToFix * Math.cos((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) + 0.3;
          itp = placeBearingDistance(itp, this.previousLeg.outboundCourse, extendDist);
          turnCentre = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse, extendDist);
          distanceToFix = distanceTo(turnCentre, nextFix);
        }
        const bearingTcItp = bearingTo(turnCentre, itp);
        const bearingTcFix = bearingTo(turnCentre, nextFix);
        const angleFtpFix = acos(this.radius / distanceToFix);
        trackChange = MathUtils.diffAngle(bearingTcItp, MathUtils.diffAngle(turnDirectionSign * angleFtpFix, bearingTcFix), turnDirection);
        const ftp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse + trackChange - 90 * turnDirectionSign, this.radius);
        this.lineStartPoint = this.previousLeg.getPathEndPoint();
        this.lineEndPoint = itp;
        this.hasArc = true;
        this.arcStartPoint = itp;
        this.arcCentrePoint = turnCentre;
        this.arcEndPoint = ftp;
        this.arcSweepAngle = trackChange;
        this.terminator = this.arcEndPoint;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: PathVectorType.Line,
          startPoint: this.lineStartPoint,
          endPoint: this.lineEndPoint
        });
        this.predictedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.arcStartPoint,
          centrePoint: this.arcCentrePoint,
          endPoint: this.arcEndPoint,
          sweepAngle: this.arcSweepAngle
        });
        this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
        this.isNull = false;
        this.isComputed = true;
      }
      getPathDebugPoints() {
        const points = [];
        points.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.lineStartPoint,
          annotation: 'T4 RAD START'
        }, {
          type: PathVectorType.DebugPoint,
          startPoint: this.lineEndPoint,
          annotation: 'T4 RAD END'
        });
        if (this.hasArc) {
          points.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.arcStartPoint,
            annotation: 'T4 ARC START'
          }, {
            type: PathVectorType.DebugPoint,
            startPoint: this.arcCentrePoint
          }, {
            type: PathVectorType.DebugPoint,
            startPoint: this.arcEndPoint,
            annotation: 'T4 ARC END'
          });
        }
        return points;
      }
      get endsInCircularArc() {
        return this.hasArc;
      }
      isAbeam(ppos) {
        if (this.isNull) {
          return false;
        }
        let dtg = 0;
        if (this.state === DirectToFixTransitionGuidanceState.Straight) {
          const straightDist = distanceTo(this.lineStartPoint, this.lineEndPoint);
          const straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
          dtg += straightDtg;
          if (dtg >= straightDist) {
            return false;
          }
        }
        if (this.hasArc) {
          if (this.state === DirectToFixTransitionGuidanceState.Turn) {
            const arcDtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
            dtg += arcDtg;
          } else {
            dtg += arcLength(this.radius, this.arcSweepAngle);
          }
        }
        return dtg > 0;
      }
      get distance() {
        if (this.isNull) {
          return 0;
        }
        const straightDistance = distanceTo(this.lineStartPoint, this.lineEndPoint);
        if (this.hasArc) {
          const circumference = 2 * Math.PI * this.radius;
          return straightDistance + circumference / 360 * this.arcSweepAngle;
        }
        return straightDistance;
      }
      getTurningPoints() {
        return [this.arcStartPoint, this.arcEndPoint];
      }
      getDistanceToGo(ppos) {
        let straightDtg = 0;
        if (this.state === DirectToFixTransitionGuidanceState.Straight) {
          straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
        }
        if (!this.hasArc) {
          return straightDtg;
        }
        return straightDtg + arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
      }
      getGuidanceParameters(ppos, trueTrack, tas) {
        let dtg;
        let params;

        // State machine & DTG

        switch (this.state) {
          case DirectToFixTransitionGuidanceState.Straight:
            dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
            if (dtg <= 0 && this.hasArc) {
              this.state = DirectToFixTransitionGuidanceState.Turn;
            }
            break;
          case DirectToFixTransitionGuidanceState.Turn:
            dtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
            break;
        }

        // Guidance

        switch (this.state) {
          case DirectToFixTransitionGuidanceState.Straight:
            params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.lineEndPoint);
            let bankNext = 0;
            if (this.hasArc) {
              bankNext = this.arcSweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, false);
            }
            const rad = Geometry.getRollAnticipationDistance(tas, 0, bankNext);
            if (dtg <= rad) {
              params.phiCommand = bankNext;
            }
            break;
          case DirectToFixTransitionGuidanceState.Turn:
            params = arcGuidance(ppos, trueTrack, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
            // TODO next leg RAD
            break;
        }
        return params;
      }
      getNominalRollAngle(gs) {
        const gsMs = gs * (463 / 900);
        return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
      }
      get repr() {
        return "DIRECT TO FIX(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
      }
    }

    class CALeg extends Leg {
      constructor(course, altitude, metadata, segment, extraLength) {
        super();
        this.course = course;
        this.altitude = altitude;
        this.metadata = metadata;
        this.extraLength = extraLength;
        _defineProperty$2(this, "estimatedTermination", void 0);
        _defineProperty$2(this, "computedPath", []);
        _defineProperty$2(this, "start", void 0);
        _defineProperty$2(this, "wasMovedByPpos", false);
        this.segment = segment;
      }
      get terminationWaypoint() {
        return this.estimatedTermination;
      }
      get ident() {
        return Math.round(this.altitude).toString();
      }
      getPathStartPoint() {
        var _this$inboundGuidable;
        return (_this$inboundGuidable = this.inboundGuidable) === null || _this$inboundGuidable === void 0 ? void 0 : _this$inboundGuidable.getPathEndPoint();
      }
      getPathEndPoint() {
        return this.estimatedTermination;
      }
      get predictedPath() {
        return this.computedPath;
      }
      recomputeWithParameters(isActive, _tas, _gs, ppos, _trueTrack) {
        // FIXME somehow after reloads the isRunway property is gone, so consider airports as runways for now
        const afterRunway = this.inboundGuidable instanceof IFLeg && (this.inboundGuidable.fix.isRunway || this.inboundGuidable.fix.icao.startsWith('A'));

        // We assign / spread properties here to avoid copying references and causing bugs
        if (isActive && !afterRunway) {
          this.wasMovedByPpos = true;
          if (!this.start) {
            this.start = _objectSpread2({}, ppos);
          } else {
            this.start.lat = ppos.lat;
            this.start.long = ppos.long;
          }
          if (!this.estimatedTermination) {
            this.recomputeEstimatedTermination();
          }
        } else if (!this.wasMovedByPpos) {
          var _this$inboundGuidable2;
          const newPreviousGuidableStart = (_this$inboundGuidable2 = this.inboundGuidable) === null || _this$inboundGuidable2 === void 0 ? void 0 : _this$inboundGuidable2.getPathEndPoint();
          if (newPreviousGuidableStart) {
            if (!this.start) {
              this.start = _objectSpread2({}, newPreviousGuidableStart);
            } else {
              this.start.lat = newPreviousGuidableStart.lat;
              this.start.long = newPreviousGuidableStart.long;
            }
          }
          this.recomputeEstimatedTermination();
        }
        this.computedPath = [{
          type: PathVectorType.Line,
          startPoint: this.start,
          endPoint: this.getPathEndPoint()
        }];
        this.isComputed = true;
      }
      recomputeEstimatedTermination() {
        const ESTIMATED_VS = 2000; // feet per minute
        const ESTIMATED_KTS = 175; // NM per hour

        // FIXME hax!
        let originAltitude = 0;
        if (this.inboundGuidable instanceof IFLeg && this.inboundGuidable.fix.icao.startsWith('A')) {
          originAltitude = this.inboundGuidable.fix.infos.oneWayRunways[0].elevation * 3.28084;
        }
        const minutesToAltitude = (this.altitude - Math.max(0, originAltitude)) / ESTIMATED_VS; // minutes
        let distanceToTermination = minutesToAltitude / 60 * ESTIMATED_KTS; // NM

        if (!this.wasMovedByPpos && this.extraLength > 0) {
          distanceToTermination += this.extraLength;
        }
        this.estimatedTermination = Avionics.Utils.bearingDistanceToCoordinates(this.course, distanceToTermination, this.start.lat, this.start.long);
      }
      get inboundCourse() {
        return this.course;
      }
      get outboundCourse() {
        return this.course;
      }
      getDistanceToGo(ppos) {
        return courseToFixDistanceToGo(ppos, this.course, this.estimatedTermination);
      }
      getGuidanceParameters(ppos, trueTrack, _tas) {
        // FIXME: should be just track guidance, no xtk
        // (the start of the predicted path should also float with ppos once active, along with the transition to the leg)
        // return {
        //    law: ControlLaw.TRACK,
        //    course: this.course,
        // };
        return courseToFixGuidance(ppos, trueTrack, this.course, this.estimatedTermination);
      }
      getNominalRollAngle(_gs) {
        return undefined;
      }
      get distanceToTermination() {
        const startPoint = this.getPathStartPoint();
        return distanceTo(startPoint, this.estimatedTermination);
      }
      isAbeam(_ppos) {
        return false;
      }
      get repr() {
        return "CA(".concat(this.course.toFixed(1), "T) TO ").concat(Math.round(this.altitude), " FT");
      }
    }

    class CRLeg extends Leg {
      constructor(course, origin, radial, metadata, segment) {
        super();
        this.course = course;
        this.origin = origin;
        this.radial = radial;
        this.metadata = metadata;
        _defineProperty$2(this, "computedPath", []);
        _defineProperty$2(this, "intercept", undefined);
        this.segment = segment;
      }
      get terminationWaypoint() {
        return this.intercept;
      }
      get ident() {
        return this.origin.ident.substring(0, 3) + this.origin.theta.toFixed(0);
      }
      getPathStartPoint() {
        if (this.inboundGuidable && this.inboundGuidable.isComputed) {
          return this.inboundGuidable.getPathEndPoint();
        }
        throw new Error('[CRLeg] No computed inbound guidable.');
      }
      getPathEndPoint() {
        return this.intercept;
      }
      get predictedPath() {
        return this.computedPath;
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        this.intercept = Geo.doublePlaceBearingIntercept(this.getPathStartPoint(), this.origin.coordinates, this.course, this.radial);
        const overshot = distanceTo(this.getPathStartPoint(), this.intercept) >= 5000;
        if (this.intercept && !overshot) {
          this.computedPath = [{
            type: PathVectorType.Line,
            startPoint: this.getPathStartPoint(),
            endPoint: this.intercept
          }];
          this.isNull = false;
          this.isComputed = true;
        } else {
          this.predictedPath.length = 0;
          this.isNull = true;
          this.isComputed = true;
        }
      }

      /**
       * Returns `true` if the inbound transition has overshot the leg
       */
      get overshot() {
        const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
        return side === PointSide.After;
      }
      get inboundCourse() {
        return this.course;
      }
      get outboundCourse() {
        return this.course;
      }
      get distanceToTermination() {
        const startPoint = this.getPathStartPoint();
        return distanceTo(startPoint, this.intercept);
      }
      getDistanceToGo(ppos) {
        return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      }
      getGuidanceParameters(ppos, trueTrack, _tas) {
        return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
      }
      getNominalRollAngle(_gs) {
        return 0;
      }
      getPseudoWaypointLocation(_distanceBeforeTerminator) {
        return undefined;
      }
      isAbeam(ppos) {
        const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
        return dtg >= 0 && dtg <= this.distance;
      }
      get repr() {
        return "CR ".concat(this.course, "T to ").concat(this.origin.ident).concat(this.origin.theta);
      }
    }

    /**
     * Temporary - better solution is just to have an `InfiniteLine` vector...
     */
    const VM_LEG_SIZE = 321;

    // TODO needs updated with wind prediction, and maybe local magvar if following for longer distances
    class VMLeg extends Leg {
      constructor(heading, metadata, segment) {
        super();
        this.heading = heading;
        this.metadata = metadata;
        _defineProperty$2(this, "predictedPath", []);
        _defineProperty$2(this, "displayedOnMap", false);
        this.segment = segment;
      }
      get terminationWaypoint() {
        return undefined;
      }
      get ident() {
        return 'MANUAL';
      }
      getPathStartPoint() {
        var _this$inboundGuidable;
        return (_this$inboundGuidable = this.inboundGuidable) === null || _this$inboundGuidable === void 0 ? void 0 : _this$inboundGuidable.getPathEndPoint();
      }
      getPathEndPoint() {
        return Avionics.Utils.bearingDistanceToCoordinates(this.heading, VM_LEG_SIZE, this.getPathStartPoint().lat, this.getPathStartPoint().long);
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        // FIXME course based on predicted wind

        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: PathVectorType.Line,
          startPoint: this.getPathStartPoint(),
          endPoint: this.getPathEndPoint()
        });
        this.isComputed = true;
      }
      get inboundCourse() {
        // FIXME this is a bit naughty...
        return this.heading;
      }
      get outboundCourse() {
        // FIXME this is a bit naughty...
        return this.heading;
      }
      get distance() {
        return 0;
      }
      get distanceToTermination() {
        return 1;
      }

      // Can't get pseudo-waypoint location without a finite terminator
      getPseudoWaypointLocation(_distanceBeforeTerminator) {
        return undefined;
      }
      getGuidanceParameters(_ppos, _trueTrack) {
        return {
          law: ControlLaw.HEADING,
          heading: this.heading
        };
      }
      getNominalRollAngle(_gs) {
        return 0;
      }
      getDistanceToGo(_ppos) {
        return undefined;
      }
      isAbeam(_ppos) {
        return true;
      }
      get disableAutomaticSequencing() {
        return true;
      }
      get repr() {
        return "VM(".concat(this.heading.toFixed(1), "T)");
      }
    }

    class DFLeg extends XFLeg {
      constructor(fix, metadata, segment) {
        super(fix);
        this.metadata = metadata;
        _defineProperty$2(this, "computedPath", []);
        _defineProperty$2(this, "start", void 0);
        this.segment = segment;
      }
      getPathStartPoint() {
        var _this$inboundGuidable, _this$inboundGuidable2;
        return (_this$inboundGuidable = (_this$inboundGuidable2 = this.inboundGuidable) === null || _this$inboundGuidable2 === void 0 ? void 0 : _this$inboundGuidable2.getPathEndPoint()) !== null && _this$inboundGuidable !== void 0 ? _this$inboundGuidable : this.estimateStartPoint();
      }
      get predictedPath() {
        return this.computedPath;
      }
      estimateStartPoint() {
        let bearing = 0;
        if (this.outboundGuidable instanceof Transition) {
          bearing = this.outboundGuidable.nextLeg.inboundCourse + 180;
        } else if (this.outboundGuidable instanceof Leg) {
          bearing = this.outboundGuidable.inboundCourse + 180;
        }
        bearing = Avionics.Utils.clampAngle(bearing);
        return Avionics.Utils.bearingDistanceToCoordinates(bearing, 2, this.fix.infos.coordinates.long, this.fix.infos.coordinates.long);
      }
      recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
        var _this$inboundGuidable3, _this$inboundGuidable4;
        const newStart = (_this$inboundGuidable3 = (_this$inboundGuidable4 = this.inboundGuidable) === null || _this$inboundGuidable4 === void 0 ? void 0 : _this$inboundGuidable4.getPathEndPoint()) !== null && _this$inboundGuidable3 !== void 0 ? _this$inboundGuidable3 : this.estimateStartPoint();

        // Adjust the start point if we can
        if (newStart) {
          this.start = newStart;
        }
        this.computedPath = [{
          type: PathVectorType.Line,
          startPoint: this.start,
          endPoint: this.getPathEndPoint()
        }];
        this.isComputed = true;
      }
      get inboundCourse() {
        return bearingTo(this.start, this.fix.infos.coordinates);
      }
      get outboundCourse() {
        return bearingTo(this.start, this.fix.infos.coordinates);
      }
      getDistanceToGo(ppos) {
        return courseToFixDistanceToGo(ppos, this.outboundCourse, this.getPathEndPoint());
      }
      getGuidanceParameters(ppos, trueTrack, _tas) {
        return fixToFixGuidance(ppos, trueTrack, this.start, this.fix.infos.coordinates);
      }
      getNominalRollAngle(_gs) {
        return undefined;
      }
      isAbeam(_ppos) {
        return false;
      }
      get repr() {
        return "DF TO '".concat(this.fix.ident, "'");
      }
    }

    class RFLeg extends XFLeg {
      // termination fix of the previous leg

      // to fix for the RF leg, most params referenced off this

      // location of the centre fix of the arc

      constructor(from, to, center, metadata, segment) {
        super(to);
        this.metadata = metadata;
        _defineProperty$2(this, "from", void 0);
        _defineProperty$2(this, "to", void 0);
        _defineProperty$2(this, "center", void 0);
        _defineProperty$2(this, "radius", void 0);
        _defineProperty$2(this, "angle", void 0);
        _defineProperty$2(this, "clockwise", void 0);
        _defineProperty$2(this, "mDistance", void 0);
        _defineProperty$2(this, "computedPath", []);
        this.from = from;
        this.to = to;
        this.center = center;
        this.radius = Avionics.Utils.computeGreatCircleDistance(this.center, this.to.infos.coordinates);
        this.segment = segment;
        const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates); // -90?
        const bearingTo = Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates); // -90?

        switch (to.turnDirection) {
          case 1:
            // left
            this.clockwise = false;
            this.angle = Avionics.Utils.clampAngle(bearingFrom - bearingTo);
            break;
          case 2:
            // right
            this.clockwise = true;
            this.angle = Avionics.Utils.clampAngle(bearingTo - bearingFrom);
            break;
          case 0: // unknown
          case 3: // either
          default:
            const angle = Avionics.Utils.diffAngle(bearingTo, bearingFrom);
            this.clockwise = angle > 0;
            this.angle = Math.abs(angle);
            break;
        }
        this.mDistance = 2 * Math.PI * this.radius / 360 * this.angle;
        this.computedPath = [{
          type: PathVectorType.Arc,
          startPoint: this.from.infos.coordinates,
          centrePoint: this.center,
          endPoint: this.to.infos.coordinates,
          sweepAngle: this.clockwise ? this.angle : -this.angle
        }];
        this.isComputed = true;
      }
      getPathStartPoint() {
        return this.from.infos.coordinates;
      }
      getPathEndPoint() {
        return this.to.infos.coordinates;
      }
      get predictedPath() {
        return this.computedPath;
      }
      get startsInCircularArc() {
        return true;
      }
      get endsInCircularArc() {
        return true;
      }
      get inboundCourse() {
        return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates) + (this.clockwise ? 90 : -90));
      }
      get outboundCourse() {
        return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates) + (this.clockwise ? 90 : -90));
      }
      get distance() {
        return this.mDistance;
      }
      get distanceToTermination() {
        return arcLength(this.radius, this.angle);
      }

      // basically straight from type 1 transition... willl need refinement
      getGuidanceParameters(ppos, trueTrack, _tas) {
        // FIXME should be defined in terms of to fix
        return arcGuidance(ppos, trueTrack, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
      }
      getNominalRollAngle(gs) {
        const gsMs = gs * (463 / 900);
        return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
      }

      /**
       * Calculates directed DTG parameter
       *
       * @param ppos {LatLong} the current position of the aircraft
       */
      getDistanceToGo(ppos) {
        // FIXME geometry should be defined in terms of to...
        return arcDistanceToGo(ppos, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
      }
      isAbeam(ppos) {
        const bearingPpos = Avionics.Utils.computeGreatCircleHeading(this.center, ppos);
        const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates);
        const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
        return trackAngleError >= 0;
      }
      toString() {
        return "<RFLeg radius=".concat(this.radius, " to=").concat(this.to, ">");
      }
      get repr() {
        return "RF(".concat(this.radius.toFixed(1), "NM. ").concat(this.angle.toFixed(1), "\xB0) TO ").concat(this.to.ident);
      }
    }

    var EntryType;
    (function (EntryType) {
      EntryType[EntryType["Null"] = 0] = "Null";
      EntryType[EntryType["Teardrop"] = 1] = "Teardrop";
      EntryType[EntryType["Parallel"] = 2] = "Parallel";
      EntryType[EntryType["DirectOutbound"] = 3] = "DirectOutbound";
      EntryType[EntryType["DirectTurn"] = 4] = "DirectTurn";
    })(EntryType || (EntryType = {}));
    let EntryState;
    (function (EntryState) {
      EntryState[EntryState["Turn1"] = 0] = "Turn1";
      EntryState[EntryState["Straight1"] = 1] = "Straight1";
      EntryState[EntryState["Turn2"] = 2] = "Turn2";
      EntryState[EntryState["Capture"] = 3] = "Capture";
      EntryState[EntryState["Done"] = 4] = "Done";
    })(EntryState || (EntryState = {}));
    class HoldEntryTransition extends Transition {
      // hax

      constructor(previousLeg, nextLeg) {
        super(previousLeg, nextLeg);
        this.previousLeg = previousLeg;
        this.nextLeg = nextLeg;
        _defineProperty$2(this, "entry", EntryType.Null);
        _defineProperty$2(this, "computedPath", []);
        _defineProperty$2(this, "turn1", {});
        _defineProperty$2(this, "turn2", {});
        _defineProperty$2(this, "turn3", {});
        _defineProperty$2(this, "straightCourse", void 0);
        _defineProperty$2(this, "state", EntryState.Turn1);
        _defineProperty$2(this, "wasAbeam", false);
        _defineProperty$2(this, "guidanceActive", false);
        _defineProperty$2(this, "frozen", false);
      }
      get distance() {
        return 0; // 0 so no PWPs
      }

      getDistanceToGo(_ppos) {
        if (this.entry === EntryType.Null || this.state === EntryState.Done) {
          return 0;
        }

        // TODO
        return 1;
      }
      setHxEntry() {
        switch (this.entry) {
          case EntryType.DirectTurn:
          case EntryType.Parallel:
          case EntryType.Teardrop:
          case EntryType.Null:
            this.nextLeg.setInitialState(HxLegGuidanceState.Arc1);
            break;
          case EntryType.DirectOutbound:
            this.nextLeg.setInitialState(HxLegGuidanceState.Outbound);
            break;
        }
      }
      getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs) {
        let dtg;

        // update state
        switch (this.state) {
          case EntryState.Turn1:
            dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
            if (dtg <= 0) {
              this.state = EntryState.Straight1;
            }
            break;
          case EntryState.Straight1:
            dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);
            if (dtg <= 0) {
              this.state = EntryState.Turn2;
            }
            break;
          case EntryState.Turn2:
            dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
            const refFrameOffset = Avionics.Utils.diffAngle(0, this.outboundCourse);
            const trackAngleError = this.turn2.sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - trueTrack) : Avionics.Utils.clampAngle(trueTrack - refFrameOffset);
            if (trackAngleError < 130) {
              this.state = EntryState.Capture;
            }
            break;
          case EntryState.Capture:
            dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
            if (dtg < 0.1) {
              this.nextLeg.updatePrediction();
              this.state = EntryState.Done;
            }
            break;
        }
        let bankNext = 0;
        let params;
        // compute guidance
        switch (this.state) {
          case EntryState.Turn1:
            params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
            break;
          case EntryState.Straight1:
            params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
            bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
            break;
          case EntryState.Turn2:
            // force the initial part of the turn to ensure correct direction
            const phiCommand = this.turn2.sweepAngle > 0 ? maxBank(tas, true /* FIXME false */) : -maxBank(tas, true /* FIXME false */);
            bankNext = phiCommand;
            params = {
              law: ControlLaw.LATERAL_PATH,
              trackAngleError: 0,
              phiCommand,
              crossTrackError: 0
            };
            break;
          case EntryState.Capture:
            params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
            // TODO for HF get the following leg bank
            const {
              sweepAngle
            } = this.nextLeg.geometry;
            bankNext = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
            break;
          case EntryState.Done:
            params = this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
            bankNext = params.phiCommand;
            break;
        }
        const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);
        if (rad > 0 && dtg <= rad) {
          params.phiCommand = bankNext;
        }
        return params;
      }
      getDirectTurnGuidanceParameters(ppos, trueTrack, tas, _gs) {
        let dtg;
        switch (this.state) {
          case EntryState.Turn1:
            dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
            if (dtg <= 0) {
              this.state = EntryState.Straight1;
            }
            break;
          case EntryState.Straight1:
            dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);
            if (dtg <= 0) {
              this.state = EntryState.Turn2;
            }
            break;
          case EntryState.Turn2:
            dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
            if (dtg <= 0) {
              this.state = EntryState.Capture;
            }
            break;
          case EntryState.Capture:
            dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
            if (dtg < 0.1) {
              this.state = EntryState.Done;
            }
            break;
        }
        let params;
        let bankNext;
        switch (this.state) {
          case EntryState.Turn1:
            params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
            bankNext = 0;
            break;
          case EntryState.Straight1:
            params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
            bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
            break;
          case EntryState.Turn2:
            params = arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
            bankNext = 0;
            break;
          case EntryState.Capture:
            params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
            bankNext = 0;
            break;
        }
        const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);
        if (rad > 0 && dtg <= rad) {
          params.phiCommand = bankNext;
        }
        return params;
      }

      /**
       *
       * @todo guide inbound leg for parallel + teardrop?
       */
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        if (!this.guidanceActive) {
          this.nextLeg.updatePrediction();
          this.guidanceActive = true;
        }
        switch (this.entry) {
          case EntryType.Parallel:
          case EntryType.Teardrop:
            return this.getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs);
          case EntryType.DirectOutbound:
            return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
          case EntryType.DirectTurn:
            return this.getDirectTurnGuidanceParameters(ppos, trueTrack, tas, gs);
        }
        return undefined;
      }
      getNominalRollAngle(gs) {
        if (this.entry === EntryType.Null) {
          return this.nextLeg.getNominalRollAngle(gs);
        }
        if (Math.abs(this.turn1.sweepAngle) <= 3) {
          return 0;
        }
        return this.turn1.sweepAngle > 0 ? maxBank(gs /* FIXME tas */, true) : -maxBank(gs /* FIXME tas */, true);
      }
      getTurningPoints() {
        switch (this.entry) {
          case EntryType.Parallel:
          case EntryType.Teardrop:
            return [this.nextLeg.fix.infos.coordinates, this.turn3.ftp];
          case EntryType.DirectTurn:
          case EntryType.DirectOutbound:
            return [this.nextLeg.fix.infos.coordinates, this.turn1.ftp];
          case EntryType.Null:
          default:
            return [this.nextLeg.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates];
        }
      }
      isAbeam(ppos) {
        // major hack
        if (!this.wasAbeam && this.previousLeg.getDistanceToGo(ppos) <= 0) {
          this.wasAbeam = true;
          return true;
        }
        return this.wasAbeam && this.state !== EntryState.Done;
      }
      get startsInCircularArc() {
        return true;
      }
      get endsInCircularArc() {
        return true;
      }
      get inboundCourse() {
        return this.previousLeg.outboundCourse;
      }
      get outboundCourse() {
        return this.nextLeg.inboundCourse;
      }
      get predictedPath() {
        if (this.entry === EntryType.Null) {
          return [];
        }
        if (this.entry === EntryType.DirectOutbound) {
          if (this.nextLeg instanceof HFLeg) {
            return this.nextLeg.getHippodromePath();
          }
          return [];
        }
        return this.computedPath;
      }
      getPathDebugPoints() {
        if (this.entry === EntryType.Null) {
          return [];
        }
        const debugPoints = [{
          type: PathVectorType.DebugPoint,
          startPoint: this.turn1.arcCentre,
          annotation: 'AC1'
        }, {
          type: PathVectorType.DebugPoint,
          startPoint: this.turn1.ftp,
          annotation: 'FTP1'
        }];
        if (this.entry === EntryType.Parallel || this.entry === EntryType.Teardrop) {
          debugPoints.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.turn2.itp,
            annotation: 'ITP2',
            colour: DebugPointColour.Magenta
          });
          debugPoints.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.turn2.arcCentre,
            annotation: 'AC2',
            colour: DebugPointColour.Magenta
          });
          debugPoints.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.turn2.ftp,
            annotation: 'FTP2',
            colour: DebugPointColour.Magenta
          });
          debugPoints.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.turn3.itp,
            annotation: 'ITP3',
            colour: DebugPointColour.Yellow
          });
          debugPoints.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.turn3.arcCentre,
            annotation: 'AC3',
            colour: DebugPointColour.Yellow
          });
          debugPoints.push({
            type: PathVectorType.DebugPoint,
            startPoint: this.turn3.ftp,
            annotation: 'FTP3',
            colour: DebugPointColour.Yellow
          });
        }
        return debugPoints;
      }
      computeNullEntry() {
        this.entry = EntryType.Null;
        this.computedPath.length = 0;
      }
      computeDirectOutboundEntry() {
        this.entry = EntryType.DirectOutbound;
        const {
          radius: maxRadius
        } = this.nextLeg.geometry;
        const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
        const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
        const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
        this.turn1.itp = this.nextLeg.fix.infos.coordinates;
        this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + turnSign * 90, radius, this.turn1.itp.lat, this.turn1.itp.long);
        this.turn1.sweepAngle = turnSign * 180 + trackChange;
        const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
        this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
        this.computedPath.length = 0;
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn1.itp,
          endPoint: this.turn1.ftp,
          centrePoint: this.turn1.arcCentre,
          sweepAngle: this.turn1.sweepAngle
        });
      }
      computeDirectTurnEntry() {
        this.entry = EntryType.DirectTurn;
        const {
          fixB,
          fixC,
          arcCentreFix2,
          sweepAngle,
          radius: maxRadius
        } = this.nextLeg.geometry;
        const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
        const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
        const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
        this.turn1.itp = this.nextLeg.fix.infos.coordinates;
        this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + turnSign * 90, radius, this.turn1.itp.lat, this.turn1.itp.long);
        this.turn1.sweepAngle = turnSign * 180 + trackChange;
        const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
        this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
        this.computedPath.length = 0;
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn1.itp,
          endPoint: this.turn1.ftp,
          centrePoint: this.turn1.arcCentre,
          sweepAngle: this.turn1.sweepAngle
        });
        this.straightCourse = (this.outboundCourse + 180) % 360;
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn1.ftp,
          endPoint: fixB
        });
        this.turn2.itp = fixB;
        this.turn2.ftp = fixC;
        this.turn2.sweepAngle = sweepAngle;
        this.turn2.arcCentre = arcCentreFix2;
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: fixB,
          centrePoint: arcCentreFix2,
          endPoint: fixC,
          sweepAngle
        });
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: fixC,
          endPoint: this.nextLeg.fix.infos.coordinates
        });
      }

      /**
       * @todo extend outbound path to ensure capture before hold fix
       */
      computeTeardropEntry() {
        this.entry = EntryType.Teardrop;
        const {
          radius,
          legLength
        } = this.nextLeg.geometry;
        const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
        this.straightCourse = Avionics.Utils.clampAngle(this.outboundCourse + 150 * turnSign);
        this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.straightCourse);
        const turn1Clockwise = this.turn1.sweepAngle >= 0;
        this.turn1.itp = this.nextLeg.fix.infos.coordinates;
        this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + (turn1Clockwise ? 90 : -90), radius, this.turn1.itp.lat, this.turn1.itp.long);
        const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (turn1Clockwise ? -90 : 90));
        this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
        this.computedPath.length = 0;
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn1.itp,
          endPoint: this.turn1.ftp,
          centrePoint: this.turn1.arcCentre,
          sweepAngle: this.turn1.sweepAngle
        });
        const kekRads = Math.abs(Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180)) * Math.PI / 180;
        let minStraightDistance = radius * 2 / Math.sqrt(3) * (0.1 + Math.SQRT2 - 1 / 2 - Math.abs(Math.sin(kekRads) - 1 / 2));
        const nominalStraightDistance = 1.15 * legLength; // - Math.sin(Math.abs(this.turn1.sweepAngle * Math.PI / 180)) * radius;
        let straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
        let radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);
        if (Math.SQRT2 - radii2Inbound > 0) {
          const extraCapComponent = Math.SQRT2 - radii2Inbound;
          minStraightDistance += radius * 2 / Math.sqrt(3) * extraCapComponent;
          straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
          radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);
        }
        this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse, straightDistance, this.turn1.ftp.lat, this.turn1.ftp.long);
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn1.ftp,
          endPoint: this.turn2.itp
        });
        this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 120, radius, this.turn2.itp.lat, this.turn2.itp.long);
        if (radii2Inbound >= 2) {
          // we are intercepting from the inside with room for 45 deg capture
          this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 75, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
          this.turn2.sweepAngle = turnSign * 165;
          const straightDist = (radii2Inbound - 2) * Math.SQRT2 * radius;
          this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 165, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
          this.turn3.sweepAngle = turnSign * 45;
          this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse - turnSign * 105, radius, this.turn3.itp.lat, this.turn3.itp.long);
          this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
          this.computedPath.push({
            type: PathVectorType.Line,
            startPoint: this.turn2.ftp,
            endPoint: this.turn3.itp
          });
        } else if (Math.SQRT2 - radii2Inbound < 0) {
          // we are intercepting from the outside without enough room for 45 deg capture
          const interceptAngle = Math.acos(radii2Inbound / 2) * 180 / Math.PI;
          this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * (120 + interceptAngle), radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
          this.turn2.sweepAngle = turnSign * (210 + interceptAngle);
          this.turn3.itp = this.turn2.ftp;
          this.turn3.sweepAngle = -turnSign * interceptAngle;
          this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * (120 + interceptAngle), radius, this.turn3.itp.lat, this.turn3.itp.long);
          this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
        } else {
          // we are intercepting from the outside with room for 45 deg capture
          this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
          this.turn2.sweepAngle = turnSign * 255;
          const straightDist = Math.sqrt(2 * (Math.SQRT2 - radii2Inbound) ** 2) * radius;
          this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 255, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
          this.turn3.sweepAngle = -turnSign * 45;
          this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, radius, this.turn3.itp.lat, this.turn3.itp.long);
          this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
          this.computedPath.push({
            type: PathVectorType.Line,
            startPoint: this.turn2.ftp,
            endPoint: this.turn3.itp
          });
        }
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn2.itp,
          endPoint: this.turn2.ftp,
          centrePoint: this.turn2.arcCentre,
          sweepAngle: this.turn2.sweepAngle
        });
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn3.itp,
          endPoint: this.turn3.ftp,
          centrePoint: this.turn3.arcCentre,
          sweepAngle: this.turn3.sweepAngle
        });
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn3.ftp,
          endPoint: this.nextLeg.fix.infos.coordinates
        });
      }
      computeParallelEntry() {
        this.entry = EntryType.Parallel;
        const {
          radius,
          legLength
        } = this.nextLeg.geometry;
        const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
        this.turn1.itp = this.nextLeg.fix.infos.coordinates;
        this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + (this.nextLeg.turnDirection === TurnDirection.Right ? -90 : 90), radius, this.turn1.itp.lat, this.turn1.itp.long);
        this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180);
        const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (this.nextLeg.turnDirection === TurnDirection.Right ? 90 : -90));
        this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
        this.computedPath.length = 0;
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn1.itp,
          endPoint: this.turn1.ftp,
          centrePoint: this.turn1.arcCentre,
          sweepAngle: this.turn1.sweepAngle
        });
        const turn1Rads = Math.abs(this.turn1.sweepAngle) * Math.PI / 180;
        const minStraightDistance = 0.1 + 2 * Math.cos(1 - Math.SQRT2 / 2 - Math.sin(turn1Rads)) * radius;
        const nominalStraightDistance = 1.15 * legLength - radius * Math.sin(turn1Rads);
        const straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
        this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + 180, straightDistance, this.turn1.ftp.lat, this.turn1.ftp.long);
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn1.ftp,
          endPoint: this.turn2.itp
        });
        this.straightCourse = Avionics.Utils.computeGreatCircleHeading(this.turn1.ftp, this.turn2.itp);
        this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn2.itp.lat, this.turn2.itp.long);
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 45, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
        this.turn2.sweepAngle = turnSign * -225;
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn2.itp,
          endPoint: this.turn2.ftp,
          centrePoint: this.turn2.arcCentre,
          sweepAngle: this.turn2.sweepAngle
        });
        const ftp2ToInboundAbeamRadii = Math.cos(turn1Rads) + Math.SQRT2 / 2;
        const straightDist = Math.sqrt(2 * (ftp2ToInboundAbeamRadii - (1 - Math.SQRT2 / 2)) ** 2) * radius;
        this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn2.ftp,
          endPoint: this.turn3.itp
        });
        this.turn3.sweepAngle = turnSign * 45;
        this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 45, radius, this.turn3.itp.lat, this.turn3.itp.long);
        this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
        this.computedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.turn3.itp,
          endPoint: this.turn3.ftp,
          centrePoint: this.turn3.arcCentre,
          sweepAngle: this.turn3.sweepAngle
        });
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn3.ftp,
          endPoint: this.nextLeg.fix.infos.coordinates
        });
      }
      recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack) {
        // TODO only HX leg drives this

        const hxInbound = this.outboundCourse;
        const entryAngle = Avionics.Utils.diffAngle(this.inboundCourse, hxInbound);
        if (this.frozen) {
          if (this.state === EntryState.Done) {
            this.computedPath.length = 0;
          }
          return;
        }
        if (isActive && !this.frozen) {
          this.frozen = true;
        }
        // TODO freeze once we're active?

        // TODO, should HA entry become null when the leg is no longer flown?
        // might have bad implications for the next leg, and also for straying outside protected area
        // related: if we still fly the entry... should we shorten the leg length to minimum?
        if (!this.previousLeg || entryAngle >= -3 && entryAngle <= 3) {
          this.computeNullEntry();
          this.setHxEntry();
          this.isNull = true;
          return;
        }
        this.isNull = false;

        // parallel entry is always used when entering from opposite of hold course...
        // we give a 3 degree tolerance to allow for mag var, calculation errors etc.
        if (this.nextLeg.turnDirection === TurnDirection.Left) {
          if (entryAngle > 110 && entryAngle < 177) {
            this.computeTeardropEntry();
          } else if (entryAngle >= 177 && entryAngle <= 180 || entryAngle > -180 && entryAngle < -70) {
            this.computeParallelEntry();
          } else if (entryAngle >= -70 && entryAngle < -3) {
            this.computeDirectTurnEntry();
          } else {
            this.computeDirectOutboundEntry();
          }
        } else if (this.nextLeg.turnDirection === TurnDirection.Right) {
          if (entryAngle > -177 && entryAngle < -110) {
            this.computeTeardropEntry();
          } else if (entryAngle > 70 && entryAngle <= 180 || entryAngle > -180 && entryAngle <= -177) {
            this.computeParallelEntry();
          } else if (entryAngle > 3 && entryAngle <= 70) {
            this.computeDirectTurnEntry();
          } else {
            this.computeDirectOutboundEntry();
          }
        }

        // prepare the HX leg for our entry type
        this.setHxEntry();
      }
      getPathStartPoint() {
        return this.getTurningPoints()[0];
      }
      getPathEndPoint() {
        return this.getTurningPoints()[1];
      }
      get repr() {
        return "HOLD ENTRY(".concat(this.nextLeg.repr, ")");
      }
    }

    // Copyright (c) 2021-2022 FlyByWire Simulations
    class TransitionPicker {
      static forLegs(from, to) {
        if (from instanceof AFLeg) {
          return TransitionPicker.fromAF(from, to);
        }
        if (from instanceof CALeg) {
          return TransitionPicker.fromCA(from, to);
        }
        if (from instanceof CFLeg) {
          return TransitionPicker.fromCF(from, to);
        }
        if (from instanceof DFLeg) {
          return TransitionPicker.fromDF(from, to);
        }
        if (from instanceof HALeg || from instanceof HFLeg || from instanceof HMLeg) {
          return TransitionPicker.fromHX(from, to);
        }
        if (from instanceof PILeg) {
          return TransitionPicker.fromPI(from, to);
        }
        if (from instanceof RFLeg) {
          return TransitionPicker.fromRF(from, to);
        }
        if (from instanceof TFLeg) {
          return TransitionPicker.fromTF(from, to);
        }
        if (from instanceof CILeg) {
          return TransitionPicker.fromCI(from, to);
        }
        if (from instanceof CRLeg) {
          return TransitionPicker.fromCR(from, to);
        }
        if (from instanceof VMLeg) {
          return TransitionPicker.fromVM(from, to);
        }
        return null;
      }
      static fromCA(from, to) {
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CFLeg) {
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof DFLeg) {
          return new DirectToFixTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof TFLeg) {
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof VMLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
      static fromAF(from, to) {
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CFLeg) {
          // FIXME fixed radius / revert to path capture
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
          return new HoldEntryTransition(from, to);
        }
        if (to instanceof TFLeg) {
          return new DmeArcTransition(from, to);
        }
        if (to instanceof VMLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
      static fromCF(from, to) {
        if (to instanceof AFLeg) {
          return new DmeArcTransition(from, to);
        }
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CFLeg) {
          // FIXME fixed radius / revert to path capture
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof DFLeg) {
          return new DirectToFixTransition(from, to);
        }
        if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
          return new HoldEntryTransition(from, to);
        }
        if (to instanceof PILeg) {
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof TFLeg) {
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof VMLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
      static fromCI(from, to) {
        if (to instanceof AFLeg) {
          return new DmeArcTransition(from, to);
        }
        if (to instanceof CFLeg) {
          return new FixedRadiusTransition(from, to);
        }
        return null;
      }
      static fromDF(from, to) {
        if (to instanceof AFLeg) {
          return new DmeArcTransition(from, to);
        }
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CFLeg) {
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof DFLeg) {
          return new DirectToFixTransition(from, to);
        }
        if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
          return new HoldEntryTransition(from, to);
        }
        if (to instanceof PILeg) {
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof TFLeg) {
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof VMLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
      static fromHX(from, to) {
        if (to instanceof AFLeg) {
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CFLeg) {
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof DFLeg) {
          return new DirectToFixTransition(from, to);
        }
        if (to instanceof TFLeg) {
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof VMLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
      static fromPI(from, to) {
        if (!(to instanceof CFLeg)) {
          console.error('PI -> !CF', from, to);
        }
        return null;
      }
      static fromRF(from, to) {
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
          return new HoldEntryTransition(from, to);
        }
        return null;
      }
      static fromTF(from, to) {
        if (to instanceof AFLeg) {
          return new DmeArcTransition(from, to);
        }
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CFLeg) {
          // FIXME / revert to fixed radius
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof DFLeg) {
          return new DirectToFixTransition(from, to);
        }
        if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
          return new HoldEntryTransition(from, to);
        }
        if (to instanceof PILeg) {
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof TFLeg) {
          return new FixedRadiusTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof VMLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
      static fromCR(from, to) {
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CFLeg) {
          // FIXME / revert to fixed radius
          return new PathCaptureTransition(from, to);
        }
        if (to instanceof DFLeg) {
          return new DirectToFixTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof VMLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
      static fromVM(from, to) {
        if (to instanceof CALeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof DFLeg) {
          return new DirectToFixTransition(from, to);
        }
        if (to instanceof CILeg) {
          return new CourseCaptureTransition(from, to);
        }
        if (to instanceof CRLeg) {
          return new CourseCaptureTransition(from, to);
        }
        return null;
      }
    }

    function isGuidableCapturingPath(guidable) {
      return !(guidable instanceof CALeg || guidable instanceof CILeg || guidable instanceof CRLeg || guidable instanceof VMLeg || guidable instanceof CourseCaptureTransition);
    }
    class Geometry {
      /**
       * The list of transitions between legs.
       * - entry n: transition after leg n
       */

      /**
       * The list of legs in this geometry, possibly connected through transitions:
       * - entry n: nth leg, before transition n
       */

      constructor(transitions, legs, temp) {
        this.temp = temp;
        _defineProperty$2(this, "transitions", void 0);
        _defineProperty$2(this, "legs", void 0);
        _defineProperty$2(this, "version", 0);
        _defineProperty$2(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
        _defineProperty$2(this, "isComputed", false);
        _defineProperty$2(this, "cachedVectors", []);
        _defineProperty$2(this, "cachedVectorsVersion", 0);
        this.transitions = transitions;
        this.legs = legs;
      }
      getAllPathVectors(activeLegIndex) {
        if (this.version === this.cachedVectorsVersion) {
          return this.cachedVectors;
        }
        const transmitHoldEntry = !this.temp;
        const ret = [];
        for (const [index, leg] of this.legs.entries()) {
          if (leg.isNull) {
            continue;
          }

          // TODO don't transmit any course reversals when this side range >= 160
          const transmitCourseReversal = index === activeLegIndex || index === activeLegIndex + 1;
          if (activeLegIndex !== undefined) {
            if (isCourseReversalLeg(leg) && !transmitCourseReversal) {
              continue;
            }
            if (index < activeLegIndex) {
              continue;
            }
          }
          const legInboundTransition = leg.inboundGuidable instanceof Transition ? leg.inboundGuidable : null;
          if (legInboundTransition && !legInboundTransition.isNull && (!isHold(leg) || transmitHoldEntry)) {
            ret.push(...legInboundTransition.predictedPath);
          }
          if (leg) {
            ret.push(...leg.predictedPath);
          }
        }
        this.cachedVectors = ret;
        this.cachedVectorsVersion = this.version;
        return ret;
      }

      /**
       * Recomputes the guidable using new parameters
       *
       * @param tas             predicted true airspeed speed of the current leg (for a leg) or the next leg (for a transition) in knots
       * @param gs              predicted ground speed of the current leg
       * @param ppos            present position coordinates
       * @param trueTrack       present true track
       * @param activeLegIdx    current active leg index
       * @param activeTransIdx  current active transition index
       */
      recomputeWithParameters(tas, gs, ppos, trueTrack, activeLegIdx, _activeTransIdx) {
        this.version++;
        for (let i = activeLegIdx !== null && activeLegIdx !== void 0 ? activeLegIdx : 0; this.legs.get(i) || this.legs.get(i + 1); i++) {
          if (!this.legs.has(i)) {
            continue;
          }
          const leg = this.legs.get(i);
          const wasNull = leg.isNull;
          this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs);

          // If a leg became null/not null, we immediately recompute it to calculate the new guidables and transitions
          if (!wasNull && leg.isNull || wasNull && !leg.isNull) {
            this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs);
          }
        }
      }
      static getLegPredictedTas(leg, currentTas) {
        var _leg$predictedTas;
        return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_leg$predictedTas = leg.predictedTas) !== null && _leg$predictedTas !== void 0 ? _leg$predictedTas : currentTas);
      }
      static getLegPredictedGs(leg, currentGs) {
        var _leg$predictedGs;
        return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_leg$predictedGs = leg.predictedGs) !== null && _leg$predictedGs !== void 0 ? _leg$predictedGs : currentGs);
      }
      computeLeg(index, activeLegIdx, ppos, trueTrack, tas, gs) {
        const prevLeg = this.legs.get(index - 1);
        const leg = this.legs.get(index);
        const nextLeg = this.legs.get(index + 1);
        const nextNextLeg = this.legs.get(index + 2);
        const inboundTransition = this.transitions.get(index - 1);
        const outboundTransition = this.transitions.get(index);
        const legPredictedTas = Geometry.getLegPredictedTas(leg, tas);
        const legPredictedGs = Geometry.getLegPredictedGs(leg, gs);

        // If the leg is null, we compute the following:
        //  - transition from prevLeg to nextLeg
        //  - nextLeg
        //  - transition from nextLeg to nextNextLeg (in order to compute nextLeg)
        if (leg !== null && leg !== void 0 && leg.isNull) {
          if (nextLeg) {
            var _newInboundTransition, _newOutboundTransitio;
            let newInboundTransition;
            {
              newInboundTransition = TransitionPicker.forLegs(prevLeg, nextLeg);
            }
            let newOutboundTransition;
            if (nextNextLeg && LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE === -1 || index + 1 - activeLegIdx < LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE) {
              newOutboundTransition = TransitionPicker.forLegs(nextLeg, nextNextLeg);
            }
            if (newInboundTransition && prevLeg) {
              const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
              const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
              newInboundTransition.setNeighboringGuidables(prevLeg, nextLeg);
              newInboundTransition.recomputeWithParameters(activeLegIdx === index, prevLegPredictedLegTas, prevLegPredictedLegGs, ppos, trueTrack);
            }
            const nextLegPredictedLegTas = Geometry.getLegPredictedTas(nextLeg, tas);
            const nextLegPredictedLegGs = Geometry.getLegPredictedGs(nextLeg, gs);
            nextLeg.setNeighboringGuidables((_newInboundTransition = newInboundTransition) !== null && _newInboundTransition !== void 0 ? _newInboundTransition : prevLeg, (_newOutboundTransitio = newOutboundTransition) !== null && _newOutboundTransitio !== void 0 ? _newOutboundTransitio : nextNextLeg);
            nextLeg.recomputeWithParameters(activeLegIdx === index, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
            if (newOutboundTransition) {
              newOutboundTransition.setNeighboringGuidables(nextLeg, nextNextLeg);
              newOutboundTransition.recomputeWithParameters(activeLegIdx === index + 1, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
              nextLeg.recomputeWithParameters(activeLegIdx === index, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
            }
          }
        }
        if (inboundTransition && prevLeg) {
          const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
          const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
          inboundTransition.setNeighboringGuidables(prevLeg, leg);
          inboundTransition.setNeighboringLegs(prevLeg, leg);
          inboundTransition.recomputeWithParameters(activeLegIdx === index, prevLegPredictedLegTas, prevLegPredictedLegGs, ppos, trueTrack);
        }

        // Compute leg and outbound if previous leg isn't null (we already computed 1 leg forward the previous iteration)
        if (!(prevLeg && prevLeg.isNull)) {
          leg.setNeighboringGuidables(inboundTransition !== null && inboundTransition !== void 0 ? inboundTransition : prevLeg, outboundTransition !== null && outboundTransition !== void 0 ? outboundTransition : nextLeg);
          leg.recomputeWithParameters(activeLegIdx === index, legPredictedTas, legPredictedGs, ppos, trueTrack);
          if (outboundTransition && nextLeg) {
            outboundTransition.setNeighboringGuidables(leg, nextLeg);
            outboundTransition.setNeighboringLegs(leg, nextLeg);
            outboundTransition.recomputeWithParameters(activeLegIdx === index + 1, legPredictedTas, legPredictedGs, ppos, trueTrack);

            // Since the outbound transition can have TAD, we recompute the leg again to make sure the end point is at the right place for this cycle
            leg.setNeighboringGuidables(inboundTransition !== null && inboundTransition !== void 0 ? inboundTransition : prevLeg, outboundTransition);
            leg.recomputeWithParameters(activeLegIdx === index, legPredictedTas, legPredictedGs, ppos, trueTrack);
          }
        }
      }

      /**
       * @param activeLegIdx
       * @param ppos
       * @param trueTrack
       * @param gs
       * @param tas
       */
      getGuidanceParameters(activeLegIdx, ppos, trueTrack, gs, tas) {
        const activeLeg = this.legs.get(activeLegIdx);
        const nextLeg = this.legs.get(activeLegIdx + 1);

        // TODO handle in guidance controller state
        const autoSequencing = !(activeLeg !== null && activeLeg !== void 0 && activeLeg.disableAutomaticSequencing);
        let activeGuidable = null;
        let nextGuidable = null;

        // first, check if we're abeam with one of the transitions (start or end)
        const fromTransition = this.transitions.get(activeLegIdx - 1);
        const toTransition = this.transitions.get(activeLegIdx);
        if (fromTransition && !fromTransition.isNull && fromTransition.isAbeam(ppos)) {
          if (!fromTransition.isFrozen) {
            fromTransition.freeze();
          }

          // Since CA leg CourseCaptureTransition inbound starts at PPOS, we always consider the CA leg as the active guidable
          if (fromTransition instanceof CourseCaptureTransition && activeLeg instanceof CALeg) {
            activeGuidable = activeLeg;
            nextGuidable = toTransition;
          } else {
            activeGuidable = fromTransition;
            nextGuidable = activeLeg;
          }
        } else if (toTransition && !toTransition.isNull && autoSequencing) {
          // TODO need to check that the previous leg is actually flown first...
          if (toTransition.isAbeam(ppos)) {
            if (toTransition instanceof FixedRadiusTransition && !toTransition.isFrozen) {
              toTransition.freeze();
            }
            activeGuidable = toTransition;
            nextGuidable = nextLeg;
          } else if (activeLeg) {
            activeGuidable = activeLeg;
            nextGuidable = toTransition;
          }
        } else if (activeLeg) {
          activeGuidable = activeLeg;
          if (nextLeg && autoSequencing) {
            nextGuidable = nextLeg;
          }
        }

        // figure out guidance params and roll anticipation
        let guidanceParams;
        let rad;
        let dtg;
        if (activeGuidable) {
          const phiLimit = maxBank(tas, isGuidableCapturingPath(activeGuidable));
          guidanceParams = _objectSpread2(_objectSpread2({}, activeGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs)), {}, {
            phiLimit
          });
          dtg = activeGuidable.getDistanceToGo(ppos);
          if (activeGuidable && nextGuidable) {
            rad = this.getGuidableRollAnticipationDistance(gs, activeGuidable, nextGuidable);
            if (rad > 0 && dtg <= rad) {
              const nextGuidanceParams = nextGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs);
              if (nextGuidanceParams.law === ControlLaw.LATERAL_PATH) {
                var _nextGuidanceParams$p;
                guidanceParams.phiCommand = (_nextGuidanceParams$p = nextGuidanceParams === null || nextGuidanceParams === void 0 ? void 0 : nextGuidanceParams.phiCommand) !== null && _nextGuidanceParams$p !== void 0 ? _nextGuidanceParams$p : 0;
              }
            }
          }
        }
        return guidanceParams;
      }
      getGuidableRollAnticipationDistance(gs, from, to) {
        if (!from.endsInCircularArc && !to.startsInCircularArc) {
          return 0;
        }

        // get nominal phi from previous and next leg
        const phiNominalFrom = from.endsInCircularArc ? from.getNominalRollAngle(gs) : 0;
        const phiNominalTo = to.startsInCircularArc ? to.getNominalRollAngle(gs) : 0;

        // TODO consider case where RAD > transition distance

        return Geometry.getRollAnticipationDistance(gs, phiNominalFrom, phiNominalTo);
      }
      static getRollAnticipationDistance(gs, bankA, bankB) {
        // calculate delta phi
        const deltaPhi = Math.abs(bankA - bankB);

        // calculate RAD
        const maxRollRate = 5; // deg / s, TODO picked off the wind
        const k2 = 0.0038;
        const rad = gs / 3600 * (Math.sqrt(1 + 2 * k2 * 9.81 * deltaPhi / maxRollRate) - 1) / (k2 * 9.81);
        return rad;
      }
      getDistanceToGo(activeLegIdx, ppos) {
        const activeLeg = this.legs.get(activeLegIdx);
        if (activeLeg) {
          return activeLeg.getDistanceToGo(ppos);
        }
        return null;
      }
      shouldSequenceLeg(activeLegIdx, ppos) {
        const activeLeg = this.legs.get(activeLegIdx);
        const inboundTransition = this.transitions.get(activeLegIdx - 1);

        // Restrict sequencing in cases where we are still in inbound transition. Make an exception for very short legs as the transition could be overshooting.
        if (!(inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isNull) && inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isAbeam(ppos) && activeLeg.distance > 0.01) {
          return false;
        }
        const dtg = activeLeg.getDistanceToGo(ppos);
        if (dtg <= 0 || activeLeg.isNull) {
          return true;
        }
        if (activeLeg) {
          return activeLeg.getDistanceToGo(ppos) < 0.001;
        }
        return false;
      }
      onLegSequenced(_sequencedLeg, nextLeg, followingLeg) {
        if (isCourseReversalLeg(nextLeg) || isCourseReversalLeg(followingLeg)) {
          this.version++;
        }
      }
      legsInSegment(segmentType) {
        const newMap = new Map();
        for (const entry of this.legs.entries()) {
          if (entry[1].segment === segmentType) {
            newMap.set(...entry);
          }
        }
        return newMap;
      }

      /**
       * Returns DTG for a complete leg path, taking into account transitions (including split FXR)
       *
       * @param ppos      present position
       * @param leg       the leg guidable
       * @param inbound   the inbound transition guidable, if present
       * @param outbound  the outbound transition guidable, if present
       */
      static completeLegPathDistanceToGo(ppos, leg, inbound, outbound) {
        const [, legPartLength, outboundTransLength] = Geometry.completeLegPathLengths(leg, inbound, outbound);
        if (outbound && outbound.isAbeam(ppos)) {
          return outbound.getDistanceToGo(ppos) - outbound.distance / 2; // Remove half of the transition length, since it is split (Type I)
        }

        if (inbound && inbound.isAbeam(ppos)) {
          return inbound.getDistanceToGo(ppos) + legPartLength + outboundTransLength;
        }
        return leg.getDistanceToGo(ppos) - (outbound && outbound instanceof FixedRadiusTransition ? outbound.unflownDistance : 0) + outboundTransLength;
      }

      /**
       * Returns lengths of the different segments of a leg, taking into account transitions (including split FXR)
       *
       * @param leg       the leg guidable
       * @param inbound   the inbound transition guidable, if present
       * @param outbound  the outbound transition guidable, if present
       */
      static completeLegPathLengths(leg, inbound, outbound) {
        let inboundLength = 0;
        let outboundLength = 0;
        if (outbound) {
          if (outbound instanceof FixedRadiusTransition) {
            // Type I transitions are split between the prev and next legs
            outboundLength = outbound.distance / 2;
          }
        }
        if (inbound) {
          if (inbound instanceof FixedRadiusTransition) {
            // Type I transitions are split between the prev and next legs
            inboundLength = inbound.distance / 2;
          } else {
            inboundLength = inbound.distance;
          }
        }
        return [inboundLength, leg.distance, outboundLength];
      }
    }

    let HxLegGuidanceState;

    // TODO make sure IMM EXIT works during teardrop/parallel (proceed to HF via that entry then sequence the HM immediately)
    // TODO move HMLeg specific logic to HMLeg
    (function (HxLegGuidanceState) {
      HxLegGuidanceState[HxLegGuidanceState["Inbound"] = 0] = "Inbound";
      HxLegGuidanceState[HxLegGuidanceState["Arc1"] = 1] = "Arc1";
      HxLegGuidanceState[HxLegGuidanceState["Outbound"] = 2] = "Outbound";
      HxLegGuidanceState[HxLegGuidanceState["Arc2"] = 3] = "Arc2";
    })(HxLegGuidanceState || (HxLegGuidanceState = {}));
    class HXLeg extends XFLeg {
      // TODO consider different entries for initial state...
      // TODO make protected when done with DebugHXLeg

      /**
       * Predicted tas for next prediction update
       * Not including wind
       */

      /**
       * Nominal TAS used for the current prediction
       * Not including wind
       */

      /**
       * Nominal ground speed used the current prediction
       * including wind
       */

      /**
       * Wind velocity along the inbound leg
       */

      /**
       * Current predicted hippodrome geometry
       */

      constructor(fix, metadata, segment) {
        super(fix);
        this.metadata = metadata;
        this.segment = segment;
        _defineProperty$2(this, "state", HxLegGuidanceState.Inbound);
        _defineProperty$2(this, "initialState", HxLegGuidanceState.Inbound);
        _defineProperty$2(this, "termConditionMet", false);
        _defineProperty$2(this, "nextPredictedTas", 180);
        _defineProperty$2(this, "currentPredictedTas", 180);
        _defineProperty$2(this, "currentPredictedGs", 180);
        _defineProperty$2(this, "inboundWindSpeed", void 0);
        _defineProperty$2(this, "geometry", void 0);
        this.geometry = this.computeGeometry();
      }
      get inboundLegCourse() {
        return this.fix.additionalData.course;
      }
      get outboundLegCourse() {
        return (this.inboundLegCourse + 180) % 360;
      }
      get turnDirection() {
        return this.fix.turnDirection;
      }
      get ident() {
        return this.fix.ident;
      }

      /**
       * Used by hold entry transition to set our initial state depending on entry type
       * @param initialState
       */
      setInitialState(initialState) {
        // TODO check if already active and deny...
        this.state = initialState;
        this.initialState = initialState;
      }
      get outboundStartPoint() {
        const {
          fixB
        } = this.computeGeometry();
        return fixB;
      }
      computeLegDistance() {
        var _this$fix$legAltitude, _this$inboundWindSpee;
        // is distance in NM?
        if (this.fix.additionalData.distance !== undefined) {
          return this.fix.additionalData.distance;
        }
        const alt = (_this$fix$legAltitude = this.fix.legAltitude1) !== null && _this$fix$legAltitude !== void 0 ? _this$fix$legAltitude : SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet');

        // distance is in time then...
        const defaultMinutes = alt < 14000 ? 1 : 1.5;
        const inboundGroundSpeed = this.currentPredictedTas + ((_this$inboundWindSpee = this.inboundWindSpeed) !== null && _this$inboundWindSpee !== void 0 ? _this$inboundWindSpee : 0);
        return (this.fix.additionalData.distanceInMinutes !== undefined ? this.fix.additionalData.distanceInMinutes : defaultMinutes) * inboundGroundSpeed / 60;
      }
      computeGeometry() {
        /*
         * We define some fixes at the turning points around the hippodrome like so (mirror vertically for left turn):
         *         A          B
         *         *----------*
         *       /              \
         * arc1 |  *          *  | arc2
         *       \              /
         *         *<---------*
         *      hold fix      C
         */

        const legLength = this.computeLegDistance();
        const radius = this.radius;
        const turnSign = this.turnDirection === TurnDirection.Left ? -1 : 1;
        const fixA = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius * 2, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
        const fixB = Avionics.Utils.bearingDistanceToCoordinates(this.outboundLegCourse, legLength, fixA.lat, fixA.long);
        const fixC = Avionics.Utils.bearingDistanceToCoordinates(this.outboundLegCourse, legLength, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
        const arcCentreFix1 = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
        const arcCentreFix2 = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius, fixC.lat, fixC.long);
        return {
          fixA,
          fixB,
          fixC,
          arcCentreFix1,
          arcCentreFix2,
          sweepAngle: turnSign * 180,
          legLength,
          radius
        };
      }
      get radius() {
        const gsMs = this.currentPredictedGs / 1.94384;
        const radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(this.currentPredictedTas, true) * Math.PI / 180)) / 1852;
        return radius;
      }
      get terminationPoint() {
        return this.fix.infos.coordinates;
      }
      get distance() {
        return 0; // 0 so no PWPs
      }

      get inboundCourse() {
        return this.inboundLegCourse;
      }
      get outboundCourse() {
        return this.inboundLegCourse;
      }
      get startsInCircularArc() {
        // this is intended to be used only for entry...
        return this.state === HxLegGuidanceState.Arc1 || this.state === HxLegGuidanceState.Arc2;
      }

      /**
       *
       * @param tas
       * @returns
       */
      getNominalRollAngle(gs) {
        return this.endsInCircularArc ? maxBank(gs, true) : 0;
      }
      getDistanceToGoThisOrbit(ppos) {
        const {
          fixB,
          arcCentreFix1,
          arcCentreFix2,
          sweepAngle
        } = this.geometry;
        switch (this.state) {
          case HxLegGuidanceState.Inbound:
            return courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
          case HxLegGuidanceState.Arc1:
            return arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle) + this.computeLegDistance() * 2 + this.radius * Math.PI;
          case HxLegGuidanceState.Outbound:
            return courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB) + this.computeLegDistance() + this.radius * Math.PI;
          case HxLegGuidanceState.Arc2:
            return arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle) + this.computeLegDistance();
          // no default
        }

        return 1;
      }
      getDistanceToGo(ppos) {
        return this.getDistanceToGoThisOrbit(ppos);
      }
      getHippodromePath() {
        const {
          fixA,
          fixB,
          fixC,
          arcCentreFix1,
          arcCentreFix2,
          sweepAngle
        } = this.geometry;
        return [{
          type: PathVectorType.Arc,
          startPoint: this.fix.infos.coordinates,
          centrePoint: arcCentreFix1,
          endPoint: fixA,
          sweepAngle
        }, {
          type: PathVectorType.Line,
          startPoint: fixA,
          endPoint: fixB
        }, {
          type: PathVectorType.Arc,
          startPoint: fixB,
          centrePoint: arcCentreFix2,
          endPoint: fixC,
          sweepAngle
        }, {
          type: PathVectorType.Line,
          startPoint: fixC,
          endPoint: this.fix.infos.coordinates
        }];
      }
      get predictedPath() {
        return this.getHippodromePath();
      }
      updateState(ppos, tas, geometry) {
        let dtg = 0;

        // TODO divide up into sectors and choose based on that?

        switch (this.state) {
          case HxLegGuidanceState.Inbound:
            {
              dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
              break;
            }
          case HxLegGuidanceState.Arc1:
            {
              dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, geometry.arcCentreFix1, geometry.sweepAngle);
              break;
            }
          case HxLegGuidanceState.Outbound:
            {
              dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, geometry.fixB);
              break;
            }
          case HxLegGuidanceState.Arc2:
            {
              dtg = arcDistanceToGo(ppos, geometry.fixB, geometry.arcCentreFix2, geometry.sweepAngle);
              break;
            }
          default:
            throw new Error("Bad HxLeg state ".concat(this.state));
        }
        if (dtg <= 0) {
          if (this.state === HxLegGuidanceState.Inbound) {
            if (this.termConditionMet) {
              return;
            }
            this.updatePrediction();
          }
          this.state = (this.state + 1) % (HxLegGuidanceState.Arc2 + 1);
          console.log("HX switched to state ".concat(HxLegGuidanceState[this.state]));
        }
      }
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        const {
          fixB,
          arcCentreFix1,
          arcCentreFix2,
          sweepAngle,
          legLength
        } = this.geometry;
        this.updateState(ppos, tas, this.geometry);
        let params;
        let dtg;
        let nextPhi = 0;
        let rad = 0;
        switch (this.state) {
          case HxLegGuidanceState.Inbound:
            params = courseToFixGuidance(ppos, trueTrack, this.inboundLegCourse, this.fix.infos.coordinates);
            dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
            nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
            rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
            break;
          case HxLegGuidanceState.Arc1:
            params = arcGuidance(ppos, trueTrack, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
            dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
            rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
            if (legLength <= rad) {
              nextPhi = params.phiCommand;
            }
            break;
          case HxLegGuidanceState.Outbound:
            params = courseToFixGuidance(ppos, trueTrack, this.outboundLegCourse, fixB);
            dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB);
            nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
            rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
            break;
          case HxLegGuidanceState.Arc2:
            params = arcGuidance(ppos, trueTrack, fixB, arcCentreFix2, sweepAngle);
            dtg = arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle);
            rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
            if (legLength <= rad) {
              nextPhi = params.phiCommand;
            }
            break;
          default:
            throw new Error("Bad HxLeg state ".concat(this.state));
        }

        // TODO HF/HA too
        if (dtg <= rad && !(this.state === HxLegGuidanceState.Inbound && this.termConditionMet)) {
          params.phiCommand = nextPhi;
        }
        return params;
      }
      recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack, _startAltitude, _verticalSpeed) {
        if (!isActive) {
          this.updatePrediction();
        }
      }
      setPredictedTas(tas) {
        this.nextPredictedTas = tas;
      }

      /**
       * Should be called on each crossing of the hold fix
       */
      updatePrediction() {
        const windDirection = SimVar.GetSimVarValue('AMBIENT WIND DIRECTION', 'Degrees');
        const windSpeed = SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', 'Knots');
        const windAngleToInbound = Math.abs(Avionics.Utils.diffAngle(reciprocal(windDirection), this.inboundLegCourse));
        this.inboundWindSpeed = Math.cos(windAngleToInbound * Math.PI / 180) * windSpeed;
        this.currentPredictedTas = this.nextPredictedTas;
        this.currentPredictedGs = this.currentPredictedTas + windSpeed;
        this.geometry = this.computeGeometry();

        // TODO update entry transition too
      }

      // TODO are we even using this? What exactly should it tell us?
      isAbeam(_ppos) {
        return false;
      }
      getPathStartPoint() {
        return this.fix.infos.coordinates;
      }
      getPathEndPoint() {
        // TODO consider early exit to CF on HF leg
        return this.fix.infos.coordinates;
      }
    }
    class HMLeg extends HXLeg {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "immExitLength", void 0);
      }
      /**
       * Use for IMM EXIT set/reset function on the MCDU
       * Note: if IMM EXIT is set before this leg is active it should be deleted from the f-pln instead
       * @param
       */
      setImmediateExit(exit, ppos, tas) {
        // TODO if we're still in the entry transition, HM becomes empty, but still fly the entry

        const {
          legLength,
          fixA,
          sweepAngle
        } = this.geometry;
        if (exit) {
          switch (this.state) {
            case HxLegGuidanceState.Arc1:
              // let's do a circle
              this.immExitLength = 0;
              break;
            case HxLegGuidanceState.Outbound:
              const nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
              const rad = Geometry.getRollAnticipationDistance(tas, 0, nextPhi);
              this.immExitLength = Math.min(legLength, rad + courseToFixDistanceToGo(ppos, this.inboundLegCourse, fixA));
              break;
            case HxLegGuidanceState.Arc2:
            case HxLegGuidanceState.Inbound:
              // keep the normal leg distance as we can't shorten
              this.immExitLength = legLength;
              break;
            // no default
          }
        }

        // hack to allow f-pln page to see state
        this.fix.additionalData.immExit = exit;
        this.termConditionMet = exit;

        // if resuming hold, the geometry will be recomputed on the next pass of the hold fix
        if (exit) {
          this.geometry = this.computeGeometry();
        }
      }
      computeLegDistance() {
        if (this.termConditionMet) {
          return this.immExitLength;
        }
        return super.computeLegDistance();
      }
      get disableAutomaticSequencing() {
        return !this.termConditionMet;
      }
      get repr() {
        return "HM '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection]);
      }
    }

    // TODO
    /*
    If the aircraft reaches or exceeds the altitude
    specified in the flight plan before the HA leg is active, the aircraft
    does not enter the hold
    */
    class HALeg extends HXLeg {
      constructor(to, metadata, segment) {
        super(to, metadata, segment);

        // the term altitude is guaranteed to be at or above, and in field altitude1, by ARINC424 coding rules
        this.to = to;
        this.metadata = metadata;
        this.segment = segment;
        _defineProperty$2(this, "targetAltitude", void 0);
        if (this.fix.legAltitudeDescription !== AltitudeDescriptor.AtOrAbove) {
          console.warn("HALeg invalid altitude descriptor ".concat(this.fix.legAltitudeDescription, ", must be ").concat(AltitudeDescriptor.AtOrAbove));
        }
        this.targetAltitude = this.fix.legAltitude1;
      }
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        if (SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') >= this.targetAltitude) {
          this.termConditionMet = true;
        }
        return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
      }
      recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
        if (SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') >= this.targetAltitude) {
          this.termConditionMet = true;
        }
        if (!isActive && this.termConditionMet) {
          this.isNull = true;
        }
        this.setPredictedTas(tas);
        super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
      }
      getDistanceToGo(ppos) {
        if (this.isNull) {
          return 0;
        }
        if (this.termConditionMet) {
          return this.getDistanceToGoThisOrbit(ppos);
        }
        const {
          legLength,
          radius
        } = this.geometry;
        return legLength * 2 + radius * Math.PI * 2;
      }
      get disableAutomaticSequencing() {
        return !this.termConditionMet;
      }
      get predictedPath() {
        if (!this.isNull) {
          return super.predictedPath;
        }
        return [];
      }
      get repr() {
        return "HA '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection], " - ").concat(this.targetAltitude.toFixed(0));
      }
    }
    class HFLeg extends HXLeg {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "entryTransition", void 0);
      }
      getGuidanceParameters(ppos, trueTrack, tas, gs) {
        if (this.entryTransition) {
          this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === EntryState.Capture || this.entryTransition.state === EntryState.Done;
        }
        return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
      }
      recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
        if (this.inboundGuidable instanceof HoldEntryTransition) {
          this.entryTransition = this.inboundGuidable;
          this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === EntryState.Capture || this.entryTransition.state === EntryState.Done;
        }
        this.setPredictedTas(tas);
        super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
      }
      getDistanceToGo(ppos) {
        var _this$entryTransition, _this$entryTransition2;
        return (_this$entryTransition = (_this$entryTransition2 = this.entryTransition) === null || _this$entryTransition2 === void 0 ? void 0 : _this$entryTransition2.getDistanceToGo(ppos)) !== null && _this$entryTransition !== void 0 ? _this$entryTransition : 0;
      }
      get predictedPath() {
        return [];
      }
      get disableAutomaticSequencing() {
        return false;
      }
      get repr() {
        return "HF '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection]);
      }
    }

    /**
     * This class will guide the aircraft by predicting a flight path and
     * calculating the autopilot inputs to follow the predicted flight path.
     */
    class GuidanceManager {
      constructor(flightPlanManager) {
        _defineProperty$2(this, "flightPlanManager", void 0);
        this.flightPlanManager = flightPlanManager;
      }

      /**
       * Returns a {@link Leg} from two {@link WayPoint} objects. Only for fpm v1.
       *
       * @param from      the FROM waypoint
       * @param to        the TO waypoint
       * @param toIndex   index of the TO waypoint
       * @param segment   flight plan segment
       *
       * @private
       */
      static legFromWaypoints(prevLeg, nextLeg, from, to, toIndex, segment) {
        var _to$additionalData;
        if ((to === null || to === void 0 ? void 0 : (_to$additionalData = to.additionalData) === null || _to$additionalData === void 0 ? void 0 : _to$additionalData.legType) === LegType.IF) {
          const editableData = legMetadataFromMsfsWaypoint(to);
          if (prevLeg && prevLeg instanceof XFLeg && !prevLeg.fix.endsInDiscontinuity) {
            return new TFLeg(prevLeg.fix, to, editableData, segment);
          }
          return new IFLeg(to, editableData, segment);
        }
        if (!from || !to) {
          return null;
        }
        const metadata = legMetadataFromMsfsWaypoint(to);
        if (from.endsInDiscontinuity) {
          if ((to === null || to === void 0 ? void 0 : to.additionalData.legType) === LegType.CF || (to === null || to === void 0 ? void 0 : to.additionalData.legType) === LegType.TF) {
            return new IFLeg(to, metadata, segment);
          }
          return null;
        }
        if (to.additionalData) {
          var _to$additionalData2, _to$additionalData3, _to$additionalData4;
          if (to.additionalData.legType === LegType.AF) {
            return new AFLeg(to, to.additionalData.recommendedLocation, to.additionalData.rho, to.additionalData.thetaTrue, to.additionalData.course, metadata, segment);
          }
          if (to.additionalData.legType === LegType.CF) {
            return new CFLeg(to, to.additionalData.course, metadata, segment);
          }
          if (to.additionalData.legType === LegType.DF) {
            return new DFLeg(to, metadata, segment);
          }
          if (to.additionalData.legType === LegType.RF) {
            return new RFLeg(from, to, to.additionalData.center, metadata, segment);
          }

          // FIXME VALeg should be implemented to give proper heading guidance
          if (to.additionalData.legType === LegType.CA || to.additionalData.legType === LegType.VA) {
            var _from$additionalData$;
            const course = to.additionalData.course;
            const altitude = to.additionalData.vectorsAltitude;
            const extraLength = ((_from$additionalData$ = from.additionalData.runwayLength) !== null && _from$additionalData$ !== void 0 ? _from$additionalData$ : 0) / (2 * 1852);
            return new CALeg(course, altitude, metadata, segment, extraLength);
          }
          if (to.additionalData.legType === LegType.CI || to.additionalData.legType === LegType.VI) {
            if (!nextLeg) {
              return null;
            }
            const course = to.additionalData.course;
            return new CILeg(course, nextLeg, metadata, segment);
          }
          if (to.additionalData.legType === LegType.CR) {
            // TODO clean this whole thing up
            const course = to.additionalData.course;
            const radial = to.additionalData.thetaTrue;
            const theta = to.additionalData.theta;
            const ident = WayPoint.formatIdentFromIcao(to.additionalData.recommendedIcao);
            const originObj = {
              coordinates: to.additionalData.recommendedLocation,
              ident,
              theta
            };
            return new CRLeg(course, originObj, radial, metadata, segment);
          }
          if (((_to$additionalData2 = to.additionalData) === null || _to$additionalData2 === void 0 ? void 0 : _to$additionalData2.legType) === LegType.HA) {
            return new HALeg(to, metadata, segment);
          }
          if (((_to$additionalData3 = to.additionalData) === null || _to$additionalData3 === void 0 ? void 0 : _to$additionalData3.legType) === LegType.HF) {
            return new HFLeg(to, metadata, segment);
          }
          if (((_to$additionalData4 = to.additionalData) === null || _to$additionalData4 === void 0 ? void 0 : _to$additionalData4.legType) === LegType.HM) {
            return new HMLeg(to, metadata, segment);
          }
          if (to.additionalData.legType === LegType.PI) {
            return new PILeg(to, nextLeg, metadata, segment);
          }
        }
        if (to.isVectors) {
          return new VMLeg(to.additionalData.course, metadata, segment);
        }
        return new TFLeg(from, to, metadata, segment);
      }
      getLeg(prevLeg, nextLeg, index, flightPlanIndex) {
        const from = this.flightPlanManager.getWaypoint(index - 1, flightPlanIndex);
        const to = this.flightPlanManager.getWaypoint(index, flightPlanIndex);
        const segment = this.flightPlanManager.getSegmentFromWaypoint(to, flightPlanIndex).type;
        return GuidanceManager.legFromWaypoints(prevLeg, nextLeg, from, to, index, segment);
      }
      updateGeometry(geometry, flightPlanIndex, activeIdx, wptCount) {
        for (let i = activeIdx - 1; i < wptCount; i++) {
          const prevLeg = geometry.legs.get(i - 1);
          const oldLeg = geometry.legs.get(i);
          const nextLeg = this.getLeg(prevLeg, null, i + 1, flightPlanIndex);
          const newLeg = this.getLeg(prevLeg, nextLeg, i, flightPlanIndex);
          const legsMatch = (oldLeg === null || oldLeg === void 0 ? void 0 : oldLeg.repr) === (newLeg === null || newLeg === void 0 ? void 0 : newLeg.repr);
          if (legsMatch) {

            // Sync discontinuity info (FIXME until we have proper discontinuities)

            if (oldLeg instanceof XFLeg && newLeg instanceof XFLeg) {
              oldLeg.fix = newLeg.fix;
            }

            // Sync metadata

            if (oldLeg && newLeg) {
              oldLeg.metadata = _objectSpread2(_objectSpread2({}, oldLeg.metadata), newLeg.metadata);
            }
            const prevLeg = geometry.legs.get(i - 1);
            const oldInboundTransition = geometry.transitions.get(i - 1);
            const newInboundTransition = TransitionPicker.forLegs(prevLeg, newLeg);
            const transitionsMatch = (oldInboundTransition === null || oldInboundTransition === void 0 ? void 0 : oldInboundTransition.repr) === (newInboundTransition === null || newInboundTransition === void 0 ? void 0 : newInboundTransition.repr);
            if (!transitionsMatch) {
              geometry.transitions.set(i - 1, newInboundTransition);
            }
          } else {
            if (newLeg) {
              geometry.legs.set(i, newLeg);
              const prevLeg = geometry.legs.get(i - 1);
              const computeAllTransitions = LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE === -1;
              if (prevLeg && (computeAllTransitions )) {
                const newInboundTransition = TransitionPicker.forLegs(prevLeg, newLeg);
                if (newInboundTransition) {
                  geometry.transitions.set(i - 1, newInboundTransition);
                } else {
                  geometry.transitions.delete(i - 1);
                }
              } else {
                geometry.transitions.delete(i - 1);
              }
            } else {
              geometry.legs.delete(i);
              geometry.transitions.delete(i - 1);
              geometry.transitions.delete(i);
            }
          }
        }

        // Trim geometry

        for (const [index] of geometry.legs.entries()) {
          const legBeforePrev = index < activeIdx - 1;
          const legAfterLastWpt = index >= wptCount;
          if (legBeforePrev || legAfterLastWpt) {
            geometry.legs.delete(index);
            geometry.transitions.delete(index - 1);
          }
        }
      }

      /**
       * The full leg path geometry, used for the ND and predictions on the F-PLN page.
       */
      getMultipleLegGeometry(temp) {
        if (temp) {
          if (this.flightPlanManager.getFlightPlan(1) === undefined) {
            return undefined;
          }
        }
        const activeIdx = temp ? this.flightPlanManager.getFlightPlan(1).activeWaypointIndex : this.flightPlanManager.getCurrentFlightPlan().activeWaypointIndex;
        const legs = new Map();
        const transitions = new Map();
        const wpCount = temp ? this.flightPlanManager.getFlightPlan(1).length : this.flightPlanManager.getCurrentFlightPlan().length;
        for (let i = activeIdx - 1; i < wpCount; i++) {
          // Leg
          const prevLeg = legs.get(i - 1);
          const nextLeg = this.getLeg(prevLeg, null, i + 1, temp ? FlightPlans.Temporary : FlightPlans.Active);
          const currentLeg = this.getLeg(prevLeg, nextLeg, i, temp ? FlightPlans.Temporary : FlightPlans.Active);
          if (currentLeg) {
            legs.set(i, currentLeg);
          }

          // Transition
          const transition = TransitionPicker.forLegs(prevLeg, currentLeg);
          if (transition) {
            transitions.set(i - 1, transition);
          }
        }
        return new Geometry(transitions, legs, temp);
      }
    }

    //  Copyright (c) 2021 FlyByWire Simulations
    //  SPDX-License-Identifier: GPL-3.0

    /**
     * Types that tie pseudo waypoints to sequencing actions
     */
    let PseudoWaypointSequencingAction;
    (function (PseudoWaypointSequencingAction) {
      PseudoWaypointSequencingAction[PseudoWaypointSequencingAction["TOD_REACHED"] = 0] = "TOD_REACHED";
      PseudoWaypointSequencingAction[PseudoWaypointSequencingAction["APPROACH_PHASE_AUTO_ENGAGE"] = 1] = "APPROACH_PHASE_AUTO_ENGAGE";
    })(PseudoWaypointSequencingAction || (PseudoWaypointSequencingAction = {}));

    // Copyright (c) 2021-2022 FlyByWire Simulations
    // Copyright (c) 2021-2022 Synaptic Simulations
    //
    // SPDX-License-Identifier: GPL-3.0

    let VnavDescentMode;
    (function (VnavDescentMode) {
      VnavDescentMode[VnavDescentMode["NORMAL"] = 0] = "NORMAL";
      VnavDescentMode[VnavDescentMode["CDA"] = 1] = "CDA";
      VnavDescentMode[VnavDescentMode["DPO"] = 2] = "DPO";
    })(VnavDescentMode || (VnavDescentMode = {}));
    const VnavConfig = {
      /**
       * Whether to calculate climb profile
       */
      VNAV_CALCULATE_CLIMB_PROFILE: false,
      /**
       * Whether to emit ToD pseudo waypoint
       */
      VNAV_EMIT_TOD: false,
      /**
       * Whether to emit (DECEL) pseudo waypoint
       */
      VNAV_EMIT_DECEL: true,
      /**
       * VNAV descent calculation mode (NORMAL, CDA or DPO)
       */
      VNAV_DESCENT_MODE: VnavDescentMode.CDA,
      /**
       * Whether to emit CDA flap1/2 pseudo-waypoints (only if VNAV_DESCENT_MODE is CDA)
       */
      VNAV_EMIT_CDA_FLAP_PWP: false
    };

    //  Copyright (c) 2021 FlyByWire Simulations, Horizon Simulations
    //  SPDX-License-Identifier: GPL-3.0

    const rangeSettings = [10, 20, 40, 80, 160, 320, 640];
    let EfisNdMode;
    (function (EfisNdMode) {
      EfisNdMode[EfisNdMode["APP"] = 0] = "APP";
      EfisNdMode[EfisNdMode["VOR"] = 1] = "VOR";
      EfisNdMode[EfisNdMode["MAP"] = 2] = "MAP";
      EfisNdMode[EfisNdMode["PLAN"] = 3] = "PLAN";
    })(EfisNdMode || (EfisNdMode = {}));
    let EfisOption;
    (function (EfisOption) {
      EfisOption[EfisOption["None"] = 0] = "None";
      EfisOption[EfisOption["Constraints"] = 1] = "Constraints";
      EfisOption[EfisOption["VorDmes"] = 2] = "VorDmes";
      EfisOption[EfisOption["Waypoints"] = 3] = "Waypoints";
      EfisOption[EfisOption["Ndbs"] = 4] = "Ndbs";
      EfisOption[EfisOption["Airports"] = 5] = "Airports";
    })(EfisOption || (EfisOption = {}));
    let NdSymbolTypeFlags;
    (function (NdSymbolTypeFlags) {
      NdSymbolTypeFlags[NdSymbolTypeFlags["Vor"] = 1] = "Vor";
      NdSymbolTypeFlags[NdSymbolTypeFlags["VorDme"] = 2] = "VorDme";
      NdSymbolTypeFlags[NdSymbolTypeFlags["Ndb"] = 4] = "Ndb";
      NdSymbolTypeFlags[NdSymbolTypeFlags["Waypoint"] = 8] = "Waypoint";
      NdSymbolTypeFlags[NdSymbolTypeFlags["Airport"] = 16] = "Airport";
      NdSymbolTypeFlags[NdSymbolTypeFlags["Runway"] = 32] = "Runway";
      NdSymbolTypeFlags[NdSymbolTypeFlags["Tuned"] = 64] = "Tuned";
      NdSymbolTypeFlags[NdSymbolTypeFlags["ActiveLegTermination"] = 128] = "ActiveLegTermination";
      NdSymbolTypeFlags[NdSymbolTypeFlags["EfisOption"] = 256] = "EfisOption";
      NdSymbolTypeFlags[NdSymbolTypeFlags["Dme"] = 512] = "Dme";
      NdSymbolTypeFlags[NdSymbolTypeFlags["ConstraintMet"] = 1024] = "ConstraintMet";
      NdSymbolTypeFlags[NdSymbolTypeFlags["ConstraintMissed"] = 2048] = "ConstraintMissed";
      NdSymbolTypeFlags[NdSymbolTypeFlags["ConstraintUnknown"] = 4096] = "ConstraintUnknown";
      NdSymbolTypeFlags[NdSymbolTypeFlags["SpeedChange"] = 8192] = "SpeedChange";
      NdSymbolTypeFlags[NdSymbolTypeFlags["FixInfo"] = 16384] = "FixInfo";
      NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlan"] = 32768] = "FlightPlan";
      NdSymbolTypeFlags[NdSymbolTypeFlags["PwpDecel"] = 65536] = "PwpDecel";
      NdSymbolTypeFlags[NdSymbolTypeFlags["PwpTopOfDescent"] = 131072] = "PwpTopOfDescent";
      NdSymbolTypeFlags[NdSymbolTypeFlags["PwpCdaFlap1"] = 262144] = "PwpCdaFlap1";
      NdSymbolTypeFlags[NdSymbolTypeFlags["PwpCdaFlap2"] = 524288] = "PwpCdaFlap2";
      NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlanVectorLine"] = 1048576] = "FlightPlanVectorLine";
      NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlanVectorArc"] = 2097152] = "FlightPlanVectorArc";
      NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlanVectorDebugPoint"] = 4194304] = "FlightPlanVectorDebugPoint";
      NdSymbolTypeFlags[NdSymbolTypeFlags["ActiveFlightPlanVector"] = 8388608] = "ActiveFlightPlanVector";
      NdSymbolTypeFlags[NdSymbolTypeFlags["CourseReversalLeft"] = 16777216] = "CourseReversalLeft";
      NdSymbolTypeFlags[NdSymbolTypeFlags["CourseReversalRight"] = 33554432] = "CourseReversalRight";
    })(NdSymbolTypeFlags || (NdSymbolTypeFlags = {}));
    /**
     * Possible flight plan vector groups to be transmitted to the ND.
     *
     * **NOTE:** this does not necessarily represent the current function of a transmitted flight plan. Those groups are sometimes used for other purposes than their name
     * refers to, for example the DASHED flight plan being used to transmit the non-offset path of an active flight plan with an offset applied.
     */
    let EfisVectorsGroup;
    (function (EfisVectorsGroup) {
      EfisVectorsGroup[EfisVectorsGroup["ACTIVE"] = 0] = "ACTIVE";
      EfisVectorsGroup[EfisVectorsGroup["DASHED"] = 1] = "DASHED";
      EfisVectorsGroup[EfisVectorsGroup["OFFSET"] = 2] = "OFFSET";
      EfisVectorsGroup[EfisVectorsGroup["TEMPORARY"] = 3] = "TEMPORARY";
      EfisVectorsGroup[EfisVectorsGroup["SECONDARY"] = 4] = "SECONDARY";
      EfisVectorsGroup[EfisVectorsGroup["SECONDARY_DASHED"] = 5] = "SECONDARY_DASHED";
      EfisVectorsGroup[EfisVectorsGroup["MISSED"] = 6] = "MISSED";
      EfisVectorsGroup[EfisVectorsGroup["ALTERNATE"] = 7] = "ALTERNATE";
      EfisVectorsGroup[EfisVectorsGroup["ACTIVE_EOSID"] = 8] = "ACTIVE_EOSID";
    })(EfisVectorsGroup || (EfisVectorsGroup = {}));
    let NavAidMode;
    (function (NavAidMode) {
      NavAidMode[NavAidMode["Off"] = 0] = "Off";
      NavAidMode[NavAidMode["ADF"] = 1] = "ADF";
      NavAidMode[NavAidMode["VOR"] = 2] = "VOR";
    })(NavAidMode || (NavAidMode = {}));

    const PWP_IDENT_DECEL = '(DECEL)';
    const PWP_IDENT_FLAP1 = '(FLAP1)';
    const PWP_IDENT_FLAP2 = '(FLAP2)';
    class PseudoWaypoints {
      constructor(guidanceController) {
        this.guidanceController = guidanceController;
        _defineProperty$2(this, "pseudoWaypoints", []);
      }
      acceptVerticalProfile() {
        this.recompute();
      }
      acceptMultipleLegGeometry(_geometry) {
        this.recompute();
      }
      recompute() {
        const geometry = this.guidanceController.activeGeometry;
        const wptCount = this.guidanceController.flightPlanManager.getWaypointsCount();
        const haveApproach = !!this.guidanceController.vnavDriver.currentApproachProfile;
        if (!geometry || geometry.legs.size < 1) {
          this.pseudoWaypoints.length = 0;
          return;
        }
        const newPseudoWaypoints = [];
        if (haveApproach) {
          const decel = PseudoWaypoints.pointFromEndOfPath(geometry, wptCount, this.guidanceController.vnavDriver.currentApproachProfile.decel, false );
          if (decel) {
            const [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = decel;
            newPseudoWaypoints.push({
              ident: PWP_IDENT_DECEL,
              sequencingType: PseudoWaypointSequencingAction.APPROACH_PHASE_AUTO_ENGAGE,
              alongLegIndex,
              distanceFromLegTermination,
              efisSymbolFlag: NdSymbolTypeFlags.PwpDecel,
              efisSymbolLla,
              displayedOnMcdu: true,
              stats: PseudoWaypoints.computePseudoWaypointStats(PWP_IDENT_DECEL, geometry.legs.get(alongLegIndex), distanceFromLegTermination)
            });
          }

          // for (let i = 0; i < 75; i++) {
          //     const point = PseudoWaypoints.pointFromEndOfPath(geometry, this.guidanceController.vnavDriver.currentApproachProfile.decel + i / 2, `(BRUH${i}`);
          //
          //     if (point) {
          //         const [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = point;
          //
          //         newPseudoWaypoints.push({
          //             ident: `(BRUH${i})`,
          //             sequencingType: PseudoWaypointSequencingAction.TOD_REACHED,
          //             alongLegIndex,
          //             distanceFromLegTermination,
          //             efisSymbolFlag: NdSymbolTypeFlags.PwpTopOfDescent,
          //             efisSymbolLla,
          //             displayedOnMcdu: true,
          //             stats: PseudoWaypoints.computePseudoWaypointStats(`(BRUH${i})`, geometry.legs.get(alongLegIndex), distanceFromLegTermination),
          //         });
          //     }
          // }
        }

        if (VnavConfig.VNAV_DESCENT_MODE === VnavDescentMode.CDA && VnavConfig.VNAV_EMIT_CDA_FLAP_PWP && haveApproach) {
          const flap1 = PseudoWaypoints.pointFromEndOfPath(geometry, wptCount, this.guidanceController.vnavDriver.currentApproachProfile.flap1, false );
          if (flap1) {
            const [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = flap1;
            newPseudoWaypoints.push({
              ident: PWP_IDENT_FLAP1,
              alongLegIndex,
              distanceFromLegTermination,
              efisSymbolFlag: NdSymbolTypeFlags.PwpCdaFlap1,
              efisSymbolLla,
              displayedOnMcdu: true,
              stats: PseudoWaypoints.computePseudoWaypointStats(PWP_IDENT_FLAP1, geometry.legs.get(alongLegIndex), distanceFromLegTermination)
            });
          }
          const flap2 = PseudoWaypoints.pointFromEndOfPath(geometry, wptCount, this.guidanceController.vnavDriver.currentApproachProfile.flap2, false );
          if (flap2) {
            const [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = flap2;
            newPseudoWaypoints.push({
              ident: PWP_IDENT_FLAP2,
              alongLegIndex,
              distanceFromLegTermination,
              efisSymbolFlag: NdSymbolTypeFlags.PwpCdaFlap2,
              efisSymbolLla,
              displayedOnMcdu: true,
              stats: PseudoWaypoints.computePseudoWaypointStats(PWP_IDENT_FLAP2, geometry.legs.get(alongLegIndex), distanceFromLegTermination)
            });
          }
        }
        this.pseudoWaypoints = newPseudoWaypoints;
      }
      init() {
        console.log('[aims/Guidance] PseudoWaypoints initialized!');
      }
      update(_) {
        // Pass our pseudo waypoints to the GuidanceController
        this.guidanceController.currentPseudoWaypoints.length = 0;
        let idx = 0;
        for (const pseudoWaypoint of this.pseudoWaypoints) {
          const onPreviousLeg = pseudoWaypoint.alongLegIndex === this.guidanceController.activeLegIndex - 1;
          const onActiveLeg = pseudoWaypoint.alongLegIndex === this.guidanceController.activeLegIndex;
          const afterActiveLeg = pseudoWaypoint.alongLegIndex > this.guidanceController.activeLegIndex;

          // TODO we also consider the previous leg as active because we sequence Type I transitions at the same point
          // for both guidance and legs list. IRL, the display sequences after the guidance, which means the pseudo-waypoints
          // on the first half of the transition are considered on the active leg, whereas without this hack they are
          // on the previous leg by the time we try to re-add them to the list.

          // We only want to add the pseudo waypoint if it's after the active leg or it isn't yet passed
          if (afterActiveLeg || onPreviousLeg && this.guidanceController.displayActiveLegCompleteLegPathDtg > pseudoWaypoint.distanceFromLegTermination || onActiveLeg && this.guidanceController.activeLegCompleteLegPathDtg > pseudoWaypoint.distanceFromLegTermination) {
            this.guidanceController.currentPseudoWaypoints[++idx] = pseudoWaypoint;
          }
        }
      }

      /**
       * Notifies the FMS that a pseudo waypoint must be sequenced.
       *
       * This is to be sued by {@link GuidanceController} only.
       *
       * @param pseudoWaypoint the {@link PseudoWaypoint} to sequence.
       */
      sequencePseudoWaypoint(pseudoWaypoint) {
        {
          console.log("[FMS/PseudoWaypoints] Pseudo-waypoint '".concat(pseudoWaypoint.ident, "' sequenced."));
        }
        switch (pseudoWaypoint.sequencingType) {
          case PseudoWaypointSequencingAction.TOD_REACHED:
            // TODO EFIS message;
            break;
          case PseudoWaypointSequencingAction.APPROACH_PHASE_AUTO_ENGAGE:
            const apLateralMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'Number');
            const agl = Simplane.getAltitudeAboveGround();
            if (agl < 9500 && (apLateralMode === LateralMode.NAV || apLateralMode === LateralMode.LOC_CPT || apLateralMode === LateralMode.LOC_TRACK)) {
              // Request APPROACH phase engagement for 5 seconds
              SimVar.SetSimVarValue('L:A32NX_FM_ENABLE_APPROACH_PHASE', 'Bool', true).then(() => [setTimeout(() => {
                SimVar.SetSimVarValue('L:A32NX_FM_ENABLE_APPROACH_PHASE', 'Bool', false);
              }, 5000)]);
            }
            break;
        }
      }

      /**
       * Computes a {@link WaypointStats} object for a pseudo waypoint
       *
       * @param ident             the text identifier to give to this pseudo waypoint, for display on the MCDU
       * @param leg               the leg along which this pseudo waypoint is situated
       * @param distanceAlongLeg  the distance from the termination of the leg to this pseudo waypoint
       *
       * @private
       */
      static computePseudoWaypointStats(ident, leg, distanceAlongLeg) {
        // TODO use predictions store to find out altitude, speed and time
        return {
          ident,
          bearingInFp: 0,
          distanceInFP: leg.distance - distanceAlongLeg,
          distanceFromPpos: 0,
          timeFromPpos: 0,
          etaFromPpos: 0,
          magneticVariation: 0
        };
      }
      static pointFromEndOfPath(path, wptCount, distanceFromEnd, debugString) {
        if (distanceFromEnd < 0) {
          throw new Error('[FMS/PWP](pointFromEndOfPath) distanceFromEnd was negative');
        }
        let accumulator = 0;
        for (let i = wptCount - 1; i > 0; i--) {
          const leg = path.legs.get(i);
          if (!leg || leg.isNull) {
            continue;
          }
          const inboundTrans = path.transitions.get(i - 1);
          const outboundTrans = path.transitions.get(i);
          const [inboundTransLength, legPartLength, outboundTransLength] = Geometry.completeLegPathLengths(leg, inboundTrans, outboundTrans instanceof FixedRadiusTransition ? outboundTrans : null);
          const totalLegPathLength = inboundTransLength + legPartLength + outboundTransLength;
          accumulator += totalLegPathLength;
          if (accumulator > distanceFromEnd) {
            const distanceFromEndOfLeg = distanceFromEnd - (accumulator - totalLegPathLength);
            let lla;
            if (distanceFromEndOfLeg < outboundTransLength) {
              // Point is in outbound transition segment
              const distanceBeforeTerminator = outboundTrans.distance / 2 + distanceFromEndOfLeg;
              lla = outboundTrans.getPseudoWaypointLocation(distanceBeforeTerminator);
            } else if (distanceFromEndOfLeg >= outboundTransLength && distanceFromEndOfLeg < outboundTransLength + legPartLength) {
              // Point is in leg segment
              const distanceBeforeTerminator = distanceFromEndOfLeg - outboundTransLength;
              lla = leg.getPseudoWaypointLocation(distanceBeforeTerminator);
            } else {
              // Point is in inbound transition segment
              const distanceBeforeTerminator = distanceFromEndOfLeg - outboundTransLength - legPartLength;
              lla = inboundTrans.getPseudoWaypointLocation(distanceBeforeTerminator);
            }
            if (lla) {
              return [lla, distanceFromEndOfLeg, i];
            }
            return undefined;
          }
        }
        return undefined;
      }
    }

    var safeStableStringifyExports = {};
    var safeStableStringify = {
      get exports(){ return safeStableStringifyExports; },
      set exports(v){ safeStableStringifyExports = v; },
    };

    (function (module, exports) {

      const {
        hasOwnProperty
      } = Object.prototype;
      const stringify = configure();

      // @ts-expect-error
      stringify.configure = configure;
      // @ts-expect-error
      stringify.stringify = stringify;

      // @ts-expect-error
      stringify.default = stringify;

      // @ts-expect-error used for named export
      exports.stringify = stringify;
      // @ts-expect-error used for named export
      exports.configure = configure;
      module.exports = stringify;

      // eslint-disable-next-line no-control-regex
      const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
      const strEscapeSequencesReplacer = new RegExp(strEscapeSequencesRegExp, 'g');

      // Escaped special characters. Use empty strings to fill up unused entries.
      const meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '\\"', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];
      function escapeFn(str) {
        if (str.length === 2) {
          const charCode = str.charCodeAt(1);
          return "".concat(str[0], "\\u").concat(charCode.toString(16));
        }
        const charCode = str.charCodeAt(0);
        return meta.length > charCode ? meta[charCode] : "\\u".concat(charCode.toString(16));
      }

      // Escape C0 control characters, double quotes, the backslash and every code
      // unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
      function strEscape(str) {
        // Some magic numbers that worked out fine while benchmarking with v8 8.0
        if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
          return str;
        }
        if (str.length > 100) {
          return str.replace(strEscapeSequencesReplacer, escapeFn);
        }
        let result = '';
        let last = 0;
        for (let i = 0; i < str.length; i++) {
          const point = str.charCodeAt(i);
          if (point === 34 || point === 92 || point < 32) {
            result += "".concat(str.slice(last, i)).concat(meta[point]);
            last = i + 1;
          } else if (point >= 0xd800 && point <= 0xdfff) {
            if (point <= 0xdbff && i + 1 < str.length) {
              const nextPoint = str.charCodeAt(i + 1);
              if (nextPoint >= 0xdc00 && nextPoint <= 0xdfff) {
                i++;
                continue;
              }
            }
            result += "".concat(str.slice(last, i), "\\u").concat(point.toString(16));
            last = i + 1;
          }
        }
        result += str.slice(last);
        return result;
      }
      function insertSort(array) {
        // Insertion sort is very efficient for small input sizes but it has a bad
        // worst case complexity. Thus, use native array sort for bigger values.
        if (array.length > 2e2) {
          return array.sort();
        }
        for (let i = 1; i < array.length; i++) {
          const currentValue = array[i];
          let position = i;
          while (position !== 0 && array[position - 1] > currentValue) {
            array[position] = array[position - 1];
            position--;
          }
          array[position] = currentValue;
        }
        return array;
      }
      const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
      function isTypedArrayWithEntries(value) {
        return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
      }
      function stringifyTypedArray(array, separator, maximumBreadth) {
        if (array.length < maximumBreadth) {
          maximumBreadth = array.length;
        }
        const whitespace = separator === ',' ? '' : ' ';
        let res = "\"0\":".concat(whitespace).concat(array[0]);
        for (let i = 1; i < maximumBreadth; i++) {
          res += "".concat(separator, "\"").concat(i, "\":").concat(whitespace).concat(array[i]);
        }
        return res;
      }
      function getCircularValueOption(options) {
        if (hasOwnProperty.call(options, 'circularValue')) {
          const circularValue = options.circularValue;
          if (typeof circularValue === 'string') {
            return "\"".concat(circularValue, "\"");
          }
          if (circularValue == null) {
            return circularValue;
          }
          if (circularValue === Error || circularValue === TypeError) {
            return {
              toString() {
                throw new TypeError('Converting circular structure to JSON');
              }
            };
          }
          throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
        }
        return '"[Circular]"';
      }
      function getBooleanOption(options, key) {
        let value;
        if (hasOwnProperty.call(options, key)) {
          value = options[key];
          if (typeof value !== 'boolean') {
            throw new TypeError("The \"".concat(key, "\" argument must be of type boolean"));
          }
        }
        return value === undefined ? true : value;
      }
      function getPositiveIntegerOption(options, key) {
        let value;
        if (hasOwnProperty.call(options, key)) {
          value = options[key];
          if (typeof value !== 'number') {
            throw new TypeError("The \"".concat(key, "\" argument must be of type number"));
          }
          if (!Number.isInteger(value)) {
            throw new TypeError("The \"".concat(key, "\" argument must be an integer"));
          }
          if (value < 1) {
            throw new RangeError("The \"".concat(key, "\" argument must be >= 1"));
          }
        }
        return value === undefined ? Infinity : value;
      }
      function getItemCount(number) {
        if (number === 1) {
          return '1 item';
        }
        return "".concat(number, " items");
      }
      function getUniqueReplacerSet(replacerArray) {
        const replacerSet = new Set();
        for (const value of replacerArray) {
          if (typeof value === 'string' || typeof value === 'number') {
            replacerSet.add(String(value));
          }
        }
        return replacerSet;
      }
      function getStrictOption(options) {
        if (hasOwnProperty.call(options, 'strict')) {
          const value = options.strict;
          if (typeof value !== 'boolean') {
            throw new TypeError('The "strict" argument must be of type boolean');
          }
          if (value) {
            return value => {
              let message = "Object can not safely be stringified. Received type ".concat(typeof value);
              if (typeof value !== 'function') message += " (".concat(value.toString(), ")");
              throw new Error(message);
            };
          }
        }
      }
      function configure(options) {
        options = _objectSpread2({}, options);
        const fail = getStrictOption(options);
        if (fail) {
          if (options.bigint === undefined) {
            options.bigint = false;
          }
          if (!('circularValue' in options)) {
            options.circularValue = Error;
          }
        }
        const circularValue = getCircularValueOption(options);
        const bigint = getBooleanOption(options, 'bigint');
        const deterministic = getBooleanOption(options, 'deterministic');
        const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
        const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');
        function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
          let value = parent[key];
          if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
          }
          value = replacer.call(parent, key, value);
          switch (typeof value) {
            case 'string':
              return "\"".concat(strEscape(value), "\"");
            case 'object':
              {
                if (value === null) {
                  return 'null';
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                let res = '';
                let join = ',';
                const originalIndentation = indentation;
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return '[]';
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  if (spacer !== '') {
                    indentation += spacer;
                    res += "\n".concat(indentation);
                    join = ",\n".concat(indentation);
                  }
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                    res += tmp !== undefined ? tmp : 'null';
                    res += join;
                  }
                  const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                  res += tmp !== undefined ? tmp : 'null';
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res += "".concat(join, "\"... ").concat(getItemCount(removedKeys), " not stringified\"");
                  }
                  if (spacer !== '') {
                    res += "\n".concat(originalIndentation);
                  }
                  stack.pop();
                  return "[".concat(res, "]");
                }
                let keys = Object.keys(value);
                const keyLength = keys.length;
                if (keyLength === 0) {
                  return '{}';
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Object]"';
                }
                let whitespace = '';
                let separator = '';
                if (spacer !== '') {
                  indentation += spacer;
                  join = ",\n".concat(indentation);
                  whitespace = ' ';
                }
                let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                if (isTypedArrayWithEntries(value)) {
                  res += stringifyTypedArray(value, join, maximumBreadth);
                  keys = keys.slice(value.length);
                  maximumPropertiesToStringify -= value.length;
                  separator = join;
                }
                if (deterministic) {
                  keys = insertSort(keys);
                }
                stack.push(value);
                for (let i = 0; i < maximumPropertiesToStringify; i++) {
                  const key = keys[i];
                  const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);
                  if (tmp !== undefined) {
                    res += "".concat(separator, "\"").concat(strEscape(key), "\":").concat(whitespace).concat(tmp);
                    separator = join;
                  }
                }
                if (keyLength > maximumBreadth) {
                  const removedKeys = keyLength - maximumBreadth;
                  res += "".concat(separator, "\"...\":").concat(whitespace, "\"").concat(getItemCount(removedKeys), " not stringified\"");
                  separator = join;
                }
                if (spacer !== '' && separator.length > 1) {
                  res = "\n".concat(indentation).concat(res, "\n").concat(originalIndentation);
                }
                stack.pop();
                return "{".concat(res, "}");
              }
            case 'number':
              return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
              return value === true ? 'true' : 'false';
            case 'undefined':
              return undefined;
            case 'bigint':
              if (bigint) {
                return String(value);
              }
            // fallthrough
            default:
              return fail ? fail(value) : undefined;
          }
        }
        function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
          if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
          }
          switch (typeof value) {
            case 'string':
              return "\"".concat(strEscape(value), "\"");
            case 'object':
              {
                if (value === null) {
                  return 'null';
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                const originalIndentation = indentation;
                let res = '';
                let join = ',';
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return '[]';
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  if (spacer !== '') {
                    indentation += spacer;
                    res += "\n".concat(indentation);
                    join = ",\n".concat(indentation);
                  }
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                    res += tmp !== undefined ? tmp : 'null';
                    res += join;
                  }
                  const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                  res += tmp !== undefined ? tmp : 'null';
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res += "".concat(join, "\"... ").concat(getItemCount(removedKeys), " not stringified\"");
                  }
                  if (spacer !== '') {
                    res += "\n".concat(originalIndentation);
                  }
                  stack.pop();
                  return "[".concat(res, "]");
                }
                stack.push(value);
                let whitespace = '';
                if (spacer !== '') {
                  indentation += spacer;
                  join = ",\n".concat(indentation);
                  whitespace = ' ';
                }
                let separator = '';
                for (const key of replacer) {
                  const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);
                  if (tmp !== undefined) {
                    res += "".concat(separator, "\"").concat(strEscape(key), "\":").concat(whitespace).concat(tmp);
                    separator = join;
                  }
                }
                if (spacer !== '' && separator.length > 1) {
                  res = "\n".concat(indentation).concat(res, "\n").concat(originalIndentation);
                }
                stack.pop();
                return "{".concat(res, "}");
              }
            case 'number':
              return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
              return value === true ? 'true' : 'false';
            case 'undefined':
              return undefined;
            case 'bigint':
              if (bigint) {
                return String(value);
              }
            // fallthrough
            default:
              return fail ? fail(value) : undefined;
          }
        }
        function stringifyIndent(key, value, stack, spacer, indentation) {
          switch (typeof value) {
            case 'string':
              return "\"".concat(strEscape(value), "\"");
            case 'object':
              {
                if (value === null) {
                  return 'null';
                }
                if (typeof value.toJSON === 'function') {
                  value = value.toJSON(key);
                  // Prevent calling `toJSON` again.
                  if (typeof value !== 'object') {
                    return stringifyIndent(key, value, stack, spacer, indentation);
                  }
                  if (value === null) {
                    return 'null';
                  }
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                const originalIndentation = indentation;
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return '[]';
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  indentation += spacer;
                  let res = "\n".concat(indentation);
                  const join = ",\n".concat(indentation);
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
                    res += tmp !== undefined ? tmp : 'null';
                    res += join;
                  }
                  const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
                  res += tmp !== undefined ? tmp : 'null';
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res += "".concat(join, "\"... ").concat(getItemCount(removedKeys), " not stringified\"");
                  }
                  res += "\n".concat(originalIndentation);
                  stack.pop();
                  return "[".concat(res, "]");
                }
                let keys = Object.keys(value);
                const keyLength = keys.length;
                if (keyLength === 0) {
                  return '{}';
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Object]"';
                }
                indentation += spacer;
                const join = ",\n".concat(indentation);
                let res = '';
                let separator = '';
                let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                if (isTypedArrayWithEntries(value)) {
                  res += stringifyTypedArray(value, join, maximumBreadth);
                  keys = keys.slice(value.length);
                  maximumPropertiesToStringify -= value.length;
                  separator = join;
                }
                if (deterministic) {
                  keys = insertSort(keys);
                }
                stack.push(value);
                for (let i = 0; i < maximumPropertiesToStringify; i++) {
                  const key = keys[i];
                  const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);
                  if (tmp !== undefined) {
                    res += "".concat(separator, "\"").concat(strEscape(key), "\": ").concat(tmp);
                    separator = join;
                  }
                }
                if (keyLength > maximumBreadth) {
                  const removedKeys = keyLength - maximumBreadth;
                  res += "".concat(separator, "\"...\": \"").concat(getItemCount(removedKeys), " not stringified\"");
                  separator = join;
                }
                if (separator !== '') {
                  res = "\n".concat(indentation).concat(res, "\n").concat(originalIndentation);
                }
                stack.pop();
                return "{".concat(res, "}");
              }
            case 'number':
              return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
              return value === true ? 'true' : 'false';
            case 'undefined':
              return undefined;
            case 'bigint':
              if (bigint) {
                return String(value);
              }
            // fallthrough
            default:
              return fail ? fail(value) : undefined;
          }
        }
        function stringifySimple(key, value, stack) {
          switch (typeof value) {
            case 'string':
              return "\"".concat(strEscape(value), "\"");
            case 'object':
              {
                if (value === null) {
                  return 'null';
                }
                if (typeof value.toJSON === 'function') {
                  value = value.toJSON(key);
                  // Prevent calling `toJSON` again
                  if (typeof value !== 'object') {
                    return stringifySimple(key, value, stack);
                  }
                  if (value === null) {
                    return 'null';
                  }
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                let res = '';
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return '[]';
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp = stringifySimple(i, value[i], stack);
                    res += tmp !== undefined ? tmp : 'null';
                    res += ',';
                  }
                  const tmp = stringifySimple(i, value[i], stack);
                  res += tmp !== undefined ? tmp : 'null';
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res += ",\"... ".concat(getItemCount(removedKeys), " not stringified\"");
                  }
                  stack.pop();
                  return "[".concat(res, "]");
                }
                let keys = Object.keys(value);
                const keyLength = keys.length;
                if (keyLength === 0) {
                  return '{}';
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Object]"';
                }
                let separator = '';
                let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                if (isTypedArrayWithEntries(value)) {
                  res += stringifyTypedArray(value, ',', maximumBreadth);
                  keys = keys.slice(value.length);
                  maximumPropertiesToStringify -= value.length;
                  separator = ',';
                }
                if (deterministic) {
                  keys = insertSort(keys);
                }
                stack.push(value);
                for (let i = 0; i < maximumPropertiesToStringify; i++) {
                  const key = keys[i];
                  const tmp = stringifySimple(key, value[key], stack);
                  if (tmp !== undefined) {
                    res += "".concat(separator, "\"").concat(strEscape(key), "\":").concat(tmp);
                    separator = ',';
                  }
                }
                if (keyLength > maximumBreadth) {
                  const removedKeys = keyLength - maximumBreadth;
                  res += "".concat(separator, "\"...\":\"").concat(getItemCount(removedKeys), " not stringified\"");
                }
                stack.pop();
                return "{".concat(res, "}");
              }
            case 'number':
              return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
              return value === true ? 'true' : 'false';
            case 'undefined':
              return undefined;
            case 'bigint':
              if (bigint) {
                return String(value);
              }
            // fallthrough
            default:
              return fail ? fail(value) : undefined;
          }
        }
        function stringify(value, replacer, space) {
          if (arguments.length > 1) {
            let spacer = '';
            if (typeof space === 'number') {
              spacer = ' '.repeat(Math.min(space, 10));
            } else if (typeof space === 'string') {
              spacer = space.slice(0, 10);
            }
            if (replacer != null) {
              if (typeof replacer === 'function') {
                return stringifyFnReplacer('', {
                  '': value
                }, [], replacer, spacer, '');
              }
              if (Array.isArray(replacer)) {
                return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '');
              }
            }
            if (spacer.length !== 0) {
              return stringifyIndent('', value, [], spacer, '');
            }
          }
          return stringifySimple('', value, []);
        }
        return stringify;
      }
    })(safeStableStringify, safeStableStringifyExports);
    var cjsModule = safeStableStringifyExports;

    cjsModule.configure;

    class FlowEventSync {
      constructor(recvEventCb, topic) {
        _defineProperty$2(this, "evtNum", void 0);
        _defineProperty$2(this, "dataPackageQueue", void 0);
        _defineProperty$2(this, "topic", void 0);
        _defineProperty$2(this, "isRunning", void 0);
        _defineProperty$2(this, "recvEventCb", void 0);
        this.evtNum = 0;
        this.topic = topic;
        this.dataPackageQueue = [];
        this.isRunning = true;
        this.recvEventCb = recvEventCb;
        if (topic) {
          Coherent.on('OnInteractionEvent', this.processEventsReceived.bind(this));
        }
        const sendFn = () => {
          if (this.dataPackageQueue.length > 0) {
            const syncDataPackage = {
              data: this.dataPackageQueue
            };
            LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', FlowEventSync.EB_LISTENER_KEY, cjsModule(syncDataPackage));
            this.dataPackageQueue.length = 0;
          }
          if (this.isRunning) {
            requestAnimationFrame(sendFn);
          }
        };
        requestAnimationFrame(sendFn);
      }
      stop() {
        this.isRunning = false;
      }

      /**
       * Processes events received from onInteractionEvent and executes the configured callback.
       * @param target always empty
       * @param args [0] the eventlistener key [1] SyncDataPackage
       */
      processEventsReceived(_target, args) {
        // identify if its a flowsyncevent
        if (args.length === 0 || args[0] !== FlowEventSync.EB_LISTENER_KEY) {
          return;
        }
        const syncDataPackage = JSON.parse(args[1]);
        syncDataPackage.data.forEach(data => {
          if (data.topic === this.topic) {
            try {
              this.recvEventCb(data.topic, data.data !== undefined ? JSON.parse(data.data) : undefined);
            } catch (e) {
              console.error(e);
              if (e instanceof Error) {
                console.error(e.stack);
              }
            }
          }
        });
      }

      /**
       * Sends an event via flow events.
       * @param topic The topic to send data on.
       * @param data The data to send.
       */
      sendEvent(topic, data) {
        const dataObj = cjsModule(data);
        const dataPackage = {
          evtNum: this.evtNum++,
          topic,
          data: dataObj
        };
        this.dataPackageQueue.push(dataPackage);
      }
      receiveEvent() {
        // noop
      }
    }
    _defineProperty$2(FlowEventSync, "EB_LISTENER_KEY", 'EB_EVENTS');

    const UPDATE_TIMER = 2500;
    class EfisVectors {
      constructor(guidanceController) {
        this.guidanceController = guidanceController;
        _defineProperty$2(this, "syncer", new FlowEventSync());
        _defineProperty$2(this, "currentActiveVectors", []);
        _defineProperty$2(this, "currentDashedVectors", []);
        _defineProperty$2(this, "currentTemporaryVectors", []);
        _defineProperty$2(this, "updateTimer", 0);
      }
      forceUpdate() {
        this.updateTimer = UPDATE_TIMER + 1;
      }
      update(deltaTime) {
        var _this$guidanceControl, _this$guidanceControl2, _this$guidanceControl3, _this$guidanceControl4, _this$guidanceControl5, _this$guidanceControl6;
        this.updateTimer += deltaTime;
        if (this.updateTimer < UPDATE_TIMER) {
          return;
        }
        this.updateTimer = 0;
        const activeFlightPlanVectors = (_this$guidanceControl = (_this$guidanceControl2 = this.guidanceController.activeGeometry) === null || _this$guidanceControl2 === void 0 ? void 0 : _this$guidanceControl2.getAllPathVectors(this.guidanceController.activeLegIndex)) !== null && _this$guidanceControl !== void 0 ? _this$guidanceControl : [];
        const temporaryFlightPlanVectors = (_this$guidanceControl3 = (_this$guidanceControl4 = this.guidanceController.temporaryGeometry) === null || _this$guidanceControl4 === void 0 ? void 0 : _this$guidanceControl4.getAllPathVectors(this.guidanceController.temporaryLegIndex)) !== null && _this$guidanceControl3 !== void 0 ? _this$guidanceControl3 : [];
        const visibleActiveFlightPlanVectors = activeFlightPlanVectors.filter(vector => EfisVectors.isVectorReasonable(vector));
        const visibleTemporaryFlightPlanVectors = temporaryFlightPlanVectors.filter(vector => EfisVectors.isVectorReasonable(vector));
        if (visibleActiveFlightPlanVectors.length !== activeFlightPlanVectors.length) {
          this.guidanceController.efisStateForSide.L.legsCulled = true;
          this.guidanceController.efisStateForSide.R.legsCulled = true;
        } else {
          this.guidanceController.efisStateForSide.L.legsCulled = false;
          this.guidanceController.efisStateForSide.R.legsCulled = false;
        }

        // ACTIVE

        const engagedLateralMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'Number');
        const armedLateralMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_ARMED', 'Enum');
        const navArmed = isArmed(armedLateralMode, ArmedLateralMode.NAV);
        const transmitActive = engagedLateralMode === LateralMode.NAV || engagedLateralMode === LateralMode.LOC_CPT || engagedLateralMode === LateralMode.LOC_TRACK || navArmed;
        const clearActive = !transmitActive && this.currentActiveVectors.length > 0;
        if (transmitActive) {
          this.currentActiveVectors = visibleActiveFlightPlanVectors;
          this.transmitGroup(this.currentActiveVectors, EfisVectorsGroup.ACTIVE);
        }
        if (clearActive) {
          this.currentActiveVectors = [];
          this.transmitGroup(this.currentActiveVectors, EfisVectorsGroup.ACTIVE);
        }

        // DASHED

        const transmitDashed = !transmitActive;
        const clearDashed = !transmitDashed && this.currentDashedVectors.length > 0;
        if (transmitDashed) {
          this.currentDashedVectors = visibleActiveFlightPlanVectors;
          this.transmitGroup(this.currentDashedVectors, EfisVectorsGroup.DASHED);
        }
        if (clearDashed) {
          this.currentDashedVectors = [];
          this.transmitGroup(this.currentDashedVectors, EfisVectorsGroup.DASHED);
        }

        // TEMPORARY

        const transmitTemporary = this.guidanceController.hasTemporaryFlightPlan && ((_this$guidanceControl5 = this.guidanceController.temporaryGeometry) === null || _this$guidanceControl5 === void 0 ? void 0 : (_this$guidanceControl6 = _this$guidanceControl5.legs) === null || _this$guidanceControl6 === void 0 ? void 0 : _this$guidanceControl6.size) > 0;
        const clearTemporary = !transmitTemporary && this.currentTemporaryVectors.length > 0;
        if (transmitTemporary) {
          this.currentTemporaryVectors = visibleTemporaryFlightPlanVectors;
          this.transmitGroup(this.currentTemporaryVectors, EfisVectorsGroup.TEMPORARY);
        }
        if (clearTemporary) {
          this.currentTemporaryVectors = [];
          this.transmitGroup(this.currentTemporaryVectors, EfisVectorsGroup.TEMPORARY);
        }
      }

      /**
       * Protect against potential perf issues from immense vectors
       */
      static isVectorReasonable(vector) {
        if (!pathVectorValid(vector)) {
          return false;
        }
        const length = pathVectorLength(vector);
        return length <= 5000;
      }
      transmitGroup(vectors, group) {
        this.transmit(vectors, group, 'L');
        this.transmit(vectors, group, 'R');
      }
      transmit(vectors, vectorsGroup, side) {
        this.syncer.sendEvent("A32NX_EFIS_VECTORS_".concat(side, "_").concat(EfisVectorsGroup[vectorsGroup]), vectors);
      }
    }

    let TaskCategory;
    (function (TaskCategory) {
      TaskCategory[TaskCategory["EfisVectors"] = 0] = "EfisVectors";
    })(TaskCategory || (TaskCategory = {}));
    class TaskQueue {
      constructor() {
        _defineProperty$2(this, "taskQueue", []);
        _defineProperty$2(this, "currentTask", null);
        _defineProperty$2(this, "currentTaskExecutor", null);
      }
      update(_deltaTime) {
        if (!this.currentTask && this.taskQueue.length > 0) {
          const nextTask = this.taskQueue.shift();
          if (nextTask) {
            this.currentTask = nextTask;
            this.currentTaskExecutor = nextTask.executor();
          }
        }
        if (this.currentTask) {
          const done = this.currentTaskExecutor.next().done;
          if (done) {
            this.currentTask = null;
            this.currentTaskExecutor = null;
          }
        }
      }
      runStepTask(executor) {
        this.taskQueue.push(executor);
      }
      cancelAllInCategory(category) {
        var _this$currentTask;
        if (((_this$currentTask = this.currentTask) === null || _this$currentTask === void 0 ? void 0 : _this$currentTask.category) === category) {
          this.currentTask = null;
          this.currentTaskExecutor = null;
        }
        for (const queuedTask of this.taskQueue) {
          if (queuedTask.category === category) {
            this.taskQueue = this.taskQueue.filter(task => task === queuedTask);
          }
        }
      }
    }

    class SimVarString {
      /**
       * Pack a string into numbers for use in a simvar
       * ASCII chars from dec 32-63 can be encoded, 6-bit per char, 8 chars per simvar
       * IMPORTANT: write the values as strings to the simvars or you will have precision errors
       * @param value
       * @param maxLength if specified enough simvars will be returned to fit this length,
       * and the value will be trimmed to this length
       * @returns an array of numbers ready to be written to simvars
       */
      static pack(value, maxLength) {
        let word = -1;
        const ret = [];
        for (let i = 0; i < Math.min(maxLength, value.length); i++) {
          const char = i % 8;
          if (char === 0) {
            word++;
            ret[word] = 0;
          }
          let code = value.charCodeAt(i) - 31;
          if (code < 1 || code > 63 || !Number.isFinite(code)) {
            code = 0;
          }
          ret[word] += 2 ** (char * 6) * code;
        }
        if (maxLength && ret.length < Math.ceil(maxLength / 8)) {
          ret.push(...new Array(Math.ceil(maxLength / 8) - ret.length).fill(0));
        }
        return ret;
      }

      /**
       * Unpacks numeric values packed by @see packString
       * @param values an array of numbers from the simvars
       * @returns the unpacked string
       */
      static unpack(values) {
        let ret = '';
        for (let i = 0; i < values.length * 8; i++) {
          const word = Math.floor(i / 8);
          const char = i % 8;
          const code = Math.floor(values[word] / 2 ** (char * 6)) & 0x3f;
          if (code > 0) {
            ret += String.fromCharCode(code + 31);
          }
        }
        return ret;
      }
    }

    class GuidanceConstants {}
    _defineProperty$2(GuidanceConstants, "k2", 0.0045);
    _defineProperty$2(GuidanceConstants, "FORCED_TURN_TKAE_THRESHOLD", 150);

    /**
     * Represents the current turn state of the LNAV driver
     */
    let LnavTurnState;
    (function (LnavTurnState) {
      LnavTurnState[LnavTurnState["Normal"] = 0] = "Normal";
      LnavTurnState[LnavTurnState["ForceLeftTurn"] = 1] = "ForceLeftTurn";
      LnavTurnState[LnavTurnState["ForceRightTurn"] = 2] = "ForceRightTurn";
    })(LnavTurnState || (LnavTurnState = {}));
    class LnavDriver {
      constructor(guidanceController) {
        _defineProperty$2(this, "guidanceController", void 0);
        _defineProperty$2(this, "lastAvail", void 0);
        _defineProperty$2(this, "lastLaw", void 0);
        _defineProperty$2(this, "lastXTE", void 0);
        _defineProperty$2(this, "lastTAE", void 0);
        _defineProperty$2(this, "lastPhi", void 0);
        _defineProperty$2(this, "turnState", LnavTurnState.Normal);
        _defineProperty$2(this, "ppos", new LatLongAlt());
        _defineProperty$2(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
        this.guidanceController = guidanceController;
        this.lastAvail = null;
        this.lastLaw = null;
        this.lastXTE = null;
        this.lastTAE = null;
        this.lastPhi = null;
      }
      init() {
        console.log('[Aims/Guidance] LnavDriver initialized!');
      }
      update(_) {
        let available = false;
        this.ppos.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        this.ppos.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        const geometry = this.guidanceController.activeGeometry;
        const activeLegIdx = this.guidanceController.activeLegIndex;
        if (geometry && geometry.legs.size > 0) {
          const dtg = geometry.getDistanceToGo(this.guidanceController.activeLegIndex, this.ppos);
          const inboundTrans = geometry.transitions.get(activeLegIdx - 1);
          const activeLeg = geometry.legs.get(activeLegIdx);
          const outboundTrans = geometry.transitions.get(activeLegIdx) ? geometry.transitions.get(activeLegIdx) : null;
          if (!activeLeg) {
            return;
          }
          let completeDisplayLegPathDtg;
          if (inboundTrans instanceof FixedRadiusTransition && !inboundTrans.isNull) {
            if (inboundTrans.isAbeam(this.ppos)) {
              const inboundHalfDistance = inboundTrans.distance / 2;
              const inboundDtg = inboundTrans.getDistanceToGo(this.ppos);
              if (inboundDtg > inboundHalfDistance) {
                completeDisplayLegPathDtg = inboundDtg - inboundHalfDistance;
              }
            }
          }
          const completeLegPathDtg = Geometry.completeLegPathDistanceToGo(this.ppos, activeLeg, inboundTrans, outboundTrans);
          this.guidanceController.activeLegDtg = dtg;
          this.guidanceController.activeLegCompleteLegPathDtg = completeLegPathDtg;
          this.guidanceController.displayActiveLegCompleteLegPathDtg = completeDisplayLegPathDtg;

          // Update activeTransIndex in GuidanceController
          if (inboundTrans && inboundTrans.isAbeam(this.ppos)) {
            this.guidanceController.activeTransIndex = activeLegIdx - 1;
          } else if (outboundTrans && outboundTrans.isAbeam(this.ppos)) {
            this.guidanceController.activeTransIndex = activeLegIdx;
          } else {
            this.guidanceController.activeTransIndex = -1;
          }

          // Pseudo waypoint sequencing

          // FIXME when we have a path model, we don't have to do any of this business ?
          // FIXME see PseudoWaypoints.ts:153 for why we also allow the previous leg
          const pseudoWaypointsOnActiveLeg = this.guidanceController.currentPseudoWaypoints.filter(it => it.alongLegIndex === activeLegIdx || it.alongLegIndex === activeLegIdx - 1);
          for (const pseudoWaypoint of pseudoWaypointsOnActiveLeg) {
            // FIXME as with the hack above, we use the dtg to the intermediate point of the transition instead of
            // completeLegPathDtg, since we are pretending the previous leg is still active
            let dtgToUse;
            if (inboundTrans instanceof FixedRadiusTransition && pseudoWaypoint.alongLegIndex === activeLegIdx - 1) {
              const inboundHalfDistance = inboundTrans.distance / 2;
              const inboundDtg = inboundTrans.getDistanceToGo(this.ppos);
              if (inboundDtg > inboundHalfDistance) {
                dtgToUse = inboundDtg - inboundHalfDistance;
              } else {
                dtgToUse = completeLegPathDtg;
              }
            } else {
              dtgToUse = completeLegPathDtg;
            }
            if (pseudoWaypoint.distanceFromLegTermination >= dtgToUse) {
              this.guidanceController.sequencePseudoWaypoint(pseudoWaypoint);
            }
          }

          // Leg sequencing

          // TODO FIXME: Use FM position

          const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');

          // this is not the correct groundspeed to use, but it will suffice for now
          const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', 'Knots');
          const gs = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');
          const params = geometry.getGuidanceParameters(activeLegIdx, this.ppos, trueTrack, gs, tas);
          if (params) {
            var _params$phiLimit;
            if (this.lastLaw !== params.law) {
              this.lastLaw = params.law;
              SimVar.SetSimVarValue('L:B77HS_FG_CURRENT_LATERAL_LAW', 'number', params.law);
            }

            // Send bank limit to FG
            const bankLimit = (_params$phiLimit = params === null || params === void 0 ? void 0 : params.phiLimit) !== null && _params$phiLimit !== void 0 ? _params$phiLimit : maxBank(tas, false);
            SimVar.SetSimVarValue('L:B77HS_FG_PHI_LIMIT', 'Degrees', bankLimit);
            switch (params.law) {
              case ControlLaw.LATERAL_PATH:
                let {
                  crossTrackError,
                  trackAngleError,
                  phiCommand
                } = params;

                // Update and take into account turn state; only guide using phi during a forced turn

                if (this.turnState !== LnavTurnState.Normal) {
                  if (Math.abs(trackAngleError) < GuidanceConstants.FORCED_TURN_TKAE_THRESHOLD) {
                    // Stop forcing turn
                    this.turnState = LnavTurnState.Normal;
                  }
                  const forcedTurnPhi = this.turnState === LnavTurnState.ForceLeftTurn ? -maxBank(tas, true) : maxBank(tas, true);
                  crossTrackError = 0;
                  trackAngleError = 0;
                  phiCommand = forcedTurnPhi;
                }

                // Set FG inputs

                if (!this.lastAvail) {
                  SimVar.SetSimVarValue('L:B77HS_FG_AVAIL', 'Bool', true);
                  this.lastAvail = true;
                }
                if (crossTrackError !== this.lastXTE) {
                  SimVar.SetSimVarValue('L:B77HS_FG_CROSS_TRACK_ERROR', 'nautical miles', crossTrackError);
                  this.lastXTE = crossTrackError;
                }
                if (trackAngleError !== this.lastTAE) {
                  SimVar.SetSimVarValue('L:B77HS_FG_TRACK_ANGLE_ERROR', 'degree', trackAngleError);
                  this.lastTAE = trackAngleError;
                }
                if (phiCommand !== this.lastPhi) {
                  SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', phiCommand);
                  this.lastPhi = phiCommand;
                }
                break;
              case ControlLaw.HEADING:
                const {
                  heading,
                  phiCommand: forcedPhiHeading
                } = params;
                if (!this.lastAvail) {
                  SimVar.SetSimVarValue('L:B77HS_FG_AVAIL', 'Bool', true);
                  this.lastAvail = true;
                }
                if (this.lastXTE !== 0) {
                  SimVar.SetSimVarValue('L:B77HS_FG_CROSS_TRACK_ERROR', 'nautical miles', 0);
                  this.lastXTE = 0;
                }

                // Track Angle Error
                const currentHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'Degrees');
                const deltaHeading = MathUtils.diffAngle(currentHeading, heading);

                // Update and take into account turn state; only guide using phi during a forced turn

                if (this.turnState !== LnavTurnState.Normal) {
                  if (Math.abs(deltaHeading) < GuidanceConstants.FORCED_TURN_TKAE_THRESHOLD) {
                    // Stop forcing turn
                    this.turnState = LnavTurnState.Normal;
                  }
                  const forcedTurnPhi = this.turnState === LnavTurnState.ForceLeftTurn ? -maxBank(tas, true) : maxBank(tas, true);
                  if (forcedTurnPhi !== this.lastPhi) {
                    SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', forcedTurnPhi);
                    this.lastPhi = forcedTurnPhi;
                  }
                  if (this.lastTAE !== 0) {
                    SimVar.SetSimVarValue('L:B77HS_FG_TRACK_ANGLE_ERROR', 'degree', 0);
                    this.lastTAE = 0;
                  }
                } else {
                  if (deltaHeading !== this.lastTAE) {
                    SimVar.SetSimVarValue('L:B77HS_FG_TRACK_ANGLE_ERROR', 'degree', deltaHeading);
                    this.lastTAE = deltaHeading;
                  }
                  if (forcedPhiHeading !== undefined) {
                    if (forcedPhiHeading !== this.lastPhi) {
                      SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', forcedPhiHeading);
                      this.lastPhi = forcedPhiHeading;
                    }
                  } else if (this.lastPhi !== 0) {
                    SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', 0);
                    this.lastPhi = 0;
                  }
                }
                break;
              case ControlLaw.TRACK:
                const {
                  course,
                  phiCommand: forcedPhiCourse
                } = params;
                if (!this.lastAvail) {
                  SimVar.SetSimVarValue('L:B77HS_FG_AVAIL', 'Bool', true);
                  this.lastAvail = true;
                }
                if (this.lastXTE !== 0) {
                  SimVar.SetSimVarValue('L:B77HS_FG_CROSS_TRACK_ERROR', 'nautical miles', 0);
                  this.lastXTE = 0;
                }
                const deltaCourse = MathUtils.diffAngle(trueTrack, course);
                if (this.turnState !== LnavTurnState.Normal) {
                  if (Math.abs(deltaCourse) < GuidanceConstants.FORCED_TURN_TKAE_THRESHOLD) {
                    // Stop forcing turn
                    this.turnState = LnavTurnState.Normal;
                  }
                  const forcedTurnPhi = this.turnState === LnavTurnState.ForceLeftTurn ? -maxBank(tas, true) : maxBank(tas, true);
                  if (forcedTurnPhi !== this.lastPhi) {
                    SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', forcedTurnPhi);
                    this.lastPhi = forcedTurnPhi;
                  }
                  if (this.lastTAE !== 0) {
                    SimVar.SetSimVarValue('L:B77HS_FG_TRACK_ANGLE_ERROR', 'degree', 0);
                    this.lastTAE = 0;
                  }
                } else {
                  if (deltaCourse !== this.lastTAE) {
                    SimVar.SetSimVarValue('L:B77HS_FG_TRACK_ANGLE_ERROR', 'degree', deltaCourse);
                    this.lastTAE = deltaCourse;
                  }
                  if (forcedPhiCourse !== undefined) {
                    if (forcedPhiCourse !== this.lastPhi) {
                      SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', forcedPhiCourse);
                      this.lastPhi = forcedPhiCourse;
                    }
                  } else if (this.lastPhi !== 0) {
                    SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', 0);
                    this.lastPhi = 0;
                  }
                }
                break;
            }
            available = true;
          }
          SimVar.SetSimVarValue('L:B77HS_GPS_WP_DISTANCE', 'nautical miles', dtg !== null && dtg !== void 0 ? dtg : 0);

          // Update EFIS active waypoint info

          this.updateEfisData(activeLeg, gs);

          // Sequencing

          const flightPhase = SimVar.GetSimVarValue('L:B77HS_aims_FLIGHT_PHASE', 'Enum');
          const canSequence = !activeLeg.disableAutomaticSequencing && flightPhase >= AimsFlightPhase.Takeoff;
          let withinSequencingArea = true;
          if (params.law === ControlLaw.LATERAL_PATH) {
            withinSequencingArea = Math.abs(params.crossTrackError) < 7 && Math.abs(params.trackAngleError) < 90;
          }
          if (canSequence && withinSequencingArea && geometry.shouldSequenceLeg(activeLegIdx, this.ppos) || activeLeg.isNull) {
            const outboundTransition = geometry.transitions.get(activeLegIdx);
            const nextLeg = geometry.legs.get(activeLegIdx + 1);
            const followingLeg = geometry.legs.get(activeLegIdx + 2);
            if (nextLeg) {
              // FIXME we should stop relying on discos in the wpt objects, but for now it's fiiiiiine
              // Hard-coded check for TF leg after the disco for now - only case where we don't wanna
              // sequence this way is VM
              if (activeLeg instanceof XFLeg && activeLeg.fix.endsInDiscontinuity) {
                this.sequenceDiscontinuity(activeLeg);
              } else {
                this.sequenceLeg(activeLeg, outboundTransition);
              }
              geometry.onLegSequenced(activeLeg, nextLeg, followingLeg);
            } else {
              this.sequenceDiscontinuity(activeLeg);
              geometry.onLegSequenced(activeLeg, nextLeg, followingLeg);
            }
          }
        }

        /* Set FG parameters */

        if (!available && this.lastAvail !== false) {
          SimVar.SetSimVarValue('L:B77HS_FG_AVAIL', 'Bool', false);
          SimVar.SetSimVarValue('L:B77HS_FG_CROSS_TRACK_ERROR', 'nautical miles', 0);
          SimVar.SetSimVarValue('L:B77HS_FG_TRACK_ANGLE_ERROR', 'degree', 0);
          SimVar.SetSimVarValue('L:B77HS_FG_PHI_COMMAND', 'degree', 0);
          this.lastAvail = false;
          this.lastTAE = null;
          this.lastXTE = null;
          this.lastPhi = null;
          this.turnState = LnavTurnState.Normal;
        }
      }

      /**
       * Updates the EFIS TO WPT data
       *
       * @param activeLeg currently active display leg
       * @param gs        current ground speed in knots
       *
       * @private
       */
      updateEfisData(activeLeg, gs) {
        const termination = activeLeg instanceof XFLeg ? activeLeg.fix.infos.coordinates : activeLeg.getPathEndPoint();
        const efisTrueBearing = termination ? Avionics.Utils.computeGreatCircleHeading(this.ppos, termination) : -1;
        const efisBearing = termination ? B77HS_Util.trueToMagnetic(efisTrueBearing, Facilities.getMagVar(this.ppos.lat, this.ppos.long)) : -1;

        // Don't compute distance and ETA for XM legs
        const efisDistance = activeLeg instanceof VMLeg ? -1 : Avionics.Utils.computeGreatCircleDistance(this.ppos, termination);
        const efisEta = activeLeg instanceof VMLeg ? -1 : LnavDriver.legEta(this.ppos, gs, termination);

        // FIXME should be NCD if no FM position

        SimVar.SetSimVarValue('L:B77HS_EFIS_L_TO_WPT_BEARING', 'Degrees', efisBearing);
        SimVar.SetSimVarValue('L:B77HS_EFIS_L_TO_WPT_TRUE_BEARING', 'Degrees', efisTrueBearing);
        SimVar.SetSimVarValue('L:B77HS_EFIS_L_TO_WPT_DISTANCE', 'Number', efisDistance);
        SimVar.SetSimVarValue('L:B77HS_EFIS_L_TO_WPT_ETA', 'Seconds', efisEta);
        SimVar.SetSimVarValue('L:B77HS_EFIS_R_TO_WPT_BEARING', 'Degrees', efisBearing);
        SimVar.SetSimVarValue('L:B77HS_EFIS_R_TO_WPT_TRUE_BEARING', 'Degrees', efisTrueBearing);
        SimVar.SetSimVarValue('L:B77HS_EFIS_R_TO_WPT_DISTANCE', 'Number', efisDistance);
        SimVar.SetSimVarValue('L:B77HS_EFIS_R_TO_WPT_ETA', 'Seconds', efisEta);
      }
      static legEta(ppos, gs, termination) {
        // FIXME use a more accurate estimate, calculate in predictions

        const UTC_SECONDS = Math.floor(SimVar.GetGlobalVarValue('ZULU TIME', 'seconds'));
        const nauticalMilesToGo = Avionics.Utils.computeGreatCircleDistance(ppos, termination);
        const secondsToGo = nauticalMilesToGo / Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, gs) * 3600;
        const eta = (UTC_SECONDS + secondsToGo) % (3600 * 24);
        return eta;
      }
      sequenceLeg(_leg, outboundTransition) {
        let wpIndex = this.guidanceController.flightPlanManager.getActiveWaypointIndex(false, false, 0);
        const wp = this.guidanceController.flightPlanManager.getActiveWaypoint(false, false, 0);
        console.log("[aims/Guidance] LNAV - sequencing leg. [WP: ".concat(wp.ident, " Active WP Index: ").concat(wpIndex, "]"));
        wp.waypointReachedAt = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds');
        this.guidanceController.flightPlanManager.setActiveWaypointIndex(++wpIndex, () => {}, 0);
        outboundTransition === null || outboundTransition === void 0 ? void 0 : outboundTransition.freeze();

        // Set turn state based on turn direction
        if (outboundTransition && (outboundTransition instanceof PathCaptureTransition || outboundTransition instanceof CourseCaptureTransition)) {
          if (outboundTransition.turnDirection === TurnDirection.Left) {
            this.turnState = LnavTurnState.ForceLeftTurn;
          } else if (outboundTransition.turnDirection === TurnDirection.Right) {
            this.turnState = LnavTurnState.ForceRightTurn;
          } else {
            // Just to be safe
            this.turnState = LnavTurnState.Normal;
          }
        } else {
          this.turnState = LnavTurnState.Normal;
        }
      }
      sequenceDiscontinuity(_leg) {
        console.log('[aims/Guidance] LNAV - sequencing discontinuity');

        // Lateral mode is NAV
        const lateralModel = SimVar.GetSimVarValue('L:B77HS_FMA_LATERAL_MODE', 'Enum');
        const verticalMode = SimVar.GetSimVarValue('L:B77HS_FMA_VERTICAL_MODE', 'Enum');
        let reverted = false;
        if (lateralModel === LateralMode.NAV) {
          // Set HDG (current heading)
          SimVar.SetSimVarValue('H:A320_Neo_FCU_HDG_PULL', 'number', 0);
          SimVar.SetSimVarValue('L:B77HS_FM_HEADING_SYNC', 'boolean', true);
          reverted = true;
        }
        if (verticalMode === VerticalMode.DES) {
          // revert to V/S
          SimVar.SetSimVarValue('H:A320_Neo_FCU_VS_PULL', 'number', 0);
          reverted = true;
        } else if (verticalMode === VerticalMode.CLB) {
          // revert to OP CLB
          SimVar.SetSimVarValue('H:A320_Neo_FCU_ALT_PULL', 'number', 0);
          reverted = true;
        }
        if (reverted) {
          // Triple click
          Coherent.call('PLAY_INSTRUMENT_SOUND', '3click').catch(console.error);
        }
        this.sequenceLeg(_leg, null);
      }
      sequenceManual(_leg) {
        console.log('[aims/Guidance] LNAV - sequencing MANUAL');
      }
    }

    let FlapConf;
    (function (FlapConf) {
      FlapConf[FlapConf["CLEAN"] = 0] = "CLEAN";
      FlapConf[FlapConf["FLAPS_1"] = 1] = "FLAPS_1";
      FlapConf[FlapConf["FLAPS_5"] = 2] = "FLAPS_5";
      FlapConf[FlapConf["FLAPS_15"] = 3] = "FLAPS_15";
      FlapConf[FlapConf["FLAPS_20"] = 4] = "FLAPS_20";
      FlapConf[FlapConf["FLAPS_25"] = 5] = "FLAPS_25";
      FlapConf[FlapConf["FLAPS_30"] = 6] = "FLAPS_30";
    })(FlapConf || (FlapConf = {}));
    let AccelFactorMode;
    (function (AccelFactorMode) {
      AccelFactorMode[AccelFactorMode["CONSTANT_CAS"] = 0] = "CONSTANT_CAS";
      AccelFactorMode[AccelFactorMode["CONSTANT_MACH"] = 1] = "CONSTANT_MACH";
    })(AccelFactorMode || (AccelFactorMode = {}));
    let VerticalWaypointType;
    (function (VerticalWaypointType) {
      VerticalWaypointType[VerticalWaypointType["CRZ"] = 0] = "CRZ";
      VerticalWaypointType[VerticalWaypointType["CLB"] = 1] = "CLB";
      VerticalWaypointType[VerticalWaypointType["DES"] = 2] = "DES";
    })(VerticalWaypointType || (VerticalWaypointType = {}));
    class Common {
      /**
       * Calculates ISA temperature as a function of altitude
       * @param alt in feet
       * @param aboveTropo boolean
       * @returns ISA temperature in celsius
       */
      static getIsaTemp(alt) {
        let aboveTropo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (aboveTropo) {
          return -56.5;
        }
        return 15 - 0.0019812 * alt;
      }
      static getTemp(alt) {
        let isaDev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let aboveTropo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (aboveTropo) {
          return -56.5 + isaDev;
        }
        return 15 - 0.0019812 * alt + isaDev;
      }

      /**
       * Get temperature ratio for a particular altitude (below tropopause)
       * @param alt pressure altitude
       * @param isaDev ISA deviation in celsius
       * @param aboveTropo whether the aircraft is above the tropopause
       * @returns temperature ratio
       */
      static getTheta(alt) {
        let isaDev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let aboveTropo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (aboveTropo) {
          return (216.65 + isaDev) / 288.15;
        }
        return (288.15 - 0.0019812 * alt + isaDev) / 288.15;
      }

      /**
       * Get temperature ratio for a particular altitude and mach.
       * @param theta temperature ratio (from only altitude)
       * @param mach mach
       * @returns temperature ratio
       */
      static getTheta2(theta, mach) {
        return theta * (1 + 0.2 * mach ** 2);
      }

      /**
       * Get pressure ratio for a particular theta
       * @param alt pressure altitude
       * @param aboveTropo whether the aircraft is above the tropopause
       * @returns pressure ratio
       */
      static getDelta(alt) {
        let aboveTropo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (aboveTropo && alt !== undefined) {
          return 0.22336 * Math.exp((36089.24 - alt) / 20805.7);
        }
        return this.getTheta(alt, 0, aboveTropo) ** 5.25588;
      }

      /**
       * Get pressure ratio for a particular theta and mach
       * @param delta pressure ratio (from only theta)
       * @param mach mach
       * @returns pressure ratio
       */
      static getDelta2(delta, mach) {
        return delta * (1 + 0.2 * mach ** 2) ** 3.5;
      }

      /**
       * Get KTAS value from mach
       * @param mach
       * @param theta
       * @returns speed in KTAS (knots true airspeed)
       */
      static machToTAS(mach, theta) {
        return 661.4786 * mach * Math.sqrt(theta);
      }
      static machToEAS(mach, delta) {
        return 661.4786 * mach * Math.sqrt(delta);
      }
      static CAStoMach(cas, delta) {
        const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
        const term2 = 1 / delta * (term1 ** 3.5 - 1);
        const term3 = 5 * ((term2 + 1) ** (1 / 3.5) - 1);
        return Math.sqrt(term3);
      }
      static machToCas(mach, delta) {
        const term1 = (0.2 * mach ** 2 + 1) ** 3.5;
        const term2 = (delta * term1 + 1) ** (1 / 3.5) - 1;
        return 1479.1 * Math.sqrt(term2);
      }
      static TAStoCAS(tas, theta, delta) {
        const term1 = 1 + 1 / theta * (tas / 1479.1) ** 2;
        const term2 = delta * (term1 ** 3.5 - 1) + 1;
        const term3 = term2 ** (1 / 3.5) - 1;
        return 1479.1 * Math.sqrt(term3);
      }
      static CAStoTAS(cas, theta, delta) {
        const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
        const term2 = 1 / delta * (term1 ** 3.5 - 1);
        const term3 = theta * ((term2 + 1) ** (1 / 3.5) - 1);
        return 1479.1 * Math.sqrt(term3);
      }
      static CAStoEAS(cas, delta) {
        const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
        const term2 = 1 / delta * (term1 ** 3.5 - 1);
        const term3 = delta * ((term2 + 1) ** (1 / 3.5) - 1);
        return 1479.1 * Math.sqrt(term3);
      }
      static getAccelFactorCAS(mach, aboveTropo, tempRatio) {
        const phi = ((1 + 0.2 * mach ** 2) ** 3.5 - 1) / (0.7 * mach ** 2 * (1 + 0.2 * mach ** 2) ** 2.5);
        if (aboveTropo) {
          return 1 + 0.7 * mach ** 2 * phi;
        }
        return 1 + 0.7 * mach ** 2 * (phi - 0.190263 * tempRatio);
      }
      static getAccelFactorMach(mach, aboveTropo, tempRatio) {
        if (aboveTropo) {
          return 0;
        }
        return -0.13318 * mach ** 2 * tempRatio;
      }

      /**
       * Placeholder
       * @param mach
       * @param temp
       * @param stdTemp
       * @param aboveTropo
       * @param accelFactorMode
       * @returns
       */
      static getAccelerationFactor(mach, altitude, isaDev, aboveTropo, accelFactorMode) {
        const stdTemp = Common.getIsaTemp(altitude, aboveTropo);
        const temp = Common.getTemp(altitude, isaDev, aboveTropo);
        const tempRatio = stdTemp / temp;
        if (accelFactorMode === AccelFactorMode.CONSTANT_CAS) {
          return Common.getAccelFactorCAS(mach, aboveTropo, tempRatio);
        }
        return Common.getAccelFactorMach(mach, aboveTropo, tempRatio);
      }
      static interpolate(x, x0, x1, y0, y1) {
        return (y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0);
      }
      static poundsToMetricTons(pounds) {
        return pounds / 2204.6;
      }
    }

    class EngineModel {
      // In pounds of force. Used as a multiplier for results of table 1506

      /**
       * Table 1502 - CN2 vs CN1 @ Mach 0, 0.2, 0.9
       * n2_to_n1_table
       * @param i row index (n2)
       * @param j 1 = Mach 0, 2 = Mach 0.2, 3 = Mach 0.9
       * @returns Corrected N1 (CN1)
       */

      /**
       * Table 1503 - Turbine LoMach (0) CN2 vs. Throttle @ IAP Ratio 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313
       * mach_0_corrected_commanded_ne_table
       * @param i row index (thrust lever position)
       * @param j IAP ratio
       * @returns Corrected N2 (CN2)
       */

      /**
       * Table 1504 - Turbine HiMach (0.9) CN2 vs. Throttle @ IAP Ratio 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313
       * mach_hi_corrected_commanded_ne_table
       * @param i row index (thrust lever position)
       * @param j IAP ratio
       * @returns Corrected N2 (CN2)
       */

      /**
       * Table 1506 - Corrected net Thrust vs CN1 @ Mach 0 to 0.9 in 0.1 steps
       * n1_and_mach_on_thrust_table
       * @param i row index (CN1)
       * @param j mach
       * @returns Corrected net thrust (pounds of force)
       */

      /**
       * Placeholder
       * @param table
       * @param i
       * @param j
       * @returns
       */
      static tableInterpolation(table, i, j) {
        const numRows = table.length;
        const numCols = table[0].length;
        // Iterate through rows to find the upper bound to i
        let r;
        for (r = 1; r < numRows; r++) {
          if (table[r][0] > i) {
            break;
          }
        }
        // Get lower bound to i
        const r1 = Math.max(1, r - 1);
        const r2 = Math.min(numRows - 1, r);
        // Iterate through rows to find the upper bound to j
        let c;
        for (c = 1; c < numCols; c++) {
          if (table[0][c] > j) {
            break;
          }
        }
        // Get the lower bound to j
        const c1 = Math.max(1, c - 1);
        const c2 = Math.min(numCols - 1, c);
        const interpolatedRowAtC1 = r1 === r2 ? table[r1][c1] : Common.interpolate(i, table[r1][0], table[r2][0], table[r1][c1], table[r2][c1]);
        const interpolatedRowAtC2 = r1 === r2 ? table[r1][c2] : Common.interpolate(i, table[r1][0], table[r2][0], table[r1][c2], table[r2][c2]);
        return Common.interpolate(j, table[0][c1], table[0][c2], interpolatedRowAtC1, interpolatedRowAtC2);
      }

      /**
       * Retrieve a bilinear interpolated row value from a table
       * @param table
       * @param j Value on column axis
       * @param result Value normally returned as result
       */
      static reverseTableInterpolation(table, j, result) {
        const numRows = table.length;
        const numCols = table[0].length;
        let c;
        for (c = 1; c < numCols; c++) {
          if (table[0][c] > j) {
            break;
          }
        }
        const c1 = Math.max(1, c - 1);
        const c2 = Math.min(numCols - 1, c);
        let r;
        for (r = 1; r < numRows; r++) {
          if (table[r][c1] > result) {
            break;
          }
        }
        const r1 = Math.max(1, r - 1);
        const r2 = Math.min(numRows - 1, r);
        for (r = 1; r < numRows; r++) {
          if (table[r][c2] > result) {
            break;
          }
        }
        const r3 = Math.max(1, r - 1);
        const r4 = Math.min(numRows - 1, r);
        const interpolatedRowAtC1 = r1 === r2 ? table[r1][0] : Common.interpolate(result, table[r1][c1], table[r2][c1], table[r1][0], table[r2][0]);
        const interpolatedRowAtC2 = r3 === r4 ? table[r3][0] : Common.interpolate(result, table[r3][c2], table[r4][c2], table[r3][0], table[r4][0]);
        return Common.interpolate(j, table[0][c1], table[0][c2], interpolatedRowAtC1, interpolatedRowAtC2);
      }

      /**
       * Placeholder
       * @param cn1 corrected N1 %
       * @param mach mach value
       * @param alt altitude in feet
       * @returns fuel flow, in pounds per hour (per engine)
       */
      static getCorrectedFuelFlow(cn1, mach, alt) {
        const coefficients = [-639.6602981, 0.00000e+00, 1.03705e+02, -2.23264e+03, 5.70316e-03, -2.29404e+00, 1.08230e+02, 2.77667e-04, -6.17180e+02, -7.20713e-02, 2.19013e-07, 2.49418e-02, -7.31662e-01, -1.00003e-05, -3.79466e+01, 1.34552e-03, 5.72612e-09, -2.71950e+02, 8.58469e-02, -2.72912e-06, 2.02928e-11];
        const flow = coefficients[0] + coefficients[1] + coefficients[2] * cn1 + coefficients[3] * mach + coefficients[4] * alt + coefficients[5] * cn1 ** 2 + coefficients[6] * cn1 * mach + coefficients[7] * cn1 * alt + coefficients[8] * mach ** 2 + coefficients[9] * mach * alt + coefficients[10] * alt ** 2 + coefficients[11] * cn1 ** 3 + coefficients[12] * cn1 ** 2 * mach + coefficients[13] * cn1 ** 2 * alt + coefficients[14] * cn1 * mach ** 2 + coefficients[15] * cn1 * mach * alt + coefficients[16] * cn1 * alt ** 2 + coefficients[17] * mach ** 3 + coefficients[18] * mach ** 2 * alt + coefficients[19] * mach * alt ** 2 + coefficients[20] * alt ** 3;
        return flow;
      }

      // static getCN1fromUncorrectedThrust(thrust: number)

      static getCorrectedN1(n1, theta2) {
        return n1 / Math.sqrt(theta2);
      }
      static getUncorrectedN1(cn1, theta2) {
        return cn1 * Math.sqrt(theta2);
      }
      static getUncorrectedN2(cn2, theta2) {
        return cn2 * Math.sqrt(theta2);
      }
      static getUncorrectedThrust(correctedThrust, delta2) {
        return correctedThrust * delta2;
      }
      static getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) {
        return correctedFuelFlow * delta2 * Math.sqrt(theta2);
      }
      static getCorrectedThrust(uncorrectedThrust, delta2) {
        return uncorrectedThrust / delta2;
      }
    }
    _defineProperty$2(EngineModel, "maxThrust", 27120);
    _defineProperty$2(EngineModel, "table1502", [[0, 0, 0.2, 0.9], [18.200000, 0.000000, 0.000000, 17.000000], [22.000000, 1.900000, 1.900000, 17.400000], [26.000000, 2.500000, 2.500000, 18.200000], [57.000000, 12.800000, 12.800000, 27.000000], [68.200000, 19.600000, 19.600000, 34.827774], [77.000000, 26.000000, 26.000000, 40.839552], [83.000000, 31.420240, 31.420240, 44.768766], [89.000000, 40.972041, 40.972041, 50.092140], [92.800000, 51.000000, 51.000000, 55.042000], [97.000000, 65.000000, 65.000000, 65.000000], [100.000000, 77.000000, 77.000000, 77.000000], [104.000000, 85.000000, 85.000000, 85.500000], [116.500000, 101.000000, 101.000000, 101.000000]]);
    _defineProperty$2(EngineModel, "table1503", [[0, 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313], [0.000000, 68.200000, 69.402657, 70.671269, 73.432244, 76.544349, 78.644882, 78.644882], [0.100000, 76.000000, 77.340205, 78.753906, 81.830654, 85.298688, 87.639458, 87.639458], [0.200000, 83.000000, 84.463645, 86.007556, 89.367688, 93.155146, 95.711513, 95.711513], [0.400000, 92.800000, 94.436461, 96.162664, 99.919535, 104.154188, 107.012390, 107.012390], [0.600000, 98.000000, 99.728159, 101.551090, 105.518475, 109.990414, 113.008774, 113.008774], [0.750000, 101.500000, 103.289879, 105.177914, 109.286991, 113.918643, 117.044802, 117.044802], [0.900000, 103.000000, 104.816330, 106.000000, 110.902070, 115.602170, 118.774528, 118.774528], [1.000000, 104.200000, 106.037491, 107.975750, 112.194133, 116.948991, 120.158309, 120.158309]]);
    _defineProperty$2(EngineModel, "table1504", [[0, 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313], [0.000000, 63.267593, 64.383271, 65.560133, 68.121427, 71.008456, 72.957073, 72.957073], [0.100000, 70.503476, 71.746753, 73.058212, 75.912441, 79.129658, 81.301137, 81.301137], [0.200000, 76.997217, 78.355007, 79.787258, 82.904376, 86.417916, 88.789399, 88.789399], [0.400000, 86.088455, 87.606562, 89.207922, 92.693086, 96.621477, 99.272967, 99.272967], [0.600000, 90.912377, 92.515550, 94.206642, 97.887095, 102.035612, 104.835676, 104.835676], [0.750000, 94.159247, 95.819677, 97.571165, 101.383063, 105.679741, 108.579808, 108.579808], [0.900000, 95.550763, 97.235732, 98.333795, 102.881334, 107.241510, 110.184435, 110.184435], [1.000000, 104.200000, 106.037491, 107.975750, 112.194133, 116.948991, 120.158309, 120.158309]]);
    _defineProperty$2(EngineModel, "table1506", [[0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000], [20.000000, 0.091741, 0.057020, 0.052029, 0.028096, -0.017284, -0.037284, -0.057077, -0.205841, -0.315399, -0.488717], [25.000000, 0.142810, 0.072215, 0.053026, 0.030404, -0.009593, -0.026571, -0.041999, -0.151328, -0.266204, -0.439028], [30.000000, 0.189837, 0.082322, 0.055050, 0.032748, 0.017389, 0.003990, -0.026921, -0.056814, -0.081946, -0.369391], [35.000000, 0.262207, 0.126047, 0.077206, 0.045921, 0.024719, 0.006062, -0.002812, -0.022800, -0.044248, -0.293631], [40.000000, 0.330230, 0.162757, 0.124088, 0.069579, 0.057905, 0.049621, 0.029790, -0.002139, -0.025811, -0.220630], [45.000000, 0.393293, 0.250096, 0.156707, 0.112419, 0.091418, 0.076757, 0.056090, 0.018509, -0.007375, -0.155120], [50.000000, 0.452337, 0.311066, 0.211353, 0.158174, 0.127429, 0.104915, 0.081171, 0.047419, 0.011062, -0.098474], [55.000000, 0.509468, 0.373568, 0.269961, 0.209106, 0.168650, 0.137223, 0.108383, 0.075660, 0.028704, -0.049469], [60.000000, 0.594614, 0.439955, 0.334629, 0.267477, 0.217773, 0.176899, 0.141404, 0.107148, 0.064556, -0.005036], [65.000000, 0.660035, 0.512604, 0.407151, 0.335055, 0.276928, 0.226669, 0.183627, 0.145850, 0.104441, 0.039012], [70.000000, 0.733601, 0.593506, 0.488571, 0.412623, 0.347163, 0.288210, 0.237559, 0.195142, 0.152485, 0.087269], [75.000000, 0.818693, 0.683880, 0.578756, 0.499514, 0.427939, 0.361604, 0.304241, 0.257197, 0.212005, 0.144042], [80.000000, 0.910344, 0.783795, 0.675982, 0.593166, 0.516644, 0.444822, 0.382689, 0.332384, 0.284867, 0.212679], [85.000000, 1.025165, 0.891823, 0.776548, 0.688692, 0.608128, 0.533210, 0.469351, 0.418690, 0.370870, 0.294907], [90.000000, 1.157049, 1.004695, 0.874400, 0.778466, 0.694251, 0.619011, 0.557581, 0.511153, 0.467149, 0.390203], [95.000000, 1.281333, 1.116993, 0.960774, 0.851733, 0.763455, 0.690890, 0.637136, 0.601322, 0.567588, 0.495167], [100.000000, 1.357935, 1.220844, 1.023864, 0.894234, 0.800352, 0.733488, 0.693684, 0.654691, 0.617963, 0.539115], [105.000000, 1.378826, 1.239626, 1.048498, 0.915750, 0.819609, 0.751137, 0.710375, 0.670444, 0.632832, 0.552086], [110.000000, 1.392754, 1.252148, 1.069322, 0.933937, 0.835886, 0.766054, 0.724483, 0.683759, 0.645400, 0.563051]]);

    class FlightModel {
      // in knots/second

      // in m/s^2

      // in knots/second

      // in m/s^2

      // From https://github.com/flybywiresim/a32nx/pull/6903#issuecomment-1073168320

      /**
       * Get lift coefficient at given conditions
       * @param weight in pounds
       * @param mach self-explanatory
       * @param delta pressure at the altitude divided by the pressure at sea level
       * @param loadFactor g-Force
       * @returns lift coefficient (Cl)
       */
      static getLiftCoefficient(weight, mach, delta) {
        let loadFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        return weight * loadFactor / (1481.4 * mach ** 2 * delta * this.wingArea);
      }
      static getLiftCoefficientFromEAS(lift, eas) {
        return 295.369 * lift / (eas ** 2 * this.wingArea);
      }

      /**
       * Get drag coefficient at given conditions
       * @param Cl coefficient of lift
       * @param spdBrkDeflected whether speedbrake is deflected at half or not
       * @param gearExtended whether gear is extended or not
       * @param flapConf flap configuration
       * @returns drag coefficient (Cd)
       */
      // TODO add correct drag for each flaps settings
      static getDragCoefficient(Cl) {
        let spdBrkDeflected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let gearExtended = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let flapConf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : FlapConf.CLEAN;
        // Values taken at mach 0
        let baseDrag;
        switch (flapConf) {
          case FlapConf.CLEAN:
            baseDrag = 0.0211 * Cl ** 3 + 0.0412 * Cl ** 2 - 0.015 * Cl + 0.0215;
            break;
          case FlapConf.CONF_1:
            baseDrag = 0.0303 * Cl ** 4 - 0.064 * Cl ** 3 + 0.1166 * Cl ** 2 - 0.0538 * Cl + 0.0398;
            break;
          case FlapConf.CONF_2:
            baseDrag = 0.0168 * Cl ** 3 - 0.0018 * Cl ** 2 - 0.0037 * Cl + 0.0729;
            break;
          case FlapConf.CONF_3:
            baseDrag = 0.013 * Cl ** 3 - 0.0056 * Cl ** 2 + 0.0005 * Cl + 0.0902;
            break;
          case FlapConf.CONF_FULL:
            baseDrag = 0.0077 * Cl ** 3 - 0.0056 * Cl ** 2 - 0.001 * Cl + 0.1405;
            break;
        }
        const spdBrkIncrement = spdBrkDeflected ? 0.01008 : 0;
        const gearIncrement = gearExtended ? 0.0372 : 0;
        return baseDrag + spdBrkIncrement + gearIncrement;
      }

      /**
       * Get drag at given conditions
       * @param weight in pounds
       * @param mach self-explanatory
       * @param delta pressure at the altitude divided by the pressure at sea level
       * @param spdBrkDeflected Whether speedbrake is deflected at half or not
       * @param gearExtended whether gear is extended or not
       * @param flapConf flap configuration
       * @returns drag
       */
      static getDrag(weight, mach, delta, spdBrkDeflected, gearExtended, flapConf) {
        const Cl = this.getLiftCoefficient(weight, mach, delta);
        const Cd = this.getDragCoefficient(Cl, spdBrkDeflected, gearExtended, flapConf);
        const deltaCd = this.getMachCorrection(mach, flapConf);
        return 1481.4 * mach ** 2 * delta * this.wingArea * (Cd + deltaCd);
      }
      static getMachCorrection(mach, flapConf) {
        if (flapConf !== FlapConf.CLEAN) {
          return 0;
        }
        return this.interpolate(mach, this.machValues, this.dragCoefficientCorrections);
      }

      /**
       * Interpolates in a list
       * @param x The value to look up in in `xs`.
       * @param xs The table of x values with known y values
       * @param ys The y values corresponding to the x values in `xs`
       */
      static interpolate(x, xs, ys) {
        if (x <= xs[0]) {
          return ys[0];
        }
        for (let i = 0; i < xs.length - 1; i++) {
          if (x > xs[i] && x <= xs[i + 1]) {
            return Common.interpolate(x, xs[i], xs[i + 1], ys[i], ys[i + 1]);
          }
        }
        return ys[ys.length - 1];
      }

      // NEW

      /**
       * Returns the available climb or descent gradient.
       *
       * @param thrust the thrust in lbf
       * @param drag
       * @param weight in lbs
       *
       * @returns the available gradient in radians
       */
      static getAvailableGradient(thrust, drag, weight) {
        return Math.asin((thrust - drag) / weight);
      }

      /**
       * Returns an acceleration for a given available gradient, fpa and acceleration factor.
       *
       * @param availableGradient in radians
       * @param fpa in radians
       * @param accelFactor
       *
       * @returns the acceleration
       */
      static accelerationForGradient(availableGradient, fpa, accelFactor) {
        return (Math.sin(availableGradient) - Math.sin(fpa)) * accelFactor;
      }

      /**
       * Returns an fpa for a given available gradient, acceleration and acceleration factor.
       *
       * @param availableGradient in radians
       * @param acceleration
       * @param accelFactor
       *
       * @returns the fpa in radians
       */
      static fpaForGradient(availableGradient, acceleration, accelFactor) {
        return Math.asin(Math.sin(availableGradient) - acceleration / accelFactor);
      }

      // END NEW

      static getConstantThrustPathAngle(thrust, weight, drag, accelFactor) {
        return Math.asin((thrust - drag) / weight / accelFactor);
      }
      static getConstantThrustPathAngleFromCoefficients(thrust, weight, Cl, Cd, accelFactor) {
        return Math.asin((thrust / weight - Cd / Cl) / accelFactor);
      }
      static getThrustFromConstantPathAngle(fpa, weight, drag, accelFactor) {
        // fpa is in degrees
        return weight * (accelFactor * Math.sin(fpa * MathUtils.DEGREES_TO_RADIANS)) + drag;
      }
      static getThrustFromConstantPathAngleCoefficients(fpa, weight, Cl, Cd, accelFactor) {
        // fpa is in degrees
        return weight * (accelFactor * Math.sin(fpa * MathUtils.DEGREES_TO_RADIANS) + Cd / Cl);
      }
      static getSpeedChangePathAngle(thrust, weight, drag) {
        return Math.asin((thrust - drag) / weight - 1 / FlightModel.gravityConstMS2 * FlightModel.requiredAccelRateMS2);
      }
      static getSpeedChangePathAngleFromCoefficients(thrust, weight, Cl, Cd) {
        return Math.asin(thrust / weight - Cd / Cl - 1 / FlightModel.gravityConstMS2 * FlightModel.requiredAccelRateMS2);
      }
      static getAccelRateFromIdleGeoPath(thrust, weight, drag, fpaDeg) {
        // fpa is in degrees
        const fpaRad = fpaDeg * MathUtils.DEGREES_TO_RADIANS;
        return FlightModel.gravityConstKNS * ((thrust - drag) / weight - Math.sin(fpaRad));
      }
      static getAccelRateFromIdleGeoPathCoefficients(thrust, weight, Cl, Cd, fpaDeg) {
        // fpa is in degrees
        const fpaRad = fpaDeg * MathUtils.DEGREES_TO_RADIANS;
        return FlightModel.gravityConstKNS * (thrust / weight - Cd / Cl - Math.sin(fpaRad));
      }

      /**
       * Gets distance required to accelerate/decelerate
       * @param thrust
       * @param drag
       * @param weight in pounds
       * @param initialSpeed
       * @param targetSpeed
       * @param fpa flight path angle, default value 0 for level segments
       * @param accelFactor acceleration factor, default value 0 for level segments
       * @returns distance to accel/decel
       */
      static getAccelerationDistance(thrust, drag, weight, initialSpeed, targetSpeed) {
        let fpa = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        let accelFactor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        const sign = Math.sign(fpa);
        const force = thrust - drag + sign * weight * Math.sin(fpa * (Math.PI / 180)) * accelFactor;
        const accel = force / weight; // TODO: Check units
        const timeToAccel = (targetSpeed - initialSpeed) / accel;
        const distanceToAccel = initialSpeed * timeToAccel + 0.5 * accel * timeToAccel ** 2; // TODO: Check units
        return distanceToAccel;
      }
    }
    _defineProperty$2(FlightModel, "Cd0", 0.01873);
    _defineProperty$2(FlightModel, "wingSpan", 117.454);
    _defineProperty$2(FlightModel, "wingArea", 1317.47);
    _defineProperty$2(FlightModel, "wingEffcyFactor", 0.70);
    _defineProperty$2(FlightModel, "requiredAccelRateKNS", 1.33);
    _defineProperty$2(FlightModel, "requiredAccelRateMS2", 0.684);
    _defineProperty$2(FlightModel, "gravityConstKNS", 19.0626);
    _defineProperty$2(FlightModel, "gravityConstMS2", 9.806665);
    _defineProperty$2(FlightModel, "machValues", [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85]);
    _defineProperty$2(FlightModel, "dragCoefficientCorrections", [0, 0.0002, 0.0003, 0.0004, 0.0008, 0.0015, 0.01]);

    let VnavStepError;
    (function (VnavStepError) {
      VnavStepError[VnavStepError["AVAILABLE_GRADIENT_INSUFFICIENT"] = 0] = "AVAILABLE_GRADIENT_INSUFFICIENT";
      VnavStepError[VnavStepError["TOO_LOW_DECELERATION"] = 1] = "TOO_LOW_DECELERATION";
    })(VnavStepError || (VnavStepError = {}));
    class Predictions {
      /**
       * THIS IS DONE.
       * @param initialAltitude altitude at beginning of step, in feet
       * @param stepSize the size of the altitude step, in feet
       * @param econCAS airspeed during climb (taking SPD LIM & restrictions into account)
       * @param econMach mach during climb, after passing crossover altitude
       * @param commandedN1 N1% at CLB (or idle) setting, depending on flight phase
       * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
       * @param initialFuelWeight weight of fuel at the end of last step
       * @param headwindAtMidStepAlt headwind component (in knots) at initialAltitude + (stepSize / 2); tailwind is negative
       * @param isaDev ISA deviation (in celsius)
       * @param tropoAltitude tropopause altitude (feet)
       * @param speedbrakesExtended whether or not speedbrakes are extended at half (for geometric segment path test only)
       */
      static altitudeStep(initialAltitude, stepSize, econCAS, econMach, commandedN1, zeroFuelWeight, initialFuelWeight, headwindAtMidStepAlt, isaDev, tropoAltitude) {
        let speedbrakesExtended = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
        let flapsConfig = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : FlapConf.CLEAN;
        const midStepAltitude = initialAltitude + stepSize / 2;
        const theta = Common.getTheta(midStepAltitude, isaDev);
        const delta = Common.getDelta(midStepAltitude);
        let mach = Common.CAStoMach(econCAS, delta);
        let eas;
        let tas;
        let usingMach = false;
        // If above crossover altitude, use econMach
        if (mach > econMach) {
          mach = econMach;
          eas = Common.machToEAS(mach, delta);
          tas = Common.machToTAS(mach, theta);
          usingMach = true;
        } else {
          eas = Common.CAStoEAS(econCAS, delta);
          tas = Common.CAStoTAS(econCAS, theta, delta);
        }

        // Engine model calculations
        const theta2 = Common.getTheta2(theta, mach);
        const delta2 = Common.getDelta2(delta, mach);
        const correctedN1 = EngineModel.getCorrectedN1(commandedN1, theta2);
        const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, mach) * 2 * EngineModel.maxThrust;
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, mach, midStepAltitude) * 2;
        const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf
        const fuelFlow = EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2); // in lbs/hour

        const weightEstimate = zeroFuelWeight + initialFuelWeight;
        let pathAngle;
        let verticalSpeed;
        let stepTime;
        let distanceTraveled;
        let fuelBurned;
        let lift = weightEstimate;
        let midStepWeight = weightEstimate;
        let previousMidStepWeight = midStepWeight;
        let iterations = 0;
        do {
          // Assume lift force is equal to weight as an initial approximation
          const liftCoefficient = FlightModel.getLiftCoefficientFromEAS(lift, eas);
          const dragCoefficient = FlightModel.getDragCoefficient(liftCoefficient, speedbrakesExtended, false, flapsConfig);
          const accelFactorMode = usingMach ? AccelFactorMode.CONSTANT_MACH : AccelFactorMode.CONSTANT_CAS;
          const accelFactor = Common.getAccelerationFactor(mach, midStepAltitude, isaDev, midStepAltitude > tropoAltitude, accelFactorMode);
          pathAngle = FlightModel.getConstantThrustPathAngleFromCoefficients(thrust, midStepWeight, liftCoefficient, dragCoefficient, accelFactor);
          verticalSpeed = 101.268 * tas * Math.sin(pathAngle); // in feet per minute
          stepTime = stepSize / verticalSpeed; // in minutes
          distanceTraveled = (tas - headwindAtMidStepAlt) * (stepTime / 60); // in nautical miles
          fuelBurned = fuelFlow / 60 * stepTime;
          // const endStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned); <- not really needed

          // Adjust variables for better accuracy next iteration
          previousMidStepWeight = midStepWeight;
          midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
          lift = midStepWeight * Math.cos(pathAngle);
          iterations++;
        } while (iterations < 4 && Math.abs(previousMidStepWeight - midStepWeight) < 100);
        return {
          pathAngle: pathAngle * MathUtils.RADIANS_TO_DEGREES,
          verticalSpeed,
          timeElapsed: stepTime,
          distanceTraveled,
          fuelBurned,
          finalAltitude: initialAltitude + stepSize
        };
      }

      /**
       * THIS IS DONE.
       * @param altitude altitude of this level segment
       * @param stepSize the distance of the step, in NM
       * @param econCAS airspeed during level segment
       * @param econMach mach during level segment (when over crossover altitude)
       * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
       * @param initialFuelWeight weight of fuel at the end of last step
       * @param headwind headwind component (in knots) at altitude; tailwind is negative
       * @param isaDev ISA deviation (in celsius)
       */
      static levelFlightStep(altitude, stepSize, econCAS, econMach, zeroFuelWeight, initialFuelWeight, headwind, isaDev) {
        const theta = Common.getTheta(altitude, isaDev);
        const delta = Common.getDelta(altitude);
        let mach = Common.CAStoMach(econCAS, delta);
        let tas;
        // If above crossover altitude, use econMach
        if (mach > econMach) {
          mach = econMach;
          tas = Common.machToTAS(mach, theta);
        } else {
          tas = Common.CAStoTAS(econCAS, theta, delta);
        }
        const initialWeight = zeroFuelWeight + initialFuelWeight;
        const thrust = FlightModel.getDrag(initialWeight, mach, delta, false, false, FlapConf.CLEAN);

        // Engine model calculations
        const theta2 = Common.getTheta2(theta, mach);
        const delta2 = Common.getDelta2(delta, mach);
        // Divide by 2 to get thrust per engine
        const correctedThrust = thrust / delta2 / 2;
        // Since table 1506 describes corrected thrust as a fraction of max thrust, divide it
        const correctedN1 = EngineModel.reverseTableInterpolation(EngineModel.table1506, mach, correctedThrust / EngineModel.maxThrust);
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, mach, altitude) * 2;
        const fuelFlow = EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2); // in lbs/hour

        const stepTime = (tas - headwind) / stepSize / 60; // in minutes
        const fuelBurned = fuelFlow / 60 * stepTime;
        let result;
        result.pathAngle = 0;
        result.verticalSpeed = 0;
        result.timeElapsed = stepTime;
        result.distanceTraveled = stepSize;
        result.fuelBurned = fuelBurned;
        result.finalAltitude = altitude;
        return result;
      }

      /**
       * THIS IS DONE.
       * @param initialAltitude altitude at beginning of step, in feet
       * @param initialCAS airspeed at beginning of step
       * @param finalCAS airspeed at end of step
       * @param initialMach initial mach, above crossover altitude
       * @param finalMach final mach, above crossover altitude
       * @param commandedN1 N1% at CLB (or idle) setting, depending on flight phase
       * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
       * @param initialFuelWeight weight of fuel at the end of last step
       * @param headwindAtInitialAltitude headwind component (in knots) at initialAltitude
       * @param isaDev ISA deviation (in celsius)
       * @param tropoAltitude tropopause altitude (feet)
       * @param gearExtended whether the gear is extended
       * @param flapConfig the flaps configuration
       * @param minimumAbsoluteAcceleration the minimum absolute acceleration before emitting TOO_LOW_DECELERATION (kts/s)
       */
      static speedChangeStep(flightPahAngle, initialAltitude, initialCAS, finalCAS, initialMach, finalMach, commandedN1, zeroFuelWeight, initialFuelWeight, headwindAtInitialAltitude, isaDev, tropoAltitude) {
        let gearExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
        let flapConfig = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : FlapConf.CLEAN;
        let minimumAbsoluteAcceleration = arguments.length > 14 ? arguments[14] : undefined;
        const theta = Common.getTheta(initialAltitude, isaDev);
        const delta = Common.getDelta(initialAltitude);
        let actualInitialMach = Common.CAStoMach(initialCAS, delta);
        let actualFinalMach = Common.CAStoMach(finalCAS, delta);
        let initialTas;
        let finalTas;
        // let initialEas;
        // let finalEas;

        // let usingMachAtStart;
        // If above crossover altitude, use mach
        if (actualInitialMach > initialMach) {
          actualInitialMach = initialMach;
          initialTas = Common.machToTAS(actualInitialMach, theta);
          // initialEas = Common.machToEAS(actualInitialMach, delta);
          // usingMachAtStart = true;
        } else {
          initialTas = Common.CAStoTAS(initialCAS, theta, delta);
          // initialEas = Common.CAStoEAS(initialCAS, delta);
          // usingMachAtStart = false;
        }

        // let usingMachAtEnd;
        if (actualFinalMach > finalMach) {
          actualFinalMach = finalMach;
          finalTas = Common.machToTAS(actualFinalMach, theta);
          // finalEas = Common.machToEAS(actualFinalMach, delta);
          // usingMachAtEnd = true;
        } else {
          finalTas = Common.CAStoTAS(finalCAS, theta, delta);
          // finalEas = Common.CAStoEAS(finalCAS, delta);
          // usingMachAtEnd = false;
        }

        const averageMach = (actualInitialMach + actualFinalMach) / 2;
        const averageTas = (initialTas + finalTas) / 2;

        // Engine model calculations
        const theta2 = Common.getTheta2(theta, averageMach);
        const delta2 = Common.getDelta2(delta, averageMach);
        const correctedN1 = EngineModel.getCorrectedN1(commandedN1, theta2);
        const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, averageMach) * 2 * EngineModel.maxThrust;
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, averageMach, initialAltitude) * 2;
        const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf
        const fuelFlow = EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2); // in lbs/hour

        const weightEstimate = zeroFuelWeight + initialFuelWeight;
        const pathAngleRadians = flightPahAngle * MathUtils.DEGREES_TO_RADIANS;
        let error;
        let verticalSpeed;
        let stepTime;
        let distanceTraveled;
        let fuelBurned;
        let finalAltitude;
        let lift = weightEstimate;
        let midStepWeight = weightEstimate;
        let previousMidStepWeight = midStepWeight;
        let iterations = 0;
        do {
          // Calculate the available gradient
          const drag = FlightModel.getDrag(lift, averageMach, delta, false, gearExtended, flapConfig);
          const availableGradient = FlightModel.getAvailableGradient(thrust, drag, weightEstimate);
          if (Math.abs(availableGradient) < Math.abs(pathAngleRadians)) {
            error = VnavStepError.AVAILABLE_GRADIENT_INSUFFICIENT;
          }
          const acceleration = FlightModel.accelerationForGradient(availableGradient, pathAngleRadians, 9.81);

          // TODO what do we do with this
          // const accelFactorMode = usingMachAtStart ? AccelFactorMode.CONSTANT_MACH : AccelFactorMode.CONSTANT_CAS;
          // const accelFactor = Common.getAccelerationFactor(averageMach,
          //     initialAltitude,
          //     isaDev,
          //     initialAltitude > tropoAltitude,
          //     accelFactorMode);

          // pathAngle = FlightModel.fpaForGradient(
          //     availableGradient,
          //     FlightModel.requiredAccelRateMS2,
          //     accelFactor,
          // );

          const accelerationKNS = FlightModel.requiredAccelRateKNS * acceleration / FlightModel.requiredAccelRateMS2;
          if (Math.abs(accelerationKNS) < minimumAbsoluteAcceleration) {
            error = VnavStepError.TOO_LOW_DECELERATION;
          }
          stepTime = Math.abs(finalTas - initialTas) / Math.abs(accelerationKNS);
          distanceTraveled = stepTime / 3600 * averageTas;
          verticalSpeed = 101.268 * averageTas * Math.sin(pathAngleRadians); // in feet per minute
          // // TODO: double-check if accel rate operates on TAS or CAS
          // stepTime = Math.abs(finalTas - initialTas) / accelerationKNS; // in seconds
          finalAltitude = initialAltitude + verticalSpeed * (stepTime / 60); // in feet
          // TODO: now that we have final altitude, we could get accurate mid-step headwind instead of using initial headwind...
          // distanceTraveled = (averageTas - headwindAtInitialAltitude) * (stepTime / 3_600); // in NM
          fuelBurned = fuelFlow / 60 * stepTime;
          // const endStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned); <- not really needed

          // Adjust variables for better accuracy next iteration
          previousMidStepWeight = midStepWeight;
          midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
          lift = midStepWeight * Math.cos(pathAngleRadians);
          iterations++;
        } while (iterations < 4 && Math.abs(previousMidStepWeight - midStepWeight) < 100);
        return {
          pathAngle: pathAngleRadians * MathUtils.RADIANS_TO_DEGREES,
          verticalSpeed,
          timeElapsed: stepTime,
          distanceTraveled,
          fuelBurned,
          finalAltitude,
          error
        };
      }

      /**
       * THIS IS DONE.
       * @param initialAltitude altitude at beginning of step, in feet
       * @param finalAltitude altitude at end of step, in feet
       * @param distance distance of step, in NM
       * @param econCAS airspeed during step
       * @param econMach mach during step
       * @param idleN1 N1% at idle setting
       * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
       * @param initialFuelWeight weight of fuel at the end of last step
       * @param headwindAtMidStepAlt headwind component (in knots) at initialAltitude + (stepSize / 2); tailwind is negative
       * @param isaDev ISA deviation (in celsius)
       * @param tropoAltitude tropopause altitude (feet)
       */
      static geometricStepAchievable(initialAltitude, finalAltitude, distance, econCAS, econMach, idleN1, zeroFuelWeight, initialFuelWeight, headwindAtMidStepAlt, isaDev, tropoAltitude) {
        const idleStepResults = Predictions.altitudeStep(initialAltitude, finalAltitude - initialAltitude, econCAS, econMach, idleN1, zeroFuelWeight, initialFuelWeight, headwindAtMidStepAlt, isaDev, tropoAltitude, true);

        // If converted FPA is less than the FPA from altitudeStep, then this path is too steep :(
        const distanceInFeet = distance * 6076.12;
        const stepFPA = Math.atan((finalAltitude - initialAltitude) / distanceInFeet) * MathUtils.RADIANS_TO_DEGREES;
        return idleStepResults.pathAngle <= stepFPA;
      }

      /**
       * THIS IS DONE.
       * @param initialAltitude altitude at beginning of step, in feet
       * @param finalAltitude altitude at end of step, in feet
       * @param distance distance of step, in NM
       * @param econCAS airspeed during step
       * @param econMach mach during step
       * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
       * @param initialFuelWeight weight of fuel at the end of last step
       * @param isaDev ISA deviation (in celsius)
       * @param tropoAltitude tropopause altitude (feet)
       */
      static geometricStep(initialAltitude, finalAltitude, distance, econCAS, econMach, zeroFuelWeight, initialFuelWeight, isaDev, tropoAltitude) {
        const distanceInFeet = distance * 6076.12;
        const fpaRadians = Math.atan((finalAltitude - initialAltitude) / distanceInFeet);
        const fpaDegrees = fpaRadians * MathUtils.RADIANS_TO_DEGREES;
        const midStepAltitude = (initialAltitude + finalAltitude) / 2;
        const theta = Common.getTheta(midStepAltitude, isaDev);
        const delta = Common.getDelta(midStepAltitude);
        let mach = Common.CAStoMach(econCAS, delta);
        let eas;
        let tas;
        let usingMach = false;
        // If above crossover altitude, use econMach
        if (mach > econMach) {
          mach = econMach;
          eas = Common.machToEAS(mach, delta);
          tas = Common.machToTAS(mach, theta);
          usingMach = true;
        } else {
          eas = Common.CAStoEAS(econCAS, delta);
          tas = Common.CAStoTAS(econCAS, theta, delta);
        }
        const weightEstimate = zeroFuelWeight + initialFuelWeight;
        const theta2 = Common.getTheta2(theta, mach);
        const delta2 = Common.getDelta2(delta, mach);
        let thrust;
        let verticalSpeed;
        let stepTime;
        let fuelBurned;
        let lift = weightEstimate * Math.cos(fpaRadians);
        let midStepWeight = weightEstimate;
        let previousMidStepWeight = midStepWeight;
        let iterations = 0;
        do {
          const liftCoefficient = FlightModel.getLiftCoefficientFromEAS(lift, eas);
          const dragCoefficient = FlightModel.getDragCoefficient(liftCoefficient);
          const accelFactorMode = usingMach ? AccelFactorMode.CONSTANT_MACH : AccelFactorMode.CONSTANT_CAS;
          const accelFactor = Common.getAccelerationFactor(mach, midStepAltitude, isaDev, midStepAltitude > tropoAltitude, accelFactorMode);
          thrust = FlightModel.getThrustFromConstantPathAngleCoefficients(fpaDegrees, midStepWeight, liftCoefficient, dragCoefficient, accelFactor);
          verticalSpeed = 101.268 * tas * Math.sin(fpaRadians); // in feet per minute
          stepTime = (finalAltitude - initialAltitude) / verticalSpeed; // in minutes

          // Divide by 2 to get thrust per engine
          const correctedThrust = thrust / delta2 / 2;
          // Since table 1506 describes corrected thrust as a fraction of max thrust, divide it
          const correctedN1 = EngineModel.reverseTableInterpolation(EngineModel.table1506, mach, correctedThrust / EngineModel.maxThrust);
          const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, mach, midStepAltitude) * 2;
          const fuelFlow = EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2); // in lbs/hour

          fuelBurned = fuelFlow / 60 * stepTime;

          // Adjust variables for better accuracy next iteration
          previousMidStepWeight = midStepWeight;
          midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
          lift = midStepWeight * Math.cos(fpaRadians);
          iterations++;
        } while (iterations < 4 && Math.abs(previousMidStepWeight - midStepWeight) < 100);
        return {
          pathAngle: fpaDegrees,
          verticalSpeed,
          timeElapsed: stepTime,
          distanceTraveled: distance,
          fuelBurned,
          finalAltitude
        };
      }

      // static constantSlopeSegment(
      //
      // ): StepResults {
      //     // e = ((T - D / W)
      //     // a = g * (sin(available climb angle) - sin (desired fpa))
      //     // d = ((final velocity squared) - (initial velocity squared)) / (2 * a)
      // }

      /**
       * THIS IS DONE.
       * @param initialAltitude altitude at beginning of step, in feet
       * @param finalAltitude altitude at end of step, in feet
       * @param distance distance of step, in NM
       * @param econCAS airspeed during step
       * @param econMach mach during step
       * @param idleN1 N1% at idle setting
       * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
       * @param initialFuelWeight weight of fuel at the end of last step
       * @param isaDev ISA deviation (in celsius)
       */
      static decelerationFromGeometricStep(initialAltitude, finalAltitude, econCAS, econMach, idleN1, zeroFuelWeight, initialFuelWeight, isaDev) {
        const distanceInFeet = distance * 6076.12;
        const fpaRadians = Math.atan((finalAltitude - initialAltitude) / distanceInFeet);
        const fpaDegrees = fpaRadians * MathUtils.RADIANS_TO_DEGREES;
        const midStepAltitude = (initialAltitude + finalAltitude) / 2;
        const theta = Common.getTheta(midStepAltitude, isaDev);
        const delta = Common.getDelta(midStepAltitude);
        let mach = Common.CAStoMach(econCAS, delta);
        let eas;
        // If above crossover altitude, use econMach
        if (mach > econMach) {
          mach = econMach;
          eas = Common.machToEAS(mach, delta);
        } else {
          eas = Common.CAStoEAS(econCAS, delta);
        }
        const theta2 = Common.getTheta2(theta, mach);
        const delta2 = Common.getDelta2(delta, mach);
        const correctedN1 = EngineModel.getCorrectedN1(idleN1, theta2);
        const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, mach) * 2 * EngineModel.maxThrust;
        const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf

        const weightEstimate = zeroFuelWeight + initialFuelWeight;
        const lift = weightEstimate * Math.cos(fpaRadians);
        const liftCoefficient = FlightModel.getLiftCoefficientFromEAS(lift, eas);
        const dragCoefficient = FlightModel.getDragCoefficient(liftCoefficient);
        const accelRate = FlightModel.getAccelRateFromIdleGeoPathCoefficients(thrust, weightEstimate, liftCoefficient, dragCoefficient, fpaDegrees);
        return accelRate;
      }
    }

    const ALTITUDE_ADJUSTMENT_FACTOR = 1.4;

    /**
     * The minimum deceleration rate, in knots per second, to target on the approach path.
     *
     * This will be used as the target rate in case it cannot be achieved using the desired fpa.
     */
    const MINIMUM_APPROACH_DECELERATION = 0.5;
    let ApproachPathSegmentType;
    (function (ApproachPathSegmentType) {
      ApproachPathSegmentType[ApproachPathSegmentType["CONSTANT_SLOPE"] = 0] = "CONSTANT_SLOPE";
      ApproachPathSegmentType[ApproachPathSegmentType["CONSTANT_SPEED"] = 1] = "CONSTANT_SPEED";
      ApproachPathSegmentType[ApproachPathSegmentType["LEVEL_DECELERATION"] = 2] = "LEVEL_DECELERATION";
    })(ApproachPathSegmentType || (ApproachPathSegmentType = {}));
    class DecelPathBuilder {
      static computeDecelPath(geometry) {
        // TO GET FPA:
        // If approach exists, use approach alt constraints to get FPA and glidepath
        // If no approach but arrival, use arrival alt constraints, if any
        // If no other alt constraints, use 3 degree descent from cruise altitude

        // Given FPA above, calculate distance required (backwards from Vapp @ runway threshold alt + 50ft + 1000ft),
        // to decelerate from green dot speed to Vapp using `decelerationFromGeometricStep`
        // Then, add a speedChangeStep (1.33 knots/second decel) backwards from this point (green dot spd) to previous speed, aka min(last spd constraint, spd lim)
        //      - TODO: make sure alt constraints are obeyed during this speed change DECEL segment?
        // The point at the beginning of the speedChangeStep is DECEL

        const TEMP_TROPO = 36000;
        const TEMP_FUEL_WEIGHT = 2300;
        const DES = 250;
        const O = 203;
        const S = 184;
        const F = 143;
        const vappSegment = DecelPathBuilder.computeVappSegment(geometry);
        let fuelWeight = TEMP_FUEL_WEIGHT;
        const cFullTo3Segment = DecelPathBuilder.computeConfigurationChangeSegment(ApproachPathSegmentType.CONSTANT_SLOPE, -3, 1000, F, 135, fuelWeight, FlapConf.CONF_FULL, true, TEMP_TROPO);
        fuelWeight += cFullTo3Segment.fuelBurned;
        const c3to2Segment = DecelPathBuilder.computeConfigurationChangeSegment(ApproachPathSegmentType.CONSTANT_SLOPE, -3, cFullTo3Segment.initialAltitude, F + (S - F) / 2, F, fuelWeight, FlapConf.CONF_3, true, TEMP_TROPO);
        fuelWeight += c3to2Segment.fuelBurned;
        const c2to1Segment = DecelPathBuilder.computeConfigurationChangeSegment(ApproachPathSegmentType.CONSTANT_SLOPE, -3, c3to2Segment.initialAltitude, S, F + (S - F) / 2, fuelWeight, FlapConf.CONF_2, false, TEMP_TROPO);
        fuelWeight += c2to1Segment.fuelBurned;
        const c1toCleanSegment = DecelPathBuilder.computeConfigurationChangeSegment(ApproachPathSegmentType.CONSTANT_SLOPE, -2.5, c2to1Segment.initialAltitude, O, S, fuelWeight, FlapConf.CONF_1, false, TEMP_TROPO);
        fuelWeight += c1toCleanSegment.fuelBurned;
        let cleanToDesSpeedSegment = DecelPathBuilder.computeConfigurationChangeSegment(ApproachPathSegmentType.CONSTANT_SLOPE, -2.5, c1toCleanSegment.initialAltitude, DES, O, fuelWeight, FlapConf.CLEAN, false, TEMP_TROPO);

        // TODO for TOO_LOW_DECELERATION do CONSTANT_DECELERATION, not LEVEL_DECELERATION
        if (cleanToDesSpeedSegment.error === VnavStepError.AVAILABLE_GRADIENT_INSUFFICIENT || cleanToDesSpeedSegment.error === VnavStepError.TOO_LOW_DECELERATION) {

          // if (VnavConfig.VNAV_DESCENT_MODE !== VnavDescentMode.CDA) {
          cleanToDesSpeedSegment = DecelPathBuilder.computeConfigurationChangeSegment(ApproachPathSegmentType.LEVEL_DECELERATION, undefined, c1toCleanSegment.initialAltitude, DES, O, fuelWeight, FlapConf.CLEAN, false, TEMP_TROPO);
          // } else {
          //     throw new Error('[VNAV/computeDecelPath] Computation of cleanToDesSpeedSegment for CDA is not yet implemented');
          // }
        }

        return {
          flap1: vappSegment.distanceTraveled + cFullTo3Segment.distanceTraveled + c3to2Segment.distanceTraveled + c2to1Segment.distanceTraveled + c1toCleanSegment.distanceTraveled,
          flap2: vappSegment.distanceTraveled + cFullTo3Segment.distanceTraveled + c3to2Segment.distanceTraveled + c2to1Segment.distanceTraveled,
          decel: vappSegment.distanceTraveled + cFullTo3Segment.distanceTraveled + c3to2Segment.distanceTraveled + c2to1Segment.distanceTraveled + c1toCleanSegment.distanceTraveled + cleanToDesSpeedSegment.distanceTraveled,
          top: cleanToDesSpeedSegment.finalAltitude
        };
      }

      /**
       * Calculates the Vapp segment of the DECEL path.
       *
       * @return the Vapp segment step results
       */
      static computeVappSegment(geometry) {
        const TEMP_VAPP = 135; // TODO actual Vapp

        const finalAltitude = DecelPathBuilder.findLastApproachPoint(geometry);

        // TODO For now we use some "reasonable" values for the segment. When we have the ability to predict idle N1 and such at approach conditions,
        // we can change this.
        return _objectSpread2(_objectSpread2({}, Predictions.altitudeStep(1000, -(1000 - finalAltitude), TEMP_VAPP,
        // TODO placeholder value
        999,
        // TODO placeholder value
        26,
        // TODO placeholder value
        107000,
        // TODO placeholder value
        5000,
        // TODO placeholder value
        2,
        // TODO placeholder value
        0,
        // TODO placeholder value
        36000,
        // TODO placeholder value
        false // TODO placeholder value
        )), {}, {
          distanceTraveled: 3.14 // FIXME hard-coded correct value for -3deg fpa
        });
      }

      /**
       * Calculates a config change segment of the DECEL path.
       *
       * @return the config change segment step results
       */
      static computeConfigurationChangeSegment(type, fpa, finalAltitude, fromSpeed, toSpeed, initialFuelWeight,
      // TODO take finalFuelWeight and make an iterative prediction
      newConfiguration, gearExtended, tropoAltitude) {
        // TODO For now we use some "reasonable" values for the segment. When we have the ability to predict idle N1 and such at approach conditions,
        // we can change this.

        switch (type) {
          case ApproachPathSegmentType.CONSTANT_SLOPE:
            // FIXME hard-coded to -3deg in speedChangeStep

            let currentIterationAltitude = finalAltitude * ALTITUDE_ADJUSTMENT_FACTOR;
            let stepResults;
            let altitudeError = 0;
            let iterationCount = 0;
            do {
              const newStepResults = Predictions.speedChangeStep(fpa !== null && fpa !== void 0 ? fpa : -3, currentIterationAltitude, fromSpeed, toSpeed, 999, 999, 26, 107000, initialFuelWeight, 2, 0, tropoAltitude, gearExtended, newConfiguration, MINIMUM_APPROACH_DECELERATION);

              // Stop if we encounter a NaN
              if (Number.isNaN(newStepResults.finalAltitude)) {
                break;
              }
              stepResults = newStepResults;
              altitudeError = finalAltitude - stepResults.finalAltitude;
              currentIterationAltitude += altitudeError;
              iterationCount++;
            } while (Math.abs(altitudeError) >= 25 && iterationCount < 4);
            return _objectSpread2(_objectSpread2({}, stepResults), {}, {
              initialAltitude: currentIterationAltitude
            });
          case ApproachPathSegmentType.CONSTANT_SPEED:
            throw new Error('[FMS/VNAV/computeConfigurationChangeSegment] CONSTANT_SPEED is not supported for configuration changes.');
          case ApproachPathSegmentType.LEVEL_DECELERATION:
            return Predictions.speedChangeStep(0, finalAltitude * ALTITUDE_ADJUSTMENT_FACTOR, fromSpeed, toSpeed, 999, 999, 26, 107000, initialFuelWeight, 2, 0, tropoAltitude, gearExtended, newConfiguration);
          default:
            throw new Error('[FMS/VNAV/computeConfigurationChangeSegment] Unknown segment type.');
        }
      }

      /**
       * Returns altitude of either, in order of priority:
       * - runway threshold;
       * - missed approach point;
       * - airport.
       */
      static findLastApproachPoint(geometry) {
        const lastLeg = geometry.legs.get(geometry.legs.size - 1);

        // Last leg is TF AND is runway or airport
        if (lastLeg instanceof TFLeg && (lastLeg.to.isRunway || lastLeg.to.type === 'A')) {
          return lastLeg.to.legAltitude1;
        }
        return 150; // TODO temporary value
      }
    }

    class DescentBuilder {
      static computeDescentPath(geometry, decelPath) {
        var _ref, _decelPath$decel;
        const cruiseAlt = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number');
        const verticalDistance = (_ref = cruiseAlt - (decelPath === null || decelPath === void 0 ? void 0 : decelPath.top)) !== null && _ref !== void 0 ? _ref : 0;
        const fpa = 3;
        const tod = (_decelPath$decel = decelPath === null || decelPath === void 0 ? void 0 : decelPath.decel) !== null && _decelPath$decel !== void 0 ? _decelPath$decel : 0 + verticalDistance / Math.tan(fpa * Math.PI / 180) * 0.000164579;
        return {
          tod
        };

        //     const decelPointDistance = DecelPathBuilder.computeDecelPath(geometry);
        //
        //     const lastLegIndex = geometry.legs.size - 1;
        //
        //     // Find descent legs before decel point
        //     let accumulatedDistance = 0;
        //     let currentLegIdx;
        //     let currentLeg;
        //     for (currentLegIdx = lastLegIndex; accumulatedDistance < decelPointDistance; currentLegIdx--) {
        //         currentLeg = geometry.legs.get(currentLegIdx);
        //
        //         accumulatedDistance += currentLeg.distance;
        //     }
        //     currentLegIdx--;
        //
        //     const geometricPath = GeomtricPathBuilder.buildGeometricPath(geometry, currentLegIdx);
        //
        //     console.log(geometricPath);
        //
        //     return { geometricPath };
        // }
      }
    }

    class AtmosphericConditions {
      // TODO use tropo from mcdu

      constructor() {
        _defineProperty$2(this, "ambientTemperatureFromSim", void 0);
        _defineProperty$2(this, "altitudeFromSim", void 0);
        _defineProperty$2(this, "tropo", 36090);
        _defineProperty$2(this, "casFromSim", void 0);
        _defineProperty$2(this, "tasFromSim", void 0);
        _defineProperty$2(this, "windSpeedFromSim", void 0);
        _defineProperty$2(this, "windDirectionFromSim", void 0);
        _defineProperty$2(this, "computedIsaDeviation", void 0);
        this.update();
      }
      update() {
        this.ambientTemperatureFromSim = SimVar.GetSimVarValue('AMBIENT TEMPERATURE', 'celsius');
        this.altitudeFromSim = SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet');
        this.tasFromSim = SimVar.GetSimVarValue('AIRSPEED TRUE', 'knots');
        this.casFromSim = this.computeCasFromTas(this.altitudeFromSim, this.tasFromSim);
        // TODO filter?
        this.windSpeedFromSim = SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', 'Knots');
        this.windDirectionFromSim = SimVar.GetSimVarValue('AMBIENT WIND DIRECTION', 'Degrees');
        this.computedIsaDeviation = this.ambientTemperatureFromSim - Common.getIsaTemp(this.altitudeFromSim);
      }
      get currentStaticAirTemperature() {
        return this.ambientTemperatureFromSim;
      }
      get currentAltitude() {
        return this.altitudeFromSim;
      }
      get currentAirspeed() {
        return this.casFromSim;
      }
      get currentTrueAirspeed() {
        return this.tasFromSim;
      }
      get currentWindSpeed() {
        return this.windSpeedFromSim;
      }
      get currentWindDirection() {
        return this.windDirectionFromSim;
      }
      getCurrentWindVelocityComponent(direction) {
        return Math.cos(Avionics.Utils.diffAngle(direction, this.currentWindDirection)) * this.currentWindSpeed;
      }
      get isaDeviation() {
        return this.computedIsaDeviation;
      }
      predictStaticAirTemperatureAtAltitude(altitude) {
        return Common.getIsaTemp(altitude, altitude > this.tropo) + this.isaDeviation;
      }
      totalAirTemperatureFromMach(altitude, mach) {
        // From https://en.wikipedia.org/wiki/Total_air_temperature, using gamma = 1.4
        return (this.predictStaticAirTemperatureAtAltitude(altitude) + 273.15) * (1 + 0.2 * mach ** 2) - 273.15;
      }
      computeMachFromCas(altitude, speed) {
        const deltaSrs = Common.getDelta(altitude, altitude > this.tropo);
        return Common.CAStoMach(speed, deltaSrs);
      }
      computeCasFromMach(altitude, mach) {
        const deltaSrs = Common.getDelta(altitude, altitude > this.tropo);
        return Common.machToCas(mach, deltaSrs);
      }
      computeCasFromTas(altitude, speed) {
        const thetaSrs = Common.getTheta(altitude, this.isaDeviation, altitude > this.tropo);
        const deltaSrs = Common.getDelta(altitude, altitude > this.tropo);
        return Common.TAStoCAS(speed, thetaSrs, deltaSrs);
      }
      computeTasFromCas(altitude, speed) {
        const thetaSrs = Common.getTheta(altitude, this.isaDeviation, altitude > this.tropo);
        const deltaSrs = Common.getDelta(altitude, altitude > this.tropo);
        return Common.CAStoTAS(speed, thetaSrs, deltaSrs);
      }
    }

    // Copyright (c) 2022 FlyByWire Simulations

    /**
     * This class exists to provide very coarse predictions for
     * LNAV turn prediction while we await the full VNAV experience
     */
    class CoarsePredictions {
      static updatePredictions(guidanceController, atmosphere) {
        const flightPlanManager = guidanceController.flightPlanManager;
        for (let i = 0; i < flightPlanManager.getWaypointsCount(FlightPlans.Active); i++) {
          const wp = flightPlanManager.getWaypoint(i, FlightPlans.Active, true);
          const leg = guidanceController.activeGeometry.legs.get(i);
          if (!wp || !leg) {
            continue;
          }
          const alt = wp.additionalData.predictedAltitude;
          const cas = wp.additionalData.predictedSpeed;
          let tas = atmosphere.computeTasFromCas(alt, cas);
          let gs = tas;

          // predicted with live data for active and next two legs
          if (i >= guidanceController.activeLegIndex && i < guidanceController.activeLegIndex + 3) {
            tas = atmosphere.currentTrueAirspeed;
            gs = tas + atmosphere.currentWindSpeed;
          }
          leg.predictedTas = Number.isFinite(tas) ? tas : undefined;
          leg.predictedGs = Number.isFinite(gs) ? gs : tas;
        }
      }
    }

    class VnavDriver {
      // eslint-disable-next-line camelcase

      constructor(guidanceController) {
        this.guidanceController = guidanceController;
        _defineProperty$2(this, "atmosphericConditions", new AtmosphericConditions());
        _defineProperty$2(this, "currentClimbProfile", void 0);
        _defineProperty$2(this, "currentDescentProfile", void 0);
        _defineProperty$2(this, "currentApproachProfile", void 0);
        _defineProperty$2(this, "guidanceMode", void 0);
        _defineProperty$2(this, "targetVerticalSpeed", void 0);
        _defineProperty$2(this, "targetAltitude", void 0);
        _defineProperty$2(this, "coarsePredictionsUpdate", new B77HS_Util.UpdateThrottler(5000));
        _defineProperty$2(this, "lastCruiseAltitude", 0);
      }
      init() {
        console.log('[aims/Guidance] VnavDriver initialized!');
      }
      acceptMultipleLegGeometry(geometry) {
        this.computeVerticalProfile(geometry);
      }
      update(deltaTime) {
        this.atmosphericConditions.update();
        if (this.coarsePredictionsUpdate.canUpdate(deltaTime) !== -1) {
          CoarsePredictions.updatePredictions(this.guidanceController, this.atmosphericConditions);
        }
        const newCruiseAltitude = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number');
        if (newCruiseAltitude !== this.lastCruiseAltitude) {
          this.lastCruiseAltitude = newCruiseAltitude;
          this.computeVerticalProfile(this.guidanceController.activeGeometry);
        }
        this.updateGuidance();
      }
      computeVerticalProfile(geometry) {
        if (geometry.legs.size > 0) {
          if (this.guidanceController.flightPlanManager.getApproach(FlightPlans.Active)) {
            this.currentApproachProfile = DecelPathBuilder.computeDecelPath(geometry);
          } else {
            this.currentApproachProfile = null;
          }
          this.currentDescentProfile = DescentBuilder.computeDescentPath(geometry, this.currentApproachProfile);
          this.guidanceController.pseudoWaypoints.acceptVerticalProfile();
        }
      }
      updateGuidance() {
        let newGuidanceMode = RequestedVerticalMode.None;
        let newVerticalSpeed = 0;
        let newAltitude = 0;
        if (this.guidanceController.isManualHoldActive()) {
          const fcuVerticalMode = SimVar.GetSimVarValue('L:B77HS_FMA_VERTICAL_MODE', 'Enum');
          if (fcuVerticalMode === VerticalMode.DES) {
            const holdSpeed = SimVar.GetSimVarValue('L:B77HS_FM_HOLD_SPEED', 'number');
            const atHoldSpeed = this.atmosphericConditions.currentAirspeed <= holdSpeed + 5;
            if (atHoldSpeed) {
              newGuidanceMode = RequestedVerticalMode.VsSpeed;
              newVerticalSpeed = -1000;
              newAltitude = 0;
            }
          }
        }
        if (this.guidanceController.isManualHoldActive() || this.guidanceController.isManualHoldNext()) {
          let holdSpeedCas = SimVar.GetSimVarValue('L:B77HS_FM_HOLD_SPEED', 'number');
          const holdDecelReached = SimVar.GetSimVarValue('L:B77HS_FM_HOLD_DECEL', 'bool');
          const speedControlManual = Simplane.getAutoPilotAirspeedSelected();
          const isMach = Simplane.getAutoPilotMachModeActive();
          if (speedControlManual && holdDecelReached) {
            if (isMach) {
              const holdValue = Simplane.getAutoPilotMachHoldValue();
              holdSpeedCas = this.atmosphericConditions.computeCasFromMach(this.atmosphericConditions.currentAltitude, holdValue);
            } else {
              holdSpeedCas = Simplane.getAutoPilotAirspeedHoldValue();
            }
          }
          const holdSpeedTas = this.atmosphericConditions.computeTasFromCas(this.atmosphericConditions.currentAltitude, holdSpeedCas);
          this.guidanceController.setHoldSpeed(holdSpeedTas);
        }
        if (newGuidanceMode !== this.guidanceMode) {
          this.guidanceMode = newGuidanceMode;
          SimVar.SetSimVarValue('L:B77HS_FG_REQUESTED_VERTICAL_MODE', 'number', this.guidanceMode);
        }
        if (newVerticalSpeed !== this.targetVerticalSpeed) {
          this.targetVerticalSpeed = newVerticalSpeed;
          SimVar.SetSimVarValue('L:B77HS_FG_TARGET_VERTICAL_SPEED', 'number', this.targetVerticalSpeed);
        }
        if (newAltitude !== this.targetAltitude) {
          this.targetAltitude = newAltitude;
          SimVar.SetSimVarValue('L:B77HS_FG_TARGET_ALTITUDE', 'number', this.targetAltitude);
        }
      }
    }

    // How often the (milliseconds)
    const GEOMETRY_RECOMPUTATION_TIMER = 5000;
    class GuidanceController {
      get hasTemporaryFlightPlan() {
        // eslint-disable-next-line no-underscore-dangle
        return this.flightPlanManager._currentFlightPlanIndex === FlightPlans.Temporary;
      }
      updateEfisState(side, state) {
        const ndMode = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_MODE"), 'Enum');
        const ndRange = rangeSettings[SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_RANGE"), 'Enum')];
        if ((state === null || state === void 0 ? void 0 : state.mode) !== ndMode || (state === null || state === void 0 ? void 0 : state.range) !== ndRange) {
          this.taskQueue.cancelAllInCategory(TaskCategory.EfisVectors);
          this.efisVectors.forceUpdate();
        }
        state.mode = ndMode;
        state.range = ndRange;
        this.updateEfisApproachMessage();
      }
      updateMrpState() {
        // PLAN mode center

        const focusedWpIndex = SimVar.GetSimVarValue('L:A32NX_SELECTED_WAYPOINT', 'number');
        const focusedWp = this.flightPlanManager.getWaypoint(focusedWpIndex);
        if (this.lastFocusedWpIndex !== focusedWpIndex) {
          this.lastFocusedWpIndex = focusedWpIndex;
          this.efisVectors.forceUpdate();
        }
        if (focusedWp) {
          this.focusedWaypointCoordinates.lat = focusedWp.infos.coordinates.lat;
          this.focusedWaypointCoordinates.long = focusedWp.infos.coordinates.long;
          SimVar.SetSimVarValue('L:A32NX_SELECTED_WAYPOINT_LAT', 'Degrees', this.focusedWaypointCoordinates.lat);
          SimVar.SetSimVarValue('L:A32NX_SELECTED_WAYPOINT_LONG', 'Degrees', this.focusedWaypointCoordinates.long);
        }
      }
      updateMapPartlyDisplayed() {
        if (this.efisStateForSide.L.dataLimitReached || this.efisStateForSide.L.legsCulled) {
          SimVar.SetSimVarValue('L:A32NX_EFIS_L_MAP_PARTLY_DISPLAYED', 'boolean', true);
        } else {
          SimVar.SetSimVarValue('L:A32NX_EFIS_L_MAP_PARTLY_DISPLAYED', 'boolean', false);
        }
        if (this.efisStateForSide.R.dataLimitReached || this.efisStateForSide.R.legsCulled) {
          SimVar.SetSimVarValue('L:A32NX_EFIS_R_MAP_PARTLY_DISPLAYED', 'boolean', true);
        } else {
          SimVar.SetSimVarValue('L:A32NX_EFIS_R_MAP_PARTLY_DISPLAYED', 'boolean', false);
        }
      }
      updateEfisIdent() {
        var _this$activeGeometry$, _this$activeGeometry$2;
        // Update EFIS ident

        const efisIdent = (_this$activeGeometry$ = (_this$activeGeometry$2 = this.activeGeometry.legs.get(this.activeLegIndex)) === null || _this$activeGeometry$2 === void 0 ? void 0 : _this$activeGeometry$2.ident) !== null && _this$activeGeometry$ !== void 0 ? _this$activeGeometry$ : 'PPOS';
        const efisVars = SimVarString.pack(efisIdent, 9);
        // setting the simvar as a number greater than about 16 million causes precision error > 1... but this works..
        SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_IDENT_0', 'string', efisVars[0].toString());
        SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_IDENT_1', 'string', efisVars[1].toString());
        SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_IDENT_0', 'string', efisVars[0].toString());
        SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_IDENT_1', 'string', efisVars[1].toString());
      }
      updateEfisApproachMessage() {
        let apprMsg = '';
        const appr = this.flightPlanManager.getApproach(FlightPlans.Active);
        if (appr && appr.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN) {
          const phase = getFlightPhaseManager().phase;
          if (phase > AimsFlightPhase.Cruise || phase === AimsFlightPhase.Cruise && this.flightPlanManager.getDistanceToDestination(FlightPlans.Active) < 250) {
            apprMsg = appr.name;
          }
        }
        if (apprMsg !== this.approachMessage) {
          this.approachMessage = apprMsg;
          const apprMsgVars = SimVarString.pack(apprMsg, 9);
          // setting the simvar as a number greater than about 16 million causes precision error > 1... but this works..
          SimVar.SetSimVarValue('L:A32NX_EFIS_L_APPR_MSG_0', 'string', apprMsgVars[0].toString());
          SimVar.SetSimVarValue('L:A32NX_EFIS_L_APPR_MSG_1', 'string', apprMsgVars[1].toString());
          SimVar.SetSimVarValue('L:A32NX_EFIS_R_APPR_MSG_0', 'string', apprMsgVars[0].toString());
          SimVar.SetSimVarValue('L:A32NX_EFIS_R_APPR_MSG_1', 'string', apprMsgVars[1].toString());
        }
      }
      constructor(flightPlanManager, guidanceManager) {
        _defineProperty$2(this, "flightPlanManager", void 0);
        _defineProperty$2(this, "guidanceManager", void 0);
        _defineProperty$2(this, "lnavDriver", void 0);
        _defineProperty$2(this, "vnavDriver", void 0);
        _defineProperty$2(this, "pseudoWaypoints", void 0);
        _defineProperty$2(this, "efisVectors", void 0);
        _defineProperty$2(this, "activeGeometry", void 0);
        _defineProperty$2(this, "temporaryGeometry", void 0);
        _defineProperty$2(this, "activeLegIndex", void 0);
        _defineProperty$2(this, "temporaryLegIndex", -1);
        _defineProperty$2(this, "activeTransIndex", void 0);
        _defineProperty$2(this, "activeLegDtg", void 0);
        _defineProperty$2(this, "activeLegCompleteLegPathDtg", void 0);
        _defineProperty$2(this, "displayActiveLegCompleteLegPathDtg", void 0);
        _defineProperty$2(this, "focusedWaypointCoordinates", {
          lat: 0,
          long: 0
        });
        _defineProperty$2(this, "currentPseudoWaypoints", []);
        _defineProperty$2(this, "automaticSequencing", true);
        _defineProperty$2(this, "leftEfisState", void 0);
        _defineProperty$2(this, "rightEfisState", void 0);
        _defineProperty$2(this, "efisStateForSide", void 0);
        _defineProperty$2(this, "approachMessage", '');
        _defineProperty$2(this, "taskQueue", new TaskQueue());
        _defineProperty$2(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
        _defineProperty$2(this, "lastFocusedWpIndex", -1);
        _defineProperty$2(this, "lastFlightPlanVersion", SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number'));
        _defineProperty$2(this, "geometryRecomputationTimer", GEOMETRY_RECOMPUTATION_TIMER + 1);
        this.flightPlanManager = flightPlanManager;
        this.guidanceManager = guidanceManager;
        this.lnavDriver = new LnavDriver(this);
        this.vnavDriver = new VnavDriver(this);
        this.pseudoWaypoints = new PseudoWaypoints(this);
        this.efisVectors = new EfisVectors(this);
      }
      init() {
        console.log('[aims/Guidance] GuidanceController initialized!');
        this.lnavDriver.ppos.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        this.lnavDriver.ppos.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        this.activeLegIndex = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Active);
        this.updateGeometries();
        this.leftEfisState = {
          mode: EfisNdMode.ARC,
          range: 10,
          dataLimitReached: false,
          legsCulled: false
        };
        this.rightEfisState = {
          mode: EfisNdMode.ARC,
          range: 10,
          dataLimitReached: false,
          legsCulled: false
        };
        this.efisStateForSide = {
          L: this.leftEfisState,
          R: this.rightEfisState
        };
        this.updateEfisState('L', this.leftEfisState);
        this.updateEfisState('R', this.rightEfisState);
        this.efisStateForSide.L = this.leftEfisState;
        this.efisStateForSide.R = this.leftEfisState;
        this.lnavDriver.init();
        this.vnavDriver.init();
        this.pseudoWaypoints.init();
        Coherent.on('A32NX_IMM_EXIT', (fpIndex, immExit) => {
          const leg = this.activeGeometry.legs.get(fpIndex);
          const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', 'Knots');
          if (leg instanceof HMLeg) {
            leg.setImmediateExit(immExit, this.lnavDriver.ppos, tas);
            this.flightPlanManager.updateFlightPlanVersion();
            this.automaticSequencing = true;
          }
        }, undefined);
      }
      update(deltaTime) {
        this.geometryRecomputationTimer += deltaTime;
        this.activeLegIndex = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Active);
        this.temporaryLegIndex = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Temporary);
        this.updateEfisState('L', this.leftEfisState);
        this.updateEfisState('R', this.rightEfisState);

        // Generate new geometry when flight plan changes
        // TODO also need to do it when FMS perf params change, e.g. speed limit/alt, climb/crz/des speeds
        const newFlightPlanVersion = this.flightPlanManager.currentFlightPlanVersion;
        if (newFlightPlanVersion !== this.lastFlightPlanVersion) {
          this.lastFlightPlanVersion = newFlightPlanVersion;
          try {
            this.updateGeometries();
            this.geometryRecomputationTimer = GEOMETRY_RECOMPUTATION_TIMER + 1;
          } catch (e) {
            console.error('[FMS] Error during update of geometry. See exception below.');
            console.error(e);
          }
        }
        if (this.geometryRecomputationTimer > GEOMETRY_RECOMPUTATION_TIMER) {
          this.geometryRecomputationTimer = 0;
          try {
            this.recomputeGeometries();
            if (this.activeGeometry) {
              this.vnavDriver.acceptMultipleLegGeometry(this.activeGeometry);
              this.pseudoWaypoints.acceptMultipleLegGeometry(this.activeGeometry);
            }
          } catch (e) {
            console.error('[FMS] Error during geometry recomputation. See exception below.');
            console.error(e);
          }
        }
        try {
          this.updateMrpState();
        } catch (e) {
          console.error('[FMS] Error during map state computation. See exception below.');
          console.error(e);
        }
        try {
          this.updateMapPartlyDisplayed();
        } catch (e) {
          console.error('[FMS] Error during map partly displayed computation. See exception below.');
          console.error(e);
        }
        try {
          this.lnavDriver.update(deltaTime);
        } catch (e) {
          console.error('[FMS] Error during LNAV driver update. See exception below.');
          console.error(e);
        }
        try {
          this.vnavDriver.update(deltaTime);
        } catch (e) {
          console.error('[FMS] Error during VNAV driver update. See exception below.');
          console.error(e);
        }
        try {
          this.pseudoWaypoints.update(deltaTime);
        } catch (e) {
          console.error('[FMS] Error during pseudo waypoints update. See exception below.');
          console.error(e);
        }
        try {
          this.efisVectors.update(deltaTime);
        } catch (e) {
          console.error('[FMS] Error during EFIS vectors update. See exception below.');
          console.error(e);
        }
        try {
          this.taskQueue.update(deltaTime);
        } catch (e) {
          console.error('[FMS] Error during task queue update. See exception below.');
          console.error(e);
        }
      }

      /**
       * Called when the lateral flight plan is changed
       */
      updateGeometries() {
        this.updateActiveGeometry();
        if (this.flightPlanManager.getFlightPlan(FlightPlans.Temporary)) {
          this.updateTemporaryGeometry();
        } else {
          this.temporaryGeometry = undefined;
        }
        this.recomputeGeometries();
        this.updateEfisIdent();
        this.geometryRecomputationTimer = 0;
        this.vnavDriver.acceptMultipleLegGeometry(this.activeGeometry);
        this.pseudoWaypoints.acceptMultipleLegGeometry(this.activeGeometry);
      }
      updateActiveGeometry() {
        const wptCount = this.flightPlanManager.getWaypointsCount(FlightPlans.Active);
        const activeIdx = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Active);
        if (this.activeGeometry) {
          this.guidanceManager.updateGeometry(this.activeGeometry, FlightPlans.Active, activeIdx, wptCount);
        } else {
          this.activeGeometry = this.guidanceManager.getMultipleLegGeometry();
        }
      }
      updateTemporaryGeometry() {
        const wptCount = this.flightPlanManager.getWaypointsCount(FlightPlans.Temporary);
        const activeIdx = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Temporary);
        if (this.temporaryGeometry) {
          this.guidanceManager.updateGeometry(this.temporaryGeometry, FlightPlans.Temporary, activeIdx, wptCount);
        } else {
          this.temporaryGeometry = this.guidanceManager.getMultipleLegGeometry(true);
        }
      }
      recomputeGeometries() {
        const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', 'Knots');
        const gs = SimVar.GetSimVarValue('GPS GROUND SPEED', 'Knots');
        const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
        if (this.activeGeometry) {
          this.activeGeometry.recomputeWithParameters(tas, gs, this.lnavDriver.ppos, trueTrack, this.activeLegIndex, this.activeTransIndex);
        }
        if (this.temporaryGeometry) {
          this.temporaryGeometry.recomputeWithParameters(tas, gs, this.lnavDriver.ppos, trueTrack, this.temporaryLegIndex, this.temporaryLegIndex - 1);
        }
      }

      /**
       * Notifies the FMS that a pseudo waypoint must be sequenced.
       *
       * This is to be sued by {@link LnavDriver} only.
       *
       * @param pseudoWaypoint the {@link PseudoWaypoint} to sequence.
       */
      sequencePseudoWaypoint(pseudoWaypoint) {
        this.pseudoWaypoints.sequencePseudoWaypoint(pseudoWaypoint);
      }
      isManualHoldActive() {
        if (this.activeGeometry) {
          const activeLeg = this.activeGeometry.legs.get(this.activeLegIndex);
          return activeLeg instanceof HMLeg;
        }
        return false;
      }
      isManualHoldNext() {
        if (this.activeGeometry) {
          const nextLeg = this.activeGeometry.legs.get(this.activeLegIndex + 1);
          return nextLeg instanceof HMLeg;
        }
        return false;
      }
      setHoldSpeed(tas) {
        let holdLeg;
        if (this.isManualHoldActive()) {
          holdLeg = this.activeGeometry.legs.get(this.activeLegIndex);
        } else if (this.isManualHoldNext()) {
          holdLeg = this.activeGeometry.legs.get(this.activeLegIndex + 1);
        }
        if (holdLeg) {
          holdLeg.setPredictedTas(tas);
        }
      }
    }

    let TuningMode;

    /**
     * This is a placeholder for the new radio nav tuning logic... coming soon to an B77HS near you
     */
    (function (TuningMode) {
      TuningMode[TuningMode["Auto"] = 0] = "Auto";
      TuningMode[TuningMode["Manual"] = 1] = "Manual";
      TuningMode[TuningMode["Remote"] = 2] = "Remote";
    })(TuningMode || (TuningMode = {}));
    class NavRadioManager {
      constructor(_parentInstrument) {
        this._parentInstrument = _parentInstrument;
        _defineProperty$2(this, "tuningMode", TuningMode.Auto);
        _defineProperty$2(this, "manualTuned", void 0);
        _defineProperty$2(this, "rmpTuned", void 0);
        SimVar.SetSimVarValue('L:B77HS_AIMS_RADIONAV_TUNING_MODE', 'Enum', TuningMode.Auto);
      }
      update(deltaTime, manualTuned, rmpTuned) {
        if (this.manualTuned !== manualTuned || this.rmpTuned !== rmpTuned) {
          // too avoid SetSimVar too often
          this.manualTuned = manualTuned;
          this.rmpTuned = rmpTuned;
          if (manualTuned) {
            this.tuningMode = TuningMode.Manual;
          } else if (rmpTuned) {
            this.tuningMode = TuningMode.Remote;
          } else {
            if (this.tuningMode === TuningMode.Remote) {
              // Happens when NAV push button is pushed back
              // It resets all the frequencies (real life behavior)
              SimVar.SetSimVarValue('K:ADF_ACTIVE_SET', 'Frequency ADF BCD32', 0);
              SimVar.SetSimVarValue('K:ADF2_ACTIVE_SET', 'Frequency ADF BCD32', 0);
              SimVar.SetSimVarValue('K:NAV1_RADIO_SET_HZ', 'Hz', 0);
              SimVar.SetSimVarValue('K:NAV2_RADIO_SET_HZ', 'Hz', 0);
              SimVar.SetSimVarValue('K:NAV3_RADIO_SET_HZ', 'Hz', 0);
            }
            this.tuningMode = TuningMode.Auto;
          }
          SimVar.SetSimVarValue('L:B77HS_AIMS_RADIONAV_TUNING_MODE', 'Enum', this.tuningMode);
        }
      }
    }

    // WARNING: this is a temporary implementation until the new nav database is complete
    // Do not write any code which depends on it
    class NearbyFacilities {
      // metres

      constructor() {
        _defineProperty$2(this, "nearbyAirports", new Map());
        _defineProperty$2(this, "nearbyNdbNavaids", new Map());
        _defineProperty$2(this, "nearbyVhfNavaids", new Map());
        _defineProperty$2(this, "nearbyWaypoints", new Map());
        _defineProperty$2(this, "version", 0);
        _defineProperty$2(this, "listener", void 0);
        _defineProperty$2(this, "initDone", false);
        _defineProperty$2(this, "airportSessionId", void 0);
        _defineProperty$2(this, "ndbSessionId", void 0);
        _defineProperty$2(this, "vorSessionId", void 0);
        _defineProperty$2(this, "waypointSessionId", void 0);
        _defineProperty$2(this, "lastPpos", {
          lat: 0,
          long: 0
        });
        _defineProperty$2(this, "throttler", new UpdateThrottler(10000));
        _defineProperty$2(this, "radius", 381 * 1852);
        _defineProperty$2(this, "limit", 160);
        this.listener = RegisterViewListener('JS_LISTENER_FACILITY', async () => {
          this.listener.on('SendAirport', this.addAirport.bind(this));
          this.listener.on('SendIntersection', this.addWaypoint.bind(this));
          this.listener.on('SendNdb', this.addNdbNavaid.bind(this));
          this.listener.on('SendVor', this.addVhfNavaid.bind(this));
          this.listener.on('NearestSearchCompleted', this.onSearchCompleted.bind(this));
          this.airportSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Airport);
          this.ndbSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Ndb);
          this.vorSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Vor);
          this.waypointSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Intersection);
          this.initDone = true;
        });
      }
      init() {
        // Do nothing for now
      }
      async update(deltaTime) {
        if (!this.initDone || this.throttler.canUpdate(deltaTime) === -1) {
          return;
        }
        const ppos = {
          lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
          long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
        };
        if (Avionics.Utils.computeDistance(ppos, this.lastPpos) > 5) {
          this.lastPpos = ppos;
        }
        Coherent.call('SEARCH_NEAREST', this.airportSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
        Coherent.call('SEARCH_NEAREST', this.vorSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
        Coherent.call('SEARCH_NEAREST', this.ndbSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
        Coherent.call('SEARCH_NEAREST', this.waypointSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
      }
      onSearchCompleted(result) {
        let nearestList;
        let loadCall;
        switch (result.sessionId) {
          case this.airportSessionId:
            nearestList = this.nearbyAirports;
            loadCall = 'LOAD_AIRPORTS';
            break;
          case this.ndbSessionId:
            nearestList = this.nearbyNdbNavaids;
            loadCall = 'LOAD_NDBS';
            break;
          case this.vorSessionId:
            nearestList = this.nearbyVhfNavaids;
            loadCall = 'LOAD_VORS';
            break;
          case this.waypointSessionId:
            nearestList = this.nearbyWaypoints;
            loadCall = 'LOAD_INTERSECTIONS';
            break;
          default:
            return;
        }
        for (const icao of result.removed) {
          delete nearestList[icao];
          this.version++;
        }
        const loadIcaos = [];
        for (const icao of result.added) {
          if (nearestList.has(icao)) {
            continue;
          }
          loadIcaos.push(icao);
        }
        if (loadIcaos.length > 0) {
          Coherent.call(loadCall, loadIcaos);
        }
      }
      addAirport(airport) {
        this.nearbyAirports.set(airport.icao, airport);
        this.version++;
      }
      addWaypoint(waypoint) {
        this.nearbyWaypoints.set(waypoint.icao, waypoint);
        this.version++;
      }
      addNdbNavaid(ndb) {
        this.nearbyNdbNavaids.set(ndb.icao, ndb);
        this.version++;
      }
      addVhfNavaid(vor) {
        this.nearbyVhfNavaids.set(vor.icao, vor);
        this.version++;
      }
    }

    class EfisSymbols {
      constructor(flightPlanManager, guidanceController) {
        _defineProperty$2(this, "blockUpdate", false);
        _defineProperty$2(this, "flightPlanManager", void 0);
        _defineProperty$2(this, "guidanceController", void 0);
        _defineProperty$2(this, "guidanceManager", void 0);
        _defineProperty$2(this, "nearby", void 0);
        _defineProperty$2(this, "syncer", new FlowEventSync());
        _defineProperty$2(this, "lastMode", {
          L: -1,
          R: -1
        });
        _defineProperty$2(this, "lastRange", {
          L: 0,
          R: 0
        });
        _defineProperty$2(this, "lastEfisOption", {
          L: 0,
          R: 0
        });
        _defineProperty$2(this, "lastPlanCentre", undefined);
        _defineProperty$2(this, "lastPpos", {
          lat: 0,
          long: 0
        });
        _defineProperty$2(this, "lastTrueHeading", -1);
        _defineProperty$2(this, "lastNearbyFacilitiesVersion", void 0);
        _defineProperty$2(this, "lastFpVersion", void 0);
        this.flightPlanManager = flightPlanManager;
        this.guidanceController = guidanceController;
        this.guidanceManager = guidanceController.guidanceManager;
        this.nearby = new NearbyFacilities();
      }
      init() {
        this.nearby.init();
      }
      async update(deltaTime) {
        var _this$flightPlanManag, _this$lastPlanCentre, _this$lastPlanCentre2;
        this.nearby.update(deltaTime);
        if (this.blockUpdate) {
          return;
        }

        // TODO use aims position
        const ppos = {
          lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
          long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
        };
        const trueHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
        const pposChanged = Avionics.Utils.computeDistance(this.lastPpos, ppos) > 2;
        if (pposChanged) {
          this.lastPpos = ppos;
        }
        const trueHeadingChanged = Avionics.Utils.diffAngle(trueHeading, this.lastTrueHeading) > 2;
        if (trueHeadingChanged) {
          this.lastTrueHeading = trueHeading;
        }
        const nearbyFacilitiesChanged = this.nearby.version !== this.lastNearbyFacilitiesVersion;
        this.lastNearbyFacilitiesVersion = this.nearby.version;
        const fpChanged = this.lastFpVersion !== this.flightPlanManager.currentFlightPlanVersion;
        this.lastFpVersion = this.flightPlanManager.currentFlightPlanVersion;
        // FIXME map reference point should be per side
        const planCentreIndex = SimVar.GetSimVarValue('L:A32NX_SELECTED_WAYPOINT', 'number');
        const planCentre = (_this$flightPlanManag = this.flightPlanManager.getWaypoint(planCentreIndex)) === null || _this$flightPlanManag === void 0 ? void 0 : _this$flightPlanManag.infos.coordinates;
        const planCentreChanged = (planCentre === null || planCentre === void 0 ? void 0 : planCentre.lat) !== ((_this$lastPlanCentre = this.lastPlanCentre) === null || _this$lastPlanCentre === void 0 ? void 0 : _this$lastPlanCentre.lat) || (planCentre === null || planCentre === void 0 ? void 0 : planCentre.long) !== ((_this$lastPlanCentre2 = this.lastPlanCentre) === null || _this$lastPlanCentre2 === void 0 ? void 0 : _this$lastPlanCentre2.long);
        this.lastPlanCentre = planCentre;
        const activeFp = this.flightPlanManager.getCurrentFlightPlan();
        // TODO temp f-pln

        const hasSuitableRunway = airport => {
          for (const runway of airport.runways) {
            switch (runway.surface) {
              case RunwaySurface.Asphalt:
              case RunwaySurface.Bituminous:
              case RunwaySurface.Concrete:
              case RunwaySurface.Tarmac:
                if (runway.length >= 1500 && runway.width >= 30) {
                  return true;
                }
                break;
            }
          }
          return false;
        };
        for (const side of EfisSymbols.sides) {
          const range = rangeSettings[SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_RANGE"), 'number')];
          const mode = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_MODE"), 'number');
          const efisOption = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_OPTION"), 'Enum');
          const rangeChange = this.lastRange[side] !== range;
          this.lastRange[side] = range;
          const modeChange = this.lastMode[side] !== mode;
          this.lastMode[side] = mode;
          const efisOptionChange = this.lastEfisOption[side] !== efisOption;
          this.lastEfisOption[side] = efisOption;
          const nearbyOverlayChanged = efisOption !== EfisOption.Constraints && efisOption !== EfisOption.None && nearbyFacilitiesChanged;
          if (!pposChanged && !trueHeadingChanged && !rangeChange && !modeChange && !efisOptionChange && !nearbyOverlayChanged && !fpChanged && !planCentreChanged) {
            continue;
          }
          if (mode === EfisNdMode.PLAN && !planCentre) {
            this.syncer.sendEvent("A32NX_EFIS_".concat(side, "_SYMBOLS"), []);
            return;
          }
          const [editAhead, editBehind, editBeside] = this.calculateEditArea(range, mode);

          // eslint-disable-next-line no-loop-func
          const withinEditArea = ll => {
            const dist = Avionics.Utils.computeGreatCircleDistance(mode === EfisNdMode.PLAN ? planCentre : ppos, ll);
            let bearing = Avionics.Utils.computeGreatCircleHeading(mode === EfisNdMode.PLAN ? planCentre : ppos, ll);
            if (mode !== EfisNdMode.PLAN) {
              bearing = Avionics.Utils.clampAngle(bearing - trueHeading);
            }
            bearing = bearing * Math.PI / 180;
            const dx = dist * Math.sin(bearing);
            const dy = dist * Math.cos(bearing);
            return Math.abs(dx) < editBeside && dy > -editBehind && dy < editAhead;
          };
          const symbols = [];

          // symbols most recently inserted always end up at the end of the array
          // we reverse the array at the end to make sure symbols are drawn in the correct order
          // eslint-disable-next-line no-loop-func
          const upsertSymbol = symbol => {
            const symbolIdx = symbols.findIndex(s => s.databaseId === symbol.databaseId);
            if (symbolIdx !== -1) {
              var _symbol$constraints, _symbol$direction, _symbol$length, _symbol$location;
              const oldSymbol = symbols.splice(symbolIdx, 1)[0];
              symbol.constraints = (_symbol$constraints = symbol.constraints) !== null && _symbol$constraints !== void 0 ? _symbol$constraints : oldSymbol.constraints;
              symbol.direction = (_symbol$direction = symbol.direction) !== null && _symbol$direction !== void 0 ? _symbol$direction : oldSymbol.direction;
              symbol.length = (_symbol$length = symbol.length) !== null && _symbol$length !== void 0 ? _symbol$length : oldSymbol.length;
              symbol.location = (_symbol$location = symbol.location) !== null && _symbol$location !== void 0 ? _symbol$location : oldSymbol.location;
              symbol.type |= oldSymbol.type;
              if (oldSymbol.radials) {
                if (symbol.radials) {
                  symbol.radials.push(...oldSymbol.radials);
                } else {
                  symbol.radials = oldSymbol.radials;
                }
              }
              if (oldSymbol.radii) {
                if (symbol.radii) {
                  symbol.radii.push(...oldSymbol.radii);
                } else {
                  symbol.radii = oldSymbol.radii;
                }
              }
            }
            symbols.push(symbol);
          };

          // TODO ADIRs aligned (except in plan mode...?)
          if (efisOption === EfisOption.VorDmes) {
            for (const vor of this.nearby.nearbyVhfNavaids.values()) {
              if (vor.type !== VorType.VORDME && vor.type !== VorType.VOR && vor.type !== VorType.DME && vor.type !== VorType.VORTAC && vor.type !== VorType.TACAN) {
                continue;
              }
              const ll = {
                lat: vor.lat,
                long: vor.lon
              };
              if (withinEditArea(ll)) {
                upsertSymbol({
                  databaseId: vor.icao,
                  ident: vor.icao.substring(7, 12),
                  location: ll,
                  type: this.vorDmeTypeFlag(vor.type) | NdSymbolTypeFlags.EfisOption
                });
              }
            }
          } else if (efisOption === EfisOption.Ndbs) {
            for (const ndb of this.nearby.nearbyNdbNavaids.values()) {
              const ll = {
                lat: ndb.lat,
                long: ndb.lon
              };
              if (withinEditArea(ll)) {
                upsertSymbol({
                  databaseId: ndb.icao,
                  ident: ndb.icao.substring(7, 12),
                  location: ll,
                  type: NdSymbolTypeFlags.Ndb | NdSymbolTypeFlags.EfisOption
                });
              }
            }
          } else if (efisOption === EfisOption.Airports) {
            for (const ap of this.nearby.nearbyAirports.values()) {
              const ll = {
                lat: ap.lat,
                long: ap.lon
              };
              if (withinEditArea(ll) && hasSuitableRunway(ap)) {
                upsertSymbol({
                  databaseId: ap.icao,
                  ident: ap.icao.substring(7, 12),
                  location: ll,
                  type: NdSymbolTypeFlags.Airport | NdSymbolTypeFlags.EfisOption
                });
              }
            }
          } else if (efisOption === EfisOption.Waypoints) {
            for (const wp of this.nearby.nearbyWaypoints.values()) {
              const ll = {
                lat: wp.lat,
                long: wp.lon
              };
              if (withinEditArea(ll)) {
                upsertSymbol({
                  databaseId: wp.icao,
                  ident: wp.icao.substring(7, 12),
                  location: ll,
                  type: NdSymbolTypeFlags.Waypoint | NdSymbolTypeFlags.EfisOption
                });
              }
            }
          }
          for (let i = 0; i < 4; i++) {
            const fixInfo = this.flightPlanManager.getFixInfo(i);
            const refFix = fixInfo === null || fixInfo === void 0 ? void 0 : fixInfo.getRefFix();
            if (refFix !== undefined) {
              upsertSymbol({
                databaseId: refFix.icao,
                ident: refFix.ident,
                location: refFix.infos.coordinates,
                type: NdSymbolTypeFlags.FixInfo,
                radials: fixInfo.getRadialTrueBearings(),
                radii: [fixInfo.getRadiusValue()]
              });
            }
          }
          const formatConstraintAlt = function (alt, descent) {
            var _activeFp$originTrans, _activeFp$destination;
            let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
            const transAlt = (_activeFp$originTrans = activeFp === null || activeFp === void 0 ? void 0 : activeFp.originTransitionAltitudePilot) !== null && _activeFp$originTrans !== void 0 ? _activeFp$originTrans : activeFp === null || activeFp === void 0 ? void 0 : activeFp.originTransitionAltitudeDb;
            const transFl = (_activeFp$destination = activeFp === null || activeFp === void 0 ? void 0 : activeFp.destinationTransitionLevelPilot) !== null && _activeFp$destination !== void 0 ? _activeFp$destination : activeFp === null || activeFp === void 0 ? void 0 : activeFp.destinationTransitionLevelDb;
            if (descent) {
              const fl = Math.round(alt / 100);
              if (transFl && fl >= transFl) {
                return "".concat(prefix, "FL").concat(fl);
              }
            } else if (transAlt && alt >= transAlt) {
              return "".concat(prefix, "FL").concat(Math.round(alt / 100));
            }
            return "".concat(prefix).concat(Math.round(alt));
          };
          const formatConstraintSpeed = function (speed) {
            let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            return "".concat(prefix).concat(Math.floor(speed), "KT");
          };
          for (const [index, leg] of this.guidanceController.activeGeometry.legs.entries()) {
            if (!leg.isNull && leg.terminationWaypoint && leg.displayedOnMap) {
              if (!(leg.terminationWaypoint instanceof WayPoint)) {
                const isActive = index === this.guidanceController.activeLegIndex;
                let type = NdSymbolTypeFlags.FlightPlan;
                if (isActive) {
                  type |= NdSymbolTypeFlags.ActiveLegTermination;
                }
                const ident = leg.ident;
                const cutIdent = leg.ident.substring(0, 4).padEnd(5, ' ');
                const id = (Math.random() * 10000000).toString().substring(0, 5);
                upsertSymbol({
                  databaseId: "X".concat(id).concat(cutIdent),
                  ident,
                  type,
                  location: leg.terminationWaypoint
                });
              }
            }
          }

          // TODO don't send the waypoint before active once FP sequencing is properly implemented
          // (currently sequences with guidance which is too early)
          // eslint-disable-next-line no-lone-blocks
          {
            for (let i = activeFp.length - 1; i >= activeFp.activeWaypointIndex - 1 && i >= 0; i--) {
              const wp = activeFp.getWaypoint(i);

              // Managed by legs
              // FIXME these should integrate with the normal algorithms to pick up contraints, not be drawn in enroute ranges, etc.
              const legType = wp.additionalData.legType;
              if (legType === LegType.CA || legType === LegType.CR || legType === LegType.CI || legType === LegType.FM || legType === LegType.PI || legType === LegType.VA || legType === LegType.VI || legType === LegType.VM) {
                continue;
              }
              if (wp.type === 'A') {
                // we pick these up later
                continue;
              }
              // if range >= 160, don't include terminal waypoints, except at enroute boundary
              if (range >= 160) {
                const segment = activeFp.findSegmentByWaypointIndex(i);
                if (segment.type === SegmentType.Departure) {
                  // keep the last waypoint from the SID as it is the enroute boundary
                  if (!activeFp.isLastWaypointInSegment(i)) {
                    continue;
                  }
                } else if (segment.type !== SegmentType.Enroute) {
                  continue;
                }
              }
              if (!withinEditArea(wp.infos.coordinates)) {
                continue;
              }
              let type = NdSymbolTypeFlags.FlightPlan;
              const constraints = [];
              let direction;
              const isCourseReversal = wp.additionalData.legType === LegType.HA || wp.additionalData.legType === LegType.HF || wp.additionalData.legType === LegType.HM || wp.additionalData.legType === LegType.PI;
              if (i === activeFp.activeWaypointIndex) {
                type |= NdSymbolTypeFlags.ActiveLegTermination;
              } else if (isCourseReversal && i > activeFp.activeWaypointIndex + 1 && range <= 80 && !LnavConfig.DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS) {
                if (wp.turnDirection === TurnDirection.Left) {
                  type |= NdSymbolTypeFlags.CourseReversalLeft;
                } else {
                  type |= NdSymbolTypeFlags.CourseReversalRight;
                }
                direction = wp.additionalData.course;
              }
              if (wp.legAltitudeDescription > 0 && wp.legAltitudeDescription < 6) {
                // TODO vnav to predict
                type |= NdSymbolTypeFlags.ConstraintUnknown;
              }
              if (efisOption === EfisOption.Constraints) {
                const descent = wp.constraintType === WaypointConstraintType.DES;
                switch (wp.legAltitudeDescription) {
                  case 1:
                    constraints.push(formatConstraintAlt(wp.legAltitude1, descent));
                    break;
                  case 2:
                    constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '+'));
                    break;
                  case 3:
                    constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '-'));
                    break;
                  case 4:
                    constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '-'));
                    constraints.push(formatConstraintAlt(wp.legAltitude2, descent, '+'));
                    break;
                }
                if (wp.speedConstraint > 0) {
                  constraints.push(formatConstraintSpeed(wp.speedConstraint));
                }
              }
              upsertSymbol({
                databaseId: wp.icao,
                ident: wp.ident,
                location: wp.infos.coordinates,
                type,
                constraints: constraints.length > 0 ? constraints : undefined,
                direction
              });
            }
          }
          const airports = [[activeFp.originAirfield, activeFp.getOriginRunway()], [activeFp.destinationAirfield, activeFp.getDestinationRunway()]];
          for (const [airport, runway] of airports) {
            if (!airport) {
              continue;
            }
            if (runway) {
              if (withinEditArea(runway.beginningCoordinates)) {
                upsertSymbol({
                  databaseId: airport.icao,
                  ident: "".concat(airport.ident).concat(Avionics.Utils.formatRunway(runway.designation)),
                  location: runway.beginningCoordinates,
                  direction: runway.direction,
                  length: runway.length / 1852,
                  type: NdSymbolTypeFlags.Runway
                });
              }
            } else if (withinEditArea(airport.infos.coordinates)) {
              upsertSymbol({
                databaseId: airport.icao,
                ident: airport.ident,
                location: airport.infos.coordinates,
                type: NdSymbolTypeFlags.Airport
              });
            }
          }

          // Pseudo waypoints

          for (const pwp of this.guidanceController.currentPseudoWaypoints.filter(it => it)) {
            upsertSymbol({
              databaseId: "W      ".concat(pwp.ident),
              ident: pwp.ident,
              location: pwp.efisSymbolLla,
              type: pwp.efisSymbolFlag
            });
          }
          const wordsPerSymbol = 6;
          const maxSymbols = 640 / wordsPerSymbol;
          if (symbols.length > maxSymbols) {
            symbols.splice(0, symbols.length - maxSymbols);
            this.guidanceController.efisStateForSide[side].dataLimitReached = true;
          } else {
            this.guidanceController.efisStateForSide[side].dataLimitReached = false;
          }
          this.syncer.sendEvent("A32NX_EFIS_".concat(side, "_SYMBOLS"), symbols);

          // make sure we don't run too often
          this.blockUpdate = true;
          setTimeout(() => {
            this.blockUpdate = false;
          }, 200);
        }
      }
      generatePathVectorSymbol(vector) {
        let typeVectorPart;
        if (vector.type === PathVectorType.Line) {
          typeVectorPart = NdSymbolTypeFlags.FlightPlanVectorLine;
        } else if (vector.type === PathVectorType.Arc) {
          typeVectorPart = NdSymbolTypeFlags.FlightPlanVectorArc;
        } else if (vector.type === PathVectorType.DebugPoint) {
          typeVectorPart = NdSymbolTypeFlags.FlightPlanVectorDebugPoint;
        }

        // FIXME https://cdn.discordapp.com/attachments/845070631644430359/911876826169741342/brabs.gif
        const id = Math.round(Math.random() * 10000).toString();
        const symbol = {
          databaseId: id,
          ident: vector.type === PathVectorType.DebugPoint ? vector.annotation : id,
          type: NdSymbolTypeFlags.ActiveFlightPlanVector | typeVectorPart,
          location: vector.startPoint
        };
        if (vector.type === PathVectorType.Line) {
          symbol.lineEnd = vector.endPoint;
        }
        if (vector.type === PathVectorType.Arc) {
          symbol.arcEnd = vector.endPoint;
          symbol.arcRadius = distanceTo(vector.startPoint, vector.centrePoint);
          symbol.arcSweepAngle = vector.sweepAngle;
        }
        return symbol;
      }
      vorDmeTypeFlag(type) {
        switch (type) {
          case VorType.VORDME:
          case VorType.VORTAC:
            return NdSymbolTypeFlags.VorDme;
          case VorType.VOR:
            return NdSymbolTypeFlags.Vor;
          case VorType.DME:
          case VorType.TACAN:
            return NdSymbolTypeFlags.Dme;
          default:
            return 0;
        }
      }
      findPointFromEndOfPath(path, distanceFromEnd) {
        let accumulator = 0;

        // FIXME take transitions into account on newer FMSs
        for (const [, leg] of path.legs) {
          accumulator += leg.distance;
          if (accumulator > distanceFromEnd) {
            const distanceFromEndOfLeg = distanceFromEnd - (accumulator - leg.distance);
            return leg.getPseudoWaypointLocation(distanceFromEndOfLeg);
          }
        }

        // console.error(`[VNAV/findPointFromEndOfPath] ${distanceFromEnd.toFixed(2)}nm is larger than the total lateral path.`);

        return undefined;
      }
      calculateEditArea(range, mode) {
        switch (mode) {
          case EfisNdMode.MAP:
            if (range <= 10) {
              return [10.5, 3.5, 8.3];
            }
            if (range <= 20) {
              return [20.5, 7, 16.6];
            }
            if (range <= 40) {
              return [40.5, 14, 33.2];
            }
            if (range <= 80) {
              return [80.5, 28, 66.4];
            }
            if (range <= 160) {
              return [160.5, 56, 132.8];
            }
            if (range <= 320) {
              return [320.5, 112, 265.6];
            }
            return [640.5, 224, 531.2];
          case EfisNdMode.VOR:
            if (range <= 10) {
              return [7.6, 7.1, 7.1];
            }
            if (range <= 20) {
              return [14.7, 14.2, 14.2];
            }
            if (range <= 40) {
              return [28.9, 28.4, 28.4];
            }
            if (range <= 80) {
              return [57.3, 56.8, 56.8];
            }
            if (range <= 160) {
              return [114.1, 113.6, 113.6];
            }
            if (range <= 320) {
              return [227.7, 227.2, 227.2];
            }
            return [454.9, 454.4, 454.4];
          case EfisNdMode.APP:
            if (range <= 10) {
              return [7.6, 7.1, 7.1];
            }
            if (range <= 20) {
              return [14.7, 14.2, 14.2];
            }
            if (range <= 40) {
              return [28.9, 28.4, 28.4];
            }
            if (range <= 80) {
              return [57.3, 56.8, 56.8];
            }
            if (range <= 160) {
              return [114.1, 113.6, 113.6];
            }
            if (range <= 320) {
              return [227.7, 227.2, 227.2];
            }
            return [454.9, 454.4, 454.4];
          case EfisNdMode.PLAN:
            if (range <= 10) {
              return [7, 7, 7];
            }
            if (range <= 20) {
              return [14, 14, 14];
            }
            if (range <= 40) {
              return [28, 28, 28];
            }
            if (range <= 80) {
              return [56, 56, 56];
            }
            if (range <= 160) {
              return [112, 112, 112];
            }
            if (range <= 320) {
              return [224, 224, 224];
            }
            return [448, 448, 448];
          default:
            return [0, 0, 0];
        }
      }
    }
    _defineProperty$2(EfisSymbols, "sides", ['L', 'R']);

    class VerticalFlightPlanBuilder {
      static buildVerticalFlightPlan(geometry) {
        const arrivalLegs = geometry.legsInSegment(SegmentType.Arrival);
        const approachLegs = geometry.legsInSegment(SegmentType.Approach);
        const descent = VerticalFlightPlanBuilder.buildVerticalDescent(arrivalLegs, approachLegs);
        return {
          climb: {
            thrustReductionAltitude: 1500,
            accelerationAltitude: 2100,
            climConstraints: {}
          },
          cruise: {
            cruiseAltitude: 36000
          },
          descent
        };
      }
      static buildVerticalDescent(descentLegs, approachLegs) {
        const descentConstraints = {};
        for (const leg of descentLegs.entries()) {
          descentConstraints[leg[0]] = {};
          descentConstraints[leg[0]].altitude = leg[1].altitudeConstraint;
          descentConstraints[leg[0]].speed = leg[1].speedConstraint;
        }
        const approachConstraints = {};
        for (const leg of approachLegs.entries()) {
          approachConstraints[leg[0]] = {};
          approachConstraints[leg[0]].altitude = leg[1].altitudeConstraint;
          approachConstraints[leg[0]].speed = leg[1].speedConstraint;
        }
        return {
          descentConstraints,
          approachConstraints
        };
      }
    }

    class Arinc429WordSsmParseError extends Error {
      constructor(ssm) {
        super();
        this.ssm = ssm;
      }
    }
    let Arinc429SignStatusMatrix;
    (function (Arinc429SignStatusMatrix) {
      Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["FailureWarning"] = 0] = "FailureWarning";
      Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["NoComputedData"] = 1] = "NoComputedData";
      Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["FunctionalTest"] = 2] = "FunctionalTest";
      Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["NormalOperation"] = 3] = "NormalOperation";
    })(Arinc429SignStatusMatrix || (Arinc429SignStatusMatrix = {}));
    class Arinc429Word {
      constructor(word) {
        _defineProperty$2(this, "ssm", void 0);
        _defineProperty$2(this, "value", void 0);
        Arinc429Word.f64View[0] = word;
        const ssm = Arinc429Word.u32View[0];
        if (ssm >= 0b00 && ssm <= 0b11) {
          this.ssm = ssm;
        } else {
          throw new Arinc429WordSsmParseError(ssm);
        }
        this.value = Arinc429Word.f32View[1];
      }
      static empty() {
        return new Arinc429Word(0);
      }
      static fromSimVarValue(name) {
        return new Arinc429Word(SimVar.GetSimVarValue(name, 'number'));
      }
      isFailureWarning() {
        return this.ssm === Arinc429SignStatusMatrix.FailureWarning;
      }
      isNoComputedData() {
        return this.ssm === Arinc429SignStatusMatrix.NoComputedData;
      }
      isFunctionalTest() {
        return this.ssm === Arinc429SignStatusMatrix.FunctionalTest;
      }
      isNormalOperation() {
        return this.ssm === Arinc429SignStatusMatrix.NormalOperation;
      }

      /**
       * Returns the value when normal operation, the supplied default value otherwise.
       */
      valueOr(defaultValue) {
        return this.isNormalOperation() ? this.value : defaultValue;
      }
      getBitValue(bit) {
        return (this.value >> bit - 1 & 1) !== 0;
      }
      getBitValueOr(bit, defaultValue) {
        return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
      }
    }
    _defineProperty$2(Arinc429Word, "f64View", new Float64Array(1));
    _defineProperty$2(Arinc429Word, "u32View", new Uint32Array(Arinc429Word.f64View.buffer));
    _defineProperty$2(Arinc429Word, "f32View", new Float32Array(Arinc429Word.f64View.buffer));

    // Note the logic for this is different on A330/350/380

    class FcuSync {
      constructor() {
        _defineProperty$2(this, "trueRef", false);
      }
      // eslint-disable-next-line no-empty-function
      init() {}
      update(_deltaTime) {
        const irMaint = Arinc429Word.fromSimVarValue('L:A32NX_ADIRS_IR_1_MAINT_WORD');
        const trueRefPb = SimVar.GetSimVarValue('L:A32NX_PUSH_TRUE_REF', 'bool');
        const trueRef = (irMaint.getBitValueOr(15, false) || trueRefPb) && !irMaint.getBitValueOr(2, false);
        if (trueRef !== this.trueRef) {
          this.trueRef = trueRef;
          SimVar.SetSimVarValue('L:A32NX_aims_TRUE_REF', 'boolean', trueRef);
          const activeMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'number');
          if (activeMode === LateralMode.HDG || activeMode === LateralMode.TRACK) {
            SimVar.SetSimVarValue('L:A32NX_FM_HEADING_SYNC', 'boolean', true);
          }
        }
      }
    }

    class ReadySignal {
      constructor() {
        _defineProperty$2(this, "baseInstrument", null);
        _defineProperty$2(this, "updateThrottler", new B77HS_Util.UpdateThrottler(1000));
      }
      init(baseInstrument, _flightPlanManager) {
        this.baseInstrument = baseInstrument;
      }
      update(deltaTime) {
        if (this.updateThrottler.canUpdate(deltaTime) !== -1 && this.baseInstrument.getGameState() === GameState.ingame && SimVar.GetSimVarValue('L:B77HS_IS_READY', 'number') !== 1) {
          // set ready signal that JS code is initialized and flight is actually started
          // -> user pressed 'READY TO FLY' button
          SimVar.SetSimVarValue('L:B77HS_IS_READY', 'number', 1);
        }
      }
    }

    class EfisLabels {
      constructor() {
        _defineProperty$2(this, "lastTransitionAltitude", void 0);
        _defineProperty$2(this, "lastTransitionLevel", void 0);
        _defineProperty$2(this, "flightPlanManager", void 0);
      }
      init(_baseInstrument, flightPlanManager) {
        this.flightPlanManager = flightPlanManager;
      }
      update(_deltaTime) {
        const transitionAltitude = this.flightPlanManager.originTransitionAltitude;
        const transitionLevel = this.flightPlanManager.destinationTransitionLevel;

        // FIXME ARINC429 when the PR adding a TS impl. lands...
        if (transitionAltitude !== this.lastTransitionAltitude) {
          SimVar.SetSimVarValue('L:AIRLINER_TRANS_ALT', 'Number', transitionAltitude !== null && transitionAltitude !== void 0 ? transitionAltitude : 0);
          this.lastTransitionAltitude = transitionAltitude;
        }
        if (transitionLevel !== this.lastTransitionLevel) {
          SimVar.SetSimVarValue('L:AIRLINER_APPR_TRANS_ALT', 'Number', (transitionLevel !== null && transitionLevel !== void 0 ? transitionLevel : 0) * 100);
          this.lastTransitionLevel = transitionLevel;
        }
      }
    }

    /** See a320-coherent-triggers.md */
    const FMMessageTriggers = {
      SEND_TO_MCDU: 'B77HS_FMGC_SEND_MESSAGE_TO_MCDU',
      RECALL_FROM_MCDU_WITH_ID: 'B77HS_FMGC_RECALL_MESSAGE_FROM_MCDU_WITH_ID',
      POP_FROM_STACK: 'B77HS_FMGC_POP_MESSAGE'
    };

    /* eslint-disable no-multi-spaces */
    let NdFmMessageFlag;
    /* eslint-enable no-multi-spaces */
    (function (NdFmMessageFlag) {
      NdFmMessageFlag[NdFmMessageFlag["None"] = 0] = "None";
      NdFmMessageFlag[NdFmMessageFlag["SelectTrueRef"] = 1] = "SelectTrueRef";
      NdFmMessageFlag[NdFmMessageFlag["CheckNorthRef"] = 2] = "CheckNorthRef";
      NdFmMessageFlag[NdFmMessageFlag["NavAccuracyDowngrade"] = 4] = "NavAccuracyDowngrade";
      NdFmMessageFlag[NdFmMessageFlag["NavAccuracyUpgradeNoGps"] = 8] = "NavAccuracyUpgradeNoGps";
      NdFmMessageFlag[NdFmMessageFlag["SpecifiedVorDmeUnavailble"] = 16] = "SpecifiedVorDmeUnavailble";
      NdFmMessageFlag[NdFmMessageFlag["NavAccuracyUpgradeGps"] = 32] = "NavAccuracyUpgradeGps";
      NdFmMessageFlag[NdFmMessageFlag["GpsPrimary"] = 64] = "GpsPrimary";
      NdFmMessageFlag[NdFmMessageFlag["MapPartlyDisplayed"] = 128] = "MapPartlyDisplayed";
      NdFmMessageFlag[NdFmMessageFlag["SetOffsideRangeMode"] = 256] = "SetOffsideRangeMode";
      NdFmMessageFlag[NdFmMessageFlag["OffsideFmControl"] = 512] = "OffsideFmControl";
      NdFmMessageFlag[NdFmMessageFlag["OffsideFmWxrControl"] = 1024] = "OffsideFmWxrControl";
      NdFmMessageFlag[NdFmMessageFlag["OffsideWxrControl"] = 2048] = "OffsideWxrControl";
      NdFmMessageFlag[NdFmMessageFlag["GpsPrimaryLost"] = 4096] = "GpsPrimaryLost";
      NdFmMessageFlag[NdFmMessageFlag["RtaMissed"] = 8192] = "RtaMissed";
      NdFmMessageFlag[NdFmMessageFlag["BackupNav"] = 16384] = "BackupNav";
    })(NdFmMessageFlag || (NdFmMessageFlag = {}));
    const FMMessageTypes = {
      SelectTrueRef: {
        id: 1,
        ndFlag: NdFmMessageFlag.SelectTrueRef,
        text: 'SELECT TRUE REF',
        color: 'Amber',
        ndPriority: 1,
        clearable: true
      },
      CheckNorthRef: {
        id: 2,
        ndFlag: NdFmMessageFlag.CheckNorthRef,
        text: 'CHECK NORTH REF',
        color: 'Amber',
        ndPriority: 1,
        clearable: true
      },
      NavAccuracyDowngrade: {
        id: 3,
        ndFlag: NdFmMessageFlag.NavAccuracyDowngrade,
        text: 'NAV ACCUR DOWNGRAD',
        color: 'Amber',
        ndPriority: 1,
        clearable: true
      },
      NavAccuracyUpgradeNoGps: {
        id: 4,
        ndFlag: NdFmMessageFlag.NavAccuracyUpgradeNoGps,
        text: 'NAV ACCUR UPGRAD',
        color: 'Amber',
        ndPriority: 1,
        clearable: true
      },
      SpecifiedVorDmeUnavailble: {
        id: 5,
        ndFlag: NdFmMessageFlag.SpecifiedVorDmeUnavailble,
        text: 'SPECIF VOR/D UNAVAIL',
        color: 'Amber',
        ndPriority: 1,
        clearable: true
      },
      NavAccuracyUpgradeGps: {
        id: 6,
        ndFlag: NdFmMessageFlag.NavAccuracyUpgradeGps,
        text: 'NAV ACCUR UPGRAD',
        color: 'White',
        ndPriority: 1,
        clearable: true
      },
      GpsPrimary: {
        id: 7,
        ndFlag: NdFmMessageFlag.GpsPrimary,
        text: 'GPS PRIMARY',
        color: 'White',
        ndPriority: 1,
        clearable: true
      },
      MapPartlyDisplayed: {
        id: 8,
        ndFlag: NdFmMessageFlag.MapPartlyDisplayed,
        efisText: 'MAP PARTLY DISPLAYED',
        color: 'Amber',
        ndPriority: 2
      },
      SetOffsideRangeMode: {
        id: 9,
        ndFlag: NdFmMessageFlag.SetOffsideRangeMode,
        text: 'SET OFFSIDE RNG/MODE',
        color: 'Amber',
        ndPriority: 3
      },
      OffsideFmControl: {
        id: 10,
        ndFlag: NdFmMessageFlag.OffsideFmControl,
        text: 'OFFSIDE FM CONTROL',
        color: 'Amber',
        ndPriority: 4
      },
      OffsideFmWxrControl: {
        id: 11,
        ndFlag: NdFmMessageFlag.OffsideFmWxrControl,
        text: 'OFFSIDE FM/WXR CONTROL',
        color: 'Amber',
        ndPriority: 5
      },
      OffsideWxrControl: {
        id: 12,
        ndFlag: NdFmMessageFlag.OffsideWxrControl,
        text: 'OFFSIDE WXR CONTROL',
        color: 'Amber',
        ndPriority: 6
      },
      GpsPrimaryLost: {
        id: 13,
        ndFlag: NdFmMessageFlag.GpsPrimaryLost,
        text: 'GPS PRIMARY LOST',
        color: 'Amber',
        ndPriority: 7
      },
      RtaMissed: {
        id: 14,
        ndFlag: NdFmMessageFlag.RtaMissed,
        text: 'RTA MISSED',
        color: 'Amber',
        ndPriority: 8
      },
      BackupNav: {
        id: 15,
        ndFlag: NdFmMessageFlag.BackupNav,
        text: 'BACK UP NAV',
        color: 'Amber',
        ndPriority: 9
      },
      TurnAreaExceedance: {
        id: 16,
        text: 'TURN AREA EXCEEDANCE',
        color: 'Amber'
      }
    };

    class TurnAreaExceedance {
      constructor() {
        _defineProperty$2(this, "message", FMMessageTypes.TurnAreaExceedance);
        _defineProperty$2(this, "efisSide", void 0);
        _defineProperty$2(this, "trigRising", new Trigger(true));
        _defineProperty$2(this, "trigFalling", new Trigger(true));
        _defineProperty$2(this, "guidanceController", void 0);
        _defineProperty$2(this, "navigation", void 0);
      }
      init(baseInstrument) {
        this.guidanceController = baseInstrument.guidanceController;
        this.navigation = baseInstrument.navigation;
      }
      process(deltaTime) {
        var _this$guidanceControl;
        const gs = this.navigation.groundSpeed;
        const dtg = (_this$guidanceControl = this.guidanceController.activeLegDtg) !== null && _this$guidanceControl !== void 0 ? _this$guidanceControl : Infinity;
        const ttg = gs > 10 ? 3600 * dtg / gs : Infinity;
        const nextLeg = this.guidanceController.activeGeometry.legs.get(this.guidanceController.activeLegIndex + 1);

        // if within 1.5 min of PI and it's path goes outside the coded distance limit
        const turnAreaExceeded = ttg <= 90 && nextLeg instanceof PILeg && nextLeg.turnAreaExceeded;
        this.trigRising.input = turnAreaExceeded;
        this.trigRising.update(deltaTime);
        this.trigFalling.input = !turnAreaExceeded;
        this.trigFalling.update(deltaTime);
        if (this.trigRising.output) {
          return FMMessageUpdate.SEND;
        }
        if (this.trigFalling.output) {
          return FMMessageUpdate.RECALL;
        }
        return FMMessageUpdate.NO_ACTION;
      }
    }
    class TurnAreaExceedanceLeft extends TurnAreaExceedance {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "efisSide", 'L');
      }
    }
    class TurnAreaExceedanceRight extends TurnAreaExceedance {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "efisSide", 'R');
      }
    }

    class GpsPrimary {
      constructor() {
        _defineProperty$2(this, "message", FMMessageTypes.GpsPrimary);
        _defineProperty$2(this, "lastState", false);
      }
      process(_) {
        const newState = SimVar.GetSimVarValue('L:B77HS_ADIRS_USES_GPS_AS_PRIMARY', 'Bool') === 1;
        if (newState !== this.lastState) {
          this.lastState = newState;
          return newState ? FMMessageUpdate.SEND : FMMessageUpdate.RECALL;
        }
        return FMMessageUpdate.NO_ACTION;
      }
    }

    /**
     * Since this happens when the simvar goes to zero, we need to use some CONF nodes to make sure we do not count the initial
     * first-frame value, as the ADIRS module might not have run yet.
     */
    class GpsPrimaryLost {
      constructor() {
        _defineProperty$2(this, "message", FMMessageTypes.GpsPrimaryLost);
        _defineProperty$2(this, "confLost", new ConfirmationNode(1000));
        _defineProperty$2(this, "trigLost", new Trigger(true));
        _defineProperty$2(this, "confRegained", new ConfirmationNode(1000));
        _defineProperty$2(this, "trigRegained", new Trigger(true));
      }
      process(deltaTime) {
        const lostNow = SimVar.GetSimVarValue('L:B77HS_ADIRS_USES_GPS_AS_PRIMARY', 'Bool') === 0;
        this.confLost.input = lostNow;
        this.confLost.update(deltaTime);
        this.trigLost.input = this.confLost.output;
        this.trigLost.update(deltaTime);
        this.confRegained.input = !lostNow;
        this.confRegained.update(deltaTime);
        this.trigRegained.input = this.confRegained.output;
        this.trigRegained.update(deltaTime);
        if (this.trigLost.output) {
          return FMMessageUpdate.SEND;
        }
        if (this.trigRegained.output) {
          return FMMessageUpdate.RECALL;
        }
        return FMMessageUpdate.NO_ACTION;
      }
    }

    class MapPartlyDisplayed {
      constructor() {
        _defineProperty$2(this, "message", FMMessageTypes.MapPartlyDisplayed);
        _defineProperty$2(this, "efisSide", void 0);
        _defineProperty$2(this, "trigRising", new Trigger(true));
        _defineProperty$2(this, "trigFalling", new Trigger(true));
      }
      process(deltaTime) {
        const partlyDisplayed = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(this.efisSide, "_MAP_PARTLY_DISPLAYED"), 'boolean');
        this.trigRising.input = partlyDisplayed === 1;
        this.trigRising.update(deltaTime);
        this.trigFalling.input = partlyDisplayed === 0;
        this.trigFalling.update(deltaTime);
        if (this.trigRising.output) {
          return FMMessageUpdate.SEND;
        }
        if (this.trigFalling.output) {
          return FMMessageUpdate.RECALL;
        }
        return FMMessageUpdate.NO_ACTION;
      }
    }
    class MapPartlyDisplayedLeft extends MapPartlyDisplayed {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "efisSide", 'L');
      }
    }
    class MapPartlyDisplayedRight extends MapPartlyDisplayed {
      constructor() {
        super(...arguments);
        _defineProperty$2(this, "efisSide", 'R');
      }
    }

    /**
     * This class manages Type II messages sent from the FMGC.
     *
     * Since many of those are also sent to the EFIS, this class sets a bitfield signalling the active messages to the DMCs
     *
     * At the moment, other Type II messages which are not displayed on the EFIS are declared in the old JavaScript CDU/"FMC".
     *
     * **Note:** The plan is eventually to move them here as well - but since they can be triggered manually on pilot output as well, and it
     * is not currently convenient to use this class from the JS CDU, we will not do that at the moment
     *
     * -Benjamin
     */
    class FmsMessages {
      constructor() {
        _defineProperty$2(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
        _defineProperty$2(this, "baseInstrument", void 0);
        _defineProperty$2(this, "ndMessageFlags", {
          L: 0,
          R: 0
        });
        _defineProperty$2(this, "messageSelectors", [new GpsPrimary(), new GpsPrimaryLost(), new MapPartlyDisplayedLeft(), new MapPartlyDisplayedRight(), new TurnAreaExceedanceLeft(), new TurnAreaExceedanceRight()]);
      }
      init(baseInstrument, _flightPlanManager) {
        this.baseInstrument = baseInstrument;
        for (const selector of this.messageSelectors) {
          if (selector.init) {
            selector.init(this.baseInstrument);
          }
        }
      }
      update(deltaTime) {
        let didMutateNd = false;
        for (const selector of this.messageSelectors) {
          const newState = selector.process(deltaTime);
          const message = selector.message;
          switch (newState) {
            case FMMessageUpdate.SEND:
              if (message.text) {
                this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);
              }
              if (message.ndFlag > 0) {
                if (selector.efisSide) {
                  this.ndMessageFlags[selector.efisSide] |= message.ndFlag;
                } else {
                  for (const side in this.ndMessageFlags) {
                    if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
                      this.ndMessageFlags[side] |= message.ndFlag;
                    }
                  }
                }
                didMutateNd = true;
              }
              break;
            case FMMessageUpdate.RECALL:
              if (message.text) {
                this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id
              }

              if (message.ndFlag > 0) {
                if (selector.efisSide) {
                  this.ndMessageFlags[selector.efisSide] &= ~message.ndFlag;
                } else {
                  for (const side in this.ndMessageFlags) {
                    if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
                      this.ndMessageFlags[side] &= ~message.ndFlag;
                    }
                  }
                }
                didMutateNd = true;
              }
              break;
            case FMMessageUpdate.NO_ACTION:
              break;
            default:
              throw new Error('Invalid FM message update state');
          }
        }
        if (didMutateNd) {
          for (const side in this.ndMessageFlags) {
            if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
              SimVar.SetSimVarValue("L:B77HS_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
            }
          }
        }
      }
      send(messageClass) {
        const message = this.messageSelectors.find(it => it instanceof messageClass).message;
        this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);
        if (message.ndFlag) {
          for (const side in this.ndMessageFlags) {
            if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
              this.ndMessageFlags[side] |= message.ndFlag;
              SimVar.SetSimVarValue("L:B77HS_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
            }
          }
        }
      }
      recall(messageClass) {
        const message = this.messageSelectors.find(it => it instanceof messageClass).message;
        this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id

        if (message.ndFlag) {
          for (const side in this.ndMessageFlags) {
            if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
              this.ndMessageFlags[side] &= ~message.ndFlag;
              SimVar.SetSimVarValue("L:B77HS_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
            }
          }
        }
      }
      recallId(id) {
        const message = this.messageSelectors.find(it => it.message.id === id).message;
        this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id

        if (message.ndFlag) {
          for (const side in this.ndMessageFlags) {
            if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
              this.ndMessageFlags[side] &= ~message.ndFlag;
              SimVar.SetSimVarValue("L:B77HS_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
            }
          }
        }
      }
    }

    /**
     * Type II message update state.
     *
     * Used when a message selector implements the {@link FMMessageSelector.process `process`} method.
     */
    let FMMessageUpdate;

    /**
     * Defines a selector for a Type II message.
     */
    (function (FMMessageUpdate) {
      FMMessageUpdate[FMMessageUpdate["NO_ACTION"] = 0] = "NO_ACTION";
      FMMessageUpdate[FMMessageUpdate["SEND"] = 1] = "SEND";
      FMMessageUpdate[FMMessageUpdate["RECALL"] = 2] = "RECALL";
    })(FMMessageUpdate || (FMMessageUpdate = {}));

    const fmsMessages = new FmsMessages();
    const components = [fmsMessages, new EfisLabels(), new ReadySignal(), new FcuSync()];
    function initComponents(baseInstrument, flightPlanManager) {
      components.forEach(component => component.init(baseInstrument, flightPlanManager));
    }
    function updateComponents(deltaTime) {
      components.forEach(component => component.update(deltaTime));
    }
    function recallMessageById(id) {
      fmsMessages.recallId(id);
    }

    const rnpDefaults = {
      [FlightArea.Takeoff]: 1,
      [FlightArea.Terminal]: 1,
      [FlightArea.Enroute]: 2,
      [FlightArea.Oceanic]: 2,
      [FlightArea.VorApproach]: 0.5,
      [FlightArea.GpsApproach]: 0.3,
      [FlightArea.PrecisionApproach]: 0.5,
      [FlightArea.NonPrecisionApproach]: 0.5
    };
    class RequiredPerformance {
      constructor(flightPlanManager) {
        this.flightPlanManager = flightPlanManager;
        _defineProperty$2(this, "activeRnp", void 0);
        _defineProperty$2(this, "requestLDev", false);
        _defineProperty$2(this, "manualRnp", false);
      }
      update(_deltaTime) {
        this.updateAutoRnp();
        this.updateLDev();
      }
      setPilotRnp(rnp) {
        this.manualRnp = true;
        this.setActiveRnp(rnp);
      }
      clearPilotRnp() {
        this.manualRnp = false;
        this.updateAutoRnp();
      }
      updateAutoRnp() {
        if (this.manualRnp) {
          return;
        }
        const area = this.flightPlanManager.activeArea;
        const rnp = rnpDefaults[area];
        if (rnp !== this.activeRnp) {
          this.setActiveRnp(rnp);
        }
      }
      setActiveRnp(rnp) {
        this.activeRnp = rnp;
        SimVar.SetSimVarValue('L:B77HS_AIMS_L_RNP', 'number', rnp !== null && rnp !== void 0 ? rnp : 0);
        SimVar.SetSimVarValue('L:B77HS_AIMS_R_RNP', 'number', rnp !== null && rnp !== void 0 ? rnp : 0);
      }
      updateLDev() {
        const area = this.flightPlanManager.activeArea;
        const ldev = area !== FlightArea.Enroute && area !== FlightArea.Oceanic && this.activeRnp <= 0.3 + Number.EPSILON;
        if (ldev !== this.requestLDev) {
          this.requestLDev = ldev;
          SimVar.SetSimVarValue('L:B77HS_AIMS_L_LDEV_REQUEST', 'bool', this.requestLDev);
          SimVar.SetSimVarValue('L:B77HS_AIMS_R_LDEV_REQUEST', 'bool', this.requestLDev);
        }
      }
    }

    class Navigation {
      constructor(flightPlanManager) {
        this.flightPlanManager = flightPlanManager;
        _defineProperty$2(this, "requiredPerformance", void 0);
        _defineProperty$2(this, "currentPerformance", void 0);
        _defineProperty$2(this, "accuracyHigh", false);
        _defineProperty$2(this, "ppos", {
          lat: 0,
          long: 0
        });
        _defineProperty$2(this, "groundSpeed", 0);
        this.requiredPerformance = new RequiredPerformance(this.flightPlanManager);
      }

      // eslint-disable-next-line no-empty-function
      init() {}
      update(deltaTime) {
        this.requiredPerformance.update(deltaTime);
        this.updateCurrentPerformance();
        this.updatePosition();
      }
      updateCurrentPerformance() {
        const gs = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');

        // FIXME fake it until we make it :D
        const estimate = 0.03 + Math.random() * 0.02 + gs * 0.00015;
        // basic IIR filter
        this.currentPerformance = this.currentPerformance === undefined ? estimate : this.currentPerformance * 0.9 + estimate * 0.1;
        const accuracyHigh = this.currentPerformance <= this.requiredPerformance.activeRnp;
        if (accuracyHigh !== this.accuracyHigh) {
          this.accuracyHigh = accuracyHigh;
          SimVar.SetSimVarValue('L:B77HS_AIMS_L_NAV_ACCURACY_HIGH', 'bool', this.accuracyHigh);
          SimVar.SetSimVarValue('L:B77HS_AIMS_R_NAV_ACCURACY_HIGH', 'bool', this.accuracyHigh);
        }
      }
      updatePosition() {
        this.ppos.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        this.ppos.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        this.groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');
      }
    }

    function initFmgcLoop(baseInstrument, flightPlanManager) {
      initComponents(baseInstrument, flightPlanManager);
    }
    function updateFmgcLoop(deltaTime) {
      updateComponents(deltaTime);
    }

    exports.DecelPathBuilder = DecelPathBuilder;
    exports.DescentBuilder = DescentBuilder;
    exports.EfisSymbols = EfisSymbols;
    exports.FlightPlanAsoboSync = FlightPlanAsoboSync;
    exports.FlightPlanManager = FlightPlanManager;
    exports.GuidanceController = GuidanceController;
    exports.GuidanceManager = GuidanceManager;
    exports.ManagedFlightPlan = ManagedFlightPlan;
    exports.NavRadioManager = NavRadioManager;
    exports.Navigation = Navigation;
    exports.VerticalFlightPlanBuilder = VerticalFlightPlanBuilder;
    exports.WaypointBuilder = WaypointBuilder;
    exports.getFlightPhaseManager = getFlightPhaseManager;
    exports.initFmgcLoop = initFmgcLoop;
    exports.normaliseApproachName = normaliseApproachName;
    exports.recallMessageById = recallMessageById;
    exports.updateFmgcLoop = updateFmgcLoop;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
