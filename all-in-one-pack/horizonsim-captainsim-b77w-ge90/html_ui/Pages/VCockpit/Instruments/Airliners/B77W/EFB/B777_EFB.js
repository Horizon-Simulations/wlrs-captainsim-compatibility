/* From Horizon Simulations */
/*Changes by Horizon Simulations: 
-set Class Boeing Colors to top for easier tweaking
-Change color codes of class Boeing Colors
-Change PFD ground colors in line 77450
-replace all --boeing-color with BoeingColor class
*/
/** Keep this in sync with WTB748_Common.css & WTB78x_Common.css */

class BoeingColors {
}
BoeingColors.black = 'black';
BoeingColors.blackTranslucent = 'rgba(0, 0, 0, 0.2)';
BoeingColors.white = 'white';
BoeingColors.gray = '#89869a';
BoeingColors.darkGray = '#89869a';//darker grey is #646474
BoeingColors.blue = 'hsl(230, 100%, 51%)';
BoeingColors.red = 'red';
BoeingColors.amber = '#ffd600';
BoeingColors.green = '#00ff00';
BoeingColors.magenta = '#ff5bff';
BoeingColors.cyan = '#00ffff';
/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
class HandlerSubscription {
/** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler, initialNotifyFunc, onDestroy) {
        this.handler = handler;
        this.initialNotifyFunc = initialNotifyFunc;
        this.onDestroy = onDestroy;
        this._isAlive = true;
        this._isPaused = false;
        this.canInitialNotify = initialNotifyFunc !== undefined;
    }
        /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify() {
        if (!this._isAlive) {
            throw new Error('HandlerSubscription: cannot notify a dead Subscription.');
        }
        this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot pause a dead Subscription.');
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot resume a dead Subscription.');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        if (initialNotify) {
            this.initialNotify();
        }
        return this;
    }
    /** @inheritdoc */
    destroy() {
        if (!this._isAlive) {
            return;
        }
        this._isAlive = false;
        this.onDestroy && this.onDestroy(this);
    }
}

/**
 * A basic implementation of {@link Consumer}.
 */
class BasicConsumer {
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe, state = {}, currentHandler) {
        this.subscribe = subscribe;
        this.state = state;
        this.currentHandler = currentHandler;
        /** @inheritdoc */
        this.isConsumer = true;
        this.activeSubs = new Map();
    }
    /** @inheritdoc */
    handle(handler, paused = false) {
        let activeHandler;
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            activeHandler = (data) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.currentHandler(data, this.state, handler);
            };
        }
        else {
            activeHandler = handler;
        }
        let activeSubArray = this.activeSubs.get(handler);
        if (!activeSubArray) {
            activeSubArray = [];
            this.activeSubs.set(handler, activeSubArray);
        }
        const onDestroyed = (destroyed) => {
            const activeSubsArray = this.activeSubs.get(handler);
            if (activeSubsArray) {
                activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
                if (activeSubsArray.length === 0) {
                    this.activeSubs.delete(handler);
                }
            }
        };
        const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
        // Need to handle the case where the subscription is destroyed immediately
        if (sub.isAlive) {
            activeSubArray.push(sub);
        }
        else if (activeSubArray.length === 0) {
            this.activeSubs.delete(handler);
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        var _a;
        const activeSubArray = this.activeSubs.get(handler);
        if (activeSubArray) {
            (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
            if (activeSubArray.length === 0) {
                this.activeSubs.delete(handler);
            }
        }
    }
    /** @inheritdoc */
    atFrequency(frequency, immediateFirstPublish = true) {
        const initialState = {
            previousTime: Date.now(),
            firstRun: immediateFirstPublish
        };
        return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    getAtFrequencyHandler(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime || state.firstRun) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                if (state.firstRun) {
                    state.firstRun = false;
                }
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    withPrecision(precision) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    getWithPrecisionHandler(precision) {
        return (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
                state.hasLastValue = true;
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        };
    }
    /** @inheritdoc */
    whenChangedBy(amount) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    getWhenChangedByHandler(amount) {
        return (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (!state.hasLastValue || diff >= amount) {
                state.hasLastValue = true;
                state.lastValue = dataValue;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    whenChanged() {
        return new BasicConsumer(this.subscribe, { lastValue: '', hasLastValue: false }, this.getWhenChangedHandler());
    }
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    getWhenChangedHandler() {
        return (data, state, next) => {
            if (!state.hasLastValue || state.lastValue !== data) {
                state.hasLastValue = true;
                state.lastValue = data;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    onlyAfter(deltaTime) {
        return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    getOnlyAfterHandler(deltaTime) {
        return (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        };
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}
/**
 * A {@link Subscription} for a {@link BasicConsumer}.
 */
class ConsumerSubscription {
        /** @inheritdoc */
    get isAlive() {
        return this.sub.isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this.sub.isPaused;
    }
    /** @inheritdoc */
    get canInitialNotify() {
        return this.sub.canInitialNotify;
    }
/**
     * Constructor.
     * @param sub The event bus subscription backing this subscription.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(sub, onDestroy) {
        this.sub = sub;
        this.onDestroy = onDestroy;
    }
    /** @inheritdoc */
    pause() {
        this.sub.pause();
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        this.sub.resume(initialNotify);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this.sub.destroy();
        this.onDestroy(this);
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new BasicConsumer((handler, paused) => {
            return this.bus.on(topic, handler, paused);
        });
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use generic listener event sync (default false).
     * If true, FlowEventSync will only work for gauges.
     * @param shouldResync Whether the eventbus should ask for a resync of all previously cached events (default true)
     */
    constructor(useAlternativeEventSync = false, shouldResync = true) {
        this._topicSubsMap = new Map();
        this._wildcardSubs = new Array();
        this._notifyDepthMap = new Map();
        this._wildcardNotifyDepth = 0;
        this._eventCache = new Map();
        this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
        this._busId = Math.floor(Math.random() * 2147483647);
        // fallback to flowevent when genericdatalistener not avail (su9)
        useAlternativeEventSync = (typeof RegisterGenericDataListener === 'undefined');
        const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        if (shouldResync === true) {
            this.syncEvent('event_bus', 'resync_request', false);
            this.on('event_bus', (data) => {
                if (data == 'resync_request') {
                    this.resyncEvents();
                }
            });
        }
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic, handler, paused = false) {
        let subs = this._topicSubsMap.get(topic);
        if (subs === undefined) {
            this._topicSubsMap.set(topic, subs = []);
            this.pub('event_bus_topic_first_sub', topic, false, false);
        }
        const initialNotifyFunc = (sub) => {
            const lastState = this._eventCache.get(topic);
            if (lastState !== undefined) {
                sub.handler(lastState.data);
            }
        };
        const onDestroyFunc = (sub) => {
            var _a;
            // If we are not in the middle of a notify operation, remove the subscription.
            // Otherwise, do nothing and let the post-notify clean-up code handle it.
            if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
                const subsToSplice = this._topicSubsMap.get(topic);
                if (subsToSplice) {
                    subsToSplice.splice(subsToSplice.indexOf(sub), 1);
                }
            }
        };
        const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
        subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic, handler) {
        const handlers = this._topicSubsMap.get(topic);
        const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler) {
        const sub = new HandlerSubscription(handler, undefined, this.onWildcardSubDestroyedFunc);
        this._wildcardSubs.push(sub);
        return sub;
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler) {
        const toDestroy = this._wildcardSubs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        var _a;
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const subs = this._topicSubsMap.get(topic);
        if (subs !== undefined) {
            let needCleanUpSubs = false;
            const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
            this._notifyDepthMap.set(topic, notifyDepth + 1);
            const len = subs.length;
            for (let i = 0; i < len; i++) {
                try {
                    const sub = subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(data);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            this._notifyDepthMap.set(topic, notifyDepth);
            if (needCleanUpSubs && notifyDepth === 0) {
                const filteredSubs = subs.filter(sub => sub.isAlive);
                this._topicSubsMap.set(topic, filteredSubs);
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        let needCleanUpSubs = false;
        this._wildcardNotifyDepth++;
        const wcLen = this._wildcardSubs.length;
        for (let i = 0; i < wcLen; i++) {
            const sub = this._wildcardSubs[i];
            if (sub.isAlive && !sub.isPaused) {
                sub.handler(topic, data);
            }
            needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        }
        this._wildcardNotifyDepth--;
        if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
            this._wildcardSubs = this._wildcardSubs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    onWildcardSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this._wildcardNotifyDepth === 0) {
            this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic) {
        var _a, _b;
        return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Executes a function once for each topic with at least one subscriber.
     * @param fn The function to execute.
     */
    forEachSubscribedTopic(fn) {
        this._topicSubsMap.forEach((subs, topic) => { subs.length > 0 && fn(topic, subs.length); });
    }
}
/**
 * An abstract class for bus sync implementations.
 */
class EventBusSyncBase {
    /**
     * Creates an instance of EventBusFlowEventSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.
     */
    constructor(recvEventCb, busId) {
        this.isPaused = false;
        this.lastEventSynced = -1;
        this.dataPackageQueue = [];
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.hookReceiveEvent();
        /** Sends the queued up data packages */
        const sendFn = () => {
            if (!this.isPaused && this.dataPackageQueue.length > 0) {
                // console.log(`Sending ${this.dataPackageQueue.length} packages`);
                const syncDataPackage = {
                    busId: this.busId,
                    packagedId: Math.floor(Math.random() * 1000000000),
                    data: this.dataPackageQueue
                };
                if (this.executeSync(syncDataPackage)) {
                    this.dataPackageQueue.length = 0;
                }
                else {
                    console.warn('Failed to send sync data package');
                }
            }
            requestAnimationFrame(sendFn);
        };
        requestAnimationFrame(sendFn);
    }
    /**
     * Processes events received and sends them onto the local bus.
     * @param syncData The data package to process.
     */
    processEventsReceived(syncData) {
        if (this.busId !== syncData.busId) {
            // HINT: coherent events are still received twice, so check for this
            if (this.lastEventSynced !== syncData.packagedId) {
                this.lastEventSynced = syncData.packagedId;
                syncData.data.forEach((data) => {
                    try {
                        this.recvEventCb(data.topic, data.data !== undefined ? data.data : undefined, false, data.isCached);
                    }
                    catch (e) {
                        console.error(e);
                        if (e instanceof Error) {
                            console.error(e.stack);
                        }
                    }
                });
            }
        }
    }
    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // stringify data
        const dataObj = data;
        // build a data package
        const dataPackage = {
            topic: topic,
            data: dataObj,
            isCached: isCached
        };
        // queue data package
        this.dataPackageQueue.push(dataPackage);
    }
}
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 * DON'T USE this, it has bad performance implications.
 * @deprecated
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
class EventBusCoherentSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // HINT: Stringifying the data again to circumvent the bad perf on Coherent interop
        try {
            this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, undefined, true);
        this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
            try {
                const evt = JSON.parse(e);
                this.processEventsReceived(evt);
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 */
class EventBusFlowEventSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // console.log('Sending sync package: ' + syncDataPackage.packagedId);
        try {
            LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        Coherent.on('OnInteractionEvent', (target, args) => {
            // identify if its a busevent
            if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
                return;
            }
            this.processEventsReceived(JSON.parse(args[2]));
        });
    }
}
EventBusFlowEventSync.EB_LISTENER_KEY = 'EB_EVENTS';
//// END GLOBALS DECLARATION
/**
 * A class that manages event bus synchronization via the Generic Data Listener.
 */
class EventBusListenerSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        try {
            this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        // pause the sync until the listener is ready
        this.isPaused = true;
        this.listener = RegisterGenericDataListener(() => {
            this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
                try {
                    this.processEventsReceived(data);
                }
                catch (error) {
                    console.error(error);
                }
            });
            this.isPaused = false;
        });
    }
}
EventBusListenerSync.EB_KEY = 'wt.eb.evt';
EventBusListenerSync.EB_LISTENER_KEY = 'JS_LISTENER_GENERICDATA';

/**
 * Captures the state of a value from a consumer.
 */
class ConsumerValue {
        // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this object is alive. While alive, this object will update its value from its event consumer unless it
     * is paused. Once dead, this object will no longer update its value and cannot be resumed again.
     */
    get isAlive() {
        return this._isAlive;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused. While paused, this object's value will not update.
     */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Creates an instance of a ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     */
    constructor(consumer, initialValue) {
        /** @inheritDoc */
        this.canInitialNotify = true;
        this.consumerHandler = (v) => { this.value = v; };
        this._isAlive = true;
        this._isPaused = false;
        this.value = initialValue;
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    /** @inheritDoc */
    get() {
        return this.value;
    }
    /**
     * Sets the consumer from which this object derives its value. If the consumer is null, this object's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This object, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (!this._isAlive) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this object. Once paused, this object's value will not be updated.
     * @returns This object, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this object. Once resumed, this object's value will be updated from consumed
     * events.
     *
     * Any `initialNotify` argument passed to this method is ignored. This object is always immediately notified of its
     * event consumer's value when resumed.
     * @returns This object, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /**
     * Destroys this object. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        this._isAlive = false;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * Creates a new ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     * @returns The created ConsumerValue.
     */
    static create(consumer, initialValue) {
        return new ConsumerValue(consumer, initialValue);
    }
}

/* eslint-disable @typescript-eslint/no-duplicate-enum-values */
/* eslint-disable @typescript-eslint/ban-ts-comment */
/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Bool"] = "bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["DegreesPerSecond"] = "degrees per second";
    SimVarValueType["Enum"] = "enum";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Hertz"] = "hertz";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["HPA"] = "hectopascals";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["LBS"] = "pounds";
    SimVarValueType["LLA"] = "latlonalt";
    SimVarValueType["Mach"] = "mach";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["MetersPerSecond"] = "meters per second";
    SimVarValueType["MetersPerSecondSquared"] = "meters per second squared";
    SimVarValueType["MillimetersWater"] = "millimeters of water";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["Number"] = "number";
    SimVarValueType["Percent"] = "percent";
    SimVarValueType["PercentOver100"] = "percent over 100";
    SimVarValueType["Pounds"] = "pounds";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["RadiansPerSecond"] = "radians per second";
    SimVarValueType["Rankine"] = "rankine";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["SlugsPerCubicFoot"] = "slug per cubic foot";
    SimVarValueType["String"] = "string";
    SimVarValueType["Volts"] = "Volts";
    SimVarValueType["FtLb"] = "Foot pounds";
})(SimVarValueType || (SimVarValueType = {}));
const latlonaltRegEx = new RegExp(/latlonalt/i);
const latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
const pbhRegex = new RegExp(/pbh/i);
const pid_structRegex = new RegExp(/pid_struct/i);
const xyzRegex = new RegExp(/xyz/i);
const stringRegex = new RegExp(/string/i);
const boolRegex = new RegExp(/boolean|bool/i);
const numberRegex = new RegExp(/number/i);
const defaultSource = '';
// @ts-ignore
SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
        if (simvar) {
            let output;
            const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (registeredID >= 0) {
                if (numberRegex.test(unit)) {
                    output = simvar.getValueReg(registeredID);
                }
                else if (stringRegex.test(unit)) {
                    output = simvar.getValueReg_String(registeredID);
                }
                else if (latlonaltRegEx.test(unit)) {
                    output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
                }
                else if (pbhRegex.test(unit)) {
                    output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
                }
                else if (pid_structRegex.test(unit)) {
                    output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
                }
                else if (xyzRegex.test(unit)) {
                    output = new XYZ(simvar.getValue_XYZ(name, dataSource));
                }
                else {
                    output = simvar.getValueReg(registeredID);
                }
            }
            return output;
        }
        else {
            console.warn('SimVar handler is not defined (' + name + ')');
        }
    }
    catch (error) {
        console.warn('ERROR ', error, ' GetSimVarValue ' + name + ' unit : ' + unit);
        return null;
    }
    return null;
};
// @ts-ignore
SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == undefined) {
        console.warn(name + ' : Trying to set a null value');
        return Promise.resolve();
    }
    try {
        if (simvar) {
            const regID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (regID >= 0) {
                if (stringRegex.test(unit)) {
                    return Coherent.call('setValueReg_String', regID, value);
                }
                else if (boolRegex.test(unit)) {
                    return Coherent.call('setValueReg_Bool', regID, !!value);
                }
                else if (numberRegex.test(unit)) {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
                else if (latlonaltRegEx.test(unit)) {
                    return Coherent.call('setValue_LatLongAlt', name, value, dataSource);
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    return Coherent.call('setValue_LatLongAltPBH', name, value, dataSource);
                }
                else if (pbhRegex.test(unit)) {
                    return Coherent.call('setValue_PBH', name, value, dataSource);
                }
                else if (pid_structRegex.test(unit)) {
                    return Coherent.call('setValue_PID_STRUCT', name, value, dataSource);
                }
                else if (xyzRegex.test(unit)) {
                    return Coherent.call('setValue_XYZ', name, value, dataSource);
                }
                else {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
            }
        }
        else {
            console.warn('SimVar handler is not defined');
        }
    }
    catch (error) {
        console.warn('error SetSimVarValue ' + error);
    }
    return Promise.resolve();
};
// @ts-ignore
({
    GetSimVarValue: SimVar.GetSimVarValue,
    SetSimVarValue: SimVar.SetSimVarValue,
});

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    publish(topic, data, sync = false, isCached = true) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync, isCached);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Creates a new instance of SimVarPublisher.
     * @param entries Entries describing the SimVars to publish.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(entries, bus, pacer) {
        super(bus, pacer);
        this.resolvedSimVars = new Map();
        this.indexedSimVars = new Map();
        this.subscribed = new Set();
        for (const [topic, entry] of entries) {
            if (entry.indexed) {
                this.indexedSimVars.set(topic, {
                    name: entry.name,
                    type: entry.type,
                    map: entry.map,
                    indexes: entry.indexed === true ? undefined : new Set(entry.indexed),
                    defaultIndex: entry.defaultIndex,
                });
            }
            else {
                this.resolvedSimVars.set(topic, Object.assign({}, entry));
            }
        }
        const handleSubscribedTopic = this.handleSubscribedTopic.bind(this);
        // Iterate over each subscribed topic on the bus to see if it matches any of our topics. If so, start publishing.
        this.bus.forEachSubscribedTopic(handleSubscribedTopic);
        // Listen to first-time topic subscriptions. If any of them match our topics, start publishing.
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(handleSubscribedTopic);
    }
    /**
     * Handles when an event bus topic is subscribed to for the first time.
     * @param topic The subscribed topic.
     */
    handleSubscribedTopic(topic) {
        if (this.resolvedSimVars.has(topic)) {
            // If topic matches an already resolved topic -> start publishing.
            this.onTopicSubscribed(topic);
        }
        else {
            // Check if topic matches indexed topic.
            this.tryMatchIndexedSubscribedTopic(topic);
        }
    }
    /**
     * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
     * publishing the indexed topic.
     * @param topic The subscribed topic to check.
     */
    tryMatchIndexedSubscribedTopic(topic) {
        var _a;
        if (this.indexedSimVars.size === 0) {
            return;
        }
        let entry = this.indexedSimVars.get(topic);
        if (entry) {
            // The subscribed topic matches an unsuffixed topic -> check if the unsuffixed topic should be published and if
            // so, resolve the default index.
            if (entry.defaultIndex !== null) {
                const resolved = this.resolveIndexedSimVar(topic, entry, (_a = entry.defaultIndex) !== null && _a !== void 0 ? _a : 1);
                if (resolved !== undefined) {
                    this.onTopicSubscribed(resolved);
                }
            }
            return;
        }
        if (!SimVarPublisher.INDEXED_REGEX.test(topic)) { // Don't generate an array if we don't have to.
            return;
        }
        const match = topic.match(SimVarPublisher.INDEXED_REGEX);
        const [, matchedTopic, index] = match;
        entry = this.indexedSimVars.get(matchedTopic);
        if (entry) {
            const resolved = this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index));
            if (resolved !== undefined) {
                this.onTopicSubscribed(resolved);
            }
        }
    }
    /**
     * Attempts to resolve an indexed topic with an index, generating a version of the topic which is mapped to an
     * indexed simvar. The resolved indexed topic can then be published.
     * @param topic The topic to resolve.
     * @param entry The entry of the topic to resolve.
     * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
     * a suffix) and will be mapped the index-1 version of its simvar.
     * @returns The resolved indexed topic, or `undefined` if the topic could not be resolved with the specified index.
     */
    resolveIndexedSimVar(topic, entry, index) {
        index !== null && index !== void 0 ? index : (index = 1);
        const resolvedTopic = `${topic}_${index}`;
        if (this.resolvedSimVars.has(resolvedTopic)) {
            return resolvedTopic;
        }
        const defaultIndex = entry.defaultIndex === undefined ? 1 : entry.defaultIndex;
        // Ensure that the index we are trying to resolve is a valid index for the topic.
        if (entry.indexes !== undefined && !entry.indexes.has(index)) {
            return undefined;
        }
        this.resolvedSimVars.set(resolvedTopic, {
            name: entry.name.replace('#index#', `${index !== null && index !== void 0 ? index : 1}`),
            type: entry.type,
            map: entry.map,
            unsuffixedTopic: defaultIndex === index ? topic : undefined
        });
        return resolvedTopic;
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry !== undefined) {
            const value = this.getValueFromEntry(entry);
            this.publish(topic, value);
            // Check if we need to publish the same value to the unsuffixed version of the topic.
            if (entry.unsuffixedTopic) {
                this.publish(entry.unsuffixedTopic, value);
            }
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return this.getValueFromEntry(entry);
    }
    /**
     * Gets the current value for a resolved topic entry.
     * @param entry An entry for a resolved topic.
     * @returns The current value for the specified entry.
     */
    getValueFromEntry(entry) {
        return entry.map === undefined
            ? this.getSimVarValue(entry)
            : entry.map(this.getSimVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getSimVarValue(entry) {
        const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}
SimVarPublisher.INDEXED_REGEX = /(.*)_(0|[1-9]\d*)$/;
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class GameVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
        // Start polling all simvars for which there are existing subscriptions.
        for (const topic of this.simvars.keys()) {
            if (bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((topic) => {
            if (this.simvars.has(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const value = this.getValue(topic);
        if (value !== undefined) {
            this.publish(topic, value);
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.simvars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return entry.map === undefined
            ? this.getGameVarValue(entry)
            : entry.map(this.getGameVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getGameVarValue(entry) {
        const svValue = SimVar.GetGameVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}

/**
 * A publisher for publishing H:Events on the bus.
 */
class HEventPublisher extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
        //console.log(`dispaching hevent:  ${hEvent}`);
        this.publish('hEvent', hEvent, sync, false);
    }
}

/**
 * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
 * to change the state of the output subscribable.
 */
class SubscribablePipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let onDestroy;
        if (typeof arg4 === 'function') {
            handler = (fromVal) => {
                to.set(arg3(fromVal, to.get()));
            };
            onDestroy = arg4;
        }
        else {
            handler = (fromVal) => {
                to.set(fromVal);
            };
            onDestroy = arg3;
        }
        super(handler, (sub) => { sub.handler(from.get()); }, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribable {
    constructor() {
        this.isSubscribable = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this subscribable.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    notify() {
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.notifySubscription(this.singletonSub);
                }
            }
            catch (error) {
                console.error(`AbstractSubscribable: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        this.notifySubscription(sub);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribable: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
/**
 * An implementation of {@link MappedSubscribable}.
 */
class MappedSubscribableClass extends AbstractSubscribable {
/** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Constructor.
     * @param input This subscribable's input.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     */
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
        super();
        this.input = input;
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.canInitialNotify = true;
        this._isAlive = true;
        this._isPaused = false;
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.input.get()));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.input.get());
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSub = this.input.sub(inputValue => {
            this.updateValue(inputValue);
        }, true);
    }
        /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     * @param inputValue The input value.
     */
    updateValue(inputValue) {
        const value = this.mapFunc(inputValue, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot pause a dead subscribable');
        }
        if (this._isPaused) {
            return this;
        }
        this.inputSub.pause();
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot resume a dead subscribable');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        this.inputSub.resume(true);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        this.inputSub.destroy();
    }
}

/**
 * A subscribable subject which derives its value from an event consumer.
 */
class ConsumerSubject extends AbstractSubscribable {
// eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this subject is alive. While alive, this subject will update its value from its event consumer unless it
     * is paused. Once dead, this subject will no longer update its value and cannot be resumed again.
     */
    get isAlive() {
        return this._isAlive;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
        super();
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        /** @inheritdoc */
        this.canInitialNotify = true;
        this.consumerHandler = this.onEventConsumed.bind(this);
        this._isAlive = true;
        this._isPaused = false;
        this.value = initialVal;
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
        // eslint-disable-next-line jsdoc/require-jsdoc
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
        return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    onEventConsumed(value) {
        if (!this.equalityFunc(this.value, value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (!this._isAlive) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events. When this subject is resumed, it immediately updates its value from its event consumer, if one exists.
     *
     * Any `initialNotify` argument passed to this method is ignored. This subject is always immediately notified of its
     * event consumer's value when resumed.
     * @returns This subject, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        this._isAlive = false;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/**
 * A subscribable subject whose value can be freely manipulated.
 */
class Subject extends AbstractSubscribable {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        super();
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.isMutableSubscribable = true;
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /** @inheritdoc */
    notifySub(sub) {
        sub(this.value);
    }
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value) {
        if (typeof this.value !== 'object' || this.value === null) {
            return;
        }
        let changed = false;
        for (const prop in value) {
            changed = value[prop] !== this.value[prop];
            if (changed) {
                break;
            }
        }
        Object.assign(this.value, value);
        changed && this.notify();
    }
    /** @inheritdoc */
    notify() {
        super.notify();
    }
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get() {
        return this.value;
    }
}

/**
 * A utility class which provides the current game state.
 */
class GameStateProvider {
    /**
     * Constructor.
     */
    constructor() {
        this.gameState = Subject.create(undefined);
        window.document.addEventListener('OnVCockpitPanelAttributesChanged', this.onAttributesChanged.bind(this));
        this.onAttributesChanged();
    }
    /**
     * Responds to changes in document attributes.
     */
    onAttributesChanged() {
        var _a;
        if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute('gamestate')) {
            const attribute = window.parent.document.body.getAttribute('gamestate');
            if (attribute !== null) {
                const state = GameState[attribute];
                // The game state is set briefly to ingame after loading is finished before changing to briefing. In order to
                // not notify subscribers of this erroneous ingame state, we will debounce any state changes into ingame by two
                // frames.
                if (state === GameState.ingame && this.gameState.get() !== GameState.ingame) {
                    setTimeout(() => {
                        setTimeout(() => {
                            const newAttribute = window.parent.document.body.getAttribute('gamestate');
                            if (newAttribute !== null) {
                                this.gameState.set(GameState[newAttribute]);
                            }
                        });
                    });
                }
                else {
                    this.gameState.set(state);
                }
                return;
            }
        }
        this.gameState.set(undefined);
    }
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get() {
        var _a;
        return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : (GameStateProvider.INSTANCE = new GameStateProvider())).gameState;
    }
}

/** Utilities for AIRAC cycles. */
class AiracUtils {
    /**
     * Parses the MSFS facility database effective dates into an AIRAC cycle.
     * @param facilitiesDateRange The MSFS facilities date range from the game var `FLIGHT NAVDATA DATE RANGE`.
     * @param out An optional object to write the result to. If not specified a new object will be used.
     * @returns The AIRAC cycle information for the MSFS facility database, or undefined if an error occurs.
     */
    static parseFacilitiesCycle(facilitiesDateRange, out) {
        const match = facilitiesDateRange.match(AiracUtils.MSFS_DATE_RANGE_REGEX);
        if (match === null) {
            console.warn('AiracUtils: Failed to parse facilitiesDateRange', facilitiesDateRange);
            return undefined;
        }
        const [, effMonth, effDay, expMonth, expDay, expYear] = match;
        const effDate = new Date(`${effMonth}-${effDay}-${expYear} UTC`);
        const expDate = new Date(`${expMonth}-${expDay}-${expYear} UTC`);
        // We need to work around a bug where the sim gives the year of the expiration date rather than the effective date.
        if (effDate.getTime() > expDate.getTime()) {
            effDate.setUTCFullYear(effDate.getUTCFullYear() - 1);
        }
        const effectiveTimestamp = effDate.getTime();
        const result = out !== undefined ? out : {};
        return AiracUtils.fillCycleFromEffectiveTimestamp(effectiveTimestamp, result);
    }
    /**
     * Gets a cycle offset from another cycle in increments of 28-days (the length of an AIRAC cycle).
     * @param baseCycle The base cycle to offset from.
     * @param offset The offset in number of cycles (i.e. 28-day increments).
     * @param out An optional object to write the result to. If not specified a new object will be used.
     * @returns The AIRAC cycle information.
     */
    static getOffsetCycle(baseCycle, offset, out) {
        const effectiveTimestamp = baseCycle.effectiveTimestamp + offset * AiracUtils.CYCLE_DURATION;
        const result = out !== undefined ? out : {};
        return AiracUtils.fillCycleFromEffectiveTimestamp(effectiveTimestamp, result);
    }
    /**
     * Gets the AIRAC cycle number in the effective year, given the effective date.
     * @param effectiveTimestamp The effective timestamp, in milliseconds since the UNIX epoch, to determine the cycle number for.
     * @returns The cycle number.
     */
    static getCycleNumber(effectiveTimestamp) {
        AiracUtils.dateCache.setTime(effectiveTimestamp);
        const january1 = Date.UTC(AiracUtils.dateCache.getUTCFullYear(), 0, 1);
        const january1Delta = effectiveTimestamp - january1;
        return Math.trunc(january1Delta / AiracUtils.CYCLE_DURATION) + 1;
    }
    /**
     * Gets the current cycle for a given date.
     * @param date The date to determine the current cycle for.
     * @param out An optional object to write the result to. If not specified a new object will be used.
     * @returns The AIRAC cycle information.
     */
    static getCurrentCycle(date, out) {
        const datumDelta = date.getTime() - AiracUtils.DATUM_CYCLE_TIMESTAMP;
        const offset = Math.floor(datumDelta / AiracUtils.CYCLE_DURATION);
        const effectiveTimestamp = AiracUtils.DATUM_CYCLE_TIMESTAMP + offset * AiracUtils.CYCLE_DURATION;
        const result = out !== undefined ? out : {};
        return AiracUtils.fillCycleFromEffectiveTimestamp(effectiveTimestamp, result);
    }
    /**
     * Fills an {@link AiracCycle} object given an effective timestamp.
     * @param effectiveTimestamp The time this cycle becomes effective in milliseonds since the UNIX epoch.
     * @param out The output object.
     * @returns The object passed as `out` with all the data filled.
     */
    static fillCycleFromEffectiveTimestamp(effectiveTimestamp, out) {
        AiracUtils.dateCache.setTime(effectiveTimestamp);
        out.effectiveTimestamp = effectiveTimestamp;
        out.expirationTimestamp = effectiveTimestamp + AiracUtils.CYCLE_DURATION;
        out.cycle = AiracUtils.getCycleNumber(effectiveTimestamp);
        out.cycleString = out.cycle.toString().padStart(2, '0');
        out.ident = `${(AiracUtils.dateCache.getUTCFullYear() % 100).toString().padStart(2, '0')}${out.cycleString}`;
        return out;
    }
}
AiracUtils.dateCache = new Date();
/** Duration of an AIRAC cycle (28 days) in milliseconds. */
AiracUtils.CYCLE_DURATION = 86400000 * 28;
AiracUtils.MSFS_DATE_RANGE_REGEX = /([A-Z]{3})(\d\d?)([A-Z]{3})(\d\d?)\/(\d\d)/;
// Reference cycle to allow us to calculate the current cycle for an arbitrary date (2401, effective 25 JAN 2024).
AiracUtils.DATUM_CYCLE_TIMESTAMP = Date.UTC(2024, 0, 25);

/**
 * A utility class for working with common aeronautical constants and calculations.
 */
class AeroMath {
    // ---- Ideal gas law relationships for air ----
    /**
     * Gets the static pressure of air, in hectopascals, given temperature and density.
     * @param temperature The temperature, in degrees Celsius.
     * @param density The density, in kilograms per cubic meter.
     * @returns The static pressure of air, in hectopascals, with the specified temperature and density.
     */
    static pressureAir(temperature, density) {
        return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    /**
     * Gets the density of air, in kilograms per cubic meter, given static pressure and temperature.
     * @param pressure The static pressure, in hectopascals.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The density of air, in kilograms per cubic meter, with the specified static pressure and temperature.
     */
    static densityAir(pressure, temperature) {
        return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    /**
     * Gets the temperature of air, in degrees Celsius, given static pressure and density.
     * @param pressure The static pressure, in hectopascals.
     * @param density The density, in kilograms per cubic meter.
     * @returns The temperature of air, in degrees Celsius, with the specified static pressure and temperature.
     */
    static temperatureAir(pressure, density) {
        return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    // ---- Other properties of air ----.
    /**
     * Gets the speed of sound in air, in meters per second, for a given temperature.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The speed of sound in air, in meters per second, for the given temperature.
     */
    static soundSpeedAir(temperature) {
        // speed of sound = sqrt(gamma * R * T)
        // gamma = 1.4
        // R = specific gas constant of dry air
        return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    // ---- Pressure ratios ----
    /**
     * Gets the ratio of total pressure to static pressure for a given mach number in a subsonic compressible airflow.
     * @param mach The mach number.
     * @returns The ratio of total pressure to static pressure for the specific mach number.
     */
    static totalPressureRatioAir(mach) {
        return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    // ---- Temperature ratios ----
    /**
     * Gets the ratio of total air temperature to static air temperature for a given mach number.
     * @param mach The mach number.
     * @param recovery The recovery factor. This is a value in the range `[0, 1]` representing the fraction of the
     * kinetic energy of the airflow that is converted to heat. Defaults to 1.
     * @returns The ratio of total air temperature to static air temperature for the specified mach number.
     */
    static totalTemperatureRatioAir(mach, recovery = 1) {
        return 1 + 0.2 * recovery * mach * mach;
    }
    // ---- ISA modeling ----
    /**
     * Gets the ISA temperature, in degrees Celsius, at a given pressure altitude. The supported pressure altitude range
     * is from -610 to 80000 meters above MSL. This method will return the temperature at -610 meters for all altitudes
     * below this range, and the temperature at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA temperature, in degrees Celsius, for the specified pressure altitude.
     */
    static isaTemperature(altitude) {
        // We don't use lookup table for perf reasons.
        if (altitude < 11000) {
            return 15 + Math.max(altitude, -610) * -0.0065;
        }
        else if (altitude < 20000) {
            return -56.5;
        }
        else if (altitude < 32000) {
            return -56.5 + (altitude - 20000) * 0.001;
        }
        else if (altitude < 47000) {
            return -44.5 + (altitude - 32000) * 0.0028;
        }
        else if (altitude < 51000) {
            return -2.5;
        }
        else if (altitude < 71000) {
            return -2.5 + (altitude - 51000) * -0.0028;
        }
        else {
            return -58.5 + (Math.min(altitude, 80000) - 71000) * -0.002;
        }
    }
    /**
     * Gets the ISA pressure, in hectopascals, at a given pressure altitude. The supported pressure altitude range is
     * from -610 to 80000 meters above MSL. This method will return the pressure at -610 meters for all altitudes below
     * this range, and the pressure at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA pressure, in hectopascals, for the specified pressure altitude.
     */
    static isaPressure(altitude) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // P(h) = P(h0) * (1 + dT/dh / T(h0) * (h - h0)) ^ (-g / (R * dT/dh))
        // Temperature constant with altitude:
        // P(h) = P(h0) * e^(-g / (R * T) * (h - h0))
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (altitude < -610) {
            // Modeling stops at -610 meters, so return the pressure for -610 meters for any altitude below this.
            return 1088.707021458965;
        }
        else if (altitude <= 11000) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return 1013.25 * Math.pow(1 - 2.25577e-5 * altitude, 5.25580);
        }
        else if (altitude <= 20000) {
            // Tropopause
            // dT/dh = 0
            return 226.32547681422847 * Math.exp(-1.57686e-4 * (altitude - 11000));
        }
        else if (altitude <= 32000) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 54.7512459834976 * Math.pow(1 + 4.61574e-6 * (altitude - 20000), -34.1627);
        }
        else if (altitude <= 47000) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 8.68079131804552 * Math.pow(1 + 1.22458e-5 * (altitude - 32000), -12.2010);
        }
        else if (altitude <= 51000) {
            // Stratopause
            // dT/dh = 0
            return 1.1091650294132658 * Math.exp(-1.26225e-4 * (altitude - 47000));
        }
        else if (altitude <= 71000) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return 0.6694542213945832 * Math.pow(1 - 1.03455e-5 * (altitude - 51000), 12.2010);
        }
        else if (altitude <= 80000) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return 0.03956893750841349 * Math.pow(1 - 9.31749e-6 * (altitude - 71000), 17.0814);
        }
        else {
            // Modeling stops at 80000 meters, so return the pressure for 80000 meters for any altitude above this.
            return 0.008864013902895545;
        }
    }
    /**
     * Gets the pressure altitude, in meters above MSL, corresponding to a given ISA pressure. The supported pressure
     * altitude range is from -610 to 80000 meters above MSL. This method will return -610 meters for all pressures above
     * the pressure at -610 meters, and 80000 meters for all pressures below the pressure at 80000 meters.
     * @param pressure The ISA pressure for which to get the altitude, in hectopascals.
     * @returns The pressure altitude, in meters above MSL, corresponding to the specified ISA pressure.
     */
    static isaAltitude(pressure) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // h(P) = T(h0) / dT/dh * ((P / P(h0)) ^ (-(R * dT/dh) / g) - 1) + h0
        // Temperature constant with altitude:
        // h(P) = -(R * T) / g * ln(P / P(h0)) + h0
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (pressure > 1088.707021458965) {
            // Modeling stops at -610 meters, so return -610 meters for any pressure above the pressure at this altitude.
            return -610;
        }
        else if (pressure > 226.32547681422847) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return -44330.76067152236 * (Math.pow(pressure / 1013.25, 0.1902659918566155) - 1);
        }
        else if (pressure > 54.7512459834976) {
            // Tropopause
            // dT/dh = 0
            return -6341.717083317479 * Math.log(pressure / 226.32547681422847) + 11000;
        }
        else if (pressure > 8.68079131804552) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 216649.984617851092 * (Math.pow(pressure / 54.7512459834976, -0.02927169105486393) - 1) + 20000;
        }
        else if (pressure > 1.1091650294132658) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 81660.6509987098 * (Math.pow(pressure / 8.68079131804552, -0.08196049504139005) - 1) + 32000;
        }
        else if (pressure > 0.6694542213945832) {
            // Stratopause
            // dT/dh = 0
            return -7922.360863537334 * Math.log(pressure / 1.1091650294132658) + 47000;
        }
        else if (pressure > 0.03956893750841349) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return -96660.38374172345 * (Math.pow(pressure / 0.6694542213945832, 0.08196049504139005) - 1) + 51000;
        }
        else if (pressure > 0.008864013902895545) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return -107325.0414006347 * (Math.pow(pressure / 0.03956893750841349, 0.05854321074385004) - 1) + 71000;
        }
        else {
            // Modeling stops at 80000 meters, so return 80000 meters for any pressure below the pressure at this altitude.
            return 80000;
        }
    }
    /**
     * Gets the ISA density, in kilograms per cubic meter, at a given pressure altitude. The supported pressure altitude
     * range is from -610 to 80000 meters above MSL. This method will return the density at -610 meters for all altitudes
     * below this range, and the density at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The ISA density, in kilograms per cubic meter, for the specified pressure altitude.
     */
    static isaDensity(altitude, deltaIsa = 0) {
        return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the speed of sound, in meters per second, at a given pressure altitude under ISA conditions.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The speed of sound, in meters per second, at the specified pressure altitude under ISA conditions.
     */
    static soundSpeedIsa(altitude, deltaIsa = 0) {
        return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the offset to apply to pressure altitude, in meters, to obtain indicated altitude for a given altimeter
     * barometric pressure setting.
     * @param baro The barometic pressure setting, in hectopascals, for which to get the offset.
     * @returns The offset to apply to pressure altitude, in meters, to obtain indicated altitude for the specified
     * altimeter barometric pressure setting.
     */
    static baroPressureAltitudeOffset(baro) {
        return 44330.76067152236 * (Math.pow(baro / 1013.25, 0.1902659918566155) - 1);
}
    /**
     * Gets the altimeter barometric pressure setting, in hectopascals, to obtain a given offset to apply to pressure
     * altitude to yield indicated altitude.
     * @param offset The altitude offset, in meters, for which to get the barometric pressure setting.
     * @returns The altimeter barometric pressure setting, in hectopascals, to obtain the specified offset to apply to
     * pressure altitude to yield indicated altitude.
     */
    static altitudeOffsetBaroPressure(offset) {
        return 1013.25 * Math.pow(1 + 2.25577e-5 * offset, 5.25580);
    }
    // ---- Speed conversions ----
    // The following section contains methods for converting between different speeds: CAS, TAS, EAS, and mach.
    // All conversions are based on the following:
    // Constants:
    // gamma (adiabatic index of air) = 1.4
    // pressure_sea_level_isa = 1013.25 hPa
    // sound_speed_sea_level_isa = 340.2964 m/s
    // density_sea_level_isa = 1.22498 kg/m^3
    // Relationship between mach and impact pressure (only valid for subsonic flow):
    // mach = sqrt(5 * ((impact_pressure / static_pressure + 1) ^ ((gamma - 1) / gamma)) - 1)
    // impact_pressure = static_pressure * ((1 + 0.2 * mach ^ 2) ^ (gamma / (gamma - 1)) - 1)
    // Relationship between mach and airspeed:
    // mach = airspeed / sound_speed
    // airspeed = mach * sound_speed
    // Relationship between EAS and TAS:
    // eas = tas * sqrt(density / density_sea_level_isa)
    /**
     * Converts true airspeed (TAS) to mach number.
     * @param tas The true airspeed to convert, in the same units as `soundSpeed`.
     * @param soundSpeed The speed of sound, in the same units as `tas`.
     * @returns The mach number equivalent of the specified true airspeed.
     */
    static tasToMach(tas, soundSpeed) {
        return tas / soundSpeed;
    }
    /**
     * Converts true airspeed (TAS) to mach number under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The mach number equivalent of the specified true airspeed at the specified pressure altitude under ISA
     * conditions.
     */
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
        return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts mach number to true airspeed (TAS).
     * @param mach The mach number to convert.
     * @param soundSpeed The speed of sound.
     * @returns The true airspeed equivalent of the specified mach number, in the same units as `soundSpeed`.
     */
    static machToTas(mach, soundSpeed) {
        return mach * soundSpeed;
    }
    /**
     * Converts mach number to true airspeed (TAS), in meters per second, under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified mach number at the specified
     * pressure altitude under ISA conditions.
     */
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
        return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number. The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified static pressure.
     */
    static casToMach(cas, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate mach from CAS by
        // calculating the impact pressure using sea level ISA conditions, then using that impact pressure to calculate
        // mach using ambient static pressure.
        const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
        const impactPressure = 1013.25 * (Math.pow(1 + (0.2 * mach0 * mach0), 3.5) - 1);
        return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified pressure altitude under
     * ISA conditions.
     */
    static casToMachIsa(cas, altitude) {
        return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number at the specified
     * static pressure.
     */
    static machToCas(mach, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate CAS from mach by
        // calculating the impact pressure using ambient static pressure, then using that impact pressure to calculate
        // CAS using sea level ISA conditions.
        const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number  at the specified
     * pressure altitude under ISA conditions.
     */
    static machToCasIsa(mach, altitude) {
        return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS).
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * ambient pressure and temperature.
     */
    static casToTas(cas, pressure, temperature) {
        return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS) under ISA conditions.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
        return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS).
     * @param tas The true airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * ambient pressure and temperature.
     */
    static tasToCas(tas, pressure, temperature) {
        return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS) under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
        return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    /**
     * Converts true airspeed (TAS) to equivalent airspeed (EAS).
     * @param tas The true airspeed to convert.
     * @param density The ambient density, in kilograms per cubic meter.
     * @returns The equivalent airspeed corresponding to the specified true airspeed at the specified ambient density.
     * The equivalent airspeed is expressed in the same units as the true airspeed.
     */
    static tasToEas(tas, density) {
        return tas * Math.sqrt(density / AeroMath.DENSITY_SEA_LEVEL_ISA);
    }
    /**
     * Converts true airspeed (TAS) to equivalent airspeed (EAS) under ISA conditions.
     * @param tas The true airspeed to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The equivalent airspeed corresponding to the specified true airspeed at the specified pressure altitude
     * under ISA conditions. The equivalent airspeed is expressed in the same units as the true airspeed.
     */
    static tasToEasIsa(tas, altitude, deltaIsa = 0) {
        return AeroMath.tasToEas(tas, AeroMath.isaDensity(altitude, deltaIsa));
    }
    /**
     * Converts equivalent airspeed (EAS) to true airspeed (TAS).
     * @param eas The equivalent airspeed to convert.
     * @param density The ambient density, in kilograms per cubic meter.
     * @returns The true airspeed corresponding to the specified equivalent airspeed at the specified ambient density.
     * The true airspeed is expressed in the same units as the equivalent airspeed.
     */
    static easToTas(eas, density) {
        return eas * Math.sqrt(AeroMath.DENSITY_SEA_LEVEL_ISA / density);
    }
    /**
     * Converts equivalent airspeed (EAS) to true airspeed (TAS) under ISA conditions.
     * @param eas The equivalent airspeed to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed corresponding to the specified equivalent airspeed at the specified pressure altitude
     * under ISA conditions. The true airspeed is expressed in the same units as the equivalent airspeed.
     */
    static easToTasIsa(eas, altitude, deltaIsa = 0) {
        return AeroMath.easToTas(eas, AeroMath.isaDensity(altitude, deltaIsa));
    }
    /**
     * Converts mach number to equivalent airspeed (EAS).
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified mach number at the
     * specified ambient static pressure.
     */
    static machToEas(mach, pressure) {
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * mach * Math.sqrt(pressure / 1013.25);
    }
    /**
     * Converts mach number to equivalent airspeed (EAS) under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified mach number at the
     * specified pressure altitude under ISA conditions.
     */
    static machToEasIsa(mach, altitude) {
        return AeroMath.machToEas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts equivalent airspeed (EAS) to mach number.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number corresponding to the specified equivalent airspeed at the specified ambient static
     * pressure.
     */
    static easToMach(eas, pressure) {
        return eas * Math.sqrt(1013.25 / pressure) / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
    }
    /**
     * Converts equivalent airspeed (EAS) to mach number under ISA conditions.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number corresponding to the specified equivalent airspeed at the specified pressure altitude
     * under ISA conditions.
     */
    static easToMachIsa(eas, altitude) {
        return AeroMath.easToMach(eas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to equivalent airspeed (EAS). The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified calibrated airspeed at the
     * specified ambient static pressure.
     */
    static casToEas(cas, pressure) {
        // The below is a slightly optimized concatenation of the CAS-to-mach and mach-to-EAS conversions.
        const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
        const impactPressure = 1013.25 * (Math.pow(1 + (0.2 * mach0 * mach0), 3.5) - 1);
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * pressure / 1013.25 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to equivalent airspeed (EAS) under ISA conditions. The conversion is only valid
     * for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The equivalent airspeed, in meters per second, corresponding to the specified calibrated airspeed at the
     * specified pressure altitude under ISA conditions.
     */
    static casToEasIsa(cas, altitude) {
        return AeroMath.casToEas(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts equivalent airspeed (EAS) to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed, in meters per second, corresponding to the specified equivalent airspeed at the
     * specified ambient static pressure.
     */
    static easToCas(eas, pressure) {
        return AeroMath.machToCas(AeroMath.easToMach(eas, pressure), pressure);
    }
    /**
     * Converts equivalent airspeed (EAS) to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid
     * for subsonic speeds.
     * @param eas The equivalent airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed, in meters per second, corresponding to the specified equivalent airspeed at the
     * specified pressure altitude under ISA conditions.
     */
    static easToCasIsa(eas, altitude) {
        return AeroMath.easToCas(eas, AeroMath.isaPressure(altitude));
    }
    // ---- Lift and drag equations ----
    // force_coefficient = force / (dynamic_pressure * area)
    // dynamic_pressure = 0.5 * density * speed ^ 2
    /**
     * Calculates a fluid flow force coefficient given a force and flow parameters.
     * @param force The flow force, in newtons.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force coefficient given the specified force and flow parameters.
     */
    static flowCoefFromForce(force, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return force / (dynamicPressure * area);
    }
    /**
     * Calculates a fluid flow force given a coefficient and flow parameters.
     * @param coef The flow force coefficient.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force given the specified coefficient and flow parameters.
     */
    static flowForceFromCoef(coef, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return coef * dynamicPressure * area;
    }
}
/** The ideal gas constant, in units of joules per mole per kelvin. */
AeroMath.R = 8.314462618153;
/** The specific gas constant of dry air, in units of joules per kilogram per kelvin. */
AeroMath.R_AIR = 287.057;
/** Approximate value of the adiabatic index of air near room temperature. */
AeroMath.GAMMA_AIR = 1.4;
/** The speed of sound in air at sea level under ISA conditions, in meters per second. */
AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
/** The density of air at sea level under ISA conditions, in kilograms per cubic meter. */
AeroMath.DENSITY_SEA_LEVEL_ISA = AeroMath.isaDensity(0);
AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
AeroMath.lift = AeroMath.flowForceFromCoef;
AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
AeroMath.drag = AeroMath.flowForceFromCoef;

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags, valuesToSet, mask) {
        return (flags & ~mask) | (valuesToSet & mask);
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values.
 *
 * When a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time
 * elapsed since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The
 * calculation of the weighting is such that the weight of each raw value in the sequence decays exponentially with the
 * "age" (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to
 * the sequence) of the value.
 */
class ExpSmoother {
    /**
     * Creates a new instance of ExpSmoother.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.dtThreshold = dtThreshold;
        this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or null if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        let next;
        if (this.tau > 0 && this.lastValue !== null) {
            const factor = this.calculateFactor(dt);
            next = ExpSmoother.smooth(raw, this.lastValue, factor);
        }
        else {
            next = raw;
        }
        this.lastValue = next;
        return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
        if (dt > this.dtThreshold) {
            return 0;
        }
        else {
            return Math.exp(-dt / this.tau);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        return this.lastValue = (value !== null && value !== void 0 ? value : null);
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value, precision = 1) {
        return Math.round(value / precision) * precision;
    }
    /**
     * Ceils a number.
     * @param value The number to ceil.
     * @param precision The precision with which to ceil. Defaults to `1`.
     * @returns The ceiled number.
     */
    static ceil(value, precision = 1) {
        return Math.ceil(value / precision) * precision;
    }
    /**
     * Floors a number.
     * @param value The number to floor.
     * @param precision The precision with which to floor. Defaults to `1`.
     * @returns The floored number.
     */
    static floor(value, precision = 1) {
        return Math.floor(value / precision) * precision;
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start, end, directional = true) {
        const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
        return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 360)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in degrees.
     * @param end The ending angle, in degrees.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in degrees, in the range `[0, 360)`.
     */
    static diffAngleDeg(start, end, directional = true) {
        const diff = ((end - start) % 360 + 360) % 360;
        return directional ? diff : Math.min(diff, 360 - diff);
    }
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        if (x0 !== x1 && y0 !== y1) {
            const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
            return fraction * (y1 - y0) + y0;
        }
        else {
            return y0;
        }
    }
    /**
     * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
     * lengths, then only the components shared by all vectors are interpolated in the result.
     * @param out The object to which to write the result.
     * @param x The key of the vector to interpolate.
     * @param x0 The key of the first known vector.
     * @param x1 The key of the second known vector.
     * @param y0 The first known vector.
     * @param y1 The second known vector.
     * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
     * Defaults to false.
     * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
     * Defaults to false.
     * @returns The interpolated vector corresponding to the specified key.
     */
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        const length = Math.min(y0.length, y1.length, out.length);
        for (let i = 0; i < length; i++) {
            out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
        }
        return out;
    }
/**
     * Gets the sign of a number, including 0.
     * @param n The number to get the sign of.
     * @returns 1.0 if the number is positive, +0 or Infinity;
      -1.0 if the number is negative, -0 or -Infinity;
      NaN if the number is NaN
     */
    static hardSign(n) {
        return isNaN(n) ? NaN : (n < 0 || Object.is(n, -0) ? -1 : 1);
    }
}
/** Twice the value of pi. */
MathUtils.TWO_PI = Math.PI * 2;
/** Half the value of pi. */
MathUtils.HALF_PI = Math.PI / 2;
/** Square root of 3. */
MathUtils.SQRT3 = Math.sqrt(3);
/** Square root of 1/3. */
MathUtils.SQRT1_3 = 1 / Math.sqrt(3);

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.canConvert(value.unit)) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number' && (!unit || this.unit.canConvert(unit))) {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    abs(out) {
        if (out) {
            return out.set(Math.abs(this.number), this.unit);
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        if (isNaN(converted) && this.isNaN()) {
            return true;
        }
        const diff = this.number - converted;
        return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, out);
        }
        else {
            return this.source.add(arg1, out);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, out);
        }
        else {
            return this.source.subtract(arg1, out);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor, out) {
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs(out) {
        return this.source.abs(out);
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family, numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i++].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i++].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.family = family;
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
/**
 * Predefined unit families.
 */
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["Distance"] = "distance";
    UnitFamily["Angle"] = "angle";
    UnitFamily["Duration"] = "duration";
    UnitFamily["Weight"] = "weight";
    UnitFamily["Mass"] = "weight";
    UnitFamily["Volume"] = "volume";
    UnitFamily["Pressure"] = "pressure";
    UnitFamily["Temperature"] = "temperature";
    UnitFamily["TemperatureDelta"] = "temperature_delta";
    UnitFamily["Speed"] = "speed";
    UnitFamily["Acceleration"] = "acceleration";
    UnitFamily["WeightFlux"] = "weight_flux";
    UnitFamily["MassFlux"] = "weight_flux";
    UnitFamily["VolumeFlux"] = "volume_flux";
    UnitFamily["Density"] = "density";
    UnitFamily["Force"] = "force";
    UnitFamily["DistancePerWeight"] = "distance_per_weight";
    UnitFamily["DistanceRatio"] = "distance_ratio";
    UnitFamily["WeightPerDistance"] = "weight_per_distance";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.Distance, 'meter', 1);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, 'kilometer', 1000);
UnitType.INCH = new SimpleUnit(UnitFamily.Distance, 'inch', 0.0254);
UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, 'foot', 0.3048);
/** Statute mile. */
UnitType.MILE = new SimpleUnit(UnitFamily.Distance, 'mile', 1609.34);
/** Nautical mile. */
UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, 'nautical mile', 1852);
/** Great-arc radian. The average radius of Earth. */
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, 'great arc radian', 6378100);
/** 9.80665 meters, for internal use. */
UnitType.G_METER = new SimpleUnit(UnitFamily.Distance, '9.80665 meter', 9.80665);
UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.Weight, 'pound', 0.453592);
UnitType.SLUG = new SimpleUnit(UnitFamily.Weight, 'slug', 14.59390);
UnitType.TON = new SimpleUnit(UnitFamily.Weight, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, 'tonne', 1000);
/** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, 'liter', 0.80283679);
/** Weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'gallon', 3.0390664);
/** Weight equivalent of one imperial gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'imperial gallon', 3.6497683);
UnitType.LITER = new SimpleUnit(UnitFamily.Volume, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, 'gallon', 3.78541);
/** Hectopascal. */
UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, 'hectopascal', 1);
/** Millibar. */
UnitType.MB = new SimpleUnit(UnitFamily.Pressure, 'millibar', 1);
/** Atmosphere. */
UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, 'atmosphere', 1013.25);
/** Inch of mercury. */
UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, 'inch of mercury', 33.8639);
/** Millimeter of mercury. */
UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, 'millimeter of mercury', 1.33322);
/** Pound per square inch. */
UnitType.PSI = new SimpleUnit(UnitFamily.Pressure, 'pound per square inch', 68.9476);
UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, 'kelvin', 1, 0);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, '° Fahrenheit', 5 / 9, 459.67);
UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, '° Rankine', 5 / 9, 0);
/** Change in degrees Celsius. */
UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Celsius', 1);
/** Change in degrees Fahrenheit. */
UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Fahrenheit', 5 / 9);
UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], 'knot');
/** Kilometer per hour. */
UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
/** Miles per hour. */
UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
/** Meter per minute. */
UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
/** Meter per second. */
UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
/** Foot per minute. */
UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
/** Foot per second. */
UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
/** Meter per minute per second. */
UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
/** Meter per second per second. */
UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Foot per minute per second. */
UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
/** Foot per second per second. */
UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
/** Knot per second. */
UnitType.KNOT_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.NMILE], [UnitType.HOUR, UnitType.SECOND]);
/** Average gravitational acceleration on Earth at sea level. */
UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);
/** Kilogram per hour. */
UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
/** Pound per hour. */
UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
/** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one imperial gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
/** Density in slugs per cubic foot */
UnitType.SLUG_PER_FT3 = new CompoundUnit(UnitFamily.Density, [UnitType.SLUG], [UnitType.FOOT, UnitType.FOOT, UnitType.FOOT]);
/** Density in kilograms per cubic meter */
UnitType.KG_PER_M3 = new CompoundUnit(UnitFamily.Density, [UnitType.KILOGRAM], [UnitType.METER, UnitType.METER, UnitType.METER]);
/** Newton. */
UnitType.NEWTON = new CompoundUnit(UnitFamily.Force, [UnitType.KILOGRAM, UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Pound (force). */
UnitType.POUND_FORCE = new CompoundUnit(UnitFamily.Force, [UnitType.POUND, UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);
/** One statute mile per weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.MILE_PER_GALLON_FUEL = new CompoundUnit(UnitFamily.DistancePerWeight, [UnitType.MILE], [UnitType.GALLON_FUEL]);
/** One nautical mile per weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.NMILE_PER_GALLON_FUEL = new CompoundUnit(UnitFamily.DistancePerWeight, [UnitType.NMILE], [UnitType.GALLON_FUEL]);
/** One foot per nautical mile. */
UnitType.FOOT_PER_NMILE = new CompoundUnit(UnitFamily.DistanceRatio, [UnitType.FOOT], [UnitType.NMILE]);

/**
 * Utility methods for working with Subscribables.
 */
class SubscribableUtils {
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isSubscribable === true;
    }
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isMutableSubscribable === true;
    }
    /**
     * Checks if a query is a subscribable set.
     * @param query A query.
     * @returns Whether the query is a subscribable set.
     */
    static isSubscribableSet(query) {
        return typeof query === 'object' && query !== null && query.isSubscribableSet === true;
    }
    /**
     * Checks if a query is a mutable subscribable set.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable set.
     */
    static isMutableSubscribableSet(query) {
        return typeof query === 'object' && query !== null && query.isMutableSubscribableSet === true;
    }
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable(value, excludeSubscribables) {
        if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
            return value;
        }
        else {
            return Subject.create(value);
        }
    }
// eslint-disable-next-line jsdoc/require-jsdoc
    static pipeMappedSource(source, to, sourceMap, arg4, arg5) {
        let pipeMap;
        let paused;
        if (typeof arg4 === 'function') {
            pipeMap = arg4;
            paused = arg5 !== null && arg5 !== void 0 ? arg5 : false;
        }
        else {
            paused = arg4 !== null && arg4 !== void 0 ? arg4 : false;
        }
        const sub = new MappedSourcePipe(source, to, undefined, sourceMap, pipeMap);
        if (!paused) {
            sub.resume(true);
        }
        return sub;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static pipeOptionalMappedSource(source, to, onOrphaned, sourceMap, arg5, arg6) {
        let pipeMap;
        let paused;
        if (typeof arg5 === 'function') {
            pipeMap = arg5;
            paused = arg6 !== null && arg6 !== void 0 ? arg6 : false;
        }
        else {
            paused = arg5 !== null && arg5 !== void 0 ? arg5 : false;
        }
        const sub = new MappedSourcePipe(source, to, onOrphaned, sourceMap, pipeMap);
        if (!paused) {
            sub.resume(true);
        }
        return sub;
    }
}
/**
 * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
 * `NaN`.
 * @param a The first number to compare.
 * @param b The second number to compare.
 * @returns Whether the two numbers are strictly equal or both `NaN`.
 */
SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || (isNaN(a) && isNaN(b));
/**
 * An equality function which returns false unconditionally.
 * @returns false unconditionally.
 */
SubscribableUtils.NEVER_EQUALITY = () => false;
/**
 * A pipe from an input subscribable that is mapped from a source subscribable to an output mutable subscribable. Each
 * notification received by the pipe from the source subscribable is used to change the pipe's input subscribable.
 */
class MappedSourcePipe {
    /** @inheritDoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritDoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Creates a new instance of MappedSourcePipe. The pipe is initialized as paused.
     * @param source The source of the pipe.
     * @param target The target of this pipe.
     * @param onOrphaned A function that selects a default value to use to set the state of the target subscribable
     * when the source state can't be mapped to a subscribable. The current value of the target subscribable is passed
     * to the function. The default value will _not_ be transformed by `pipeMap`. If not defined, then the target
     * subscribable is left unchanged when the source state can't be mapped to a subscribable.
     * @param sourceMap A function that maps source values to the pipe's input subscribables.
     * @param pipeMap A function that transforms this pipe's input values.
     */
    constructor(source, target, onOrphaned, sourceMap, pipeMap) {
        this.target = target;
        this.onOrphaned = onOrphaned;
        this.sourceMap = sourceMap;
        this.pipeMap = pipeMap;
        this._isAlive = true;
        this._isPaused = true;
        /** @inheritDoc */
        this.canInitialNotify = true;
        this.isPipePaused = true;
        this.sourceSub = source.sub(this.onSourceChanged.bind(this), false, true);
    }
    /**
     * Responds to when this pipe's source value changes.
     * @param source The new source value.
     */
    onSourceChanged(source) {
        var _a;
        (_a = this.pipe) === null || _a === void 0 ? void 0 : _a.destroy();
        const mappedSource = this.sourceMap(source);
        if (mappedSource) {
            if (this.pipeMap) {
                this.pipe = mappedSource.pipe(this.target, this.pipeMap, this.isPipePaused);
            }
            else {
                this.pipe = mappedSource.pipe(this.target, this.isPipePaused);
            }
        }
        else {
            this.pipe = undefined;
            if (!this.isPipePaused && this.onOrphaned) {
                this.onOrphaned(this.target);
            }
        }
    }
    /** @inheritDoc */
    pause() {
        var _a;
        if (!this._isAlive) {
            throw new Error('Subscription: cannot pause a dead Subscription.');
        }
        this._isPaused = true;
        this.isPipePaused = true;
        this.sourceSub.pause();
        (_a = this.pipe) === null || _a === void 0 ? void 0 : _a.pause();
        return this;
    }
    /** @inheritDoc */
    resume(initialNotify = false) {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot resume a dead Subscription.');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        this.sourceSub.resume(true);
        this.isPipePaused = false;
        if (this.pipe) {
            this.pipe.resume(initialNotify);
        }
        else if (initialNotify && this.onOrphaned) {
            this.onOrphaned(this.target);
        }
        return this;
    }
    /** @inheritDoc */
    destroy() {
        var _a;
        if (!this._isAlive) {
            return;
        }
        this._isAlive = false;
        this.sourceSub.destroy();
        (_a = this.pipe) === null || _a === void 0 ? void 0 : _a.destroy();
        this.pipe = undefined;
    }
}

/**
 * Utility class for generating common functions for mapping subscribables.
 */
class SubscribableMapFunctions {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity() {
        return (input) => input;
    }
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not() {
        return (input) => !input;
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise.
     */
    static or() {
        return (input) => input.length > 0 && input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if no tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if no tuple member is `true` or there are no
     * tuple members, and to `false` otherwise.
     */
    static nor() {
        return (input) => !input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static and() {
        return (input) => input.length > 0 && !input.includes(false);
    }
    /**
     * Generates a function which maps an input boolean tuple to `false` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static nand() {
        return (input) => input.length < 1 || input.includes(false);
    }
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate() {
        return (input) => -input;
    }
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs() {
        return Math.abs;
    }
/**
* Generates a function which maps an input number tuple to the minimum numeric value contained in the tuple.
     * A zero-length tuple is mapped to Infinity.
     * @returns A function which maps an input number tuple to the minimum numeric value contained in the tuple.
     */
    static min() {
        return (input) => Math.min(...input);
    }
    /**
     * Generates a function which maps an input number tuple to the maximum numeric value contained in the tuple.
     * A zero-length tuple is mapped to -Infinity.
     * @returns A function which maps an input number tuple to the maximum numeric value contained in the tuple.
     */
    static max() {
        return (input) => Math.max(...input);
    }
    /**
     * Generates a function which maps an input tuple to a count of the number of items in the tuple that satisfy a
     * given condition.
     * @param predicate A function which evaluates whether an item should be counted.
     * @returns A function which maps an input tuple to a count of the number of items in the tuple that satisfy the
     * condition specified by the predicate.
     */
    static count(predicate) {
        const reduceFunc = (sum, curr) => {
            if (predicate(curr)) {
                return sum + 1;
            }
            else {
                return sum;
            }
        };
        return SubscribableMapFunctions.reduce(reduceFunc, 0);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static reduce(callbackFn, initialValue) {
        return (input) => input.reduce(callbackFn, initialValue);
    }
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision(precision) {
        return SubscribableUtils.isSubscribable(precision)
            ? (input) => {
                const precisionVal = precision.get();
                return Math.round(input / precisionVal) * precisionVal;
            }
            : (input) => {
                return Math.round(input / precision) * precision;
            };
    }
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy(threshold) {
        return SubscribableUtils.isSubscribable(threshold)
            ? (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal
            : (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise. In other words, the mapping function will not pass through changes in the input value if not
     * enough time has elapsed since the last change that was passed through.
     *
     * **Caution**: The mapping function can only pass through the input value when the input value changes. This means
     * that if the mapping function rejects a change in the input value due to the maximum frequency being exceeded, it
     * is possible that particular input value will never be reflected in the mapped value, even after the frequency
     * cutoff has expired. For example, if the input value changes from `a` to `b` but is rejected by the mapping
     * function and subsequently remains `b` forever, then the mapped value will remain `a` forever.
     * @param freq The maximum frequency at which to map the input to itself, in hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    static atFrequency(freq, timeFunc = Date.now) {
        let t0;
        let timeRemaining = 0;
        if (SubscribableUtils.isSubscribable(freq)) {
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    const period = 1000 / freq.get();
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
        else {
            const period = 1000 / freq;
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
    }
}

/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
class MappedSubject extends AbstractSubscribable {
/** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
        super();
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        /** @inheritdoc */
        this.canInitialNotify = true;
        this._isAlive = true;
        this._isPaused = false;
        this.inputs = inputs;
        this.inputValues = inputs.map(input => input.get());
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.inputValues, undefined));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.inputValues, undefined);
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSubs = this.inputs.map((input, index) => input.sub(inputValue => {
            this.inputValues[index] = inputValue;
            this.updateValue();
        }));
    }
        // eslint-disable-next-line jsdoc/require-jsdoc
    static create(...args) {
        let mapFunc, equalityFunc, mutateFunc, initialVal;
        if (typeof args[0] === 'function') {
            // Mapping function was supplied.
            mapFunc = args.shift();
            if (typeof args[0] === 'function') {
                equalityFunc = args.shift();
            }
            else {
                equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
            }
            if (typeof args[0] === 'function') {
                mutateFunc = args.shift();
                initialVal = args.shift();
            }
        }
        else {
            mapFunc = MappedSubject.IDENTITY_MAP;
            equalityFunc = MappedSubject.NEVER_EQUALS;
        }
        return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     */
    updateValue() {
        const value = this.mapFunc(this.inputValues, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot pause a dead subject');
        }
        if (this._isPaused) {
            return this;
        }
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].pause();
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot resume a dead subject');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputValues[i] = this.inputs[i].get();
            this.inputSubs[i].resume();
        }
        this.updateValue();
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].destroy();
        }
    }
}
MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
MappedSubject.NEVER_EQUALS = () => false;

/**
 * A Subject which provides a {@link NumberUnitInterface} value.
 */
class NumberUnitSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Returns a number {@link Subscribable} of this `NumberUnit` converted according to a unit or unit `Subscribable`
     *
     * @param unit the unit to subscribe to
     *
     * @returns a `MappedSubscribable<number>`
     */
    asUnit(unit) {
        return MappedSubject.create(([numberUnit, toUnit]) => numberUnit.asUnit(toUnit), this, SubscribableUtils.toSubscribable(unit, true));
    }
}

/**
 * 2D vector mathematical operations.
 */
class Vec2Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y) {
        const vec = new Float64Array(2);
        if (x !== undefined && y !== undefined) {
            vec[0] = x;
            vec[1] = y;
        }
        return vec;
    }
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Gets the determinant of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The determinant of the vectors.
     */
    static det(v1, v2) {
        return v1[0] * v2[1] - v1[1] * v2[0];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
    /**
     * Checks if a point is within a polygon.
     * @param polygon The polygon to check against.
     * @param point The point to test.
     * @returns True if the point is within or on the polygon, false otherwise.
     * @throws An error if first and last points in a polygon are not the same.
     */
    static pointWithinPolygon(polygon, point) {
        //Adapted from https://github.com/rowanwins/point-in-polygon-hao
        let k = 0;
        let f = 0;
        let u1 = 0;
        let v1 = 0;
        let u2 = 0;
        let v2 = 0;
        let currentP = null;
        let nextP = null;
        const x = point[0];
        const y = point[1];
        const contourLen = polygon.length - 1;
        currentP = polygon[0];
        if (currentP[0] !== polygon[contourLen][0] &&
            currentP[1] !== polygon[contourLen][1]) {
            throw new Error('First and last coordinates in a ring must be the same');
        }
        u1 = currentP[0] - x;
        v1 = currentP[1] - y;
        for (let i = 0; i < polygon.length - 1; i++) {
            nextP = polygon[i + 1];
            v2 = nextP[1] - y;
            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {
                currentP = nextP;
                v1 = v2;
                u1 = currentP[0] - x;
                continue;
            }
            u2 = nextP[0] - point[0];
            if (v2 > 0 && v1 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f > 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 > 0 && v2 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f < 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v2 === 0 && v1 < 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 < 0) {
                f = u1 * v2 - u2 * v1;
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 === 0) {
                if (u2 <= 0 && u1 >= 0) {
                    return undefined;
                }
                else if (u1 <= 0 && u2 >= 0) {
                    return undefined;
                }
            }
            currentP = nextP;
            v1 = v2;
            u1 = u2;
        }
        if (k % 2 === 0) {
            return false;
        }
        return true;
    }
}
/**
 * 3D vector mathematical operations.
 */
class Vec3Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y, z) {
        const vec = new Float64Array(3);
        if (x !== undefined && y !== undefined && z !== undefined) {
            vec[0] = x;
            vec[1] = y;
            vec[2] = z;
        }
        return vec;
    }
    /**
     * Gets the spherical angle theta (polar angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi (azimuthal angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x The new x-component.
     * @param y The new y-component.
     * @param z The new z-component.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r The new length (magnitude).
     * @param theta The new spherical angle theta (polar angle), in radians.
     * @param phi The new spherical angle phi (azimuthal angle), in radians.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = r * sinTheta * Math.cos(phi);
        vec[1] = r * sinTheta * Math.sin(phi);
        vec[2] = r * Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]) && isFinite(vec[2]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}
/**
 * N-dimensional vector mathematical operations.
 */
class VecNMath {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(length, ...components) {
        const vec = new Float64Array(length);
        for (let i = 0; i < length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec, ...components) {
        for (let i = 0; i < vec.length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec) {
        return Math.hypot(...vec);
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1, v2) {
        if (v1.length !== v2.length) {
            throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
        }
        let dot = 0;
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            dot += v1[i] * v2[i];
        }
        return dot;
    }
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            out[i] = v1[i] / mag;
        }
        return out;
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        if (vec1.length !== vec2.length) {
            return false;
        }
        for (let i = 0; i < vec1.length; i++) {
            if (vec1[i] !== vec2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        for (let i = 0; i < vec.length; i++) {
            if (!isFinite(vec[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from, to) {
        if (from.length !== to.length) {
            throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
        }
        to.set(from);
        return to;
    }
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0]) && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1]);
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a 3D vector to be observed.
 */
class Vec3Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
        let x, y, z;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
            z = arg3;
        }
        else {
            x = arg1[0];
            y = arg1[1];
            z = arg1[2];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(z, this.value[2]);
        if (!equals) {
            Vec3Math.set(x, y, z, this.value);
            this.notify();
        }
    }
}

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint ot which to write the result.
     * @returns The antipode of this point.
     * @throws Error if argument `out` is undefined.
     */
    antipode(out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.antipode(out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /** @inheritdoc */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The antipode of this point.
     */
    antipode(out) {
        return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    /** @inheritdoc */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        if (other) {
            if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
                return true;
            }
            const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
            const distance = this.distance(other);
            return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /** @inheritdoc */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static equals(arg1, arg2, arg3, arg4, arg5) {
        if (arg1 instanceof Float64Array) {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else if (typeof arg1 === 'number') {
            return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distance(arg1, arg2, arg3, arg4) {
        if (arg1 instanceof Float64Array) {
            return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
        }
        else {
            let lat1, lon1, lat2, lon2;
            if (typeof arg1 === 'number') {
                lat1 = arg1;
                lon1 = arg2;
                lat2 = arg3;
                lon2 = arg4;
            }
            else {
                lat1 = arg1.lat;
                lon1 = arg1.lon;
                lat2 = arg2.lat;
                lon2 = arg2.lon;
            }
            lat1 *= Avionics.Utils.DEG2RAD;
            lon1 *= Avionics.Utils.DEG2RAD;
            lat2 *= Avionics.Utils.DEG2RAD;
            lon2 *= Avionics.Utils.DEG2RAD;
            // haversine formula
            const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
            const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
            const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distanceRhumb(arg1, arg2, arg3, arg4) {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === 'number') {
            lat1 = arg1 * Avionics.Utils.DEG2RAD;
            lon1 = arg2 * Avionics.Utils.DEG2RAD;
            lat2 = arg3 * Avionics.Utils.DEG2RAD;
            lon2 = arg4 * Avionics.Utils.DEG2RAD;
        }
        else if (arg1 instanceof Float64Array) {
            const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
            lat1 = point1.lat;
            lon1 = point1.lon;
            const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
            lat2 = point2.lat;
            lon2 = point2.lon;
        }
        else {
            lat1 = arg1.lat;
            lon1 = arg1.lon;
            lat2 = arg2.lat;
            lon2 = arg2.lon;
        }
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1, lon1, lat2, lon2) {
        return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this._sinRadius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return this._sinRadius * angle;
    }
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length) {
        return length / this._sinRadius;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        this._sinRadius = Math.sin(this._radius);
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse() {
        Vec3Math.multScalar(this._center, -1, this._center);
        this._radius = Math.PI - this._radius;
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
        return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Inverts a heading value by adding 180 and normalizing.
     * @param heading The heading to invert/reciprocate.
     * @returns The inverted/reciprocated heading.
     * */
    static reciprocateHeading(heading) {
        return NavMath.normalizeHeading(heading + 180);
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius, in meters.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param radius The airplane turn radius, in meters.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="@microsoft/msfs-types/coherent/facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
/**
 * The class of airport facility.
 */
var AirportClass;
(function (AirportClass) {
    /** No other airport class could be identified. */
    AirportClass[AirportClass["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClass[AirportClass["HardSurface"] = 1] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClass[AirportClass["SoftSurface"] = 2] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClass[AirportClass["AllWater"] = 3] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClass[AirportClass["HeliportOnly"] = 4] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClass[AirportClass["Private"] = 5] = "Private";
})(AirportClass || (AirportClass = {}));
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
var AirportClassMask;
(function (AirportClassMask) {
    /** No other airport class could be identified. */
    AirportClassMask[AirportClassMask["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClassMask[AirportClassMask["HardSurface"] = 2] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClassMask[AirportClassMask["SoftSurface"] = 4] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClassMask[AirportClassMask["AllWater"] = 8] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClassMask[AirportClassMask["HeliportOnly"] = 16] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClassMask[AirportClassMask["Private"] = 32] = "Private";
})(AirportClassMask || (AirportClassMask = {}));
/**
 * An enumeration of possible intersection types.
 */
var IntersectionType;
(function (IntersectionType) {
    IntersectionType[IntersectionType["None"] = 0] = "None";
    IntersectionType[IntersectionType["Named"] = 1] = "Named";
    IntersectionType[IntersectionType["Unnamed"] = 2] = "Unnamed";
    IntersectionType[IntersectionType["Vor"] = 3] = "Vor";
    IntersectionType[IntersectionType["NDB"] = 4] = "NDB";
    IntersectionType[IntersectionType["Offroute"] = 5] = "Offroute";
    IntersectionType[IntersectionType["IAF"] = 6] = "IAF";
    IntersectionType[IntersectionType["FAF"] = 7] = "FAF";
    IntersectionType[IntersectionType["RNAV"] = 8] = "RNAV";
    IntersectionType[IntersectionType["VFR"] = 9] = "VFR";
})(IntersectionType || (IntersectionType = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a lateral and vertical discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
    /** A leg representing a lateral and vertical discontinuity in the flight plan that does not prevent sequencing. */
    LegType[LegType["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["All"] = 0] = "All";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
    FacilitySearchType[FacilitySearchType["Visual"] = 7] = "Visual";
    FacilitySearchType[FacilitySearchType["AllExceptVisual"] = 8] = "AllExceptVisual";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao) {
        return icao.substr(3, 4).trim();
    }
    /**
     * Checks whether an ICAO string defines a facility (optionally of a specific type).
     * @param icao An ICAO string.
     * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
     * the ICAO string defines any valid facility type.
     * @returns Whether the given ICAO string defines a facility of the specified type.
     */
    static isFacility(icao, type) {
        switch (icao[0]) {
            case 'A':
                return type === undefined || type === FacilityType.Airport;
            case 'W':
                return type === undefined || type === FacilityType.Intersection;
            case 'V':
                return type === undefined || type === FacilityType.VOR;
            case 'N':
                return type === undefined || type === FacilityType.NDB;
            case 'U':
                return type === undefined || type === FacilityType.USR;
            case 'R':
                return type === undefined || type === FacilityType.RWY;
            case 'S':
                return type === undefined || type === FacilityType.VIS;
            default:
                return false;
        }
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao) {
        return icao.substr(1, 2).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';
/**
 * Utility functions for working with facilities.
 */
class FacilityUtils {
    /**
     * Checks whether a facility is of a given type.
     * @param facility The facility to check.
     * @param type The facility type to check against.
     * @returns Whether the facility is of the specified type.
     */
    static isFacilityType(facility, type) {
        // Need to check for the intersection version of VOR/NDB facilities - these facilities have identical ICAOs
        // to their VOR/NDB counterparts, so we need to manually check the __Type property on the facility object.
        if (facility['__Type'] === 'JS_FacilityIntersection') {
            return type === FacilityType.Intersection;
        }
        return ICAO.isFacility(facility.icao, type);
    }
    /**
     * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
     * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
     * is returned.
     * @param facility A facility.
     * @returns The magnetic variation at the specified facility, in degrees.
     */
    static getMagVar(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            return -facility.magneticVariation; // VOR facility magvar is positive west instead of the standard positive east
        }
        else {
            return MagVar.get(facility.lat, facility.lon);
        }
    }
    /**
     * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees.
     * @param distance The distance, in nautical miles.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
     * facility.
     */
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
        return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    /**
     * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
     * @param reference1 The first reference facility.
     * @param radial1 The first magnetic radial, in degrees.
     * @param reference2 The second reference facility.
     * @param radial2 The second magnetic radial, in degrees.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
     * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
     */
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
        const magVar1 = FacilityUtils.getMagVar(reference1);
        const magVar2 = FacilityUtils.getMagVar(reference2);
        const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
        const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
        const radial1IncludesRef2 = radialCircle1.includes(reference2);
        const radial2IncludesRef1 = radialCircle2.includes(reference1);
        if (radial1IncludesRef2 && radial2IncludesRef1) {
            // Radials are parallel or antiparallel, and therefore do not have a unique intersection point.
            return out.set(NaN, NaN);
        }
        else if (radial1IncludesRef2) {
            // Reference 2 lies along the great circle of radial 1. The intersection point therefore is either reference 2
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
        }
        else if (radial2IncludesRef1) {
            // Reference 1 lies along the great circle of radial 2. The intersection point therefore is either reference 1
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
        }
        // Radials, unlike great circles, do not circumscribe the globe. Therefore, we choose the order of the intersection
        // operation carefully to ensure that the first solution (if it exists) is the "correct" intersection.
        const numIntersections = radialCircle1.encircles(reference2)
            ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache)
            : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
        if (numIntersections === 0) {
            return out.set(NaN, NaN);
        }
        return out.set(FacilityUtils.intersectionCache[0]);
    }
}
FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Utility functions for working with user facilities.
 */
class UserFacilityUtils {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
        const fac = {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat,
            lon,
            userFacilityType: UserFacilityType.LAT_LONG,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(lat, lon)
        };
        return fac;
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees, of the reference facility on which the new facility lies.
     * @param distance The distance, in nautical miles, from the reference facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_DISTANCE,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference.icao,
            reference1Radial: radial,
            reference1MagVar: FacilityUtils.getMagVar(reference),
            reference1Distance: distance
        };
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference1 The first reference facility.
     * @param radial1 The magnetic radial, in degrees, of the first reference facility on which the new facility lies.
     * @param reference2 The second reference facility.
     * @param radial2 The magnetic radial, in degrees, of the second reference facility on which the new facility lies.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility, or `undefined` if the specified radials do not intersect at a unique point.
     */
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
        if (isNaN(location.lat) || isNaN(location.lon)) {
            return undefined;
        }
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_RADIAL,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference1.icao,
            reference1Radial: radial1,
            reference1MagVar: FacilityUtils.getMagVar(reference1),
            reference2Icao: reference2.icao,
            reference2Radial: radial2,
            reference2MagVar: FacilityUtils.getMagVar(reference2)
        };
    }
}
UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];

var RunwaySurfaceCategory;
(function (RunwaySurfaceCategory) {
    RunwaySurfaceCategory[RunwaySurfaceCategory["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Water"] = 8] = "Water";
})(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator, lowerCase = false) {
        const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
        return lowerCase
            ? letter.toLowerCase()
            : letter;
    }
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            elevationEnd: 0,
            gradient: 0,
            latitude: 0,
            longitude: 0,
            length: 0,
            width: 0,
            startThresholdLength: 0,
            endThresholdLength: 0,
            surface: RunwaySurfaceType.Concrete,
            lighting: RunwayLightingType.Unknown
        };
    }
    /**
     * Utility method to return all of the one-way runways from a single airport facility
     * @param airport is the Airport Facility to evaluate
     * @returns all of the one-way runways in the airport facility, sorted.
     */
    static getOneWayRunwaysFromAirport(airport) {
        const runways = [];
        airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach(d => {
            runways.push(d[0]);
            runways.push(d[1]);
        });
        runways.sort(RunwayUtils.sortRunways);
        return runways;
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let endThresholdElevation = 0;
            let ilsFrequency;
            let startThresholdLength = 0, endThresholdLength = 0;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                endThresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
                startThresholdLength = runway.primaryThresholdLength;
                endThresholdLength = runway.secondaryThresholdLength;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                endThresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
                startThresholdLength = runway.secondaryThresholdLength;
                endThresholdLength = runway.primaryThresholdLength;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                elevationEnd: endThresholdElevation,
                gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency,
                length: runway.length,
                width: runway.width,
                startThresholdLength,
                endThresholdLength,
                surface: runway.surface,
                lighting: runway.lighting
            });
        }
        return splitRunways;
    }
    /**
     * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
     * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
     * then the name will be the designation of the primary runway only.
     * @param runway A paired runway.
     * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
     * @returns The name for the specified paired runway.
     */
    static getRunwayPairNameString(runway, padded = true) {
        const pad = padded ? 2 : 0;
        const dashIndex = runway.designation.search('-');
        const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad, '0')}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
        const secondary = dashIndex < 0 ? '' : `-${runway.designation.substring(dashIndex + 1).padStart(pad, '0')}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
        return primary + secondary;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    /**
     * Gets the primary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The primary runway number for the specified runway.
     */
    static getRunwayNumberPrimary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return parseInt(runway.designation);
        }
        else {
            return parseInt(runway.designation.substring(0, dashIndex));
        }
    }
    /**
     * Gets the secondary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
     * runway.
     */
    static getRunwayNumberSecondary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return undefined;
        }
        else {
            return parseInt(runway.designation.substring(dashIndex + 1));
        }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg1, arg2) {
        let runway;
        if (typeof arg1 === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else if (typeof arg1 === 'number') {
            const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else {
            runway = arg1;
        }
        const runwayDesignation = runway.designation;
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            // Note: drop the leading zero in the runway designation for the search because some third-party sceneries
            // format the frequency names without the leading zero.
            const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ''));
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
        const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
        if (!matchedRunway) {
            return undefined;
        }
        return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
        let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        switch (runwayDesignator) {
            case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
                break;
            case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
                break;
            default:
                oppositeRunwayDesignator = runwayDesignator;
                break;
        }
        return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport, or the ICAO of the airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        const icao = typeof airport === 'string' ? airport : airport.icao;
        return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    /**
     * Gets the runway surface category from a runway or runway surface type.
     * @param runway A runway or runway surface type.
     * @returns The surface category of the specified runway or runway surface type.
     */
    static getSurfaceCategory(runway) {
        const surface = typeof runway === 'object' ? runway.surface : runway;
        if (this.SURFACES_HARD.includes(surface)) {
            return RunwaySurfaceCategory.Hard;
        }
        else if (this.SURFACES_SOFT.includes(surface)) {
            return RunwaySurfaceCategory.Soft;
        }
        else if (this.SURFACES_WATER.includes(surface)) {
            return RunwaySurfaceCategory.Water;
        }
        else {
            return RunwaySurfaceCategory.Unknown;
        }
    }
}
RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: '',
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 'L',
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 'R',
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 'C',
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 'W',
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 'A',
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 'B',
};
RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban,
];
RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
];
RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
];
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A utility class for working with approach procedures.
 */
class ApproachUtils {
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType(query) {
        const rnavTypeFlags = typeof query === 'number' ? query : query.rnavTypeFlags;
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param approach The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isRnpAr(approach) {
        return approach.approachType === ApproachType.APPROACH_TYPE_RNAV
            && approach.rnavTypeFlags === RnavTypeFlags.None
            && approach.runwayNumber !== 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getFrequencyFromAirport(facility, approach) {
        if (typeof approach === 'number') {
            approach = facility.approaches[approach];
        }
        if (approach) {
            switch (approach.approachType) {
                case ApproachType.APPROACH_TYPE_ILS:
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LDA:
                case ApproachType.APPROACH_TYPE_SDF:
                    return RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                    return RunwayUtils.getBcFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
            }
        }
        return undefined;
    }
    /**
* Gets the origin facility ICAO for the FAF leg of an approach.
     * The facility type is **not** checked against the approach type to ensure it is valid,
     * in contrast to {@link getReferenceFacility} which does perform these checks.
     * @param approach The approach for which to get a reference facility.
     * @returns The ICAO of the origin facility for the FAF leg of the specified approach,
     * or `undefined` if one could not be found.
     */
    static getFafOriginIcao(approach) {
        const finalLegs = approach.finalLegs;
        // Find the faf
        let fafLeg = undefined;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = finalLegs[i];
            if (BitFlags.isAll(leg.fixTypeFlags, FixTypeFlags.FAF)) {
                fafLeg = leg;
                break;
            }
        }
        if (!fafLeg || fafLeg.originIcao === ICAO.emptyIcao) {
            return undefined;
        }
        return fafLeg.originIcao;
    }
    /**
     * Gets the reference facility for an approach. Only ILS, LOC (BC), LDA, SDF, VOR(DME), and NDB(DME) approaches can
     * have reference facilities.
     * @param approach The approach for which to get a reference facility.
     * @param facLoader The facility loader.
     * @returns A Promise which is fulfilled with the reference facility for the specified approach, or `undefined` if
     * one could not be found.
     */
    static async getReferenceFacility(approach, facLoader) {
        let facilityType;
        let isLoc = false;
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
                isLoc = true;
            // eslint-disable-next-line no-fallthrough
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                facilityType = FacilityType.VOR;
                break;
            case ApproachType.APPROACH_TYPE_NDB:
            case ApproachType.APPROACH_TYPE_NDBDME:
                facilityType = FacilityType.NDB;
                break;
            default:
                return undefined;
        }
        const originIcao = ApproachUtils.getFafOriginIcao(approach);
        if (!originIcao || !ICAO.isFacility(originIcao, facilityType)) {
            return undefined;
        }
        try {
            const facility = await facLoader.getFacility(facilityType, originIcao);
            if (isLoc && facility.type !== VorType.ILS) {
                return undefined;
            }
            else {
                return facility;
            }
        }
        catch (_a) {
            return undefined;
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/// <reference types="@microsoft/msfs-types/js/simplane" />
const airportIcaoRegionPattern = new RegExp(/^A../);
/**
 * A type map of facility type to facility search type.
 */
({
    /** Airport facility type. */
    [FacilityType.Airport]: FacilitySearchType.Airport,
    /** Intersection facility type. */
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    /** NDB facility type. */
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    /** VOR facility type. */
    [FacilityType.VOR]: FacilitySearchType.Vor,
    /** USR facility type. */
    [FacilityType.USR]: FacilitySearchType.User,
    /** Visual facility type. */
    [FacilityType.VIS]: FacilitySearchType.Visual
});
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => FacilityLoader.init(), 2000);
            }, true);
        }
        this.awaitInitialization().then(() => this.onInitialized());
    }
    /**
     * Initializes this facility loader.
     */
    static init() {
        FacilityLoader.isInitialized = true;
        for (const resolve of this.initPromiseResolveQueue) {
            resolve();
        }
        this.initPromiseResolveQueue.length = 0;
    }
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    awaitInitialization() {
        if (FacilityLoader.isInitialized) {
            return Promise.resolve();
        }
        else {
            return new Promise(resolve => {
                FacilityLoader.initPromiseResolveQueue.push(resolve);
            });
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        // Remove the region code from the icao
        if (type === FacilityType.Airport) {
            icao = icao.replace(airportIcaoRegionPattern, 'A  ');
        }
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const cachedFac = cache.get(icao);
        if (cachedFac !== undefined) {
            return Promise.resolve(cachedFac);
        }
        const currentTime = Date.now();
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            if (request !== undefined) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                Coherent.call(type, icao).then((isValid) => {
                    if (!isValid) {
                        rejection(`Facility ${icao} could not be found.`);
                        queue.delete(icao);
                    }
                });
            });
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            queue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startNearestSearchSession(type) {
        switch (type) {
            case FacilitySearchType.User:
            case FacilitySearchType.Visual:
                return this.startRepoNearestSearchSession(type);
            case FacilitySearchType.AllExceptVisual:
                return this.startCoherentNearestSearchSession(FacilitySearchType.All);
            default:
                return this.startCoherentNearestSearchSession(type);
        }
    }
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startCoherentNearestSearchSession(type) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestVorSearchSession(sessionId);
                break;
            case FacilitySearchType.Boundary:
                session = new NearestBoundarySearchSession(sessionId);
                break;
            default:
                session = new CoherentNearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    startRepoNearestSearchSession(type) {
        // Session ID doesn't really matter for these, so in order to not conflict with IDs from Coherent, we will set
        // them all to negative numbers
        const sessionId = FacilityLoader.repoSearchSessionId--;
        switch (type) {
            case FacilitySearchType.User:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            case FacilitySearchType.Visual:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            default:
                throw new Error();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        raw.maxWindDir < 0 && delete raw.maxWindDir;
        raw.minWindDir < 0 && delete raw.minWindDir;
        raw.windDir < 0 && delete raw.windDir;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        let results;
        if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
            const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
            results = await Coherent.call('SEARCH_BY_IDENT', ident, coherentFilter, maxItems);
        }
        else {
            results = [];
        }
        const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
        if (facRepositorySearchTypes) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, facRepositorySearchTypes);
        }
        return results;
    }
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
        const results = await this.searchByIdent(filter, ident, maxItems);
        if (!results) {
            return [];
        }
        const promises = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i];
            const facIdent = ICAO.getIdent(icao);
            if (facIdent === ident) {
                const facType = ICAO.getFacilityType(icao);
                promises.push(this.getFacility(facType, icao));
            }
        }
        const foundFacilities = await Promise.all(promises);
        if (foundFacilities.length > 1) {
            foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
            return foundFacilities;
        }
        else if (foundFacilities.length === 1) {
            return foundFacilities;
        }
        else {
            return [];
        }
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const isMismatch = facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W';
        const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
        const request = queue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, isMismatch);
            queue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session instanceof CoherentNearestSearchSession) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
/**
     * Gets the AIRAC cycles associated with the facility database.
     * @returns an object containing the previous, current, and next cycles.
     * If an error occurs and the MSFS facility cycle cannot be determined, the effective cycle for the current date is used instead.
     */
    static getDatabaseCycles() {
        if (FacilityLoader.databaseCycleCache === undefined) {
            const facilitiesRange = SimVar.GetGameVarValue('FLIGHT NAVDATA DATE RANGE', SimVarValueType.String);
            let current = AiracUtils.parseFacilitiesCycle(facilitiesRange);
            if (current === undefined) {
                console.error('FacilityLoader: Could not get facility database AIRAC cycle! Falling back to current cycle.');
                // fall back to current cycle!
                current = AiracUtils.getCurrentCycle(new Date());
            }
            const previous = AiracUtils.getOffsetCycle(current, -1);
            const next = AiracUtils.getOffsetCycle(current, 1);
            FacilityLoader.databaseCycleCache = {
                previous,
                current,
                next,
            };
        }
        return FacilityLoader.databaseCycleCache;
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
};
FacilityLoader.repoSearchSessionId = -1;
FacilityLoader.isInitialized = false;
FacilityLoader.initPromiseResolveQueue = [];
/**
 * A session for searching for nearest facilities through Coherent.
 */
class CoherentNearestSearchSession {
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
        Coherent.call('SET_NEAREST_EXTENDED_AIRPORT_FILTERS', this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
}
/**
 * Default filters for the nearest airports search session.
 */
NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
};
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     * @param showTerminalWaypoints Whether or not to show terminal waypoints. Defaults to true.
     */
    setIntersectionFilter(typeMask, showTerminalWaypoints = true) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask, showTerminalWaypoints ? 1 : 0);
    }
}
/**
 * Default filters for the nearest intersections search session.
 */
NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
};
/**
 * A session for searching for nearest VORs.
 */
class NearestVorSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
        Coherent.call('SET_NEAREST_VOR_FILTER', this.sessionId, classMask, typeMask);
    }
}
/**
 * Default filters for the nearest VORs search session.
 */
NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
};
/**
 * A session for searching for nearest airspace boundaries.
 */
class NearestBoundarySearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask) {
        Coherent.call('SET_NEAREST_BOUNDARY_FILTER', this.sessionId, classMask);
    }
}
/**
 * A session for searching for nearest facilities that uses the facility repository.
 */
class NearestRepoFacilitySearchSession {
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo, sessionId) {
        this.repo = repo;
        this.sessionId = sessionId;
        this.filter = undefined;
        this.cachedResults = new Set();
        this.searchId = 0;
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
        const added = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i].icao;
            if (this.cachedResults.has(icao)) {
                this.cachedResults.delete(icao);
            }
            else {
                added.push(icao);
            }
        }
        const removed = Array.from(this.cachedResults);
        this.cachedResults.clear();
        for (let i = 0; i < results.length; i++) {
            this.cachedResults.add(results[i].icao);
        }
        return Promise.resolve({
            sessionId: this.sessionId,
            searchId: this.searchId++,
            added,
            removed
        });
    }
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter) {
        this.filter = filter;
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

/**
 * Utility functions for working with arrays.
 */
class ArrayUtils {
    /**
     * Creates a new array with initialized values.
     * @param length The length of the new array.
     * @param init A function which generates initial values for the new array at each index.
     * @returns A new array of the specified length with initialized values.
     */
    static create(length, init) {
        const newArray = [];
        for (let i = 0; i < length; i++) {
            newArray[i] = init(i);
        }
        return newArray;
    }
    /**
     * Creates a new array containing a sequence of evenly-spaced numbers.
     * @param length The length of the new array.
     * @param start The number contained at index 0 of the new array. Defaults to `0`.
     * @param increment The increment between each successive number in the new array. Defaults to `1`.
     * @returns A new array containing the specified sequence of evenly-spaced numbers.
     */
    static range(length, start = 0, increment = 1) {
        return ArrayUtils.fillRange([], length, 0, start, increment);
    }
    /**
     * Fills an existing array with a sequence of evenly-spaced numbers. The sequence is written to the array in a single
     * contiguous block of consecutive indexes.
     * @param array The array to fill.
     * @param length The length of the number sequence.
     * @param startIndex The index at which to start filling the array. Defaults to `0`.
     * @param start The first number in the sequence. Defaults to {@linkcode startIndex}.
     * @param increment The increment between each successive number in the new array. Defaults to `1`.
     * @returns The array, after it has been filled with the specified number sequence.
     */
    static fillRange(array, length, startIndex = 0, start = startIndex, increment = 1) {
        const endIndex = startIndex + length;
        for (let i = startIndex; i < endIndex; i++) {
            array[i] = start + i * increment;
        }
        return array;
    }
    /**
     * Gets the element at a specific index in an array.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array.
     * @throws RangeError if the index is out of bounds.
     */
    static at(array, index) {
        if (index < 0) {
            index += array.length;
        }
        if (index < 0 || index >= array.length) {
            throw new RangeError();
        }
        return array[index];
    }
    /**
     * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
     */
    static peekAt(array, index) {
        if (index < 0) {
            index += array.length;
        }
        return array[index];
    }
    /**
     * Gets the first element of an array.
     * @param array An array.
     * @returns The first element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static first(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[0];
    }
    /**
     * Gets the first element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The first element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekFirst(array) {
        return array[0];
    }
    /**
     * Gets the last element of an array.
     * @param array An array.
     * @returns The last element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static last(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[array.length - 1];
    }
    /**
     * Gets the last element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The last element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekLast(array) {
        return array[array.length - 1];
    }
    /**
     * Checks if a certain element is included in an array.
     * @param array An array.
     * @param searchElement The element to search for.
     * @param fromIndex The position in this array at which to begin searching for `searchElement`.
     * @returns Whether the search element is included in the specified array.
     */
    static includes(array, searchElement, fromIndex) {
        return array.includes(searchElement, fromIndex);
    }
    /**
     * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
     * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
     * @param a The first array.
     * @param b The second array.
     * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
     * to a function which uses the strict equality operator (`===`).
     * @returns Whether the two specified arrays are equal.
     */
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!equalsFunc(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
     * mapped elements to a maximum depth of one, leaving the original array intact.
     * @param array An array.
     * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
     * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
     * elements to a maximum depth of one.
     */
    static flatMap(array, map) {
        const out = [];
        for (let i = 0; i < array.length; i++) {
            const mapped = map(array[i], i, array);
            if (Array.isArray(mapped)) {
                for (let j = 0; j < mapped.length; j++) {
                    out[out.length] = mapped[j];
                }
            }
            else {
                out[out.length] = mapped;
            }
        }
        return out;
    }
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat(array, depth = 1) {
        const out = [];
        this.flatHelper(array, depth, 0, out);
        return out;
    }
    /**
     * Recursively flattens an array and writes the flattened sequence of elements into another array.
     * @param array The array to flatten.
     * @param maxDepth The maximum depth to which to flatten.
     * @param depth The current flattening depth.
     * @param out The array to which to write the flattened sequence of elements.
     */
    static flatHelper(array, maxDepth, depth, out) {
        for (let i = 0; i < array.length; i++) {
            const element = array[i];
            if (Array.isArray(element) && depth < maxDepth) {
                this.flatHelper(element, maxDepth, depth + 1, out);
            }
            else {
                out[out.length] = element;
            }
        }
    }
    /**
     * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
     * length and the same elements in the same order as the source array.
     * @param source The array to copy.
     * @param target The array to copy into. If not defined, a new array will be created.
     * @returns The target array, after the source array has been copied into it.
     */
    static shallowCopy(source, target = []) {
        target.length = source.length;
        for (let i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        return target;
    }
    /**
     * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
     * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
     * where `index` is the index at which the query element would be found if it were contained in the sorted array.
     * @param array An array.
     * @param element The element to search for.
     * @param comparator A function which determines the sorting order of elements in the array. The function should
     * return a negative number if the first element is to be sorted before the second, a positive number if the first
     * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
     * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
     * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
     * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
     * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
     * the query element would be found if it were contained in the sorted array, if no element in the array has a
     * sorting order equal to the query.
     */
    static binarySearch(array, element, comparator, first = true) {
        let min = 0;
        let max = array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = comparator(element, array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array) {
        return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
}
ArrayUtils.STRICT_EQUALS = (a, b) => a === b;

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
class BinaryHeap {
// eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
        return this.tree.length;
    }
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
        this.comparator = comparator;
        this.tree = [];
    }
        /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
        return this.tree[0];
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
        if (this.tree.length === 0) {
            return undefined;
        }
        const min = this.tree[0];
        this.swap(0, this.tree.length - 1);
        this.tree.length--;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
        this.tree.push(element);
        this.heapifyUp(this.tree.length - 1);
        return this;
    }
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element) {
        if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
            return element;
        }
        return this.removeMinAndInsert(element);
    }
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element) {
        const min = this.tree[0];
        this.tree[0] = element;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
        this.tree.length = 0;
        return this;
    }
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyUp(index) {
        let parent = BinaryHeap.parent(index);
        while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
            this.swap(parent, index);
            index = parent;
            parent = BinaryHeap.parent(index);
        }
    }
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyDown(index) {
        const len = this.tree.length;
        while (index < len) {
            const left = BinaryHeap.left(index);
            const right = BinaryHeap.right(index);
            let needSwapFlags = 0;
            if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
                needSwapFlags |= 1;
            }
            if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
                needSwapFlags |= 2;
            }
            if (needSwapFlags === 3) {
                needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
            }
            if (needSwapFlags === 0) {
                break;
            }
            const swapChild = needSwapFlags === 1 ? left : right;
            this.swap(index, swapChild);
            index = swapChild;
        }
    }
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    swap(index1, index2) {
        const old1 = this.tree[index1];
        this.tree[index1] = this.tree[index2];
        this.tree[index2] = old1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    static left(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    static right(index) {
        return index * 2 + 2;
    }
}

/**
 * A sorted array.
 */
class SortedArray {
// eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
        /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index.
     * @param index An index.
     * @returns The element at the specified index.
     * @throws RangeError if index is out of bounds.
     */
    get(index) {
        if (index < 0 || index >= this._array.length) {
            throw new RangeError();
        }
        return this._array[index];
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    peek(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array.
     * @returns The first element in this array.
     * @throws RangeError if this array is empty.
     */
    first() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[0];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    peekFirst() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array.
     * @returns The last element in this array.
     * @throws RangeError if this array is empty.
     */
    last() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[this._array.length - 1];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    peekLast() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Removes an element at a specific index from this array and returns it.
     * @param index The index of the element to remove.
     * @returns The removed element, or `undefined` if no element was removed.
     */
    removeAt(index) {
        if (index < 0 || index >= this._array.length) {
            return undefined;
        }
        return this._array.splice(index, 1)[0];
    }
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop() {
        return this._array.pop();
    }
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift() {
        return this._array.shift();
    }
    /**
     * Re-sorts this array using its sorting function.
     */
    resort() {
        this._array.sort(this.comparatorFunc);
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A linearly interpolated N-dimensional lookup table.
 */
class LerpLookupTable {
// eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
        return this._dimensionCount;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg) {
        this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
        if (typeof arg === 'number') {
            this._dimensionCount = isFinite(arg) ? Math.max(0, arg) : 0;
            return;
        }
        const leastDimension = arg.reduce((accum, current) => (current.length < accum.length) ? current : accum);
        this._dimensionCount = Math.max(0, leastDimension ? (leastDimension.length - 1) : 0);
        if (this._dimensionCount === 0) {
            return;
        }
        for (let i = 0; i < arg.length; i++) {
            this.insertBreakpoint(arg[i]);
        }
    }
        /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table');
        }
        if (breakpoint.length - 1 < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
        }
        this.insertBreakpointHelper(breakpoint, 0, this.table);
        return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
        const dimensionKey = breakpoint[dimension + 1];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        if (dimension === this._dimensionCount - 1) {
            let match = array.match(query);
            if (!match) {
                match = { key: dimensionKey, value: breakpoint[0] };
                array.insert(match);
            }
        }
        else {
            let next = array.match(query);
            if (!next) {
                array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
        }
    }
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot look up a key in a 0-dimensional table');
        }
        if (key.length < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
        }
        const value = this.lookupHelper(key, 0, this.table);
        if (value === undefined) {
            throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
        }
        return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray) {
        const dimensionKey = key[dimension];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        const index = lookupArray.matchIndex(query);
        let start;
        let end;
        if (index >= 0) {
            start = lookupArray.peek(index);
            end = start;
        }
        else {
            start = lookupArray.peek(-index - 2);
            end = lookupArray.peek(-index - 1);
            if (!start) {
                start = end;
            }
            if (!end) {
                end = start;
            }
        }
        if (!start || !end) {
            return undefined;
        }
        let startValue;
        let endValue;
        if (dimension === this.dimensionCount - 1) {
            startValue = start.value;
            endValue = end.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            startValue = this.lookupHelper(key, dimension + 1, start.array);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            endValue = this.lookupHelper(key, dimension + 1, end.array);
        }
        if (startValue === undefined || endValue === undefined) {
            return undefined;
        }
        if (startValue === endValue) {
            return startValue;
        }
        return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
}
LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
LerpLookupTable.tempBreakpoint = { key: 0 };

/**
 * A linearly interpolated N-dimensional lookup table of vectors.
 */
class LerpVectorLookupTable {
// eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
        return this._dimensionCount;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of the vectors in this table. */
    get vectorLength() {
        return this._vectorLength;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg1, arg2) {
        var _a, _b;
        this.table = new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR);
        if (typeof arg1 === 'number') {
            this._dimensionCount = isFinite(arg1) ? Math.max(0, arg1) : 0;
            this._vectorLength = isFinite(arg2) ? Math.max(0, arg2) : 0;
        }
        else {
            let leastBreakpointDimension = Infinity;
            let leastVectorLength = Infinity;
            for (let i = 0; i < arg1.length; i++) {
                leastBreakpointDimension = Math.min(leastBreakpointDimension, Math.max(arg1[i].length - 1, 0));
                leastVectorLength = Math.min(leastVectorLength, (_b = (_a = arg1[i][0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
            }
            this._dimensionCount = isFinite(leastBreakpointDimension) ? leastBreakpointDimension : 0;
            this._vectorLength = isFinite(leastVectorLength) ? leastVectorLength : 0;
            if (this._dimensionCount > 0) {
                for (let i = 0; i < arg1.length; i++) {
                    this.insertBreakpoint(arg1[i]);
                }
            }
        }
        // Create temporary working vectors: we need 2 per dimension.
        this.tempVectors = ArrayUtils.create(this._dimensionCount * 2, () => new Float64Array(this._vectorLength));
    }
        /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, the breakpoint has fewer dimensions than this table, or the
     * the length of the breakpoint vector is less than this table's vector length property.
     */
    insertBreakpoint(breakpoint) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpVectorLookupTable: cannot insert a breakpoint into a 0-dimensional table');
        }
        if (breakpoint.length - 1 < this._dimensionCount) {
            throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
        }
        if (breakpoint[0].length < this._vectorLength) {
            throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint[0].length}-length vector into a table with vectors of length ${this._vectorLength}`);
        }
        this.insertBreakpointHelper(breakpoint, 0, this.table);
        return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
        const dimensionKey = breakpoint[dimension + 1];
        const query = LerpVectorLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        if (dimension === this._dimensionCount - 1) {
            let match = array.match(query);
            if (!match) {
                match = { key: dimensionKey, value: breakpoint[0] };
                array.insert(match);
            }
        }
        else {
            let next = array.match(query);
            if (!next) {
                array.insert(next = { key: dimensionKey, array: new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR) });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
        }
    }
    /**
     * Looks up a vector in this table using a specified key. The returned vector will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param out The vector to which to write the result.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The vector corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a vector could
     * not be retrieved.
     */
    get(out, ...key) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpVectorLookupTable: cannot look up a key in a 0-dimensional table');
        }
        if (key.length < this._dimensionCount) {
            throw new Error(`LerpVectorLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
        }
        const value = this.lookupHelper(key, 0, this.table, out);
        if (value === undefined) {
            throw new Error(`LerpVectorLookupTable: could not retrieve value for key ${key}`);
        }
        return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @param out The vector to which to write the result.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray, out) {
        const dimensionKey = key[dimension];
        const query = LerpVectorLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        const index = lookupArray.matchIndex(query);
        let start;
        let end;
        if (index >= 0) {
            start = lookupArray.peek(index);
            end = start;
        }
        else {
            start = lookupArray.peek(-index - 2);
            end = lookupArray.peek(-index - 1);
            if (!start) {
                start = end;
            }
            if (!end) {
                end = start;
            }
        }
        if (!start || !end) {
            return undefined;
        }
        let startValue;
        let endValue;
        if (dimension === this.dimensionCount - 1) {
            startValue = start.value;
            endValue = end.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            startValue = this.lookupHelper(key, dimension + 1, start.array, this.tempVectors[dimension * 2]);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            endValue = this.lookupHelper(key, dimension + 1, end.array, this.tempVectors[dimension * 2 + 1]);
        }
        if (startValue === undefined || endValue === undefined) {
            return undefined;
        }
        return MathUtils.lerpVector(out, dimensionKey, start.key, end.key, startValue, endValue);
    }
}
LerpVectorLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
LerpVectorLookupTable.tempBreakpoint = { key: 0 };

/**
 * A k-dimensional search tree.
 */
class KdTree {
// eslint-disable-next-line jsdoc/require-returns
    /** The number of elements in this tree. */
    get size() {
        return this.elements.length;
    }
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount, keyFunc) {
        this.keyFunc = keyFunc;
        this.elements = [];
        this.keys = [];
        this.nodes = [];
        this.minDepth = -1;
        this.maxDepth = -1;
        this.dimensionCount = Math.trunc(dimensionCount);
        if (this.dimensionCount < 2) {
            throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
        }
        this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
        this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
            return (a, b) => {
                const aKey = this.keys[a];
                const bKey = this.keys[b];
                for (let i = 0; i < this.dimensionCount; i++) {
                    const dimension = (i + index) % this.dimensionCount;
                    if (aKey[dimension] < bKey[dimension]) {
                        return -1;
                    }
                    else if (aKey[dimension] > bKey[dimension]) {
                        return 1;
                    }
                }
                return 0;
            };
        });
        this.keyCache = [
            new Float64Array(this.dimensionCount)
        ];
    }
        // eslint-disable-next-line jsdoc/require-jsdoc
    searchKey(key, radius, arg3, out, filter) {
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(undefined, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(undefined, key, radius, arg3);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(element, radius, arg3, out, filter) {
        const key = this.keyFunc(element, this.keyCache[0]);
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(element, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(element, key, radius, arg3);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(element, key, radius, visitor) {
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            return visitor(elementInner, keyInner, distance, queryKey, queryElement);
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            return searchRadius + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
        if (maxResultCount <= 0) {
            out.length = 0;
            return out;
        }
        const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
                if (heap.size === maxResultCount) {
                    heap.insertAndRemoveMin(elementIndex);
                }
                else {
                    heap.insert(elementIndex);
                }
            }
            return true;
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            let maxDist = searchRadius;
            if (heap.size === maxResultCount) {
                maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
            }
            return maxDist + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
        out.length = heap.size;
        for (let i = out.length - 1; i >= 0; i--) {
            out[i] = this.elements[heap.removeMin()];
        }
        return out;
    }
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
        const elementIndex = this.nodes[nodeIndex];
        if (elementIndex === undefined) {
            return true;
        }
        const nodeKey = this.keys[elementIndex];
        const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
        if (distanceFromNode <= radius) {
            if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
                return false;
            }
        }
        const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        const lesserNodeIndex = KdTree.lesser(nodeIndex);
        const greaterNodeIndex = KdTree.greater(nodeIndex);
        if (this.nodes[lesserNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, -1)) {
            if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        if (this.nodes[greaterNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, 1)) {
            if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        const insertDepth = this.insertElementInTree(element) + 1;
        this.maxDepth = Math.max(this.maxDepth, insertDepth);
        if (insertDepth === this.minDepth + 1) {
            this.minDepth = KdTree.depth(this.nodes.indexOf(undefined, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
        }
        // Rebalance the tree if max depth is greater than twice the min depth.
        if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
            this.rebuild();
        }
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        for (const element of elements) {
            this.elements.push(element);
            this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
            const insertedIndex = this.elements.length - 1;
            for (let i = 0; i < this.dimensionCount; i++) {
                this.indexArrays[i].push(insertedIndex);
            }
        }
        this.rebuild();
    }
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    insertElementInTree(element) {
        const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
        let index = 0;
        let depth = 0;
        let elementIndex;
        while ((elementIndex = this.nodes[index]) !== undefined) {
            const pivotDimension = depth % this.dimensionCount;
            const keyToCompare = key[pivotDimension];
            if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
                index = KdTree.lesser(index);
            }
            else {
                index = KdTree.greater(index);
            }
            depth++;
        }
        this.elements.push(element);
        this.keys.push(key);
        const insertedIndex = this.elements.length - 1;
        this.nodes[index] = insertedIndex;
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].push(insertedIndex);
        }
        return depth;
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        if (!this.removeElementFromArrays(element)) {
            return false;
        }
        this.resetIndexArrays();
        this.rebuild();
        return true;
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        let removed = false;
        for (const element of elements) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
            this.rebuild();
        }
        return removed;
    }
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    removeElementFromArrays(element) {
        const index = this.elements.indexOf(element);
        if (index < 0) {
            return false;
        }
        const lastIndex = this.elements.length - 1;
        this.elements[index] = this.elements[lastIndex];
        this.keys[index] = this.keys[lastIndex];
        this.elements.length--;
        this.keys.length--;
        return true;
    }
    /**
     * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
     * number of elements in the tree.
     */
    resetIndexArrays() {
        for (let i = 0; i < this.dimensionCount; i++) {
            const array = this.indexArrays[i];
            array.length = this.elements.length;
            for (let j = 0; j < array.length; j++) {
                array[j] = j;
            }
        }
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        let removed = false;
        for (const element of toRemove) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
        }
        this.insertAll(toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        // clear the tree structure
        this.nodes.length = 0;
        if (this.size === 0) {
            return;
        }
        // sort index arrays
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].sort(this.indexSortFuncs[i]);
        }
        this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
        const log = Math.log2(this.elements.length + 1);
        this.minDepth = Math.floor(log) - 1;
        this.maxDepth = Math.ceil(log) - 1;
    }
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    buildSubTree(nodeIndex, pivotDimension, start, end) {
        const tempArray = this.indexArrays[this.dimensionCount];
        const sortedArray = this.indexArrays[0];
        const medianIndex = Math.trunc((start + end) / 2);
        const medianKeyIndex = sortedArray[medianIndex];
        // Insert median into its position in the tree
        this.nodes[nodeIndex] = medianKeyIndex;
        if (end - start === 1) {
            return;
        }
        if (end - start <= 3) {
            const lesserIndex = medianIndex - 1;
            const greaterIndex = medianIndex + 1;
            if (lesserIndex >= start) {
                this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
            }
            if (greaterIndex < end) {
                this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
            }
            return;
        }
        for (let i = start; i < end; i++) {
            tempArray[i] = sortedArray[i];
        }
        // Partition the index arrays not in the pivot dimension around the median key in the pivot dimension and at the
        // same time rotate the index arrays such that the index array sorted in the next pivot dimension is located at
        // index 0.
        for (let i = 1; i < this.dimensionCount; i++) {
            const targetArray = this.indexArrays[i - 1];
            const toPartitionArray = this.indexArrays[i];
            let lesserCount = 0;
            let greaterCount = 0;
            for (let j = start; j < end; j++) {
                const keyIndex = toPartitionArray[j];
                if (keyIndex === medianKeyIndex) {
                    targetArray[medianIndex] = keyIndex;
                }
                else {
                    const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
                    if (comparison <= 0) {
                        const index = start + (lesserCount++);
                        targetArray[index] = keyIndex;
                    }
                    else {
                        const index = medianIndex + 1 + (greaterCount++);
                        targetArray[index] = keyIndex;
                    }
                }
            }
        }
        // Copy the temporary array (now containing the sorted indexes in the pivot dimension) to the last index array.
        const newSortedArray = this.indexArrays[this.dimensionCount - 1];
        for (let i = start; i < end; i++) {
            newSortedArray[i] = tempArray[i];
        }
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
        this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.elements.length = 0;
        this.keys.length = 0;
        this.nodes.length = 0;
        for (let i = 0; i < this.indexArrays.length; i++) {
            this.indexArrays[i].length = 0;
        }
        this.minDepth = -1;
        this.maxDepth = -1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    static lesser(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    static greater(index) {
        return index * 2 + 2;
    }
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    static leastIndexAtDepth(depth) {
        return 1 << depth - 1;
    }
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    static depth(index) {
        return Math.trunc(Math.log2(index + 1));
    }
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    static distance(key1, key2, dimensionCount) {
        let sumSq = 0;
        for (let i = 0; i < dimensionCount; i++) {
            const diff = key1[i] - key2[i];
            sumSq += diff * diff;
        }
        return Math.sqrt(sumSq);
    }
}

/**
 * A Subject which provides a {@link GeoPointInterface} value.
 */
class GeoPointSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     */
    constructor(value, tolerance) {
        super();
        this.value = value;
        this.tolerance = tolerance;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     * @returns A GeoPointSubject.
     */
    static create(initialVal, tolerance) {
        return new GeoPointSubject(initialVal, tolerance);
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
}

/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
class GeoKdTree {
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc) {
        this.keyFunc = keyFunc;
        this.cartesianTree = new KdTree(3, (element, out) => {
            const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
            out[0] = vec[0];
            out[1] = vec[1];
            out[2] = vec[2];
            return out;
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
        let center, radius;
        let argA, argB, argC;
        if (typeof arg1 === 'number') {
            center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
            radius = arg3;
            argA = arg4;
            argB = arg5;
            argC = arg6;
        }
        else if (!(arg1 instanceof Float64Array)) {
            center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        else {
            center = arg1;
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
        if (typeof argA === 'number') {
            return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
        }
        else {
            this.doVisitorSearch(center, radiusCartesian, argA);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(center, radiusCartesian, visitor) {
        this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
            const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
            const greatCircleDist = GeoPoint.distance(vec, center);
            return visitor(element, vec, greatCircleDist, center);
        });
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
        const cartesianFilter = filter
            ? (element, key) => {
                const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
                const greatCircleDist = GeoPoint.distance(vec, center);
                return filter(element, vec, greatCircleDist, center);
            }
            : undefined;
        return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        this.cartesianTree.insert(element);
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        this.cartesianTree.insertAll(elements);
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        return this.cartesianTree.remove(element);
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        return this.cartesianTree.removeAll(elements);
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        this.cartesianTree.rebuild();
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.cartesianTree.clear();
    }
}
GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];

/**
 * Types of subscribable array change event.
 */
var SubscribableArrayEventType;
(function (SubscribableArrayEventType) {
    /** An element was added. */
    SubscribableArrayEventType["Added"] = "Added";
    /** An element was removed. */
    SubscribableArrayEventType["Removed"] = "Removed";
    /** The array was cleared. */
    SubscribableArrayEventType["Cleared"] = "Cleared";
})(SubscribableArrayEventType || (SubscribableArrayEventType = {}));

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class AbstractSubscribableArray {
    constructor() {
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this array.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
        const array = this.getArray();
        if (index > array.length - 1) {
            throw new Error('Index out of range');
        }
        return array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
        return this.getArray()[index];
    }
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    notify(index, type, modifiedItem) {
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(index, type, modifiedItem, this.getArray());
                }
            }
            catch (error) {
                console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(index, type, modifiedItem, this.getArray());
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const array = this.getArray();
        sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
}

/**
 * Types of facility repository sync events.
 */
var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType["Add"] = "Add";
    FacilityRepositorySyncType["Remove"] = "Remove";
    FacilityRepositorySyncType["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType["DumpResponse"] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRepository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.repos = new Map();
        this.trees = {
            [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
            [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        };
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        // Request a dump from any existing instances on other instruments to initialize the repository.
        this.pubSyncEvent({
            type: FacilityRepositorySyncType.DumpRequest, uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
        });
    }
    /**
     * Gets the number of facilities stored in this repository.
     * @param types The types of facilities to count. Defaults to all facility types.
     * @returns The number of facilities stored in this repository.
     */
    size(types) {
        var _a, _b;
        let size = 0;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                size += repo.size;
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
            }
        }
        return size;
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(type, lat, lon, radius, arg5, out, filter) {
        if (type !== FacilityType.USR && type !== FacilityType.VIS) {
            throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
        }
        if (typeof arg5 === 'number') {
            return this.trees[type].search(lat, lon, radius, arg5, out, filter);
        }
        else {
            this.trees[type].search(lat, lon, radius, arg5);
        }
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
        }
        this.addToRepo(fac);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    /**
     * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
     * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
     * replaced with the new one.
     * @param facs The facilities to add.
     */
    addMultiple(facs) {
        this.addMultipleToRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        if (!ICAO.isFacility(icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
        }
        this.removeFromRepo(icao);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    /**
     * Removes multiple facilities from this repository and all other repositories synced with this one.
     * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
     */
    removeMultiple(facs) {
        this.removeMultipleFromRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map(fac => typeof fac === 'object' ? fac.icao : fac) });
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                repo.forEach(fn);
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
            }
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === undefined) {
            this.repos.set(facilityType, repo = new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            if (existing === undefined) {
                this.trees[facilityType].insert(fac);
            }
            else {
                this.trees[facilityType].removeAndInsert([existing], [fac]);
            }
        }
        if (existing === undefined) {
            this.publisher.pub('facility_added', fac, false, false);
        }
        else {
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Adds multiple facilities to this repository.
     * @param facs The facilities to add.
     */
    addMultipleToRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const addedFacilities = [];
        const changedFacilitiesRemoved = [];
        const changedFacilitiesAdded = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const facilityType = ICAO.getFacilityType(fac.icao);
            let repo = this.repos.get(facilityType);
            if (repo === undefined) {
                this.repos.set(facilityType, repo = new Map());
            }
            const existing = repo.get(fac.icao);
            repo.set(fac.icao, fac);
            if (existing === undefined) {
                addedFacilities.push(fac);
            }
            else {
                changedFacilitiesRemoved.push(existing);
                changedFacilitiesAdded.push(fac);
            }
        }
        const addedUserFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (addedUserFacilities.length > 0) {
            const removedUserFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
            this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
        }
        const addedVisFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (addedVisFacilities.length > 0) {
            const removedVisFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
            this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
        }
        for (let i = 0; i < addedFacilities.length; i++) {
            const fac = addedFacilities[i];
            this.publisher.pub('facility_added', fac, false, false);
        }
        for (let i = 0; i < changedFacilitiesAdded.length; i++) {
            const fac = changedFacilitiesAdded[i];
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     */
    removeFromRepo(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        const facilityType = ICAO.getFacilityType(icao);
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === undefined) {
            return;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === undefined) {
            return;
        }
        repo.delete(icao);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            this.trees[facilityType].remove(facilityInRepo);
        }
        this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
        this.publisher.pub('facility_removed', facilityInRepo, false, false);
    }
    /**
     * Removes multiple facilities from this repository.
     * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
     */
    removeMultipleFromRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const removedFacilities = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const icao = typeof fac === 'string' ? fac : fac.icao;
            const repo = this.repos.get(ICAO.getFacilityType(icao));
            if (repo === undefined) {
                continue;
            }
            const facilityInRepo = repo.get(icao);
            if (facilityInRepo === undefined) {
                continue;
            }
            repo.delete(icao);
            removedFacilities.push(facilityInRepo);
        }
        const removedUserFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (removedUserFacilities.length > 0) {
            this.trees[FacilityType.USR].removeAll(removedUserFacilities);
        }
        const removedVisFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (removedVisFacilities.length > 0) {
            this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
        }
        for (let i = 0; i < removedFacilities.length; i++) {
            const removedFac = removedFacilities[i];
            this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
            this.publisher.pub('facility_removed', removedFac, false, false);
        }
    }
    /**
     * Publishes a facility added or removed sync event over the event bus.
     * @param data The event data.
     */
    pubSyncEvent(data) {
        this.ignoreSync = true;
        this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.DumpResponse:
                // Only accept responses to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    break;
                }
                else {
                    this.lastDumpRequestUid = undefined;
                }
            // eslint-disable-next-line no-fallthrough
            case FacilityRepositorySyncType.Add:
                if (data.facs.length === 1) {
                    this.addToRepo(data.facs[0]);
                }
                else {
                    this.addMultipleToRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.Remove:
                if (data.facs.length === 1) {
                    this.removeFromRepo(data.facs[0]);
                }
                else {
                    this.removeMultipleFromRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.DumpRequest:
                // Don't respond to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRepository.INSTANCE = new FacilityRepository(bus));
    }
}
FacilityRepository.SYNC_TOPIC = 'facilityrepo_sync';
FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
};

/**
 * The transition type to which a flight path vector belongs.
 */
var FlightPathVectorFlags;
(function (FlightPathVectorFlags) {
    FlightPathVectorFlags[FlightPathVectorFlags["None"] = 0] = "None";
    /** A turn to a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["TurnToCourse"] = 1] = "TurnToCourse";
    /** An arcing turn to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Arc"] = 2] = "Arc";
    /** A direct course to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Direct"] = 4] = "Direct";
    /** A path to intercept a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["InterceptCourse"] = 8] = "InterceptCourse";
    /** Inbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    /** Outbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    /** A direct hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    /** A teardrop hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    /** A parallel hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    /** A course reversal. */
    FlightPathVectorFlags[FlightPathVectorFlags["CourseReversal"] = 512] = "CourseReversal";
    /** A turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["LegToLegTurn"] = 1024] = "LegToLegTurn";
    /** An anticipated turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    /** A fallback path. */
    FlightPathVectorFlags[FlightPathVectorFlags["Fallback"] = 4096] = "Fallback";
})(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        // *********************************************************************************************************
        // ******** When adding new fields, they MUST be initialized, even if it just gets set to undefined ********
        // ******** This is so that it can be used with Object.keys()                                       ********
        // *********************************************************************************************************
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction. */
        this.originRunway = undefined;
        /** The ICAO for the facility associated with the departure procedure. */
        this.departureFacilityIcao = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The ICAO for the facility associated with the arrival procedure. */
        this.arrivalFacilityIcao = undefined;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The arrival runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.arrivalRunway = undefined;
        /** The ICAO for the facility associated with the approach procedure. */
        this.approachFacilityIcao = undefined;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /** The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
/**
 * Bitflags describing a leg definition.
 */
var LegDefinitionFlags;
(function (LegDefinitionFlags) {
    LegDefinitionFlags[LegDefinitionFlags["None"] = 0] = "None";
    LegDefinitionFlags[LegDefinitionFlags["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags[LegDefinitionFlags["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags[LegDefinitionFlags["Obs"] = 4] = "Obs";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
})(LegDefinitionFlags || (LegDefinitionFlags = {}));
/**
 * Vertical flight phase.
 */
var VerticalFlightPhase;
(function (VerticalFlightPhase) {
    VerticalFlightPhase["Climb"] = "Climb";
    VerticalFlightPhase["Descent"] = "Descent";
})(VerticalFlightPhase || (VerticalFlightPhase = {}));
var SpeedUnit;
(function (SpeedUnit) {
    SpeedUnit[SpeedUnit["IAS"] = 0] = "IAS";
    SpeedUnit[SpeedUnit["MACH"] = 1] = "MACH";
})(SpeedUnit || (SpeedUnit = {}));
/** Types of speed restrictions on legs. */
var SpeedRestrictionType;
(function (SpeedRestrictionType) {
    SpeedRestrictionType[SpeedRestrictionType["Unused"] = 0] = "Unused";
    SpeedRestrictionType[SpeedRestrictionType["At"] = 1] = "At";
    SpeedRestrictionType[SpeedRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType[SpeedRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType[SpeedRestrictionType["Between"] = 4] = "Between";
})(SpeedRestrictionType || (SpeedRestrictionType = {}));

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            flags: FlightPathVectorFlags.None,
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector, circle, start, end, flags) {
        vector.flags = flags;
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the direction of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The direction of the turn described by the flight path circle vector.
     */
    static getVectorTurnDirection(vector) {
        return vector.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
     */
    static getVectorTurnRadius(vector) {
        return Math.min(vector.radius, Math.PI - vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the true course for a flight plan leg.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
     * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
     * @returns The true course for the specified flight plan leg.
     */
    static getLegTrueCourse(leg, point, magVarFacility) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const magVar = magVarFacility
            ? -magVarFacility.magneticVariation // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.reverse();
        }
        return out;
    }
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle, out) {
        return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > MathUtils.HALF_PI
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Gets the great circle tangent to a given path at a given tangent point. The tangent circle will contain the
     * tangent point and have the same direction as the path at the tangent point.
     * @param point The tangent point. If the point does not lie on the path, it will be projected onto the path.
     * @param path The geo circle describing the path.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified path at the specified point.
     */
    static getGreatCircleTangentToPath(point, path, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(path.center, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Gets the great circle tangent to a given flight path vector at a given tangent point. The tangent circle will
     * contain the tangent point and have the same direction as the vector at the tangent point.
     * @param point The tangent point. If the point does not lie on the vector, it will be projected onto the vector.
     * @param vector The flight path vector.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified flight path vector at the specified point.
     */
    static getGreatCircleTangentToVector(point, vector, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const centerVec = Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[1]);
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(centerVec, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
        }
        const radius = turnDirection === 'left'
            ? turnRadius
            : Math.PI - turnRadius;
        const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
        const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
        return out.set(turnCenter, radius);
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
            return posAngularDistance >= Math.PI ? -Infinity : Infinity;
        }
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angularTolerance = circle.angularWidth(tolerance);
        if (typeof end !== 'number') {
            end = circle.angleAlong(start, end, Math.PI, angularTolerance);
        }
        if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const angle = circle.angleAlong(start, pos, Math.PI);
        if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
        return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static projectVelocityToCircle(speed, position, direction, projectTo) {
        if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return NaN;
        }
        if (speed === 0) {
            return 0;
        }
        if (!(position instanceof Float64Array)) {
            position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
        }
        const velocityPath = typeof direction === 'number'
            ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction)
            : direction.isGreatCircle()
                ? direction
                : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
        const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
        const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
        const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
        const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
        const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
        return speed * sinTheta * sign;
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress(legCalc) {
        var _a, _b, _c, _d, _e, _f;
        var _g, _h, _j, _k, _l, _m;
        const vectors = legCalc.ingressToEgress;
        let vectorIndex = 0;
        let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
        const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
        const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
        const firstEgressVector = legCalc.egress[0];
        const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
        if (lastIngressVector && ingressJoinVector) {
            // Check if the last ingress vector joins the base flight path before the end of a vector. If so, we need to
            // replace the base flight path vector the ingress joins with a shortened version starting where the ingress
            // ends.
            const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
            const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector
                ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon)
                : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
            const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
            const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
            if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
                // Ingress joins the base flight path before the end of the joined vector.
                if (ingressEndAlongVectorDistance > normalizedTolerance) {
                    // Ingress joins the base flight path after the start of the joined vector.
                    ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
                    FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : (vectors[_g] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
                }
                else {
                    // Ingress joins the base flight path at or before the start of the joined vector.
                    Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : (vectors[_h] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVector);
                }
            }
            flightPathVectorIndex++;
        }
        const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
        for (let i = flightPathVectorIndex; i < end; i++) {
            Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : (vectors[_j] = FlightPathUtils.createEmptyCircleVector()), legCalc.flightPath[i]);
            flightPathVectorIndex++;
        }
        if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
            if (firstEgressVector) {
                // Check if the first egress vector joins the base flight path in after the start of a vector. If so, we need
                // to replace the base flight path vector the egress joins with a shortened version starting where the egress
                // starts.
                const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
                const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
                const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
                const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
                if (egressStartAlongVectorDistance > normalizedTolerance) {
                    // Egress joins the base flight path after the start of the joined vector.
                    if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
                        // Egress joins the base flight path before the end of the joined vector.
                        egressJoinVectorCircle.closest(egressStart, egressStart);
                        FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : (vectors[_k] = FlightPathUtils.createEmptyCircleVector()), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                    }
                    else {
                        // Egress joins the base flight path at or after the end of the joined vector.
                        Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : (vectors[_l] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
                    }
                }
            }
            else {
                // There is no egress, but there is a base flight path vector flagged as the vector with which the egress
                // joins. This is technically an invalid state, but we can easily just treat this as a regular "no-egress"
                // case and copy the entire egress join vector into the resolved vectors array.
                Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : (vectors[_m] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
            }
        }
        vectors.length = vectorIndex;
        return legCalc;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
}
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg, flags) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        if (turnEndPoint.equals(start)) {
            return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle, flags = 0) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const intersectionIndex = (numIntersections === 1 || circle.encircles(start)) ? 0 : 1;
        const endVec = intersections[intersectionIndex];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
[
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
[new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths via a turn starting at the start
 * point followed by an angled intercept path which intercepts the final path before the end point.
 */
class InterceptGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
        }
        const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
        if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // initial and final paths are parallel
            return 0;
        }
        const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
        const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
        // The set of centers of great circles that intersect the end path at the desired intercept angle
        const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
        const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
        if (startTurnDirection === undefined) {
            // Calculate the intercept point if the intercept path were to pass through the start point.
            const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
            if (interceptCount === 0) {
                // No great-circle path passing through the start point can intercept the final path at the desired intercept angle.
                startTurnDirection = startPath.encircles(end) ? 'left' : 'right';
            }
            else {
                let intersectionIndex = 0;
                if (interceptCount > 1) {
                    // There are two great-circle paths passing through the start point that intercept the final path at the
                    // desired angle. One of them will be directed toward the end path and the other will be directed away from
                    // it. We want to choose the one directed toward it.
                    intersectionIndex = endPath.encircles(start) ? 0 : 1;
                }
                let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                // sin x ~= x for x near 0, so to check if the angle between the start path and intercept path is parallel or
                // antiparallel we just have to check the magnitude of their cross product instead of the arcsine of the
                // magnitude.
                if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                    // If start and intercept paths are parallel or antiparallel, it doesn't really matter which direction we
                    // turn, so we will just turn in the direction that aligns us with the end path.
                    cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                    if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                        // If start and end paths are antiparallel (they can't be parallel since we would have returned from the
                        // method by now), then we just arbitrarily choose to turn right.
                        startTurnDirection = 'right';
                    }
                    else {
                        startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                    }
                }
                else {
                    startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                }
            }
        }
        const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
        const endTurnRadiusRad = endTurnRadius === undefined ? undefined : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
        if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // If the desired intercept angle is 0 degrees, the only valid path is when the starting turn ends exactly on the
            // path to intercept and the end of the turn lies before the end point
            if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
                // starting turn is not tangent to path to intercept
                return 0;
            }
            const startTurnEnd = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd, end, Math.PI);
            if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                // the end of the starting turn lies after the end point.
                return 0;
            }
            return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        // Find the great-circle path that intersects the path to intercept at the desired intercept angle and is tangent
        // to the starting turn.
        // The set of centers of great circles that are tangent to the starting turn
        const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
        const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
        if (interceptPathCount === 0) {
            return 0;
        }
        const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
        let interceptCrossSign;
        if (startToEndPathAngleRad >= interceptAngleRad) {
            // The start turn is considered to overshoot if it crosses to the contralateral side of the final path before
            // joining the intercept path that requires the shortest turn to join. The contralateral side is defined as the
            // right side for left turns and the left side for right turns. If this occurs, we need to choose the second
            // intercept path (if it exists). This is because choosing the first intercept path would trigger a case below
            // that attempts to end the start turn early, which could produce a path that requires the plane to track toward
            // the final path at an angle greater than the intercept angle.
            const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
            const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
            interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
            interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === 'right') ? 1 : -1;
        }
        else {
            // If the start path intersects the final path at a shallower angle than the intercept path, then we always want
            // to choose the intercept path that requires the shortest turn to join. Even if the turn has overshot the final
            // path by the time it can join the chosen intercept path, we handle that case below by attempting to end the
            // start turn early. We are guaranteed that ending the start turn early will not result in a path that requires
            // the plane to track toward the final path at an angle greater than the intercept angle because if it did, that
            // would mean the start turn does not overshoot the final path and therefore we wouldn't have needed to end the
            // start turn early in the first place.
            interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
            interceptCrossSign = startTurnDirection === 'right' ? 1 : -1;
        }
        const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
        const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        // Required turn anticipation for the end turn to join the intercept and final paths.
        let minDInterceptEnd = 0;
        if (endTurnRadiusRad !== undefined) {
            const endTheta = Math.PI - interceptAngleRad;
            minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
            if (isNaN(minDInterceptEnd)) {
                // Turn radius is too large for the end turn to join the intercept and final paths
                return 0;
            }
        }
        const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
        if (interceptToEndOffset < minDInterceptEnd) {
            // The intercept path does not intercept the final path early enough to make the end turn before the end point
            return 0;
        }
        let vectorIndex = index;
        if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            // The start turn ends too late to make a turn to join the final path or the start turn overshoots the end path
            // before reaching the intercept course -> attempt to end the start turn early
            if (endTurnRadiusRad === undefined) {
                // We don't need to calculate a final turn, so attempt to end the start turn where it intersects the end path
                const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
                if (startTurnEndPathIntersectionCount === 0) {
                    return 0;
                }
                const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === 'right' ? 0 : 1];
                if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The start turn intercepts the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
            }
            else {
                // We need to calculate a final turn to join the end path. This final turn must be tangent to the starting turn
                // and the end path.
                const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the starting turn
                const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the end path
                const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === 'left' ? 1 : -1));
                const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
                if (endTurnCircleCount === 0) {
                    return 0;
                }
                const endTurnCenter = intersections[0];
                const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === 'left' ? 'right' : 'left', InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
                endTurnCircle.closest(startTurnCenter, startTurnEnd);
                const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The end turn joins the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
            }
        }
        else {
            if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
            }
            let interceptPathEnd = intercept;
            if (endTurnRadiusRad !== undefined) {
                interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
            }
            if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
            }
            if (endTurnRadius !== undefined) {
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
            }
        }
        return vectorIndex - index;
    }
}
InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
        this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
        }
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        // Calculate the relative directions of the start point, intersection point, and end point.
        const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
        // positive -> start point lies after the intersection (with respect to the direction of start path)
        const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        // positive -> end point lies after the intersection (with respect to the direction of end path)
        const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        // along-track distance from the intersection point to the start/end of the minimum-radius turn from start path to end path
        let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        if (isNaN(minD)) {
            // Turn radius is too large for any turn to join the start and end paths
            minD = Infinity;
        }
        const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
        const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
        const towardEndPointTurnDirection = startPath.encircles(end, false) ? 'left' : 'right';
        let needCalculateTwoTurnPath = false;
        let needCalculateOneTurnPath = false;
        if (isEndForwardOfIntersection) {
            if (desiredTurnDirection === undefined || desiredTurnDirection === towardEndPointTurnDirection) {
                const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
                const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
                if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
                    // The minimum turn radius is too large to intercept the final path before the end point
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
                else {
                    // Make a single constant-radius turn either starting at the start point, or ending at the end point,
                    // depending on which is closer to the intersection point.
                    const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
                    if (intersectionStartDistance <= intersectionEndDistance) {
                        // start turn at start point
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
                        if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
                        }
                    }
                    else {
                        // end turn at end point
                        let turnStart = start;
                        if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
                        }
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                    }
                }
            }
            else {
                if (pathDot >= 0) {
                    // The start and end paths intersect at an angle <= 90 degrees. This means that for a turn away from the end
                    // point, the total flight path distance is minimized when the turn joins the start and end paths directly.
                    if (intersectionStartOffset <= minD) {
                        // The start point lies at or before the required turn start point to minimize the flight path distance.
                        needCalculateOneTurnPath = true;
                    }
                    else {
                        needCalculateTwoTurnPath = !preferSingleTurn;
                        needCalculateOneTurnPath = preferSingleTurn;
                    }
                }
                else {
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
            }
        }
        else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
        }
        let needDirectFallback = false;
        if (needCalculateTwoTurnPath) {
            const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
            // Attempt to make a turn to intercept the end path at 45 degrees. At this point we are in fallback territory
            // so we won't honor the desired starting turn direction.
            const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, undefined, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
            if (numInterceptVectors === 0) {
                needDirectFallback = allowDirectFallback;
            }
            else {
                vectorIndex += numInterceptVectors;
                const lastVector = vectors[vectorIndex - 1];
                const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
                if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
                }
            }
        }
        else if (needCalculateOneTurnPath) {
            // Make a single constant-radius turn from the start path to join the end path. The turn must start after the
            // intersection of the start and end paths (the only case where the turn starts before the intersection is
            // handled above).
            if (minD > Math.PI / 2) {
                // No amount of anticipation can provide a turn which joins the start and end paths of the desired radius.
                needDirectFallback = allowDirectFallback;
            }
            else {
                const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
                const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
                const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
                const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
                if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
                }
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
                }
            }
        }
        if (needDirectFallback) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45; // degrees
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, undefined, flags);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, undefined, flags);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
class DirectToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
        let vectorIndex = index;
        if (typeof startPath === 'number') {
            startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
        }
        const endPos = DirectToPointBuilder.geoPointCache[0];
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            endPos.set(end);
            end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
        }
        else {
            endPos.setFromCartesian(end);
        }
        const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
        if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
            return vectorIndex - index;
        }
        else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
            return vectorIndex - index;
        }
        const startPathEncirclesTerminator = startPath.encircles(end);
        const startPathIncludesTerminator = startPath.includes(end);
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right');
        const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === 'left'
            ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2])
            : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
        const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
        // The angle between the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
        const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
        flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
        if (!GeoPoint.equals(turnEndVec, start)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
        }
        if (!GeoPoint.equals(turnEndVec, end)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, undefined, flags);
        }
        return vectorIndex - index;
    }
}
DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the magnetic variation, in degrees, to use when calculating a flight plan leg's course. If the leg defines
     * an origin or fix VOR facility, then the magnetic variation defined at the VOR is used. Otherwise the computed
     * magnetic variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The magnetic variation, in degrees, to use when calculating the specified flight plan leg's course.
     */
    getLegMagVar(leg, point) {
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR)) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR)) ? leg.fixIcao
                : undefined;
        const facility = facIcao !== undefined ? this.facilityCache.get(facIcao) : undefined;
        // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
        return facility === undefined ? MagVar.get(point) : -facility.magneticVariation;
    }
    /**
     * Gets the true course, in degrees, for a flight plan leg. If the leg defines an origin or fix VOR facility, then
     * the magnetic variation defined at the VOR is used to adjust magnetic course. Otherwise the computed magnetic
     * variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The true course, in degrees, for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    /** @inheritdoc */
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
        var _a, _b, _c;
        var _d;
        const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : (_d.calculated = {
            courseMagVar: 0,
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            distance: 0,
            distanceWithTransitions: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTransitions: 0,
            flightPath: [],
            ingress: [],
            ingressJoinIndex: -1,
            ingressToEgress: [],
            egressJoinIndex: -1,
            egress: [],
            endsInFallback: false
        });
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            state.isFallback = calcs.endsInFallback;
            return calcs;
        }
        try {
            this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
            this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
            resolveIngressToEgress && this.resolveIngressToEgress(calcs);
            calcs.endsInFallback = state.isFallback;
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
            vectors.length = 0;
            calcs.ingress.length = 0;
            calcs.ingressJoinIndex = 0;
            calcs.egress.length = 0;
            calcs.egressJoinIndex = -1;
            calcs.ingressToEgress.length = 0;
            calcs.endsInFallback = false;
            state.isFallback = false;
        }
        return calcs;
    }
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    resolveIngressToEgress(legCalc) {
        FlightPathUtils.resolveIngressToEgress(legCalc);
    }
}
/**
 * Calculates flight path vectors for legs with no path.
 */
class NoPathLegCalculator extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.courseMagVar = 0;
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.flightPath.length = 0;
        state.currentCourse = undefined;
        state.currentPosition = undefined;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            vectors.length = 0;
            state.isFallback = false;
            return;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            if (state.isFallback && state.currentCourse !== undefined) {
                vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
            }
            else {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            }
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            vectors.length = 0;
            return;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        let initialCourse;
        if (leg.course !== 0) {
            // If a course is defined on the leg, then honor it.
            initialCourse = leg.trueDegrees ? leg.course % 360 : MagVar.magneticToTrue(leg.course, startPoint);
        }
        else {
            if (state.currentCourse === undefined) {
                // If the current course from the previous leg is undefined, then attempt to select an initial course from
                // the definition of the previous leg, if one exists.
                const prevLeg = legs[calculateIndex - 1];
                switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) {
                    case LegType.CA:
                    case LegType.CF:
                    case LegType.CR:
                    case LegType.FA:
                    case LegType.FC:
                    case LegType.FD:
                    case LegType.FM:
                    case LegType.VA:
                    case LegType.VD:
                    case LegType.VM:
                    case LegType.VR:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.HA:
                        // If the previous leg defines a course, then use that course.
                        initialCourse = this.getLegTrueCourse(prevLeg.leg, startPoint);
                        break;
                    case LegType.IF:
                        // If the previous leg is an IF for a runway fix, then use runway heading as the initial course.
                        if (ICAO.isFacility(prevLeg.leg.fixIcao, FacilityType.RWY)) {
                            const runwayFix = this.facilityCache.get(prevLeg.leg.fixIcao);
                            if (runwayFix) {
                                initialCourse = runwayFix.runway.course;
                                break;
                            }
                        }
                    // eslint-disable-next-line no-fallthrough
                    default:
                        // If we can't select an initial course from the previous leg, then default to the course that puts us on a
                        // great-circle path from the start point to the terminator fix.
                        initialCourse = startPoint.bearingTo(terminatorPos);
                        // If the calculated course is NaN (only happens when the start and end points are coincident or antipodal),
                        // then just arbitrarily use true north.
                        if (isNaN(initialCourse)) {
                            initialCourse = 0;
                        }
                }
            }
            else {
                // If the current course from the previous leg is defined, use it.
                initialCourse = state.currentCourse;
            }
        }
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, startPoint, startPath, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), leg.turnDirection === LegTurnDirection.Left ? 'left' : leg.turnDirection === LegTurnDirection.Right ? 'right' : undefined);
        state.currentPosition.set(terminatorPos);
        if (vectorIndex > 0) {
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            vectors.length = vectorIndex;
            return;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec, FlightPathVectorFlags.Arc);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    /** @inheritdoc */
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, true);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.turnBuilder = new TurnToCourseBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
        this.interceptInfo = {
            circle: undefined,
            start: undefined,
            end: undefined
        };
        this.handleInvalidInterceptCache = {
            vec3: [new Float64Array(3), new Float64Array(3), new Float64Array(3)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)],
            intersection: [new Float64Array(3), new Float64Array(3)]
        };
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const interceptInfo = this.getInterceptPathInfo(legs, calculateIndex, state, this.interceptInfo);
        if (course === undefined || !interceptInfo.circle || !state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        const effectiveInterceptPathStartVec = interceptInfo.start
            ? GeoPoint.sphericalToCartesian(interceptInfo.start, this.vec3Cache[0])
            : interceptInfo.end
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.end, -Math.PI, this.vec3Cache[0], Math.PI)
                : undefined;
        const effectiveInterceptPathEndVec = interceptInfo.end
            ? GeoPoint.sphericalToCartesian(interceptInfo.end, this.vec3Cache[1])
            : interceptInfo.start
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.start, Math.PI, this.vec3Cache[1], Math.PI)
                : undefined;
        const effectiveInterceptPathAngularWidth = interceptInfo.start && interceptInfo.end
            ? interceptInfo.circle.angleAlong(interceptInfo.start, interceptInfo.end, Math.PI)
            : effectiveInterceptPathStartVec
                ? Math.PI
                : MathUtils.TWO_PI;
        const initialVec = state.currentPosition.toCartesian(this.vec3Cache[2]);
        const includeInitialTurn = this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1;
        const interceptPathStartVec = Vec3Math.copy(initialVec, this.vec3Cache[3]);
        let initialTurnVector = undefined;
        if (includeInitialTurn) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            initialTurnVector = vectors[vectorIndex - 1];
            GeoPoint.sphericalToCartesian(initialTurnVector.endLat, initialTurnVector.endLon, interceptPathStartVec);
        }
        const interceptPath = this.geoCircleCache[0].setAsGreatCircle(interceptPathStartVec, course);
        const startPath = this.geoCircleCache[1].set(interceptPath.center, interceptPath.radius);
        // If an initial turn exists, check if a fallback intercept is required because the end of the initial turn lies
        // past the path to intercept. If an initial turn does not exist, check if any fallback intercept is required.
        let fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, initialTurnVector !== undefined, false, this.vec3Cache[4]);
        if (initialTurnVector !== undefined) {
            if (fallbackInterceptVec === undefined) {
                // An initial turn exists and does not end past the path to intercept. Check if a fallback intercept is required
                // for another reason.
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, false, this.vec3Cache[4]);
            }
            else {
                // An initial turn exists and ends past the path to intercept. First check if the initial turn intersects the
                // path to intercept
                const turnCircle = FlightPathUtils.setGeoCircleFromVector(initialTurnVector, this.geoCircleCache[2]);
                const intersections = this.intersectionCache;
                const numIntersections = turnCircle.intersection(interceptInfo.circle, intersections);
                if (numIntersections > 1) {
                    // Order intersections such that the one closer to the turn end is at index 0.
                    if (interceptInfo.circle.radius > MathUtils.HALF_PI !== interceptInfo.circle.encircles(initialVec)) {
                        const temp = intersections[0];
                        intersections[0] = intersections[1];
                        intersections[1] = temp;
                    }
                }
                for (let i = 0; i < numIntersections; i++) {
                    const intersection = intersections[i];
                    if (FlightPathUtils.isPointAlongArc(turnCircle, initialVec, interceptPathStartVec, intersection)
                        && (!effectiveInterceptPathStartVec
                            || FlightPathUtils.isPointAlongArc(interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathAngularWidth, intersection))) {
                        // End the turn early at the intercept point
                        const distance = turnCircle.distanceAlong(initialVec, intersection, Math.PI);
                        if (distance > GeoCircle.ANGULAR_TOLERANCE) {
                            const intersectionPoint = this.geoPointCache[0].setFromCartesian(intersection);
                            initialTurnVector.distance = UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                            initialTurnVector.endLat = intersectionPoint.lat;
                            initialTurnVector.endLon = intersectionPoint.lon;
                            state.currentPosition.set(initialTurnVector.endLat, initialTurnVector.endLon);
                            state.currentCourse = FlightPathUtils.getVectorFinalCourse(initialTurnVector);
                        }
                        else {
                            vectorIndex--;
                        }
                        vectors.length = vectorIndex;
                        return;
                    }
                }
                // The initial turn does not intersect the path to intercept -> calculate a fallback intercept
                // without an initial turn (i.e. change the intercept path to start at the start of the leg).
                vectorIndex = 0;
                Vec3Math.copy(initialVec, interceptPathStartVec);
                interceptPath.setAsGreatCircle(interceptPathStartVec, course);
                startPath.setAsGreatCircle(interceptPathStartVec, startCourse);
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, true, this.vec3Cache[4]);
            }
        }
        if (fallbackInterceptVec === undefined) {
            vectorIndex += this.interceptBuilder.build(vectors, vectorIndex, interceptPathStartVec, course, interceptInfo.circle);
        }
        else {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, interceptPathStartVec, startPath, fallbackInterceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
    }
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    calculateFallbackIntercept(start, interceptPath, pathToInterceptCircle, pathToInterceptStart, pathToInterceptEnd, pathToInterceptAngularWidth, onlyHandleInitialPointPastIntercept, forceFallback, out) {
        if (pathToInterceptCircle.includes(start)) {
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, start)) {
                // Initial point already lies on the path to intercept.
                return forceFallback ? Vec3Math.copy(start, out) : undefined;
            }
        }
        // Determine if the starting position is "past" the path to intercept.
        let isInitialPosPastPath = false;
        const intersections = this.handleInvalidInterceptCache.intersection;
        const numIntersections = interceptPath.intersection(pathToInterceptCircle, intersections);
        let desiredIntersection;
        if (numIntersections === 2) {
            const nextIntersectionIndex = pathToInterceptCircle.encircles(start) ? 0 : 1;
            const prevIntersectionIndex = 1 - nextIntersectionIndex;
            const nextIntersection = intersections[nextIntersectionIndex];
            const prevIntersection = intersections[prevIntersectionIndex];
            // Define the desired intercept point as the one that requires the shortest distance traveled along the initial
            // path and path to intercept circle from the initial position to some point along the path to intercept. Then,
            // determine if the initial position lies before or after the desired intercept point, relative to the direction
            // of the initial path.
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI && pathToInterceptCircle.isGreatCircle()) {
                isInitialPosPastPath = interceptPath.angleAlong(start, nextIntersection, Math.PI) > MathUtils.HALF_PI + GeoCircle.ANGULAR_TOLERANCE;
            }
            else {
                const prevIntersectionInitialPathOffset = interceptPath.angleAlong(prevIntersection, start, Math.PI);
                const nextIntersectionInitialPathOffset = interceptPath.angleAlong(start, nextIntersection, Math.PI);
                const prevIntersectionInitialPathDistance = Math.min(prevIntersectionInitialPathOffset, MathUtils.TWO_PI - prevIntersectionInitialPathOffset);
                const nextIntersectionInitialPathDistance = Math.min(nextIntersectionInitialPathOffset, MathUtils.TWO_PI - nextIntersectionInitialPathOffset);
                let prevIntersectionInterceptPathDistance = 0;
                let nextIntersectionInterceptPathDistance = 0;
                if (pathToInterceptStart && pathToInterceptEnd) {
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, prevIntersection)) {
                        const prevIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptStart, Math.PI);
                        const prevIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptEnd, Math.PI);
                        prevIntersectionInterceptPathDistance = Math.min(prevIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathStartOffset, prevIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathEndOffset);
                    }
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, nextIntersection)) {
                        const nextIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptStart, Math.PI);
                        const nextIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptEnd, Math.PI);
                        nextIntersectionInterceptPathDistance = Math.min(nextIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathStartOffset, nextIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathEndOffset);
                    }
                }
                const prevIntersectionTotalDistance = prevIntersectionInitialPathDistance + prevIntersectionInterceptPathDistance;
                const nextIntersectionTotalDistance = nextIntersectionInitialPathDistance + nextIntersectionInterceptPathDistance;
                // Only consider the starting position past the path to intercept if the path to intercept has a defined start
                // and end (i.e. is not a DME circle) OR the distance to one of the two intercept points is greater than pi/2
                // great-arc radians.
                if ((pathToInterceptStart !== undefined && pathToInterceptEnd !== undefined)
                    || (prevIntersectionTotalDistance >= MathUtils.HALF_PI || nextIntersectionTotalDistance >= MathUtils.HALF_PI)) {
                    isInitialPosPastPath = prevIntersectionTotalDistance < nextIntersectionTotalDistance - GeoCircle.ANGULAR_TOLERANCE;
                }
            }
            desiredIntersection = isInitialPosPastPath ? prevIntersection : nextIntersection;
        }
        else if (numIntersections === 1) {
            const distanceToIntersection = interceptPath.angleAlong(start, intersections[0], Math.PI);
            isInitialPosPastPath = distanceToIntersection < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && distanceToIntersection > Math.PI + GeoCircle.ANGULAR_TOLERANCE;
            desiredIntersection = intersections[0];
        }
        if ((onlyHandleInitialPointPastIntercept && !isInitialPosPastPath)) {
            return undefined;
        }
        let needHandleFallback = isInitialPosPastPath;
        if (!desiredIntersection) {
            // The intercept course does not intersect with the path to intercept circle at all -> define the desired
            // intercept point as the point on the path to intercept circle closest to the start point.
            desiredIntersection = pathToInterceptCircle.closest(start, this.handleInvalidInterceptCache.vec3[0]);
            needHandleFallback = true;
        }
        let fallbackIntercept;
        if ((!pathToInterceptStart || !pathToInterceptEnd)
            || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, desiredIntersection)) {
            // The desired intercept point is within the bounds of the path to intercept -> only handle the fallback if we
            // need to (i.e. if the starting point is past the path to intercept, if the starting path does not intersect
            // the path to intercept, or fallback is forced)
            if (needHandleFallback || forceFallback) {
                fallbackIntercept = desiredIntersection;
            }
        }
        else {
            // The desired intercept point is not within the bounds of the path to intercept -> set the fallback intercept
            // point to the start or end of the path to intercept, whichever is closer to the desired intercept point.
            const angularOffset = pathToInterceptCircle.angleAlong(pathToInterceptStart, desiredIntersection, Math.PI);
            const distanceFromStart = Math.min(angularOffset, MathUtils.TWO_PI - angularOffset);
            const distanceFromEnd = Math.abs(angularOffset - pathToInterceptAngularWidth);
            fallbackIntercept = distanceFromStart <= distanceFromEnd ? pathToInterceptStart : pathToInterceptEnd;
        }
        return fallbackIntercept === undefined ? undefined : Vec3Math.copy(fallbackIntercept, out);
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDmeLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const dmeFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = dmeFacility === undefined ? 0 : this.getLegMagVar(leg.leg, dmeFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (dmeFacility) {
            this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
            out.circle = this.dmeCircle;
            out.start = undefined;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.radialCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const radialFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = radialFacility === undefined ? 0 : this.getLegMagVar(leg.leg, radialFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (radialFacility) {
            const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
                ? -radialFacility.magneticVariation
                : MagVar.get(radialFacility);
            this.radialCircle.setAsGreatCircle(radialFacility, leg.theta + magVar);
            out.circle = this.radialCircle;
            out.start = radialFacility;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.predictLegPathCache = {
            geoPoint: [new GeoPoint(0, 0)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0)]
        };
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        const leg = legs[calculateIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = state.currentPosition === undefined ? 0 : this.getLegMagVar(leg.leg, state.currentPosition);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        out.circle = undefined;
        out.start = undefined;
        out.end = undefined;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return out;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[0]);
                    if (terminator) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator));
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    if (facility) {
                        out.circle = FlightPathUtils.getTurnCircle(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = this.facilityCache.get(leg.fixIcao);
                    }
                    break;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    if (terminator && centerFacility) {
                        out.circle = FlightPathUtils.getTurnCircle(centerFacility, terminator.distance(centerFacility), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    if (origin) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin));
                        out.start = origin;
                    }
                    break;
                }
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDmeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (!pathStartPoint || !dmeFacility) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const dmeCircle = this.geoCircleCache[1].set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const interceptVec = this.vec3Cache[1];
        const intersections = this.intersectionCache;
        const numIntersections = path.intersection(dmeCircle, intersections);
        if (numIntersections === 0) {
            // The path along the leg's defined course does not intercept the DME circle -> define the intercept to be the
            // closest point on the DME circle to the initial fix.
            dmeCircle.closest(pathStartVec, interceptVec);
        }
        else {
            // The path along the leg's defined course intercepts the DME circle -> choose the first intercept when
            // proceeding along the path from the initial fix.
            const intersectionIndex = (numIntersections === 1 || dmeCircle.encircles(pathStartVec)) ? 0 : 1;
            Vec3Math.copy(intersections[intersectionIndex], interceptVec);
        }
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, interceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, interceptVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, interceptVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!pathStartPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const endVec = path.offsetDistanceAlong(pathStartVec, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN), this.vec3Cache[1], Math.PI);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, endVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, endVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            // We are in a fallback state -> plot a direct course to the terminator fix
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, undefined, FlightPathVectorFlags.Fallback);
            state.isFallback = false;
        }
        else {
            state.isFallback = false;
            const endCourse = this.getLegTrueCourse(leg, endPoint);
            const endVec = endPoint.toCartesian(this.vec3Cache[1]);
            const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
            if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
                // ---- CASE A ----
                // The leg begins at a discontinuity OR the previous leg is a manual termination leg.
                // Create a great-circle vector with a start point arbitrarily placed 5 NM from the terminator fix.
                const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
            }
            else {
                const startVec = startPoint.toCartesian(this.vec3Cache[0]);
                const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
                const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
                const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
                const isStartEqualToEnd = startPoint.equals(endPoint);
                const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
                // A great circle defining the threshold of the terminator fix - everything to the LEFT of (i.e. encircled by)
                // this great circle is past the terminator fix as projected along the end path.
                const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
                const isStartPastThreshold = threshold.encircles(startVec, false);
                // 175 degrees
                const areStartEndPathsAntiParallel = pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE;
                let isDone = false;
                if (!areStartEndPathsAntiParallel && isStartPastThreshold) {
                    // ---- CASE B ----
                    // The start and end paths are not antiparallel and the start point is past the terminator threshold.
                    let shouldTryFallback = true;
                    const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                        : leg.turnDirection === LegTurnDirection.Right ? 'right'
                            : undefined;
                    if (pathAngleDiff >= MathUtils.HALF_PI
                        && (desiredTurnDirection === undefined || (desiredTurnDirection === 'left') === startPath.encircles(endVec))) {
                        // The start path is either heading toward the terminator threshold or is parallel to it and the desired
                        // turn direction is not away from the end point. We now need to find the intersections between the start
                        // and end paths. There should be two intersections since both paths are great circles and they are not
                        // parallel or antiparallel.
                        const intersections = this.intersectionCache;
                        const solutionCount = startPath.intersection(endPath, intersections);
                        if (solutionCount === 2) {
                            // There are two general cases:
                            //
                            // 1. The end point lies past the intersection as measured along the end path.
                            // 2. The end point lies before the intersection as measured along the end path.
                            //
                            // In case 1, we can use the default algorithm for joining the start and end paths. Therefore there is
                            // nothing to do here; we just need to make sure the code falls through to Case E below.
                            //
                            // In case 2, we will try to join the start and end paths with a single constant radius turn. This will
                            // generate a "loop" where the path follows the start path initially away from the end point and then
                            // turns back onto the end path to head back to the end point. If that is not possible or the generated
                            // path is too long, we will fall through to Case E.
                            shouldTryFallback = false;
                            // Choose the intersection closest to the start point.
                            const intersection = Vec3Math.dot(intersections[0], startVec) > 0
                                ? intersections[0]
                                : intersections[1];
                            const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, this.vec3Cache[2]), endVec);
                            const isEndPastIntersection = intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE;
                            if (!isEndPastIntersection) {
                                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius, true, false, intersection);
                                if (vectorIndex !== 0) {
                                    // Find all the great-circle vectors in the path. These are all guaranteed to be parallel to either
                                    // the start or end paths. If the total distance of all these vectors is greater than a maximum
                                    // threshold, erase the vectors and let the code fall through to Case E, which will generate a
                                    // shorter path.
                                    let distance = 0;
                                    for (let i = 0; i < vectorIndex; i++) {
                                        const vector = vectors[i];
                                        if (FlightPathUtils.isVectorGreatCircle(vector)) {
                                            distance += vector.distance;
                                        }
                                    }
                                    if (distance > 37040 /* 20 nautical miles */) {
                                        vectorIndex = 0;
                                    }
                                }
                                isDone = vectorIndex > 0;
                            }
                        }
                    }
                    if (shouldTryFallback && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type)) {
                        // The leg does not end in a fly-over fix and the next leg is eligible for fallback -> end the current leg
                        // at the start point and set a fallback state.
                        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                        (_d = state.currentCourse) !== null && _d !== void 0 ? _d : (state.currentCourse = currentCourse);
                        state.isFallback = true;
                        isDone = true;
                    }
                }
                if (!isDone) {
                    if (areStartEndPathsAntiParallel) {
                        // ---- CASE C ----
                        // The start and end paths are antiparallel. We need to execute a procedure turn to do a 180.
                        let desiredTurnDirection;
                        switch (leg.turnDirection) {
                            // If the leg defines a turn direction, respect it.
                            case LegTurnDirection.Left:
                                desiredTurnDirection = 'left';
                                break;
                            case LegTurnDirection.Right:
                                desiredTurnDirection = 'right';
                                break;
                            default: {
                                const endDistanceFromStartPath = startPath.distance(endVec);
                                if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                                    // If the end point lies on the start path, then we want to turn toward the end path after passing
                                    // the end point along the start path (defaulting to a right turn if the start and end paths are
                                    // exactly antiparallel).
                                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? 'left' : 'right';
                                }
                                else {
                                    // If the end point does not lie on the start path, then we want to turn toward the end point from
                                    // the start path.
                                    desiredTurnDirection = endDistanceFromStartPath < 0 ? 'left' : 'right';
                                }
                            }
                        }
                        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
                        // procTurnBuilder will only build vectors up to the point where the proc turn intercepts the end path.
                        // So we need to check if we need to add a vector to connect the intercept point to the end point.
                        if (vectorIndex > 0) {
                            const lastVector = vectors[vectorIndex - 1];
                            const interceptVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                            if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) { // ~60 meter tolerance
                                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector.endLat, lastVector.endLon), endPoint);
                            }
                        }
                    }
                    else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE
                        && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE
                            || (!isStartEqualToEnd
                                && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                                    || (((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))))) {
                        // ---- CASE D ----
                        // The start and end paths are parallel, so we can just connect the start and end with a track.
                        // Or the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                        // least one calculated vector. In this case we will simply create a track from the start to end and let turn
                        // anticipation handle the initial turn into the final course.
                        if (!isStartEqualToEnd) {
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
                        }
                    }
                    else {
                        // ---- CASE E ----
                        // The default case. We will attempt to join the start and end paths with a single constant-radius turn
                        // toward the end point. If that is not possible, we will fall back to using two constant-radius turns. If
                        // that is not possible, we will fall back to a direct-to path from the start point to the end point.
                        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                                : undefined;
                        vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
                        const lastVector = vectors[vectorIndex - 1];
                        if (lastVector !== undefined
                            && !leg.flyOver
                            && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                            const lastVectorEndVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const lastVectorEndPath = FlightPathUtils.getGreatCircleTangentToVector(lastVectorEndVec, lastVector, this.geoCircleCache[3]);
                            const lastVectorCourseDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(lastVectorEndPath.center, endPath.center), -1, 1));
                            if (lastVectorCourseDiff > 0.0174533 /* 1 degree */) {
                                // We are allowed to use a fallback path which does not end at the defined terminator fix and a fallback
                                // direct-to path was calculated. We need to determine if we should end the direct-to path early if it
                                // crosses past the terminator threshold or remove it entirely and end the leg immediately at the start
                                // point.
                                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                                let useImmediateFallback = false;
                                let startTurnCircle;
                                let startTurnEnd;
                                // The direct-to path can consist of either a single turn vector, a single great-circle vector, or a
                                // starting turn vector followed by a great-circle vector.
                                if (FlightPathUtils.isVectorGreatCircle(lastVector)) {
                                    if (vectorIndex < 2) {
                                        // The direct-to path has a single great-circle vector. If the direct-to course differs from the end
                                        // course by more than 90 degrees, then the entire direct-to path is past the terminator threshold.
                                        // In that case we will end this leg at the start point and set a fallback state. If the direct-to
                                        // course is within 90 degrees of the end course, then the path must be entirely behind the
                                        // threshold. In that case we will leave the path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            useImmediateFallback = true;
                                        }
                                    }
                                    else {
                                        // The direct-to path consists of a starting turn followed by a great-circle vector. If the course of
                                        // the great-circle vector differs from the end course by more than 90 degrees, then we need to
                                        // deal with the possibility that the direct-to path starts behind the terminator threshold and then
                                        // crosses past the threshold. If the courses differ by 90 or degrees or less, then we will leave
                                        // the direct-to path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            if (isStartPastThreshold) {
                                                // If the start point is past the terminator threshold, then the entire direct-to path is
                                                // guaranteed to be past the terminator threshold. Therefore we will end this leg at the start
                                                // point and set a fallback state.
                                                useImmediateFallback = true;
                                            }
                                            else {
                                                // If the start point is not past the terminator threshold, then that means at some point the
                                                // direct-to path (specifically the starting turn) must cross the threshold. Therefore we will
                                                // trigger the evaluation code below to find out where we need to end the path early as it
                                                // crosses the threshold.
                                                const startTurnVector = vectors[vectorIndex - 2];
                                                startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                                                startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[3]);
                                            }
                                        }
                                    }
                                }
                                else {
                                    // The direct-to path is a single turn vector.
                                    if (isStartPastThreshold) {
                                        // If the start point is past the terminator threshold, we will end this leg at the start point and
                                        // set a fallback state.
                                        useImmediateFallback = true;
                                    }
                                    else {
                                        // If the start point is behind the terminator threshold, then it is possible the turn crosses past
                                        // the threshold before it ends. Therefore we will trigger the evaluation code below to find out if
                                        // we need to end the path early as it crosses the threshold.
                                        // If the direct course calculation produced only a single turn vector, it possibly reduced the radius
                                        // of the starting turn below the minimum radius in order to build a valid path to the terminator.
                                        // We always want the starting turn to respect the minimum turn radius, so we will define it ourselves.
                                        startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPath.encircles(endVec) ? 'left' : 'right'), this.geoCircleCache[3]);
                                        // If the direct course turn radius was reduced, then the terminator fix lies inside the starting turn
                                        // circle of minimum radius. Therefore, the turn technically never ends because there is no point on
                                        // the turn circle that either includes the terminator fix or is tangent to a great-circle path which
                                        // includes the terminator fix.
                                        if (Math.min(lastVector.radius, Math.PI - lastVector.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                                            startTurnEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[3]);
                                        }
                                    }
                                }
                                if (startTurnCircle !== undefined) {
                                    // Find the intersections of the direct-to starting turn circle with the terminator threshold.
                                    const intersections = this.intersectionCache;
                                    const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                                    // If the starting turn is tangent to the threshold, then the entire turn must be behind the threshold
                                    // because we are guaranteed that the start point is behind the threshold if we made it into this case.
                                    // Therefore, we only care about starting turns that are secant to the threshold.
                                    if (intersectionCount === 2) {
                                        // Because the start point is guaranteed to be behind the threshold, the next intersection of the
                                        // starting turn circle with the threshold will take the path past the threshold.
                                        const thresholdCrossing = intersections[0];
                                        const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                                        if (startTurnEnd === undefined
                                            || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                                            // The starting turn crosses the terminator threshold before the end of the turn (or the turn has
                                            // no end) -> end the turn at the crossing point and set the fallback state.
                                            vectorIndex = 0;
                                            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                                            state.isFallback = true;
                                        }
                                    }
                                }
                                if (useImmediateFallback) {
                                    vectorIndex = 0;
                                    ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                                    (_h = state.currentCourse) !== null && _h !== void 0 ? _h : (state.currentCourse = currentCourse);
                                    state.isFallback = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        const lastVector = vectors[vectorIndex - 1];
        if (lastVector !== undefined) {
            ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
];
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const originFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = originFacility === undefined ? 0 : MagVar.get(originFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            vectors.length = vectorIndex;
            return;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            vectors.length = vectorIndex;
            return;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            vectors.length = vectorIndex;
            return;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            vectors.length = vectorIndex;
            return;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        vectors.length = vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!startPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const normalizedEnd = startPoint.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, normalizedEnd);
        state.currentPosition = undefined;
        state.currentCourse = undefined;
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            const fixPosition = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
            if (fixPosition) {
                state.currentPosition = new GeoPoint(fixPosition.lat, fixPosition.lon);
            }
        }
        if (!state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const holdFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = holdFacility === undefined ? 0 : this.getLegMagVar(leg.leg, holdFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const calcs = legs[calculateIndex].calculated;
        const vectors = calcs.flightPath;
        const ingress = calcs.ingress;
        let vectorIndex = 0, ingressVectorIndex = 0;
        const holdPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            vectors.length = 0;
            ingress.length = 0;
            calcs.ingressJoinIndex = -1;
            return;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            ingressVectorIndex += this.greatCircleBuilder.build(ingress, ingressVectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const turnRadiusMeters = state.desiredHoldTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        const outboundTurnCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
        const turnRadiusRad = state.desiredHoldTurnRadius.asUnit(UnitType.GA_RADIAN);
        const outboundTurnCenter = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
        const outboundTurnEnd = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
        const oppositeCourse = NavMath.normalizeHeading(course + 180);
        const outboundEnd = outboundTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        const directionalEntryCourse = normalizedEntryCourse * turnDirectionSign;
        const isDirectEntry = directionalEntryCourse >= -70 && directionalEntryCourse <= 135;
        const skipRacetrack = leg.type === LegType.HF && !isDirectEntry;
        if (isDirectEntry) {
            // direct entry
            if (directionalEntryCourse > 0) {
                // The entry course is toward the outbound leg, so we just intercept the outbound leg directly, bypassing
                // the turn from the inbound to outbound leg.
                ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), outboundEnd, this.geoCircleCache[2].setAsGreatCircle(outboundTurnEnd, oppositeCourse), turnDirection, turnRadiusMeters, false, true, undefined, FlightPathVectorFlags.HoldDirectEntry);
                calcs.ingressJoinIndex = 1;
            }
            else if (BitFlags.isAny((_d = (_c = ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.AnticipatedTurn)) {
                // Don't erase turn anticipation for direct entries
                ingressVectorIndex = ingress.length;
            }
        }
        else if (directionalEntryCourse > 110) {
            // teardrop entry
            if (directionalEntryCourse > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse, FlightPathVectorFlags.HoldTeardropEntry | FlightPathVectorFlags.TurnToCourse);
                if (numTurnVectorsAdded > 0) {
                    ingressVectorIndex += numTurnVectorsAdded;
                    const turnVector = ingress[ingressVectorIndex - 1];
                    state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                    state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
                }
            }
            ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters, true, true, undefined, FlightPathVectorFlags.HoldTeardropEntry);
            if (skipRacetrack) {
                // If we skip the racetrack, remove the part of the hold entry that is coincident with the inbound leg
                const lastEntryVector = ingress[ingressVectorIndex - 1];
                if (lastEntryVector && FlightPathUtils.isVectorGreatCircle(lastEntryVector) && holdPos.equals(lastEntryVector.endLat, lastEntryVector.endLon)) {
                    if (UnitType.METER.convertTo(lastEntryVector.distance, UnitType.GA_RADIAN) > distance + GeoPoint.EQUALITY_TOLERANCE) {
                        const lastEntryVectorEnd = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
                        lastEntryVector.endLat = lastEntryVectorEnd.lat;
                        lastEntryVector.endLon = lastEntryVectorEnd.lon;
                        lastEntryVector.distance -= UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                    }
                    else {
                        ingressVectorIndex--;
                    }
                }
            }
            calcs.ingressJoinIndex = 0;
        }
        else if (directionalEntryCourse < -70) {
            // parallel entry
            const parallelCourse = course + 180;
            const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse, FlightPathVectorFlags.HoldParallelEntry | FlightPathVectorFlags.TurnToCourse);
            if (numTurnVectorsAdded > 0) {
                ingressVectorIndex += numTurnVectorsAdded;
                const turnVector = ingress[ingressVectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            }
            ingressVectorIndex += this.procTurnBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course, FlightPathVectorFlags.HoldParallelEntry);
            calcs.ingressJoinIndex = 0;
        }
        ingress.length = ingressVectorIndex;
        if (ingress.length === 0) {
            calcs.ingressJoinIndex = -1;
        }
        let inboundStart;
        if (skipRacetrack) {
            inboundStart = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
        }
        else {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, outboundTurnCenter, holdPos, outboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, outboundTurnEnd, outboundEnd, undefined, FlightPathVectorFlags.HoldOutboundLeg);
            const inboundTurnCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const inboundTurnCenter = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const inboundTurnEnd = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, inboundTurnCenter, outboundEnd, inboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            inboundStart = inboundTurnEnd;
        }
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, inboundStart, holdPos, undefined, FlightPathVectorFlags.HoldInboundLeg);
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        vectors.length = vectorIndex;
    }
}

/**
 * Utility class for working with flight plans.
 */
class FlightPlanUtils {
    /**
     * Checks if a leg type is an "to altitude" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "heading to" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    /**
* Checks if a leg type is a "to radial" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to radial" leg type.
     */
    static isToRadialLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.TO_RADIAL_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "hold" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "hold" leg type.
     */
    static isHoldLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a manual termination leg type that ends in a discontinuity.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a manual termination leg type that ends in a discontinuity.
     */
    static isManualDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a discontinuity leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a discontinuity leg type.
     */
    static isDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    /**
     * Gets the ICAO of the facility defining the terminator of a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The ICAO of the facility defining the terminator of the specified flight plan leg, or `undefined` if
     * the leg's terminator is not defined by a facility.
     */
    static getTerminatorIcao(leg) {
        switch (leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
                return leg.fixIcao;
            default:
                return undefined;
        }
    }
}
/** Array of "to altitude" leg types. */
FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
/** Array of "heading to" leg types. */
FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "to radial" leg types. */
FlightPlanUtils.TO_RADIAL_LEG_TYPES = [LegType.CR, LegType.VR];
/** Array of "hold" leg types. */
FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
/** Array of manual termination leg types that end in a discontinuity. */
FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
/** Array of discontinuity leg types. */
FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];

/**
 * A flight path calculator for turns between legs.
 */
class FlightPathTurnCalculator {
    constructor() {
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired general turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     */
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
        var _a, _b, _c, _d;
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const fromLeg = legs[currentIndex];
            const toLeg = legs[currentIndex + 1];
            const fromLegCalc = fromLeg === null || fromLeg === void 0 ? void 0 : fromLeg.calculated;
            const toLegCalc = toLeg === null || toLeg === void 0 ? void 0 : toLeg.calculated;
            if (fromLegCalc
                && toLegCalc
                && !FlightPlanUtils.isManualDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(toLeg.leg.type)) {
                const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
                const toVector = toLegCalc.flightPath[0];
                if (fromVector && toVector
                    && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))
                    && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                    if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
                        continue;
                    }
                    else if (toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                    else if (fromVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                }
            }
            if (fromLegCalc && BitFlags.isAll((_b = (_a = fromLegCalc.egress[0]) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, FlightPathVectorFlags.LegToLegTurn)) {
                fromLegCalc.egress.length = 0;
                fromLegCalc.egressJoinIndex = -1;
            }
            if (toLegCalc && BitFlags.isAll((_d = (_c = toLegCalc.ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
                toLegCalc.ingress.length = 0;
                toLegCalc.ingressJoinIndex = -1;
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        if (trackAngleDiff > 175) {
            return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (isRestrictedByPrevTurn) {
            if (previousTanTheta === undefined) {
                // Check to see if there is a ingress transition on the from leg and if it shares a common flight path vector
                // with the one involved in the turn currently being calculated.
                if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
                    const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
                    restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
                }
            }
            else {
                // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
                // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
                // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
                // previous turn. This will maximize min(radius_current, radius_prev).
                const tanThetaRatio = previousTanTheta / tanTheta;
                const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
                const cosTotalD = Math.cos(totalD);
                let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
                if (prevTurnRestrictedD > totalD) {
                    prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
                }
                restrictedD = prevTurnRestrictedD;
            }
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            // prevent zero-length turns
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        // Let the course reversal "cut"
        let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
                }
            }
        }
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
        const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? 'left' : 'right';
        const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === 'left' ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
        toLegCalc.ingress.length = length;
        toLegCalc.ingressJoinIndex = 0;
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        var _a, _b;
        var _c, _d;
        const fromLeg = legs[fromIndex];
        const toLeg = legs[toIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = fromLeg.calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = toLeg.calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        const areLegsContinuous = fromVectorEndPoint.equals(toVectorStartPoint, 1e-5);
        if (!areLegsContinuous) {
            // The from-leg does not end within ~60 meters of the start of the to-leg.
            let shouldQuit = true;
            // Either the from- or to- leg is an AF or RF leg. These legs often end up discontinuous with the preceding or
            // proceeding leg due to the arcs being slightly offset from the intended origin and/or terminator fixes.
            if (fromLeg.leg.type === LegType.AF
                || fromLeg.leg.type === LegType.RF
                || toLeg.leg.type === LegType.AF
                || toLeg.leg.type === LegType.RF) {
                shouldQuit = false;
            }
            if (shouldQuit) {
                return toIndex;
            }
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        // Define the circles
        const arcPath = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(arcPath, FlightPathTurnCalculator.geoPointCache[2]);
        const arcRadiusRad = FlightPathUtils.getTurnRadiusFromCircle(arcPath);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(arcPath);
        const arcCircle = FlightPathTurnCalculator.geoCircleCache[1].set(arcCenter, arcRadiusRad);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[2]);
        const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
        const fromVectorPath = isArcFirst ? arcPath : trackPath;
        const toVectorPath = isArcFirst ? trackPath : arcPath;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
        const arcTrackIntersectionCount = arcCircle.intersection(trackPath, arcTrackIntersections);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const fromVectorEndVec = fromVectorEndPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
        const toVectorStartVec = toVectorStartPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[1]);
        const fromVectorHalfDistanceRad = UnitType.METER.convertTo(fromVector.distance / 2, UnitType.GA_RADIAN);
        const toVectorHalfDistanceRad = UnitType.METER.convertTo(toVector.distance / 2, UnitType.GA_RADIAN);
        const intersectionPoint = FlightPathTurnCalculator.geoPointCache[4];
        const intersectionVec = FlightPathTurnCalculator.vector3Cache[2];
        let intersectionFromVectorEndOffset = 0;
        let intersectionToVectorStartOffset = 0;
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // The arc circle and track path are tangent.
            if (areLegsContinuous) {
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
            }
            else {
                // The from-leg does not end within ~60 meters of the start of the to-leg.
                Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                intersectionFromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, intersectionVec);
                intersectionToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, toVectorStartVec);
                if (!this.isArcTrackIntersectionValid(intersectionVec, fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersectionFromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersectionToVectorStartOffset)) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
            }
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                if (intersectionFromVectorEndOffset === 0 && intersectionToVectorStartOffset === 0) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                }
                else {
                    if (intersectionFromVectorEndOffset !== 0) {
                        // The intersection is not coincident with the end of the from-vector. The egress path will start 1
                        // nautical mile before the intersection point or at the end of the from-vector, whichever comes
                        // earlier (without going past the mid-point of the from-vector) and follow the from-vector path.
                        if (fromVectorHalfDistanceRad + intersectionFromVectorEndOffset <= 1e-5) {
                            // The intersection is at the mid-point of the from-vector.
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const egressStartVec = fromVectorPath.offsetDistanceAlong(intersectionVec, -Math.min(0.00029, Math.max(0, intersectionFromVectorEndOffset), fromVectorHalfDistanceRad + intersectionFromVectorEndOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, egressStartVec, intersectionVec);
                        }
                    }
                    if (intersectionToVectorStartOffset !== 0) {
                        // The intersection is not coincident with the start of the to-vector. The ingress path will end 1
                        // nautical mile after the intersection point or at the start of the to-vector, whichever comes
                        // later (without going past the mid-point of the to-vector) and follow the to-vector path.
                        if (toVectorHalfDistanceRad + intersectionToVectorStartOffset <= 1e-5) {
                            // The intersection is at the mid-point of the to-vector.
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const ingressEndVec = toVectorPath.offsetDistanceAlong(intersectionVec, Math.min(0.00029, Math.max(0, intersectionToVectorStartOffset), toVectorHalfDistanceRad + intersectionToVectorStartOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, ingressEndVec);
                        }
                    }
                }
                return toIndex;
            }
            else {
                intersectionPoint.setFromCartesian(intersectionVec);
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            // The arc circle and track path are secant.
            let arcStartVec;
            let arcEndVec;
            let fromVectorIntersectionBearing;
            let toVectorIntersectionBearing;
            if (areLegsContinuous) {
                intersectionPoint.set(fromVectorEndPoint);
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
                arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                fromVectorIntersectionBearing = fromVectorEndBearing;
                toVectorIntersectionBearing = toVectorStartBearing;
            }
            else {
                const intersection0FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[0]);
                const intersection0ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[0], toVectorStartVec);
                const intersection1FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[1]);
                const intersection1ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[1], toVectorStartVec);
                const isIntersection0Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[0], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection0FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection0ToVectorStartOffset);
                const isIntersection1Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[1], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection1FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection1ToVectorStartOffset);
                if (!isIntersection0Valid && !isIntersection1Valid) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
                let intersectionIndex;
                if (!isIntersection0Valid) {
                    intersectionIndex = 1;
                }
                else if (!isIntersection1Valid) {
                    intersectionIndex = 0;
                }
                else {
                    // Both intersections are valid. We will bias toward intersections that lie after the end of the from-vector
                    // and before the start of the to-vector.
                    if (intersection0FromVectorEndOffset + intersection0ToVectorStartOffset >= intersection1FromVectorEndOffset + intersection1ToVectorStartOffset) {
                        intersectionIndex = 0;
                    }
                    else {
                        intersectionIndex = 1;
                    }
                }
                if (intersectionIndex === 0) {
                    Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                    intersectionFromVectorEndOffset = intersection0FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection0ToVectorStartOffset;
                }
                else if (isIntersection1Valid) {
                    Vec3Math.copy(arcTrackIntersections[1], intersectionVec);
                    intersectionFromVectorEndOffset = intersection1FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection1ToVectorStartOffset;
                }
                intersectionPoint.setFromCartesian(intersectionVec);
                if (isArcFirst) {
                    arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                    arcEndVec = intersectionVec;
                }
                else {
                    arcStartVec = intersectionVec;
                    arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                }
                fromVectorIntersectionBearing = fromVectorPath.bearingAt(intersectionVec, Math.PI);
                toVectorIntersectionBearing = toVectorPath.bearingAt(intersectionVec, Math.PI);
            }
            const arcStartRadial = arcCircle.bearingAt(arcStartVec, Math.PI) + 90;
            const arcEndRadial = arcCircle.bearingAt(arcEndVec, Math.PI) + 90;
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), toVectorIntersectionBearing)) >= 90
                : Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), fromVectorIntersectionBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, intersectionVec, FlightPathTurnCalculator.vector3Cache[5]);
            // If the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadiusRad))
                : Infinity;
            const trackLimitPoint = FlightPathTurnCalculator.geoPointCache[5];
            if (isArcFirst) {
                const trackLimitDistance = Math.min(toVectorHalfDistanceRad + intersectionToVectorStartOffset, maxTrackLimitDistance);
                intersectionPoint.offset(toVectorStartBearing, trackLimitDistance, trackLimitPoint);
            }
            else {
                const trackLimitDistance = Math.min(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset, maxTrackLimitDistance);
                intersectionPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, trackLimitPoint);
            }
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(trackPath.center, arcCircle.center);
            const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // Compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = FlightPathTurnCalculator.geoCircleCache[4].setAsGreatCircle(arcDirection === 'left' ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            // the angular width of the portion of the arc path from the intersection to the mid-point of the arc vector
            const arcMidPointAngularWidth = Avionics.Utils.RAD2DEG * (isArcFirst
                ? fromVectorPath.angularWidth(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset)
                : toVectorPath.angularWidth(toVectorHalfDistanceRad + intersectionToVectorStartOffset));
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcMidPointAngularWidth);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * ((arcDirection === 'left') === isArcFirst ? 1 : -1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadiusRad, FlightPathTurnCalculator.geoPointCache[5]);
                const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadiusRad));
                        arcTurnRadiusLimit = (arcRadiusRad - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[5]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[6]), FlightPathTurnCalculator.vector3Cache[6]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[3].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[4].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || intersectionPoint.distance(intersections[0]) >= intersectionPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
        const turnRadiusMeters = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusMeters, turnCenter, turnStart, turnMiddle, turnEnd, areLegsContinuous);
        // If the from- and to- legs are not continuous, then we need to check if we need to extend the turn anticipation
        // path beyond the turn vector to join the from- and to- vectors. If the legs are continuous, we don't need to
        // check because the turn vector is guaranteed to begin before the end of the from-vector and end after the start
        // of the to-vector.
        if (!areLegsContinuous) {
            const intersectionTurnStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, turnStart, intersectionVec);
            const intersectionTurnEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, turnEnd);
            if (intersectionTurnStartOffset > intersectionFromVectorEndOffset + 1e-5) {
                // The turn begins after the end of the from-vector. We need to join the turn vector to the end of the
                // from-vector.
                Object.assign((_a = (_c = fromLegCalc.egress)[1]) !== null && _a !== void 0 ? _a : (_c[1] = FlightPathUtils.createEmptyCircleVector()), fromLegCalc.egress[0]);
                FlightPathUtils.setCircleVector(fromLegCalc.egress[0], fromVectorPath, fromVectorEndPoint, turnStart, fromLegCalc.egress[0].flags);
                fromLegCalc.egress.length = 2;
            }
            else {
                fromLegCalc.egress.length = 1;
            }
            if (intersectionTurnEndOffset < intersectionToVectorStartOffset - 1e-5) {
                // The turn ends before the start of the to-vector. We need to join the turn vector to the start of the
                // to-vector.
                (_b = (_d = toLegCalc.ingress)[1]) !== null && _b !== void 0 ? _b : (_d[1] = FlightPathUtils.createEmptyCircleVector());
                FlightPathUtils.setCircleVector(toLegCalc.ingress[1], toVectorPath, turnEnd, toVectorStartPoint, toLegCalc.ingress[0].flags);
                toLegCalc.ingress.length = 2;
            }
            else {
                toLegCalc.ingress.length = 1;
            }
        }
        return toIndex;
    }
    /**
     * Checks if an intersection between an arc path and a track path is valid for computing turn anticipation between
     * arc and track vectors. The intersection is considered valid if and only if all the following conditions are true:
     * - The intersection is within one nautical mile of the end of the vector on which the turn begins.
     * - The intersection is within one nautical mile of the start of the vector on which the turn ends.
     * - The intersection is located after the mid-point of the vector on which the turn begins.
     * - The intersection is located before the mid-point of the vector on which the turn ends.
     * @param intersection The intersection to check.
     * @param fromVectorPath A geo circle defining the path of the vector on which the turn begins.
     * @param fromVectorEnd The end point of the vector on which the turn begins.
     * @param fromVectorHalfDistance Half of the distance covered by the vector on which the turn begins.
     * @param intersectionFromVectorEndOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the end point of the vector on which the turn begins. Positive offsets indicate the intersection is located
     * after the end point.
     * @param toVectorPath A geo circle defining the path of the vector on which the turn ends.
     * @param toVectorStart The start point of the vector on which the turn ends.
     * @param toVectorHalfDistance Half of the distance covered by the vector on which the turn ends.
     * @param intersectionToVectorStartOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the start point of the vector on which the turn ends. Positive offsets indicate the intersection is located
     * before the start point.
     * @returns Whether the specified intersection is valid for computing turn anticipation between arc and track
     * vectors.
     */
    isArcTrackIntersectionValid(intersection, fromVectorPath, fromVectorEnd, fromVectorHalfDistance, intersectionFromVectorEndOffset, toVectorPath, toVectorStart, toVectorHalfDistance, intersectionToVectorStartOffset) {
        const fromVectorMidVec = fromVectorPath.offsetDistanceAlong(fromVectorEnd, -fromVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[0], Math.PI);
        const toVectorMidVec = toVectorPath.offsetDistanceAlong(toVectorStart, toVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[1], Math.PI);
        return (Math.abs(intersectionFromVectorEndOffset) <= 2.9e-4
            && Math.abs(intersectionToVectorStartOffset) <= 2.9e-4
            && FlightPathUtils.isPointAlongArc(fromVectorPath, fromVectorMidVec, Math.PI, intersection)
            && !FlightPathUtils.isPointAlongArc(toVectorPath, toVectorMidVec, Math.PI, intersection));
    }
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyTurn(fromLegCalc, toLegCalc) {
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        toLegCalc.ingress.length = 0;
        toLegCalc.ingressJoinIndex = -1;
    }
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressEgressArrayLengths Whether to set the ingress and egress vector array lengths to 1. Defaults to
     * `true`.
     */
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end, setIngressEgressArrayLengths = true) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
        this.setAnticipatedTurnEgress(fromLegCalc, circle, start, middle, setIngressEgressArrayLengths);
        this.setAnticipatedTurnIngress(toLegCalc, circle, middle, end, setIngressEgressArrayLengths);
    }
    /**
     * Adds an egress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn begins.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the turn.
     * @param end The location of the end of the egress portion of the turn.
     * @param setEgressArrayLength Whether to set the egress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnEgress(legCalc, circle, start, end, setEgressArrayLength = true) {
        var _a;
        var _b;
        const egress = (_a = (_b = legCalc.egress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setEgressArrayLength) {
            legCalc.egress.length = 1;
        }
        legCalc.egressJoinIndex = legCalc.flightPath.length - 1;
        const egressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(egress, circle, start, end, egressFlags);
    }
    /**
     * Adds an ingress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn ends.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the ingress portion of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressArrayLength Whether to set the ingress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnIngress(legCalc, circle, start, end, setIngressArrayLength = true) {
        var _a;
        var _b;
        const ingress = (_a = (_b = legCalc.ingress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setIngressArrayLength) {
            legCalc.ingress.length = 1;
        }
        legCalc.ingressJoinIndex = 0;
        const ingressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(ingress, circle, start, end, ingressFlags);
    }
    /**
     * Gets the along-circle offset distance from a reference point to a query point, in great-arc radians. The offset
     * is signed, with positive values indicating offsets in the direction of the circle. The calculated offset has the
     * range `[-c / 2, c / 2)`, where `c` is the circumference of the circle.
     * @param circle The geo circle along which to measure the offset.
     * @param reference The reference point.
     * @param query The query point.
     * @param equalityTolerance The tolerance for considering the reference and query points to be equal, in great-arc
     * radians. If the absolute (direction-agnostic) along-circle distance between the reference and query points is less
     * than or equal to this value, then zero will be returned. Defaults to `0`.
     * @returns The along-circle offset distance from the specified reference point to the query point, in great-arc
     * radians.
     */
    static getAlongCircleOffset(circle, reference, query, equalityTolerance) {
        const circumference = circle.arcLength(MathUtils.TWO_PI);
        const halfCircumference = circumference / 2;
        return (circle.distanceAlong(reference, query, Math.PI, equalityTolerance) + halfCircumference) % circumference - halfCircumference;
    }
}
FlightPathTurnCalculator.vector3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
];
FlightPathTurnCalculator.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.isArcTrackIntersectionValidCache = {
    vec3: [Vec3Math.create(), Vec3Math.create()]
};
FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
};

/**
 * Modes for calculating airplane speed for use in flight path calculations.
 */
var FlightPathAirplaneSpeedMode;
(function (FlightPathAirplaneSpeedMode) {
    /** The default airplane speed is always used. */
    FlightPathAirplaneSpeedMode["Default"] = "Default";
    /** Ground speed is used. */
    FlightPathAirplaneSpeedMode["GroundSpeed"] = "GroundSpeed";
    /** True airspeed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeed"] = "TrueAirspeed";
    /** True airspeed plus wind speed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
})(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader, options, bus) {
        var _a, _b;
        this.facilityLoader = facilityLoader;
        this.bus = bus;
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.turnCalculator = new FlightPathTurnCalculator();
        this.state = new FlightPathStateClass();
        this.calculateQueue = [];
        this.isBusy = false;
        this.id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : '';
        const optionsCopy = Object.assign({}, options);
        delete optionsCopy.id;
        this.options = optionsCopy;
        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
        const eventBusTopicSuffix = this.id === '' ? '' : `_${this.id}`;
        const publisher = this.bus.getPublisher();
        const sub = this.bus.getSubscriber();
        const initialSyncRole = (_b = options.initSyncRole) !== null && _b !== void 0 ? _b : 'none';
        if (initialSyncRole === 'primary') {
            publisher.pub(`flightpath_sync_init${eventBusTopicSuffix}`, { options: this.options }, true, false);
            sub.on(`flightpath_sync_options_request${eventBusTopicSuffix}`).handle(uid => {
                publisher.pub(`flightpath_sync_options_response${eventBusTopicSuffix}`, { uid, options: this.options }, true, false);
            });
        }
        else if (initialSyncRole === 'replica') {
            const requestUid = Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER);
            sub.on(`flightpath_sync_options_response${eventBusTopicSuffix}`).handle(data => {
                if (data.uid === requestUid) {
                    this.setOptions(data.options);
                }
            });
            publisher.pub(`flightpath_sync_options_request${eventBusTopicSuffix}`, requestUid, true, false);
            sub.on(`flightpath_sync_init${eventBusTopicSuffix}`).handle(data => { this.setOptions(data.options); });
        }
        sub.on(`flightpath_set_options${eventBusTopicSuffix}`).handle(this.setOptions.bind(this));
    }
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    setOptions(newOptions) {
        for (const key in newOptions) {
            const option = newOptions[key];
            if (option !== undefined) {
                this.options[key] = option;
                switch (key) {
                    case 'bankAngle':
                        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
                        break;
                    case 'holdBankAngle':
                        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
                        break;
                    case 'courseReversalBankAngle':
                        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
                        break;
                    case 'turnAnticipationBankAngle':
                        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
                        break;
                }
            }
        }
    }
    /**
     * Builds a bank angle lookup table.
     * @param angle A constant bank angle, in degrees, or an array of bank angle (degrees) versus airplane speed (knots)
     * breakpoints.
     * @returns A bank angle lookup table.
     */
    buildBankAngleTable(angle) {
        if (typeof angle === 'number') {
            return new LerpLookupTable([[angle, 0]]);
        }
        else {
            return new LerpLookupTable(angle);
        }
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDmeLegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDmeLegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: calc = new NoPathLegCalculator(this.facilityCache),
            [LegType.ThruDiscontinuity]: calc
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        if (this.isBusy || this.calculateQueue.length > 0) {
            return new Promise((resolve, reject) => {
                this.calculateQueue.push(() => { this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count); });
            });
        }
        else {
            return new Promise((resolve, reject) => {
                this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count);
            });
        }
    }
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    async doCalculate(resolve, reject, legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        this.isBusy = true;
        try {
            initialIndex = Math.max(0, initialIndex);
            count = Math.max(0, Math.min(legs.length - initialIndex, count));
            this.state.updatePlaneState(this.options, this.bankAngleTable, this.holdBankAngleTable, this.courseReversalBankAngleTable, this.turnAnticipationBankAngleTable);
            // Because some facilities can be mutated, we always want to get the most up-to-date version from the facility loader
            this.facilityCache.clear();
            await this.loadFacilities(legs, initialIndex, count);
            this.initCurrentLatLon(legs, initialIndex);
            this.initCurrentCourse(legs, initialIndex);
            this.initIsFallback(legs, initialIndex);
            this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
            this.turnCalculator.computeTurns(legs, initialIndex, count, this.state.desiredTurnRadius.asUnit(UnitType.METER), this.state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), this.state.desiredTurnAnticipationTurnRadius.asUnit(UnitType.METER));
            this.resolveLegsIngressToEgress(legs, initialIndex, count);
            this.updateLegDistances(legs, initialIndex, count);
            this.isBusy = false;
            resolve();
        }
        catch (e) {
            this.isBusy = false;
            reject(e);
        }
        const nextInQueue = this.calculateQueue.shift();
        if (nextInQueue !== undefined) {
            nextInQueue();
        }
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (ICAO.isFacility(icao)) {
            facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                .then(facility => {
                this.facilityCache.set(icao, facility);
                return true;
            })
                .catch(() => false));
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) || FlightPlanUtils.isManualDiscontinuityLeg(leg.leg.type)) {
                break;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initIsFallback(legs, initialIndex) {
        var _a, _b, _c;
        this.state.isFallback = (_c = (_b = (_a = legs[Math.min(initialIndex, legs.length) - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endsInFallback) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        const definition = legs[calculateIndex];
        const calcs = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state, false);
        const start = calcs.flightPath[0];
        const end = calcs.flightPath[calcs.flightPath.length - 1];
        calcs.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                calcs.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        calcs.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        calcs.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        calcs.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        calcs.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            calcs.endLat = this.state.currentPosition.lat;
            calcs.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    resolveLegsIngressToEgress(legs, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const legCalc = legs[i].calculated;
            legCalc && FlightPathUtils.resolveIngressToEgress(legCalc);
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistances(legs, initialIndex, count) {
        var _a, _b, _c, _d, _e, _f;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            // Calculate distance without transitions
            calc.distance = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distance += calc.flightPath[j].distance;
            }
            calc.cumulativeDistance = calc.distance + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
            // Calculate distance with transitions
            calc.distanceWithTransitions = 0;
            const ingressLen = calc.ingress.length;
            for (let j = 0; j < ingressLen; j++) {
                calc.distanceWithTransitions += calc.ingress[j].distance;
            }
            const ingressToEgressLen = calc.ingressToEgress.length;
            for (let j = 0; j < ingressToEgressLen; j++) {
                calc.distanceWithTransitions += calc.ingressToEgress[j].distance;
            }
            const egressLen = calc.egress.length;
            for (let j = 0; j < egressLen; j++) {
                calc.distanceWithTransitions += calc.egress[j].distance;
            }
            calc.cumulativeDistanceWithTransitions = calc.distanceWithTransitions + ((_f = (_e = (_d = legs[i - 1]) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
    }
}
/**
 * An implementation of {@link FlightPathState}
 */
class FlightPathStateClass {
    constructor() {
        this.isFallback = false;
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
        this._desiredHoldTurnRadius = UnitType.METER.createNumber(0);
        this.desiredHoldTurnRadius = this._desiredHoldTurnRadius.readonly;
        this._desiredCourseReversalTurnRadius = UnitType.METER.createNumber(0);
        this.desiredCourseReversalTurnRadius = this._desiredCourseReversalTurnRadius.readonly;
        this._desiredTurnAnticipationTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnAnticipationTurnRadius = this._desiredTurnAnticipationTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     * @param bankAngleTable A lookup table for general turn bank angle, in degrees, versus airplane speed.
     * @param holdBankAngleTable A lookup table for hold turn bank angle, in degrees, versus airplane speed, in knots.
     * If not defined, the general turn bank angle table will be used instead.
     * @param courseReversalBankAngleTable A lookup table for course reversal turn bank angle, in degrees, versus
     * airplane speed, in knots. If not defined, the general turn bank angle table will be used instead.
     * @param turnAnticipationBankAngleTable A lookup table for turn anticipation bank angle, in degrees, versus airplane
     * speed, in knots. If not defined, the general turn bank angle table will be used instead.
     */
    updatePlaneState(options, bankAngleTable, holdBankAngleTable, courseReversalBankAngleTable, turnAnticipationBankAngleTable) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        switch (options.airplaneSpeedMode) {
            case FlightPathAirplaneSpeedMode.GroundSpeed:
                this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
                break;
            case FlightPathAirplaneSpeedMode.TrueAirspeed:
            case FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind: {
                const trueAirspeed = SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots);
                const windSpeed = options.airplaneSpeedMode === FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
                    ? SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', SimVarValueType.Knots)
                    : 0;
                this._planeSpeed.set(Math.max(trueAirspeed + windSpeed, options.defaultSpeed));
                break;
            }
            default:
                this._planeSpeed.set(options.defaultSpeed);
        }
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        const planeSpeedKnots = this._planeSpeed.asUnit(UnitType.KNOT);
        this._desiredTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(bankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        if (holdBankAngleTable) {
            this._desiredHoldTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(holdBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredHoldTurnRadius.set(this._desiredTurnRadius);
        }
        if (courseReversalBankAngleTable) {
            this._desiredCourseReversalTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(courseReversalBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredCourseReversalTurnRadius.set(this._desiredTurnRadius);
        }
        if (turnAnticipationBankAngleTable) {
            this._desiredTurnAnticipationTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(turnAnticipationBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredTurnAnticipationTurnRadius.set(this._desiredTurnRadius);
        }
    }
}

/** Utility functions for working with UUIDs. */
class UUID {
    /**
     * A function to generate a spec-compliand v4 UUID in a 32-bit safe way.
     * @returns A UUID in standard 8-4-4-4-12 notation.
     */
    static GenerateUuid() {
        const scale = 2 ** 32;
        const first = UUID.bytesToHexString(Math.random() * scale);
        const fourth = UUID.bytesToHexString(Math.random() * scale);
        let secondBits = Math.random() * scale;
        let thirdBits = Math.random() * scale;
        // 4 MSB of seventh byte = 0100
        secondBits |= 0b00000000000000000100000000000000;
        secondBits &= 0b11111111111111110100111111111111;
        const second = UUID.bytesToHexString(secondBits);
        // 2 MSB of ninth byte = 10;
        thirdBits |= 0b10000000000000000000000000000000;
        thirdBits &= 0b10111111111111111111111111111111;
        const third = UUID.bytesToHexString(thirdBits);
        return `${first}-${second.substring(0, 4)}-${second.substring(4)}-${third.substring(0, 4)}-${third.substring(4)}${fourth}`;
    }
    /**
     * Take a number and return its hexadecimal representation.
     * @param bits The bytes to format.
     * @returns The input bits as a hexadecimal string.
     */
    static bytesToHexString(bits) {
        let string = (bits >>> 0).toString(16);
        string = '00000000'.substring(string.length) + string;
        return string;
    }
}

var LegEventType;
(function (LegEventType) {
    LegEventType["Added"] = "Added";
    LegEventType["Removed"] = "Removed";
    LegEventType["Changed"] = "Changed";
})(LegEventType || (LegEventType = {}));
var SegmentEventType;
(function (SegmentEventType) {
    SegmentEventType["Added"] = "Added";
    SegmentEventType["Removed"] = "Removed";
    SegmentEventType["Changed"] = "Changed";
    SegmentEventType["Inserted"] = "Inserted";
})(SegmentEventType || (SegmentEventType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
        // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
* Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex, calculator, onLegNameRequested) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
        this.batchEntryStack = [];
        this.batchToCloseIndex = undefined;
    }
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length - 1` if `reverse` is `true`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse = false, startIndex, endIndex) {
        return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
     * @yields This flight plan's legs in forward order.
     */
    *_legs(startIndex = 0, endIndex = this.length) {
        endIndex = Math.min(this.length, endIndex);
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.min(segment.legs.length, endIndex - segment.offset);
                if (end <= 0) {
                    return;
                }
                for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
     * @yields This flight plan's legs in reverse order.
     */
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
        endIndex = Math.max(-1, endIndex);
        for (let i = this.planSegments.length - 1; i > -1; i--) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.max(-1, endIndex - segment.offset);
                if (end >= segment.legs.length) {
                    return;
                }
                for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        const segment = this.tryGetSegment(segmentIndex);
        if (segment === null) {
            throw new Error(`Flight plan segment with ${segmentIndex === undefined ? 'active leg' : `segment index ${segmentIndex}`} could not be found.`);
        }
        else {
            return segment;
        }
    }
    /**
     * Attempts to get a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment, or `null` if it could not be found.
     */
    tryGetSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        return null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLeg(arg1, arg2) {
        const leg = this._tryGetLeg(arg1, arg2);
        if (leg) {
            return leg;
        }
        throw new Error(`Leg with ${arg2 === undefined ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    tryGetLeg(arg1, arg2) {
        return this._tryGetLeg(arg1, arg2);
    }
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    _tryGetLeg(arg1, arg2) {
        var _a, _b;
        if (arg2 === undefined) {
            const legIndex = arg1;
            for (const segment of this.segments()) {
                if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                    return segment.legs[legIndex - segment.offset];
                }
            }
            return null;
        }
        else {
            const segmentIndex = arg1;
            const segmentLegIndex = arg2;
            return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
        }
    }
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex) {
        const segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex === -1) {
            return -1;
        }
        return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
* Finds a leg in this flight plan that satisfies a given condition.
     * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
     * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
     * `false` otherwise.
     * @param reverse Whether to evaluate the legs in reverse order. Defaults to `false`.
     * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length - 1` if `reverse` is `true`.
     * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
     * predicate function, or `null` if no leg satisfies the condition.
     */
    findLeg(predicate, reverse = false, startIndex, endIndex) {
        return reverse
            ? this.findLegReverse(predicate, startIndex, endIndex)
            : this.findLegForward(predicate, startIndex, endIndex);
    }
    /**
     * Evaluates legs in this flight plan in forward order and returns the first evaluated leg that satisfies a given
     * condition.
     * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
     * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
     * `false` otherwise.
     * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `this.length`.
     * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
     * predicate function, or `null` if no leg satisfies the condition.
     */
    findLegForward(predicate, startIndex = 0, endIndex = this.length) {
        endIndex = Math.min(this.length, endIndex);
        for (let segmentIndex = 0; segmentIndex < this.planSegments.length; segmentIndex++) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.min(segment.legs.length, endIndex - segment.offset);
                if (end <= 0) {
                    return null;
                }
                for (let segmentLegIndex = Math.max(0, startIndex - segment.offset); segmentLegIndex < end; segmentLegIndex++) {
                    if (predicate(segment.legs[segmentLegIndex], segment, segment.segmentIndex, segmentLegIndex, this)) {
                        return segment.legs[segmentLegIndex];
                    }
                }
            }
        }
        return null;
    }
    /**
     * Evaluates legs in this flight plan in reverse order and returns the first evaluated leg that satisfies a given
     * condition.
     * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
     * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
     * `false` otherwise.
     * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `-1`.
     * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
     * predicate function, or `null` if no leg satisfies the condition.
     */
    findLegReverse(predicate, startIndex = this.length - 1, endIndex = -1) {
        endIndex = Math.max(-1, endIndex);
        for (let segmentIndex = this.planSegments.length - 1; segmentIndex > -1; segmentIndex--) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.max(-1, endIndex - segment.offset);
                if (end >= segment.legs.length) {
                    return null;
                }
                for (let segmentLegIndex = Math.min(segment.legs.length - 1, startIndex - segment.offset); segmentLegIndex > end; segmentLegIndex--) {
                    if (predicate(segment.legs[segmentLegIndex], segment, segment.segmentIndex, segmentLegIndex, this)) {
                        return segment.legs[segmentLegIndex];
                    }
                }
            }
        }
        return null;
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Gets the current modification batch stack.
     * @returns The current modification batch stack, or `undefined` if there are no open batches.
     */
    getBatchStack() {
        return this.batchEntryStack.length > 0 ? this.batchEntryStack.map(entry => entry.batch) : undefined;
    }
    /**
     * Opens a new modification batch. The new batch will be nested within the most recently opened batch that has not
     * yet been closed. While a batch is open, all modifications made to this flight plan will be assigned to the batch.
     * The use of batches is informational only and will not affect the timing or execution of flight plan modifications.
     * All modifications are carried out immediately when the corresponding method is called regardless of whether they
     * are assigned to a batch.
     * @param name The name to assign to the new batch.
     * @returns The UUID of the new batch.
     */
    openBatch(name) {
        const parent = this.batchEntryStack[this.batchEntryStack.length - 1];
        const uuid = UUID.GenerateUuid();
        const batch = { uuid, name };
        const entry = {
            batch,
            parent,
            isClosed: false,
            pendingCalculateCount: 0,
        };
        this.batchEntryStack.push(entry);
        this.events.onBatchOpened && this.events.onBatchOpened(batch);
        return uuid;
    }
    /**
     * Closes a modification batch.
     * @param uuid The UUID of the batch to close. If defined, then the batch with the specified UUID and all open
     * batches that are nested within it will be closed (with the most-nested batch closed first, followed by the next
     * most-nested batch, and so on). If not defined, then the most recently opened batch that has not yet been closed
     * (i.e. the most-nested open batch) will be closed.
     */
    closeBatch(uuid) {
        let stopIndex = this.batchEntryStack.length;
        if (uuid === undefined) {
            if (this.batchEntryStack.length > 0) {
                stopIndex = this.batchEntryStack.length - 1;
            }
        }
        else {
            const index = this.batchEntryStack.findIndex(entry => entry.batch.uuid === uuid);
            if (index >= 0) {
                stopIndex = index;
            }
        }
        this.closeBatchIndex(stopIndex);
    }
    /**
     * Closes all currently open modification batches.
     */
    closeAllBatches() {
        this.closeBatchIndex(0);
    }
    /**
     * Closes an indexed modification batch and all batches that are nested within it.
     * @param index The index of the batch to close.
     */
    closeBatchIndex(index) {
        index = Math.max(index, 0);
        // Check if a batch closure operation is currently in progress. If one is not, then start a new batch closure
        // operation. If one is in progress, then mark the index of the new batch to close if and only if it is less-
        // nested than the in-progress operation's current batch to close.
        if (this.batchToCloseIndex === undefined) {
            this.batchToCloseIndex = index;
            while (this.batchEntryStack.length > this.batchToCloseIndex) {
                const entry = this.batchEntryStack.pop();
                const currentBatchToCloseIndex = this.batchToCloseIndex;
                const isClosingLast = this.batchEntryStack.length === currentBatchToCloseIndex + 1;
                entry.isClosed = true;
                this.events.onBatchClosed && this.events.onBatchClosed(entry.batch);
                if (entry.pendingCalculateCount === 0) {
                    this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(entry.batch);
                }
                // If we closed the last batch and no less-nested batches were marked for closure, then we will end the
                // loop. This is to prevent us from closing any batches that were newly opened in the callbacks for closing
                // the last batch.
                if (isClosingLast && this.batchToCloseIndex === currentBatchToCloseIndex) {
                    break;
                }
            }
            this.batchToCloseIndex = undefined;
        }
        else {
            this.batchToCloseIndex = Math.min(this.batchToCloseIndex, index);
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment, this.getBatchStack());
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment, this.getBatchStack());
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = {
            name: this.onLegNameRequested(leg),
            leg,
            flags,
            verticalData: {
                phase: VerticalFlightPhase.Descent,
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0,
                displayAltitude1AsFlightLevel: false,
                displayAltitude2AsFlightLevel: false,
                isAltitude1TempCompensated: false,
                isAltitude2TempCompensated: false,
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS,
            },
            userData: {}
        };
        if (segmentLegIndex === undefined) {
            segment.legs.push(legDefinition);
            segmentLegIndex = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(segmentLegIndex, 0, legDefinition);
        }
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition, this.getBatchStack());
        return legDefinition;
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (segmentLegIndex === undefined) {
            legDefinition = segment.legs.pop();
            segmentLegIndex = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(segmentLegIndex, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition, this.getBatchStack());
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao, this.getBatchStack());
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao, this.getBatchStack());
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao, this.getBatchStack());
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalRunway = undefined;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao, this.getBatchStack());
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral, this.getBatchStack());
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical, this.getBatchStack());
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating, this.getBatchStack());
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        // We iterate of the keys of `details` because we need to be able to set fields to undefined
        // and we only want to overwrite fields that were in the `details` object
        for (const key of Object.keys(details)) {
            this.procedureDetails[key] = details[key];
        }
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails, this.getBatchStack());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            const globalLegIndex = arg1;
            if (globalLegIndex >= 0) {
                segmentIndex = this.getSegmentIndex(globalLegIndex);
                if (segmentIndex >= 0) {
                    segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData, this.getBatchStack());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegVerticalData(arg1, arg2, arg3, arg4) {
        let notify = true;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let verticalData;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            verticalData = arg2;
            notify = arg3 !== undefined ? arg3 : notify;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            verticalData = arg3;
            notify = arg4 !== undefined ? arg4 : notify;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            Object.assign(leg.verticalData, verticalData);
            notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg, this.getBatchStack());
        }
        else {
            console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment, this.getBatchStack());
    }
    /**
     * Sets a global key-value user data pair for this flight plan. Setting a key's user data to `undefined` will delete
     * the key instead.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers. Defaults to true.
     */
    setUserData(key, data, notify = true) {
        if (data === undefined) {
            this.deleteUserData(key, notify);
            return;
        }
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data, this.getBatchStack());
    }
    /**
     * Deletes a global key-value user data pair for this flight plan.
     * @param key The key to delete.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key, this.getBatchStack());
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegUserData(arg1, arg2, arg3, arg4, arg5) {
        let notify;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let key;
        let data;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            key = arg2;
            data = arg3;
            notify = arg4 === undefined ? true : arg4;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            key = arg3;
            data = arg4;
            notify = arg5 === undefined ? true : arg5;
        }
        if (data === undefined) {
            this.deleteLegUserData(segmentIndex, segmentLegIndex, key, notify);
            return;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            leg.userData[key] = data;
            notify && this.events.onLegUserDataSet && this.events.onLegUserDataSet(segmentIndex, segmentLegIndex, leg, key, data, this.getBatchStack());
        }
        else {
            console.warn(`FlightPlan: failed to set leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    deleteLegUserData(arg1, arg2, arg3, arg4) {
        let notify;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let key;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            key = arg2;
            notify = arg3 === undefined ? true : arg3;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            key = arg3;
            notify = arg4 === undefined ? true : arg4;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            delete leg.userData[key];
            notify && this.events.onLegUserDataDelete && this.events.onLegUserDataDelete(segmentIndex, segmentLegIndex, leg, key, this.getBatchStack());
        }
        else {
            console.warn(`FlightPlan: failed to delete leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = undefined, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        this.procedureDetails.arrivalRunway = arrivalRunway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
    }
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(globalLegIndex, notify = true) {
        const batchStack = this.getBatchStack();
        const batchEntry = this.batchEntryStack[this.batchEntryStack.length - 1];
        let currentBatchEntry = batchEntry;
        while (currentBatchEntry) {
            currentBatchEntry.pendingCalculateCount++;
            currentBatchEntry = currentBatchEntry.parent;
        }
        notify && this.events.onCalculatePended && this.events.onCalculatePended(globalLegIndex, batchStack);
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);
        notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex, batchStack);
        currentBatchEntry = batchEntry;
        while (currentBatchEntry) {
            currentBatchEntry.pendingCalculateCount--;
            if (currentBatchEntry.isClosed && currentBatchEntry.pendingCalculateCount === 0) {
                this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(currentBatchEntry.batch);
            }
            currentBatchEntry = currentBatchEntry.parent;
        }
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @returns The copied flight plan.
     */
    copy(planIndex, copyCalcs = false) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        newPlan.copyFrom(this, copyCalcs);
        return newPlan;
    }
    /**
     * Copies a source flight plan into this one, overriding everything in this plan with everything from the source plan.
     * @param sourcePlan The plan to copy from.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     */
    copyFrom(sourcePlan, copyCalcs = false) {
        if (sourcePlan._originAirport !== undefined) {
            this.setOriginAirport(sourcePlan._originAirport, false);
        }
        else {
            this.removeOriginAirport(false);
        }
        if (sourcePlan._destinationAirport !== undefined) {
            this.setDestinationAirport(sourcePlan._destinationAirport, false);
        }
        else {
            this.removeDestinationAirport(false);
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        this.setProcedureDetails(Object.assign(new ProcedureDetails(), sourcePlan.procedureDetails), false);
        const targetPlanSegmentsCount = this.planSegments.length;
        for (let i = 0; i < targetPlanSegmentsCount; i++) {
            this.removeSegment(0, false);
        }
        for (let i = 0; i < sourcePlan.planSegments.length; i++) {
            const segment = sourcePlan.planSegments[i];
            if (segment !== undefined) {
                this.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
                for (const leg of segment.legs) {
                    const newLeg = this.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
                    const legIndex = this.getLegIndexFromLeg(newLeg);
                    this.setLegVerticalData(legIndex, leg.verticalData, false);
                    for (const key in leg.userData) {
                        this.setLegUserData(legIndex, key, leg.userData[key], false);
                    }
                    copyCalcs && FlightPlan.copyLegCalculations(leg, newLeg);
                }
            }
        }
        this.setDirectToData(sourcePlan.directToData.segmentIndex, sourcePlan.directToData.segmentLegIndex, false);
        // Have to copy from the private fields, because the public ones are getters, which would be lost when stringified
        this.setLateralLeg(sourcePlan._activeLateralLeg, false);
        this.setVerticalLeg(sourcePlan._activeVerticalLeg, false);
        this.setCalculatingLeg(sourcePlan._activeCalculatingLeg, false);
        for (const key in this.userData) {
            this.deleteUserData(key, false);
        }
        for (const key in sourcePlan.userData) {
            this.setUserData(key, sourcePlan.userData[key], false);
        }
    }
    /**
     * Copies leg calcs from an existing leg to a new leg.
     * @param existingLeg The leg that we want to copy the calcs from.
     * @param newLeg The leg that we want to copy the calcs to.
     * @returns the newLeg with the copied calcs.
     */
    static copyLegCalculations(existingLeg, newLeg) {
        if (existingLeg.calculated !== undefined) {
            newLeg.calculated = {
                courseMagVar: existingLeg.calculated.courseMagVar,
                initialDtk: existingLeg.calculated.initialDtk,
                distance: existingLeg.calculated.distance,
                cumulativeDistance: existingLeg.calculated.cumulativeDistance,
                distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
                cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
                startLat: existingLeg.calculated.startLat,
                startLon: existingLeg.calculated.startLon,
                endLat: existingLeg.calculated.endLat,
                endLon: existingLeg.calculated.endLon,
                flightPath: existingLeg.calculated.flightPath.map(vector => Object.assign({}, vector)),
                ingress: existingLeg.calculated.ingress.map(vector => Object.assign({}, vector)),
                ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
                ingressToEgress: existingLeg.calculated.ingressToEgress.map(vector => Object.assign({}, vector)),
                egressJoinIndex: existingLeg.calculated.egressJoinIndex,
                egress: existingLeg.calculated.egress.map(vector => Object.assign({}, vector)),
                endsInFallback: existingLeg.calculated.endsInFallback
            };
        }
        return newLeg;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0,
    verticalAngle: 0,
}, partial);

/**
 * An implementation of {@link SubEventInterface}.
 */
class SubEvent {
    constructor() {
        this.subs = [];
        this.notifyDepth = 0;
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    on(handler, paused = false) {
        const sub = new HandlerSubscription(handler, undefined, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /** @inheritdoc */
    clear() {
        this.notifyDepth++;
        for (let i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
        }
        this.notifyDepth--;
        if (this.notifyDepth === 0) {
            this.subs.length = 0;
        }
    }
    /** @inheritdoc */
    notify(sender, data) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(sender, data);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`SubEvent: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
}

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
* Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Creates an instance of the FlightPlanner.
     * @param id This planner's ID.
     * @param bus The event bus.
     * @param options Options with which to configure the flight planner.
     */
    constructor(id, bus, options) {
        var _a;
        this.id = id;
        this.bus = bus;
        this.eventSuffix = (this.id === '' ? '' : `_${this.id}`);
        this.eventSubscriber = this.bus.getSubscriber();
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        this.syncedBatchEntries = [];
        /** Invoked when we receive a flight plan response event. */
        this.flightPlanSynced = new SubEvent();
        this.calculator = options.calculator;
        this.getLegNameFunc = (_a = options === null || options === void 0 ? void 0 : options.getLegName) !== null && _a !== void 0 ? _a : FlightPlanner.buildDefaultLegName;
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on(`fplsync_fplRequest${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onFlightPlanRequest(data));
        subscriber.on(`fplsync_fplResponse${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on(`fplsync_fplCreated${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on(`fplsync_fplDeleted${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on(`fplsync_fplActiveLegChange${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on(`fplsync_fplLegChange${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on(`fplsync_fplSegmentChange${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on(`fplsync_fplOriginDestChanged${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on(`fplsync_fplProcDetailsChanged${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on(`fplsync_fplIndexChanged${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on(`fplsync_fplUserDataSet${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on(`fplsync_fplUserDataDelete${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on(`fplsync_fplLegUserDataSet${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onLegUserDataSet(data));
        subscriber.on(`fplsync_fplLegUserDataDelete${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onLegUserDataDelete(data));
        subscriber.on(`fplsync_fplDirectToDataChanged${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
        subscriber.on(`fplsync_fplCalculatePended${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onCalculatePended(data));
        subscriber.on(`fplsync_fplCopied${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on(`fplsync_fplBatchOpened${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onBatchOpened(data));
        subscriber.on(`fplsync_fplBatchClosed${this.eventSuffix}`).handle(data => !this.ignoreSync && this.onBatchClosed(data));
    }
    /**
     * Gets an event bus subscriber for topics published by this flight planner.
     * @returns An event bus subscriber for topics published by this flight planner.
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Subscribes to one of the event bus topics published by this flight planner.
     * @param baseTopic The base name of the topic to which to subscribe.
     * @returns A consumer for the specified event bus topic.
     */
    onEvent(baseTopic) {
        return this.eventSubscriber.on(`${baseTopic}${this.eventSuffix}`);
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     * @param data The event data.
     */
    onFlightPlanRequest(data) {
        this.ignoreSync = true;
        this.publisher.pub(`fplsync_fplResponse${this.eventSuffix}`, {
            uid: data.uid,
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub(`fplsync_fplRequest${this.eventSuffix}`, { uid: this.lastRequestUid = Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER) }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        if (data.uid !== this.lastRequestUid) {
            return;
        }
        this.lastRequestUid = undefined;
        for (let i = 0; i < data.flightPlans.length; i++) {
            // ignore bogus flight plans
            if (data.flightPlans[i].segmentCount === 0) {
                continue;
            }
            const newPlan = new FlightPlan(i, this.calculator, this.getLegNameFunc);
            newPlan.copyFrom(data.flightPlans[i], true);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
            // Make sure the newly loaded plans are calculated at least once from the beginning
            newPlan.calculate(0);
        }
        // Only process a plan index changed event if the plan actually exists.
        if (this.flightPlans[data.planIndex]) {
            this.onPlanIndexChanged(data);
        }
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator, this.getLegNameFunc);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            this.syncedBatchEntries[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: this.sendLegChanged.bind(this, planIndex),
            onSegmentChanged: this.sendSegmentChanged.bind(this, planIndex),
            onActiveLegChanged: this.sendActiveLegChange.bind(this, planIndex),
            onOriginDestChanged: this.sendOriginDestChanged.bind(this, planIndex),
            onProcedureDetailsChanged: this.sendProcedureDetailsChanged.bind(this, planIndex),
            onUserDataSet: this.sendUserDataSet.bind(this, planIndex),
            onUserDataDelete: this.sendUserDataDelete.bind(this, planIndex),
            onLegUserDataSet: this.sendLegUserDataSet.bind(this, planIndex),
            onLegUserDataDelete: this.sendLegUserDataDelete.bind(this, planIndex),
            onDirectDataChanged: this.sendDirectToData.bind(this, planIndex),
            onCalculatePended: this.sendCalculatePended.bind(this, planIndex),
            onCalculated: this.sendCalculated.bind(this, planIndex),
            onBatchOpened: this.sendBatchOpened.bind(this, planIndex),
            onBatchClosed: this.sendBatchClosed.bind(this, planIndex),
            onBatchAsyncClosed: this.sendBatchAsyncClosed.bind(this, planIndex),
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, copyCalcs = false, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        if (this.flightPlans[targetPlanIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.flightPlans[targetPlanIndex].copyFrom(sourcePlan, copyCalcs);
        }
        else {
            const newPlan = sourcePlan.copy(targetPlanIndex, copyCalcs);
            newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
            this.flightPlans[targetPlanIndex] = newPlan;
        }
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex, copyCalcs);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, data.copyCalcs, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     * @param copyCalcs Whether to leg calculations were copied.
     */
    sendPlanCopied(planIndex, targetPlanIndex, copyCalcs) {
        var _a;
        const data = { planIndex, targetPlanIndex, copyCalcs, batch: (_a = this.flightPlans[targetPlanIndex]) === null || _a === void 0 ? void 0 : _a.getBatchStack() };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        const plan = this.getFlightPlan(data.planIndex);
        let localLeg;
        switch (data.type) {
            case LegEventType.Added: {
                localLeg = plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.flags, false);
                break;
            }
            case LegEventType.Removed: {
                const leg = plan.removeLeg(data.segmentIndex, data.legIndex, false);
                // We don't want to send the event locally if we didn't find a leg
                if (!leg) {
                    return;
                }
                localLeg = leg;
                break;
            }
            case LegEventType.Changed: {
                try {
                    localLeg = plan.getLeg(data.segmentIndex, data.legIndex);
                }
                catch (_a) {
                    // We don't want to send the event locally if we didn't find a leg
                    return;
                }
                plan.setLegVerticalData(data.segmentIndex, data.legIndex, data.leg.verticalData, false);
                break;
            }
        }
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg,
            batch: data.batch
        };
        this.sendEvent('fplLegChange', localData, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg, batch) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg, batch
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        var _a, _b;
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        let localSegment = undefined;
        switch (data.type) {
            case SegmentEventType.Added:
                localSegment = data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Inserted:
                localSegment = data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Removed:
                localSegment = (_a = plan.tryGetSegment(data.segmentIndex)) !== null && _a !== void 0 ? _a : undefined;
                plan.removeSegment(data.segmentIndex, false);
                break;
            case SegmentEventType.Changed:
                localSegment = data.segment === undefined ? undefined : (_b = plan.tryGetSegment(data.segmentIndex)) !== null && _b !== void 0 ? _b : undefined;
                if (localSegment === undefined) {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        // We need to send a reference to the local flight plan's copy of the segment with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            segment: localSegment,
            batch: data.batch
        };
        this.sendEvent('fplSegmentChange', localData, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendSegmentChanged(planIndex, index, type, segment, batch) {
        const data = {
            planIndex, segmentIndex: index, type, segment, batch
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type, batch) {
        const data = {
            planIndex,
            index,
            segmentIndex, legIndex,
            previousSegmentIndex, previousLegIndex,
            type,
            batch
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendOriginDestChanged(planIndex, type, airport, batch) {
        const data = { planIndex, type, airport, batch };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        plan.setProcedureDetails(Object.assign(new ProcedureDetails(), data.details), false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     * @param batch The modification batch to which the change was assigned.
     */
    sendProcedureDetailsChanged(planIndex, details, batch) {
        const data = { planIndex, details, batch };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to global user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to global user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a global user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     * @param batch The modification batch to which the change was assigned.
     */
    sendUserDataSet(planIndex, key, userData, batch) {
        const data = { planIndex, key, data: userData, batch };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a global user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param batch The modification batch to which the change was assigned.
     */
    sendUserDataDelete(planIndex, key, batch) {
        const data = { planIndex, key, batch };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to flight plan leg user data set sync events.
     * @param data The event data.
     */
    onLegUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const localLeg = plan.tryGetLeg(data.segmentIndex, data.segmentIndex);
        if (!localLeg) {
            return;
        }
        plan.setLegUserData(data.segmentIndex, data.legIndex, data.key, data.data, false);
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg,
            key: data.key,
            data: data.data,
            batch: data.batch
        };
        this.sendEvent('fplLegUserDataSet', localData, false);
    }
    /**
     * A callback which is called in response to flight plan leg user data delete sync events.
     * @param data The event data.
     */
    onLegUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const localLeg = plan.tryGetLeg(data.segmentIndex, data.segmentIndex);
        if (!localLeg) {
            return;
        }
        plan.deleteLegUserData(data.segmentIndex, data.legIndex, data.key, false);
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg,
            key: data.key,
            batch: data.batch
        };
        this.sendEvent('fplLegUserDataDelete', localData, false);
    }
    /**
     * Sends a flight plan leg user data set event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment containing the user data's flight plan leg.
     * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
     * @param leg The user data's flight plan leg.
     * @param key The key of the user data.
     * @param userData The data that was set.
     * @param batch The modification batch to which the change was assigned.
     */
    sendLegUserDataSet(planIndex, segmentIndex, segmentLegIndex, leg, key, userData, batch) {
        const data = { planIndex, segmentIndex, legIndex: segmentLegIndex, leg, key, data: userData, batch };
        this.sendEvent('fplLegUserDataSet', data, true);
    }
    /**
     * Sends a flight plan leg user data delete event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment containing the user data's flight plan leg.
     * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
     * @param leg The user data's flight plan leg.
     * @param key The key of the user data that was deleted.
     * @param batch The modification batch to which the change was assigned.
     */
    sendLegUserDataDelete(planIndex, segmentIndex, segmentLegIndex, leg, key, batch) {
        const data = { planIndex, segmentIndex, legIndex: segmentLegIndex, leg, key, batch };
        this.sendEvent('fplLegUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     * @param batch The modification batch to which the change was assigned.
     */
    sendDirectToData(planIndex, directToData, batch) {
        const data = { planIndex, directToData: directToData, batch };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * A callback which is called in response to calculation pended sync events.
     * @param data The event data.
     */
    async onCalculatePended(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const syncedBatchEntries = this.syncedBatchEntries[data.planIndex];
        if (syncedBatchEntries && data.batch) {
            for (let i = data.batch.length - 1; i >= 0; i--) {
                const batch = data.batch[i];
                const entry = syncedBatchEntries.get(batch.uuid);
                if (entry) {
                    entry.pendingCalculateCount++;
                }
            }
        }
        this.sendEvent('fplCalculatePended', data, false);
        await plan.calculate(data.index, false);
        if (this.flightPlans[data.planIndex] !== plan) {
            return;
        }
        this.sendEvent('fplCalculated', data, false);
        if (syncedBatchEntries && data.batch) {
            for (let i = data.batch.length - 1; i >= 0; i--) {
                const batch = data.batch[i];
                const entry = syncedBatchEntries.get(batch.uuid);
                if (entry) {
                    entry.pendingCalculateCount--;
                    if (entry.isClosed && entry.pendingCalculateCount === 0) {
                        this.sendEvent('fplBatchAsyncClosed', entry.eventData, false);
                        syncedBatchEntries.delete(batch.uuid);
                    }
                }
            }
        }
    }
    /**
     * Sends a calculate pended event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the flight plan leg that the path is to be generated from.
     * @param batch The modification batch to which the calculation was assigned.
     */
    sendCalculatePended(planIndex, index, batch) {
        const data = { planIndex, index, batch };
        this.sendEvent('fplCalculatePended', data, true);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the flight plan leg that the path was generated from.
     * @param batch The modification batch to which the calculation was assigned.
     */
    sendCalculated(planIndex, index, batch) {
        const data = { planIndex, index, batch };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to modification batch opened sync events.
     * @param data The event data.
     */
    onBatchOpened(data) {
        var _a;
        var _b, _c;
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const localData = { planIndex: data.planIndex, isSynced: true, batch: data.batch };
        const entries = (_a = (_b = this.syncedBatchEntries)[_c = data.planIndex]) !== null && _a !== void 0 ? _a : (_b[_c] = new Map());
        entries.set(data.batch.uuid, { batch: data.batch, isClosed: false, pendingCalculateCount: 0, eventData: localData });
        this.sendEvent('fplBatchOpened', localData, false);
    }
    /**
     * Sends a modification batch opened event.
     * @param planIndex The index of the flight plan.
     * @param batch The modification batch that was opened.
     */
    sendBatchOpened(planIndex, batch) {
        const data = { planIndex, isSynced: false, batch };
        this.sendEvent('fplBatchOpened', data, true);
    }
    /**
     * A callback which is called in response to modification batch closed sync events.
     * @param data The event data.
     */
    onBatchClosed(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        const entries = this.syncedBatchEntries[data.planIndex];
        const entry = entries === null || entries === void 0 ? void 0 : entries.get(data.batch.uuid);
        if (entry) {
            entry.isClosed = true;
            this.sendEvent('fplBatchClosed', entry.eventData, false);
            if (entry.pendingCalculateCount === 0) {
                this.sendEvent('fplBatchAsyncClosed', entry.eventData, false);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                entries.delete(data.batch.uuid);
            }
        }
    }
    /**
     * Sends a modification batch closed event.
     * @param planIndex The index of the flight plan.
     * @param batch The modification batch that was closed.
     */
    sendBatchClosed(planIndex, batch) {
        const data = { planIndex, isSynced: false, batch };
        this.sendEvent('fplBatchClosed', data, true);
    }
    /**
     * Sends a modification batch async closed event.
     * @param planIndex The index of the flight plan.
     * @param batch The modification batch that was closed.
     */
    sendBatchAsyncClosed(planIndex, batch) {
        const data = { planIndex, isSynced: false, batch };
        this.sendEvent('fplBatchAsyncClosed', data, false);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}${this.eventSuffix}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(`${topic}${this.eventSuffix}`, data, false, false);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getPlanner(arg1, arg2, arg3) {
        let id;
        let bus;
        let options;
        if (typeof arg1 === 'string') {
            id = arg1;
            bus = arg2;
            options = arg3;
        }
        else {
            id = '';
            bus = arg1;
            options = {
                calculator: arg2,
                getLegName: arg3
            };
        }
        let instance = FlightPlanner.instances.get(id);
        if (!instance) {
            instance = new FlightPlanner(id, bus, options);
            FlightPlanner.instances.set(id, instance);
        }
        return instance;
    }
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
}
FlightPlanner.instances = new Map();

/**
 * Types of changes made to {@link SubscribableMap}.
 */
var SubscribableMapEventType;
(function (SubscribableMapEventType) {
    /** A key was added. */
    SubscribableMapEventType["Added"] = "Added";
    /** A key's entry was changed. */
    SubscribableMapEventType["Changed"] = "Changed";
    /** A key was deleted. */
    SubscribableMapEventType["Deleted"] = "Deleted";
})(SubscribableMapEventType || (SubscribableMapEventType = {}));

/**
 * A pipe from an input subscribable map to an output mutable subscribable map. Each key-value pair
 * added/changed/removed notification received by the pipe is used to add/change/remove key-value pairs in the output
 * map.
 */
class SubscribableMapPipe extends HandlerSubscription {
    /**
     * Constructor.
     * @param from The input subscribable map.
     * @param to The output mutable subscribable map.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from, to, onDestroy) {
        const handler = (map, type, key, value) => {
            if (type === SubscribableMapEventType.Deleted) {
                to.delete(key);
            }
            else {
                to.setValue(key, value);
            }
        };
        const initialNotifyFunc = () => {
            const fromMap = from.get();
            for (const key of to.get().keys()) {
                if (!fromMap.has(key)) {
                    to.delete(key);
                }
            }
            for (const [key, value] of fromMap) {
                to.setValue(key, value);
            }
        };
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableMap {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableMap = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this map.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    getValue(key) {
        return this.get().get(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this map.
     * @param type The type of change.
     * @param key The key related to the change.
     * @param value The value related to the change.
     */
    notify(type, key, value) {
        const map = this.get();
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(map, type, key, value);
                }
            }
            catch (error) {
                console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(map, type, key, value);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this map's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const map = this.get();
        for (const [key, value] of map) {
            sub.handler(map, SubscribableMapEventType.Added, key, value);
        }
    }
    /**
     * Responds to when a subscription to this map is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableMap' in to) {
                sub = new SubscribableMapPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
var SubscribableSetEventType;
(function (SubscribableSetEventType) {
    /** A key was added. */
    SubscribableSetEventType["Added"] = "Added";
    /** A key was deleted. */
    SubscribableSetEventType["Deleted"] = "Deleted";
})(SubscribableSetEventType || (SubscribableSetEventType = {}));

/**
 * A pipe from an input subscribable set to an output mutable subscribable set. Each key added/removed notification
 * received by the pipe is used to add/remove keys to/from the output set.
 */
class SubscribableSetPipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let initialNotifyFunc;
        let onDestroy;
        if (typeof arg4 === 'function') {
            const toCast = to;
            const map = arg3;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(map(key));
                }
                else {
                    const mappedKey = map(key);
                    // Only delete the mapped key if no other key in the input set maps to the same key
                    for (const inputKey of set) {
                        if (map(inputKey) === mappedKey) {
                            return;
                        }
                    }
                    toCast.delete(mappedKey);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set();
                for (const key of fromSet) {
                    toAdd.add(map(key));
                }
                for (const key of toCast.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg4;
        }
        else {
            const toCast = to;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(key);
                }
                else {
                    toCast.delete(key);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set(fromSet);
                for (const key of to.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg3;
        }
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableSet {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableSet = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this set.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    notify(type, key) {
        const set = this.get();
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(set, type, key);
                }
            }
            catch (error) {
                console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(set, type, key);
                    }
                    needCleanUpSubs || (needCleanUpSubs = canCleanUpSubs && !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const set = this.get();
        for (const key of set) {
            sub.handler(set, SubscribableSetEventType.Added, key);
        }
    }
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class ArraySubject extends AbstractSubscribableArray {
// eslint-disable-next-line jsdoc/require-returns
    /** The length of this array. */
    get length() {
        return this.array.length;
    }
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
        super();
        this.array = arr;
    }
        /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
        return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index) {
        if (index === undefined || index > this.array.length - 1) {
            index = this.array.length;
            this.array.push(item);
        }
        else {
            this.array.splice(index, 0, item);
        }
        this.notify(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
        this.array.splice(index, 0, ...arr);
        this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
        const removedItem = this.array.splice(index, 1);
        this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
        const index = this.array.indexOf(item);
        if (index > -1) {
            this.removeAt(index);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
        this.clear();
        this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
        this.array.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
        return this.array;
    }
}

/**
 * A subscribable set whose keys can be freely added and removed.
 */
class SetSubject extends AbstractSubscribableSet {
    /**
     * Constructor.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     */
    constructor(initialKeys) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableSet = true;
        this.backingSet = new Set(initialKeys);
    }
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     * @returns A new SetSubject instance.
     */
    static create(initialKeys) {
        return new SetSubject(initialKeys);
    }
    /** @inheritdoc */
    get() {
        return this.backingSet;
    }
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys) {
        const toAdd = new Set(keys);
        for (const key of this.backingSet) {
            if (!toAdd.delete(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd) {
            this.add(key);
        }
    }
    /** @inheritdoc */
    add(key) {
        const oldSize = this.backingSet.size;
        this.backingSet.add(key);
        if (oldSize !== this.backingSet.size) {
            this.notify(SubscribableSetEventType.Added, key);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const wasDeleted = this.backingSet.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableSetEventType.Deleted, key);
        }
        return wasDeleted;
    }
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set. If not defined, the key will be added to this set if it is not already present and
     * removed if it is already present.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key, force) {
        const shouldAdd = force !== null && force !== void 0 ? force : !this.backingSet.has(key);
        if (shouldAdd) {
            this.add(key);
        }
        else {
            this.delete(key);
        }
        // Explicitly query the set again instead of just returning shouldAdd in case the key was manipulated in a handler
        // triggered by its addition/removal
        return this.backingSet.has(key);
    }
    /**
     * Removes all keys from this set.
     */
    clear() {
        for (const key of this.backingSet) {
            this.backingSet.delete(key);
            this.notify(SubscribableSetEventType.Deleted, key);
        }
    }
}

/**
 * A subscribable map whose key-value pairs can be freely added and removed.
 */
class MapSubject extends AbstractSubscribableMap {
    /**
     * Constructor.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     */
    constructor(initialEntries) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableMap = true;
        this.backingMap = new Map(initialEntries);
    }
    /**
     * Creates and returns a new MapSubject.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     * @returns A new MapSubject instance.
     */
    static create(initialEntries) {
        return new MapSubject(initialEntries);
    }
    /** @inheritdoc */
    get() {
        return this.backingMap;
    }
    /**
     * Sets the key-value pairs contained in this map.
     * @param entries The key-value pairs to set.
     */
    set(entries) {
        const toAdd = entries instanceof Map ? entries : new Map(entries);
        for (const key of this.backingMap.keys()) {
            if (!toAdd.has(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd.keys()) {
            this.setValue(key, toAdd.get(key));
        }
    }
    /** @inheritdoc */
    setValue(key, value) {
        const hasKey = this.backingMap.has(key);
        const shouldNotify = !hasKey || this.backingMap.get(key) !== value;
        this.backingMap.set(key, value);
        if (shouldNotify) {
            this.notify(hasKey ? SubscribableMapEventType.Changed : SubscribableMapEventType.Added, key, value);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const value = this.backingMap.get(key);
        const wasDeleted = this.backingMap.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
        return wasDeleted;
    }
    /** @inheritdoc */
    clear() {
        for (const [key, value] of this.backingMap) {
            this.backingMap.delete(key);
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
    }
}

/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
class ObjectSubject {
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    constructor(obj) {
        this.obj = obj;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.initialNotify.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create(v) {
        return new ObjectSubject(v);
    }
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get() {
        return this.obj;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Adds a subscription to this subscribable.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, value) {
        if (typeof arg1 === 'object') {
            for (const prop in arg1) {
                if (prop in this.obj) {
                    this.set(prop, arg1[prop]);
                }
            }
        }
        else {
            const oldValue = this.obj[arg1];
            if (value !== oldValue) {
                this.obj[arg1] = value;
                this.notify(arg1, oldValue);
            }
        }
    }
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    notify(key, oldValue) {
        const canCleanUpSubs = this.notifyDepth === 0;
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(this.obj, key, this.obj[key], oldValue);
                }
            }
            catch (error) {
                console.error(`ObjectSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
            if (canCleanUpSubs) {
                // If subscriptions were added during the notification, then singletonSub would be deleted and replaced with
                // the subs array.
                if (this.singletonSub) {
                    needCleanUpSubs = !this.singletonSub.isAlive;
                }
                else if (this.subs) {
                    for (let i = 0; i < this.subs.length; i++) {
                        if (!this.subs[i].isAlive) {
                            needCleanUpSubs = true;
                            break;
                        }
                    }
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(this.obj, key, this.obj[key], oldValue);
                    }
                    needCleanUpSubs || (needCleanUpSubs = canCleanUpSubs && !sub.isAlive);
                }
                catch (error) {
                    console.error(`ObjectSubject: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            // If subscriptions were added during the notification and a cleanup operation is not already pending, then we
            // need to check if any of the new subscriptions are already dead and if so, pend a cleanup operation.
            if (canCleanUpSubs && !needCleanUpSubs) {
                for (let i = subLen; i < this.subs.length; i++) {
                    if (!this.subs[i].isAlive) {
                        needCleanUpSubs = true;
                        break;
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs) {
            if (this.singletonSub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        for (const key in this.obj) {
            const v = this.obj[key];
            sub.handler(this.obj, key, v, v);
        }
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * An accessible value whose state can be freely manipulated.
 */
class Value {
    /**
     * Creates a new instance of Value.
     * @param initialValue The initial value of the Value.
     */
    constructor(initialValue) {
        this.value = initialValue;
    }
    /**
     * Creates and returns a new Value.
     * @param initialValue The initial value of the Value.
     * @returns A new Value with the specified initial value.
     */
    static create(initialValue) {
        return new Value(initialValue);
    }
    /** @inheritDoc */
    get() {
        return this.value;
    }
    /** @inheritDoc */
    set(value) {
        this.value = value;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for air data computer information.
 */
class AdcPublisher extends SimVarPublisher {
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const simvars = new Map([
            ['indicated_alt', { name: 'INDICATED ALTITUDE:#index#', type: SimVarValueType.Feet, indexed: true }],
            ['altimeter_baro_setting_inhg', { name: 'KOHLSMAN SETTING HG:#index#', type: SimVarValueType.InHG, indexed: true }],
            ['altimeter_baro_setting_mb', { name: 'KOHLSMAN SETTING MB:#index#', type: SimVarValueType.MB, indexed: true }],
            ['altimeter_baro_preselect_raw', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, indexed: true }],
            ['altimeter_baro_preselect_inhg', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => UnitType.HPA.convertTo(raw / 16, UnitType.IN_HG), indexed: true }],
            ['altimeter_baro_preselect_mb', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => raw / 16, indexed: true }],
            ['altimeter_baro_is_std', { name: 'L:XMLVAR_Baro#index#_ForcedToSTD', type: SimVarValueType.Bool, indexed: true }],
            ['radio_alt', { name: 'RADIO HEIGHT', type: SimVarValueType.Feet }],
            ['pressure_alt', { name: 'PRESSURE ALTITUDE', type: SimVarValueType.Feet }],
            ['vertical_speed', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
            ['ambient_density', { name: 'AMBIENT DENSITY', type: SimVarValueType.SlugsPerCubicFoot }],
            ['isa_temp_c', { name: 'STANDARD ATM TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ram_air_temp_c', { name: 'TOTAL AIR TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
            ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
            ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
            ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }],
            ['stall_aoa', { name: 'STALL ALPHA', type: SimVarValueType.Degree }],
            ['zero_lift_aoa', { name: 'ZERO LIFT ALPHA', type: SimVarValueType.Degree }],
            ['density_alt', { name: 'DENSITY ALTITUDE', type: SimVarValueType.Feet }],
        ]);
        super(simvars, bus, pacer);
        (_a = this.needPublish) !== null && _a !== void 0 ? _a : (this.needPublish = {
            'mach_number': false,
            'ambient_pressure_inhg': false,
            'ambient_temp_c': false
        });
        (_b = this.needPublishIasTopics) !== null && _b !== void 0 ? _b : (this.needPublishIasTopics = new Map());
        (_c = this.needRetrievePressure) !== null && _c !== void 0 ? _c : (this.needRetrievePressure = false);
        (_d = this.needRetrieveTemperature) !== null && _d !== void 0 ? _d : (this.needRetrieveTemperature = false);
        (_e = this.needRetrieveMach) !== null && _e !== void 0 ? _e : (this.needRetrieveMach = false);
        (_f = this.pressure) !== null && _f !== void 0 ? _f : (this.pressure = 1013.25);
        (_g = this.temperature) !== null && _g !== void 0 ? _g : (this.temperature = 0);
        (_h = this.mach) !== null && _h !== void 0 ? _h : (this.mach = 0);
    }
    /** @inheritDoc */
    handleSubscribedTopic(topic) {
        var _a, _b;
        (_a = this.needPublish) !== null && _a !== void 0 ? _a : (this.needPublish = {
            'mach_number': false,
            'ambient_pressure_inhg': false,
            'ambient_temp_c': false
        });
        (_b = this.needPublishIasTopics) !== null && _b !== void 0 ? _b : (this.needPublishIasTopics = new Map());
        if (this.resolvedSimVars.has(topic)
            || topic in this.needPublish
            || AdcPublisher.TOPIC_REGEXES['ias'].test(topic)
            || AdcPublisher.TOPIC_REGEXES['tas'].test(topic)
            || AdcPublisher.TOPIC_REGEXES['indicated_mach_number'].test(topic)
            || AdcPublisher.TOPIC_REGEXES['indicated_tas'].test(topic)
            || AdcPublisher.TOPIC_REGEXES['mach_to_kias_factor'].test(topic)
            || AdcPublisher.TOPIC_REGEXES['tas_to_ias_factor'].test(topic)
            || AdcPublisher.TOPIC_REGEXES['indicated_mach_to_kias_factor'].test(topic)
            || AdcPublisher.TOPIC_REGEXES['indicated_tas_to_ias_factor'].test(topic)) {
            // If topic matches an already resolved topic -> start publishing.
            this.onTopicSubscribed(topic);
        }
        else {
            // Check if topic matches indexed topic.
            this.tryMatchIndexedSubscribedTopic(topic);
        }
    }
    /** @inheritDoc */
    onTopicSubscribed(topic) {
        if (topic in this.needPublish) {
            this.needPublish[topic] = true;
            switch (topic) {
                case 'ambient_pressure_inhg':
                    this.needRetrievePressure = true;
                    if (this.publishActive) {
                        this.retrieveAmbientPressure(true);
                    }
                    break;
                case 'ambient_temp_c':
                    this.needRetrieveTemperature = true;
                    if (this.publishActive) {
                        this.retrieveAmbientTemperature(true);
                    }
                    break;
                case 'mach_number':
                    this.needRetrieveMach = true;
                    if (this.publishActive) {
                        this.retrieveMach(true);
                    }
                    break;
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['ias'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['ias'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.iasTopic = index < 0 ? 'ias' : `ias_${index}`;
            if (this.publishActive) {
                this.retrieveIas(entry, true);
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['tas'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['tas'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.tasTopic = index < 0 ? 'tas' : `tas_${index}`;
            if (this.publishActive) {
                this.retrieveTas(entry, true);
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['indicated_mach_number'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['indicated_mach_number'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            this.needRetrievePressure = true;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.indicatedMachTopic = index < 0 ? 'indicated_mach_number' : `indicated_mach_number_${index}`;
            if (this.publishActive) {
                this.retrieveAmbientPressure(false);
                this.retrieveIas(entry, false);
                this.retrieveIndicatedMach(entry, true);
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['indicated_tas'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['indicated_tas'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            this.needRetrievePressure = true;
            this.needRetrieveTemperature = true;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.indicatedTasTopic = index < 0 ? 'indicated_tas' : `indicated_tas_${index}`;
            if (this.publishActive) {
                this.retrieveAmbientPressure(false);
                this.retrieveAmbientTemperature(false);
                this.retrieveIas(entry, false);
                this.retrieveIndicatedTas(entry, true);
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['mach_to_kias_factor'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['mach_to_kias_factor'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            this.needRetrievePressure = true;
            this.needRetrieveMach = true;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.machToKiasTopic = index < 0 ? 'mach_to_kias_factor' : `mach_to_kias_factor_${index}`;
            if (this.publishActive) {
                this.retrieveAmbientPressure(false);
                this.retrieveMach(false);
                this.retrieveIas(entry, false);
                this.publishMachToKias(entry);
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['tas_to_ias_factor'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['tas_to_ias_factor'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            this.needRetrievePressure = true;
            this.needRetrieveTemperature = true;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.tasToIasTopic = index < 0 ? 'tas_to_ias_factor' : `tas_to_ias_factor_${index}`;
            if (this.publishActive) {
                this.retrieveAmbientPressure(false);
                this.retrieveAmbientTemperature(false);
                this.retrieveIas(entry, false);
                this.retrieveTas(entry, false);
                this.publishTasToIas(entry);
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['indicated_mach_to_kias_factor'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['indicated_mach_to_kias_factor'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            this.needRetrievePressure = true;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.indicatedMachToKiasTopic = index < 0 ? 'indicated_mach_to_kias_factor' : `indicated_mach_to_kias_factor_${index}`;
            if (this.publishActive) {
                this.retrieveAmbientPressure(false);
                this.retrieveIas(entry, false);
                this.retrieveIndicatedMach(entry, false);
                this.publishIndicatedMachToKias(entry);
            }
        }
        else if (AdcPublisher.TOPIC_REGEXES['indicated_tas_to_ias_factor'].test(topic)) {
            const indexMatch = topic.match(AdcPublisher.TOPIC_REGEXES['indicated_tas_to_ias_factor'])[1];
            const index = indexMatch ? parseInt(indexMatch) : -1;
            this.needRetrievePressure = true;
            this.needRetrieveTemperature = true;
            const entry = this.getOrCreateIasTopicEntry(index);
            entry.indicatedTasToIasTopic = index < 0 ? 'indicated_tas_to_ias_factor' : `indicated_tas_to_ias_factor_${index}`;
            if (this.publishActive) {
                this.retrieveAmbientPressure(false);
                this.retrieveAmbientTemperature(false);
                this.retrieveIas(entry, false);
                this.retrieveIndicatedTas(entry, false);
                this.publishIndicatedTasToIas(entry);
            }
        }
        else {
            super.onTopicSubscribed(topic);
        }
    }
    /**
     * Gets the entry describing indicated airspeed-related topics to publish for a given airspeed indicator index, or
     * creates a new one if it does not exist.
     * @param index The airspeed indicator index for which to get an entry, or `-1` for the un-indexed airspeed
     * indicator.
     * @returns An entry describing indicated airspeed-related topics to publish for the specified airspeed indicator
     * index.
     */
    getOrCreateIasTopicEntry(index) {
        let entry = this.needPublishIasTopics.get(index);
        if (!entry) {
            entry = {
                iasSimVar: index < 0 ? 'AIRSPEED INDICATED:1' : `AIRSPEED INDICATED:${index}`,
                tasSimVar: index < 0 ? 'AIRSPEED TRUE:1' : `AIRSPEED TRUE:${index}`,
                kias: 0,
                iasMps: 0,
                ktas: 0,
                indicatedMach: 0,
                indicatedTas: 0
            };
            this.needPublishIasTopics.set(index, entry);
        }
        return entry;
    }
    /** @inheritDoc */
    onUpdate() {
        const isSlewing = SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
        if (!isSlewing) {
            if (this.needRetrievePressure) {
                this.retrieveAmbientPressure(this.needPublish['ambient_pressure_inhg']);
            }
            if (this.needRetrieveTemperature) {
                this.retrieveAmbientTemperature(this.needPublish['ambient_temp_c']);
            }
            if (this.needRetrieveMach) {
                this.retrieveMach(this.needPublish['mach_number']);
            }
            for (const entry of this.needPublishIasTopics.values()) {
                this.retrieveIas(entry, true);
                if (entry.tasTopic || entry.tasToIasTopic) {
                    this.retrieveTas(entry, true);
                }
                if (entry.indicatedMachTopic || entry.indicatedMachToKiasTopic) {
                    this.retrieveIndicatedMach(entry, true);
                }
                if (entry.indicatedTasTopic || entry.indicatedTasToIasTopic) {
                    this.retrieveIndicatedTas(entry, true);
                }
                this.publishMachToKias(entry);
                this.publishTasToIas(entry);
                this.publishIndicatedMachToKias(entry);
                this.publishIndicatedTasToIas(entry);
            }
            super.onUpdate();
        }
    }
    /**
     * Retrieves and optionally publishes the current ambient pressure.
     * @param publish Whether to publish the value.
     */
    retrieveAmbientPressure(publish) {
        const pressureInHg = SimVar.GetSimVarValue('AMBIENT PRESSURE', SimVarValueType.InHG);
        this.pressure = UnitType.IN_HG.convertTo(pressureInHg, UnitType.HPA);
        publish && this.publish('ambient_pressure_inhg', pressureInHg);
    }
    /**
     * Retrieves and optionally publishes the current ambient temperature.
     * @param publish Whether to publish the value.
     */
    retrieveAmbientTemperature(publish) {
        this.temperature = SimVar.GetSimVarValue('AMBIENT TEMPERATURE', SimVarValueType.Celsius);
        publish && this.publish('ambient_temp_c', this.temperature);
    }
    /**
     * Retrieves and optionally publishes the airplane's current mach number.
     * @param publish Whether to publish the value.
     */
    retrieveMach(publish) {
        this.mach = SimVar.GetSimVarValue('AIRSPEED MACH', SimVarValueType.Mach);
        publish && this.publish('mach_number', this.mach);
    }
    /**
     * Retrieves and optionally publishes the current indicated airspeed for an airspeed indicator index.
     * @param entry The entry for the airspeed indicator index for which to retrieve the value.
     * @param publish Whether to publish the value.
     */
    retrieveIas(entry, publish) {
        entry.kias = SimVar.GetSimVarValue(entry.iasSimVar, SimVarValueType.Knots);
        entry.iasMps = UnitType.KNOT.convertTo(entry.kias, UnitType.MPS);
        publish && entry.iasTopic && this.publish(entry.iasTopic, entry.kias);
    }
    /**
     * Retrieves and optionally publishes the current true airspeed for an airspeed indicator index.
     * @param entry The entry for the airspeed indicator index for which to retrieve the value.
     * @param publish Whether to publish the value.
     */
    retrieveTas(entry, publish) {
        entry.ktas = SimVar.GetSimVarValue(entry.tasSimVar, SimVarValueType.Knots);
        publish && entry.tasTopic && this.publish(entry.tasTopic, entry.ktas);
    }
    /**
     * Retrieves and optionally publishes the current indicated mach number for an airspeed indicator index.
     * @param entry The entry for the airspeed indicator index for which to retrieve the value.
     * @param publish Whether to publish the value.
     */
    retrieveIndicatedMach(entry, publish) {
        entry.indicatedMach = AeroMath.casToMach(entry.iasMps, this.pressure);
        publish && entry.indicatedMachTopic && this.publish(entry.indicatedMachTopic, entry.indicatedMach);
    }
    /**
     * Retrieves and optionally publishes the current indicated true airspeed for an airspeed indicator index.
     * @param entry The entry for the airspeed indicator index for which to retrieve the value.
     * @param publish Whether to publish the value.
     */
    retrieveIndicatedTas(entry, publish) {
        entry.indicatedTas = UnitType.MPS.convertTo(AeroMath.casToTas(entry.iasMps, this.pressure, this.temperature), UnitType.KNOT);
        publish && entry.indicatedTasTopic && this.publish(entry.indicatedTasTopic, entry.indicatedTas);
    }
    /**
     * Publishes the current conversion factor from mach number to knots indicated airspeed for an airspeed indicator
     * index.
     * @param entry The entry for the airspeed indicator index for which to publish the value.
     */
    publishMachToKias(entry) {
        if (!entry.machToKiasTopic) {
            return;
        }
        const factor = entry.kias < 1 || this.mach === 0
            ? 1 / AeroMath.casToMach(1, this.pressure)
            : entry.kias / this.mach;
        this.publish(entry.machToKiasTopic, isFinite(factor) ? factor : 1);
    }
    /**
     * Publishes the current conversion factor from true airspeed to indicated airspeed for an airspeed indicator index.
     * @param entry The entry for the airspeed indicator index for which to publish the value.
     */
    publishTasToIas(entry) {
        if (!entry.tasToIasTopic) {
            return;
        }
        const factor = entry.kias < 1 || entry.ktas === 0
            ? 1 / AeroMath.casToTas(1, this.pressure, this.temperature)
            : entry.kias / entry.ktas;
        this.publish(entry.tasToIasTopic, isFinite(factor) ? factor : 1);
    }
    /**
     * Publishes the current conversion factor from indicated mach number to knots indicated airspeed for an airspeed
     * indicator index.
     * @param entry The entry for the airspeed indicator index for which to publish the value.
     */
    publishIndicatedMachToKias(entry) {
        if (!entry.indicatedMachToKiasTopic) {
            return;
        }
        const factor = entry.kias < 1 || entry.indicatedMach === 0
            ? 1 / AeroMath.casToMach(1, this.pressure)
            : entry.kias / entry.indicatedMach;
        this.publish(entry.indicatedMachToKiasTopic, isFinite(factor) ? factor : 1);
    }
    /**
     * Publishes the current conversion factor from indicated true airspeed to indicated airspeed for an airspeed
     * indicator index.
     * @param entry The entry for the airspeed indicator index for which to publish the value.
     */
    publishIndicatedTasToIas(entry) {
        if (!entry.indicatedTasToIasTopic) {
            return;
        }
        const factor = entry.kias < 1 || entry.indicatedTas === 0
            ? 1 / AeroMath.casToTas(1, this.pressure, this.temperature)
            : entry.kias / entry.indicatedTas;
        this.publish(entry.indicatedTasToIasTopic, isFinite(factor) ? factor : 1);
    }
}
AdcPublisher.TOPIC_REGEXES = {
    'ias': /^ias(?:_(0|(?:[1-9])\d*))?$/,
    'tas': /^tas(?:_(0|(?:[1-9])\d*))?$/,
    'indicated_mach_number': /^indicated_mach_number(?:_(0|(?:[1-9])\d*))?$/,
    'indicated_tas': /^indicated_tas(?:_(0|(?:[1-9])\d*))?$/,
    'mach_to_kias_factor': /^mach_to_kias_factor(?:_(0|(?:[1-9])\d*))?$/,
    'tas_to_ias_factor': /^tas_to_ias_factor(?:_(0|(?:[1-9])\d*))?$/,
    'indicated_mach_to_kias_factor': /^indicated_mach_to_kias_factor(?:_(0|(?:[1-9])\d*))?$/,
    'indicated_tas_to_ias_factor': /^indicated_tas_to_ias_factor(?:_(0|(?:[1-9])\d*))?$/
};

/**
 * A publisher for AHRS information.
 */
class AhrsPublisher extends SimVarPublisher {
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['pitch_deg', { name: 'ATTITUDE INDICATOR PITCH DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['roll_deg', { name: 'ATTITUDE INDICATOR BANK DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg_true', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, map: (heading) => MagVar.magneticToTrue(heading, this.magVar), indexed: true }],
            ['delta_heading_rate', { name: 'DELTA HEADING RATE:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
            ['actual_hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
            ['actual_hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
            ['actual_pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
            ['actual_roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
        ]);
        super(simvars, bus, pacer);
        this.magVar = 0;
        (_a = this.needUpdateMagVar) !== null && _a !== void 0 ? _a : (this.needUpdateMagVar = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('hdg_deg_true')) {
            this.needUpdateMagVar = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needUpdateMagVar) {
            this.magVar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        }
        super.onUpdate();
    }
}

/**
 * A publisher for events related to the sim's AI piloting feature.
 */
class AiPilotPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of AiPilotPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(new Map([
            ['ai_delegate_controls_active', { name: 'DELEGATE CONTROLS TO AI', type: SimVarValueType.Bool }],
            ['ai_auto_rudder_active', { name: 'AUTO COORDINATION', type: SimVarValueType.Bool }]
        ]), bus);
    }
}

/**
 * Ambient precipitation states.
 */
var AmbientPrecipState;
(function (AmbientPrecipState) {
    AmbientPrecipState[AmbientPrecipState["None"] = 2] = "None";
    AmbientPrecipState[AmbientPrecipState["Rain"] = 4] = "Rain";
    AmbientPrecipState[AmbientPrecipState["Snow"] = 8] = "Snow";
})(AmbientPrecipState || (AmbientPrecipState = {}));
/**
 * A publisher for ambient environment information.
 */
class AmbientPublisher extends SimVarPublisher {
    /**
     * Creates an AmbientPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['ambient_precip_state', { name: 'AMBIENT PRECIP STATE', type: SimVarValueType.Number }],
            ['ambient_precip_rate', { name: 'AMBIENT PRECIP RATE', type: SimVarValueType.MillimetersWater }],
            ['ambient_visibility', { name: 'AMBIENT VISIBILITY', type: SimVarValueType.Meters }],
            ['ambient_in_cloud', { name: 'AMBIENT IN CLOUD', type: SimVarValueType.Bool }],
            ['ambient_qnh_inhg', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.InHG }],
            ['ambient_qnh_mb', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.MB }],
        ]);
        super(simvars, bus, pacer);
    }
}

var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_yd_status', { name: 'AUTOPILOT YAW DAMPER', type: SimVarValueType.Bool }],
    ['ap_disengage_status', { name: 'AUTOPILOT DISENGAGED', type: SimVarValueType.Bool }],
    ['ap_heading_hold', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_hold', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_max_bank_id', { name: 'AUTOPILOT MAX BANK ID', type: SimVarValueType.Number }],
    ['ap_max_bank_value', { name: 'AUTOPILOT MAX BANK', type: SimVarValueType.Degree }],
    ['ap_wing_lvl_hold', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_hold', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['ap_toga_hold', { name: 'AUTOPILOT TAKEOFF POWER ACTIVE', type: SimVarValueType.Bool }],
    ['ap_heading_selected', { name: 'AUTOPILOT HEADING LOCK DIR:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_altitude_selected', { name: 'AUTOPILOT ALTITUDE LOCK VAR:#index#', type: SimVarValueType.Feet, indexed: true }],
    ['ap_pitch_selected', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }],
    ['ap_vs_selected', { name: 'AUTOPILOT VERTICAL HOLD VAR:#index#', type: SimVarValueType.FPM, indexed: true }],
    ['ap_fpa_selected', { name: 'L:WT_AP_FPA_Target:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_ias_selected', { name: 'AUTOPILOT AIRSPEED HOLD VAR:#index#', type: SimVarValueType.Knots, indexed: true }],
    ['ap_mach_selected', { name: 'AUTOPILOT MACH HOLD VAR:#index#', type: SimVarValueType.Number, indexed: true }],
    ['ap_selected_speed_is_mach', { name: 'AUTOPILOT MANAGED SPEED IN MACH', type: SimVarValueType.Bool }],
    ['ap_selected_speed_is_manual', { name: 'L:XMLVAR_SpeedIsManuallySet', type: SimVarValueType.Bool }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_is_active_1', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:1', type: SimVarValueType.Bool }],
    ['flight_director_is_active_2', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:2', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }]
]);
/**
 * Publishes autopilot data
 */
class AutopilotPublisher extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
        this.publish('ap_master_on', true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
        this.publish('ap_master_off', true);
    }
    /**
     * Publish a YD engage event
     */
    publishYdEngage() {
        this.publish('ap_yd_on', true);
    }
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage() {
        this.publish('ap_yd_off', true);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
        this.publish('ap_lock_set', lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
        this.publish('ap_lock_release', lock);
    }
}
/**
 * Manages an autopilot system
 */
class AutopilotInstrument {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
        this.bus = bus;
        // this.hEvents = this.bus.getSubscriber<HEvent>();
        this.publisher = new AutopilotPublisher(bus);
        this.simVarPublisher = new APSimVarPublisher(bus);
        this.simVarSubscriber = new EventSubscriber(bus);
    }
    /**
     * Initialize the instrument
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        // console.log('initting autopilot');
        this.simVarSubscriber.on('ap_master_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishMasterEngage();
            }
            else {
                this.publisher.publishMasterDisengage();
            }
        });
        this.simVarSubscriber.on('ap_yd_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishYdEngage();
            }
            else {
                this.publisher.publishYdDisengage();
            }
        });
        this.simVarSubscriber.on('ap_alt_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Alt);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Alt);
            }
        });
        this.simVarSubscriber.on('ap_pitch_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Pitch);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Pitch);
            }
        });
        this.simVarSubscriber.on('ap_heading_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Heading);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Heading);
            }
        });
        this.simVarSubscriber.on('ap_nav_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Nav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Nav);
            }
        });
        this.simVarSubscriber.on('ap_approach_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Approach);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Approach);
            }
        });
        this.simVarSubscriber.on('ap_backcourse_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Backcourse);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Backcourse);
            }
        });
        this.simVarSubscriber.on('ap_bank_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Bank);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Bank);
            }
        });
        this.simVarSubscriber.on('ap_wing_lvl_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.WingLevel);
            }
            else {
                this.publisher.publishLockRelease(APLockType.WingLevel);
            }
        });
        this.simVarSubscriber.on('ap_flc_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Flc);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Flc);
            }
        });
        this.simVarSubscriber.on('ap_vs_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Vs);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Vs);
            }
        });
        this.simVarSubscriber.on('ap_glideslope_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Glideslope);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Glideslope);
            }
        });
        this.simVarSubscriber.on('vnav_active').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.VNav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.VNav);
            }
        });
    }
    /** update our publishers */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/**
 * A utility class for working with CDIs.
 */
class CdiUtils {
    /**
     * Gets the suffix for event bus topics associated with a given CDI index.
     * @param id The index for which to get the suffix.
     * @returns The suffix for event bus topics associated with the specified CDI index.
     */
    static getEventBusTopicSuffix(id) {
        return (id === '' ? '' : `_${id}`);
    }
    /**
     * Checks whether two CDI navigation sources are equal.
     * @param a The first source to check.
     * @param b The second source to check.
     * @returns Whether the two specified CDI navigation sources are equal.
     */
    static navSourceIdEquals(a, b) {
        return a.type === b.type && a.index === b.index;
    }
}

/**
 * VOR signal to/from flags.
 */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));
/**
 * A publisher of NAV, COM, ADF radio and marker beacon tuning-related sim var events.
 */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of NavComSimVarPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ...NavComSimVarPublisher.createNavRadioDefinitions(),
            ...NavComSimVarPublisher.createComRadioDefinitions(),
            ...NavComSimVarPublisher.createAdfRadioDefinitions(),
            ...NavComSimVarPublisher.createMarkerBeaconDefinitions(),
            ...NavComSimVarPublisher.createGpsDefinitions()
        ]);
        super(simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions.
     * @returns An array of nav radio sim var event definitions.
     */
    static createNavRadioDefinitions() {
        return [
            ['nav_active_frequency', { name: 'NAV ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_standby_frequency', { name: 'NAV STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_signal', { name: 'NAV SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_sound', { name: 'NAV SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_ident', { name: 'NAV IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_volume', { name: 'NAV VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_obs', { name: 'NAV OBS:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_dme', { name: 'NAV HAS DME:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_nav', { name: 'NAV HAS NAV:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_cdi', { name: 'NAV CDI:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme', { name: 'NAV DME:#index#', type: SimVarValueType.NM, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial', { name: 'NAV RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial_error', { name: 'NAV RADIAL ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_to_from', { name: 'NAV TOFROM:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer', { name: 'NAV HAS LOCALIZER:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer_crs', { name: 'NAV LOCALIZER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_airport_ident', { name: 'NAV LOC AIRPORT IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_designator', { name: 'NAV LOC RUNWAY DESIGNATOR:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_number', { name: 'NAV LOC RUNWAY NUMBER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_glideslope', { name: 'NAV HAS GLIDE SLOPE:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_error', { name: 'NAV GLIDE SLOPE ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_raw_gs', { name: 'NAV RAW GLIDE SLOPE:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_lla', { name: 'NAV VOR LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme_lla', { name: 'NAV DME LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_lla', { name: 'NAV GS LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_magvar', { name: 'NAV MAGVAR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of com radio sim var event definitions.
     * @returns An array of com radio sim var event definitions.
     */
    static createComRadioDefinitions() {
        return [
            ['com_active_frequency', { name: 'COM ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_standby_frequency', { name: 'COM STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_name', { name: 'COM ACTIVE FREQ NAME:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_type', { name: 'COM ACTIVE FREQ TYPE:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_ident', { name: 'COM ACTIVE FREQ IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            // Note: 'COM RECEIVE' is whether the radio is receiving OR transmitting,
            // whereas 'COM RECEIVE EX1' is exclusively its receiving state.
            ['com_receive', { name: 'COM RECEIVE EX1:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_status', { name: 'COM STATUS:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_transmit', { name: 'COM TRANSMIT:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_spacing_mode', { name: 'COM SPACING MODE:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_volume', { name: 'COM VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3], defaultIndex: null }],
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions.
     * @returns An array of ADF radio sim var event definitions.
     */
    static createAdfRadioDefinitions() {
        return [
            ['adf_active_frequency', { name: 'ADF ACTIVE FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_standby_frequency', { name: 'ADF STANDBY FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_sound', { name: 'ADF SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['adf_volume', { name: 'ADF VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2], defaultIndex: null }],
            ['adf_ident', { name: 'ADF IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2], defaultIndex: null }],
            ['adf_signal', { name: 'ADF SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['adf_bearing', { name: 'ADF RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2], defaultIndex: null }],
            ['adf_lla', { name: 'ADF LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createMarkerBeaconDefinitions() {
        return [
            ['marker_beacon_hisense_on', { name: 'MARKER BEACON SENSITIVITY HIGH', type: SimVarValueType.Bool }],
            ['marker_beacon_sound', { name: 'MARKER SOUND', type: SimVarValueType.Bool }],
            ['marker_beacon_state', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
            ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createGpsDefinitions() {
        return [
            ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
            ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
            ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
            ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
            ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
            ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
            ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
        ];
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher of nav radio, ADF radio, GPS, and marker beacon-related sim var events.
 *
 * @deprecated Please use `NavComSimVarPublisher` instead.
 */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    static createNavRadioDefinitions(index) {
        return [
            [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
            [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
            [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
            [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
            [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
            [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`nav_radial_error_${index}`, { name: `NAV RADIAL ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
            [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
            [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
            [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
            [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
            [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    static createAdfRadioDefinitions(index) {
        return [
            [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
        ];
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));

/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 *
 * Requires that the topics defined in {@link NavComEvents} are published to the event bus.
 */
class APRadioNavInstrument {
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     * @param cdiId The ID of the CDI from which this instrument sources navigation source data. Defaults to the empty
     * string (`''`).
     */
    constructor(bus, cdiId = '') {
        this.bus = bus;
        this.cdiId = cdiId;
        this.navRadioData = ArrayUtils.create(5, index => {
            index = Math.max(1, index);
            return {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index, type: NavSourceType.Nav }),
                radialError: 0,
                magVar: 0
            };
        });
        this.currentCdiNavSourceIndex = 1;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    init() {
        const navComSubscriber = this.bus.getSubscriber();
        for (let i = 1; i < 5; i++) {
            navComSubscriber.on(`nav_glideslope_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_gs_lla_${i}`).handle(this.setGlideslopePosition.bind(this, i));
            navComSubscriber.on(`nav_gs_error_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_raw_gs_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'gsAngle'));
            navComSubscriber.on(`nav_localizer_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_localizer_crs_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'course'));
            navComSubscriber.on(`nav_cdi_${i}`).whenChanged().handle(this.setCDIValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_has_nav_${i}`).whenChanged().handle(hasNav => !hasNav && this.setCDIValue(i, 'deviation', null));
            navComSubscriber.on(`nav_obs_${i}`).whenChanged().handle(this.setOBSValue.bind(this, i, 'heading'));
            navComSubscriber.on(`nav_lla_${i}`).handle(this.setNavPosition.bind(this, i));
            navComSubscriber.on(`nav_radial_error_${i}`).whenChanged().handle(this.setRadialError.bind(this, i));
            navComSubscriber.on(`nav_magvar_${i}`).whenChanged().handle(this.setMagVar.bind(this, i));
        }
        const navEvents = this.bus.getSubscriber();
        navEvents.on(`cdi_select${CdiUtils.getEventBusTopicSuffix(this.cdiId)}`).handle(source => {
            const oldIndex = this.currentCdiNavSourceIndex;
            this.currentCdiNavSourceIndex = source.type === NavSourceType.Nav ? source.index : 0;
            if (oldIndex !== this.currentCdiNavSourceIndex) {
                const data = this.navRadioData[this.currentCdiNavSourceIndex];
                this.publisher.pub('nav_radio_active_gs_location', data.gsLocation);
                this.publisher.pub('nav_radio_active_nav_location', data.navLocation);
                this.publisher.pub('nav_radio_active_glideslope', data.glideslope);
                this.publisher.pub('nav_radio_active_localizer', data.localizer);
                this.publisher.pub('nav_radio_active_cdi_deviation', data.cdi);
                this.publisher.pub('nav_radio_active_obs_setting', data.obs);
                this.publisher.pub('nav_radio_active_radial_error', data.radialError);
                this.publisher.pub('nav_radio_active_magvar', data.magVar);
            }
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setGlideslopeValue(index, field, value) {
        this.navRadioData[index].glideslope[field] = value;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_glideslope', this.navRadioData[index].glideslope);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_glideslope_1', this.navRadioData[index].glideslope);
                break;
            case 2:
                this.publisher.pub('nav_radio_glideslope_2', this.navRadioData[index].glideslope);
                break;
            case 3:
                this.publisher.pub('nav_radio_glideslope_3', this.navRadioData[index].glideslope);
                break;
            case 4:
                this.publisher.pub('nav_radio_glideslope_4', this.navRadioData[index].glideslope);
                break;
        }
    }
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setGlideslopePosition(index, lla) {
        this.navRadioData[index].gsLocation = lla;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_gs_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_gs_location_1', this.navRadioData[index].gsLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_gs_location_2', this.navRadioData[index].gsLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_gs_location_3', this.navRadioData[index].gsLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_gs_location_4', this.navRadioData[index].gsLocation);
                break;
        }
    }
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setNavPosition(index, lla) {
        this.navRadioData[index].navLocation = lla;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_nav_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_nav_location_1', this.navRadioData[index].navLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_nav_location_2', this.navRadioData[index].navLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_nav_location_3', this.navRadioData[index].navLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_nav_location_4', this.navRadioData[index].navLocation);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setLocalizerValue(index, field, value) {
        this.navRadioData[index].localizer[field] = value;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_localizer', this.navRadioData[index].localizer);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_localizer_1', this.navRadioData[index].localizer);
                break;
            case 2:
                this.publisher.pub('nav_radio_localizer_2', this.navRadioData[index].localizer);
                break;
            case 3:
                this.publisher.pub('nav_radio_localizer_3', this.navRadioData[index].localizer);
                break;
            case 4:
                this.publisher.pub('nav_radio_localizer_4', this.navRadioData[index].localizer);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setCDIValue(index, field, value) {
        this.navRadioData[index].cdi[field] = value;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_cdi_deviation', this.navRadioData[index].cdi);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_cdi_1', this.navRadioData[index].cdi);
                break;
            case 2:
                this.publisher.pub('nav_radio_cdi_2', this.navRadioData[index].cdi);
                break;
            case 3:
                this.publisher.pub('nav_radio_cdi_3', this.navRadioData[index].cdi);
                break;
            case 4:
                this.publisher.pub('nav_radio_cdi_4', this.navRadioData[index].cdi);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setOBSValue(index, field, value) {
        this.navRadioData[index].obs[field] = value;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_obs_setting', this.navRadioData[index].obs);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_obs_1', this.navRadioData[index].obs);
                break;
            case 2:
                this.publisher.pub('nav_radio_obs_2', this.navRadioData[index].obs);
                break;
            case 3:
                this.publisher.pub('nav_radio_obs_3', this.navRadioData[index].obs);
                break;
            case 4:
                this.publisher.pub('nav_radio_obs_4', this.navRadioData[index].obs);
                break;
        }
    }
    /**
     * Sets the radial error of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param radialError The radial error to set.
     */
    setRadialError(index, radialError) {
        this.navRadioData[index].radialError = radialError;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_radial_error', radialError);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_radial_error_1', this.navRadioData[index].radialError);
                break;
            case 2:
                this.publisher.pub('nav_radio_radial_error_2', this.navRadioData[index].radialError);
                break;
            case 3:
                this.publisher.pub('nav_radio_radial_error_3', this.navRadioData[index].radialError);
                break;
            case 4:
                this.publisher.pub('nav_radio_radial_error_4', this.navRadioData[index].radialError);
                break;
        }
    }
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    setMagVar(index, magVar) {
        magVar = NavMath.normalizeHeading(-magVar + 180) % 360 - 180;
        this.navRadioData[index].magVar = magVar;
        if (this.currentCdiNavSourceIndex === index) {
            this.publisher.pub('nav_radio_active_magvar', magVar);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_magvar_1', this.navRadioData[index].magVar);
                break;
            case 2:
                this.publisher.pub('nav_radio_magvar_2', this.navRadioData[index].magVar);
                break;
            case 3:
                this.publisher.pub('nav_radio_magvar_3', this.navRadioData[index].magVar);
                break;
            case 4:
                this.publisher.pub('nav_radio_magvar_4', this.navRadioData[index].magVar);
                break;
        }
    }
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    createEmptyLocalizer(id) {
        return {
            isValid: false,
            course: 0,
            source: id
        };
    }
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    createEmptyGlideslope(id) {
        return {
            isValid: false,
            gsAngle: 0,
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    createEmptyCdi(id) {
        return {
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    createEmptyObs(id) {
        return {
            heading: 0,
            source: id
        };
    }
}

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to this backplane.
     * @param name A symbolic name for the publisher for reference.
     * @param publisher The publisher to add.
     * @param override Whether to override any existing publishers added to this backplane under the same name. If
     * `true`, any existing publisher with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new publisher will not be added if this backplane already has a publisher with the same
     * name or a publisher of the same type. Defaults to `false`.
     */
    addPublisher(name, publisher, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, publisher, this.publishers)) {
            this.publishers.set(name, publisher);
        }
    }
    /**
     * Add an instrument to this backplane.
     * @param name A symbolic name for the instrument for reference.
     * @param instrument The instrument to add.
     * @param override Whether to override any existing instruments added to this backplane under the same name. If
     * `true`, any existing instrument with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new instrument will not be added if this backplane already has an instrument with the same
     * name or an instrument of the same type. Defaults to `false`.
     */
    addInstrument(name, instrument, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, instrument, this.instruments)) {
            this.instruments.set(name, instrument);
        }
    }
    /**
     * Gets a publisher from this backplane.
     * @param name The name of the publisher to get.
     * @returns The publisher in this backplane with the specified name, or `undefined` if there is no such publisher.
     */
    getPublisher(name) {
        return this.publishers.get(name);
    }
    /**
     * Gets an instrument from this backplane.
     * @param name The name of the instrument to get.
     * @returns The instrument in this backplane with the specified name, or `undefined` if there is no such instrument.
     */
    getInstrument(name) {
        return this.instruments.get(name);
    }
    /**
     * Checks for duplicate publishers or instruments of the same name or type.
     * @param name the name of the publisher or instrument
     * @param objToCheck the object to check
     * @param map the map to check
     * @returns true if the object is already in the map
     */
    static checkAlreadyExists(name, objToCheck, map) {
        if (map.has(name)) {
            console.warn(`${name} already exists in backplane.`);
            return true;
        }
        // check if there already is a publisher with the same type
        for (const p of map.values()) {
            if (p.constructor === objToCheck.constructor) {
                console.warn(`${name} already exists in backplane.`);
                return true;
            }
        }
        return false;
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Brake information.
 */
class BrakeSimvarPublisher extends SimVarPublisher {
    /**
     * Create a BrakePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['brake_position_left', { name: 'BRAKE LEFT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_right', { name: 'BRAKE RIGHT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_left_raw', { name: 'BRAKE LEFT POSITION EX1', type: SimVarValueType.Percent }],
            ['brake_position_right_raw', { name: 'BRAKE RIGHT POSITION EX1', type: SimVarValueType.Percent }],
            ['left_wheel_rpm', { name: 'LEFT WHEEL RPM', type: SimVarValueType.RPM }],
            ['right_wheel_rpm', { name: 'RIGHT WHEEL RPM', type: SimVarValueType.RPM }],
            ['parking_brake_set', { name: 'BRAKE PARKING POSITION', type: SimVarValueType.Bool }],
            ['autobrake_switch_pos', { name: 'AUTO BRAKE SWITCH CB', type: SimVarValueType.Number }],
            ['autobrake_active', { name: 'AUTOBRAKES ACTIVE', type: SimVarValueType.Bool }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    /**
     * Creates a new instance of ClockPublisher.
     * @param bus The event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
        this.needPublishRealTime = false;
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['simTime', { name: 'E:ABSOLUTE TIME', type: SimVarValueType.Seconds, map: ClockPublisher.absoluteTimeToUNIXTime }],
            ['simRate', { name: 'E:SIMULATION RATE', type: SimVarValueType.Number }],
            ['zulu_sunrise', { name: 'E:ZULU SUNRISE TIME', type: SimVarValueType.Seconds }],
            ['zulu_sunset', { name: 'E:ZULU SUNSET TIME', type: SimVarValueType.Seconds }],
        ]), bus, pacer);
        if (this.bus.getTopicSubscriberCount('realTime') > 0) {
            this.needPublishRealTime = true;
        }
        else {
            const sub = this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
                if (topic === 'realTime') {
                    this.needPublishRealTime = true;
                    sub.destroy();
                }
            }, true);
            sub.resume();
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
        if (this.hiFreqInterval === undefined) {
            this.hiFreqInterval = setInterval(() => this.publish('simTimeHiFreq', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds'))), 0);
        }
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
        if (this.hiFreqInterval !== undefined) {
            clearInterval(this.hiFreqInterval);
            this.hiFreqInterval = undefined;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needPublishRealTime) {
            this.publish('realTime', Date.now());
        }
        this.simVarPublisher.onUpdate();
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}
/**
 * A clock which keeps track of real-world and sim time.
 */
class Clock {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
        this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
        this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
        this.publisher.onUpdate();
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for electrical information.
 */
class ElectricalPublisher extends SimVarPublisher {
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ElectricalPublisher.simvars, bus, pacer);
        this.flightStarted = false;
        this.avBusList = ['elec_av1_bus', 'elec_av2_bus'];
        for (const topic of this.avBusList) {
            if (bus.getTopicSubscriberCount(topic)) {
                this.subscribed.add(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((event) => {
            if (this.avBusList.includes(event)) {
                this.subscribed.add(event);
            }
        });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.flightStarted = true;
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.flightStarted) {
            super.onUpdate();
            if (this.av1BusLogic && this.subscribed.has('elec_av1_bus')) {
                this.publish('elec_av1_bus', this.av1BusLogic.getValue() !== 0);
            }
            if (this.av2BusLogic && this.subscribed.has('elec_av2_bus')) {
                this.publish('elec_av2_bus', this.av2BusLogic.getValue() !== 0);
            }
        }
    }
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement) {
        this.av1BusLogic = logicElement;
    }
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement) {
        this.av2BusLogic = logicElement;
    }
}
ElectricalPublisher.simvars = new Map([
    ['elec_master_battery', { name: 'ELECTRICAL MASTER BATTERY:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_avionics_on', { name: 'CIRCUIT AVIONICS ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_navcom1_on', { name: 'CIRCUIT NAVCOM1 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom2_on', { name: 'CIRCUIT NAVCOM2 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom3_on', { name: 'CIRCUIT NAVCOM3 ON', type: SimVarValueType.Bool }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE:#index#', type: SimVarValueType.Volts, indexed: true }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_2_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:2', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_3_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:3', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_4_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:4', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_5_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:5', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_6_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:6', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_2_a', { name: 'ELECTRICAL GENALT BUS AMPS:2', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_3_a', { name: 'ELECTRICAL GENALT BUS AMPS:3', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_4_a', { name: 'ELECTRICAL GENALT BUS AMPS:4', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_5_a', { name: 'ELECTRICAL GENALT BUS AMPS:5', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_6_a', { name: 'ELECTRICAL GENALT BUS AMPS:6', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_ext_power_available', { name: 'EXTERNAL POWER AVAILABLE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_ext_power_on', { name: 'EXTERNAL POWER ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_switch', { name: 'APU GENERATOR SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_active', { name: 'APU GENERATOR ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_eng_gen_switch', { name: 'GENERAL ENG MASTER ALTERNATOR:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_on', { name: 'CIRCUIT ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_switch_on', { name: 'CIRCUIT SWITCH ON:#index#', type: SimVarValueType.Bool, indexed: true }],
]);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/** The type of engine (see `ENGINE TYPE` simvar). */
var EngineType;
(function (EngineType) {
    EngineType[EngineType["Piston"] = 0] = "Piston";
    EngineType[EngineType["Jet"] = 1] = "Jet";
    EngineType[EngineType["None"] = 2] = "None";
    EngineType[EngineType["HeloTurbine"] = 3] = "HeloTurbine";
    EngineType[EngineType["Unsupported"] = 4] = "Unsupported";
    EngineType[EngineType["Turboprop"] = 5] = "Turboprop";
})(EngineType || (EngineType = {}));
/** A publisher for Engine information. */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const isUsingAdvancedFuelSystem = SimVar.GetSimVarValue('NEW FUEL SYSTEM', SimVarValueType.Bool) !== 0;
        const totalUnusableFuelGal = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.GAL);
        const totalUnusableFuelLb = UnitType.GALLON_FUEL.convertTo(totalUnusableFuelGal, UnitType.POUND);
        const nonIndexedSimVars = [
            ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
            ['fuel_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_usable_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelGal, 0) }],
            ['fuel_usable_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelLb, 0) }],
            ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main', { name: 'FUEL TANK LEFT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main_pct', { name: 'FUEL TANK LEFT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_right_main', { name: 'FUEL TANK RIGHT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right_main_pct', { name: 'FUEL TANK RIGHT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_center', { name: 'FUEL TANK CENTER QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_weight_per_gallon', { name: 'FUEL WEIGHT PER GALLON', type: SimVarValueType.LBS }],
            ['fuel_tank_selector_state_1', { name: 'FUEL TANK SELECTOR:1', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_2', { name: 'FUEL TANK SELECTOR:2', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_3', { name: 'FUEL TANK SELECTOR:3', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_4', { name: 'FUEL TANK SELECTOR:4', type: SimVarValueType.Number }],
            ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
            ['apu_pct', { name: 'APU PCT RPM', type: SimVarValueType.Percent }],
            ['apu_pct_starter', { name: 'APU PCT STARTER', type: SimVarValueType.Percent }],
            ['apu_switch', { name: 'APU SWITCH', type: SimVarValueType.Bool }],
            ['eng_starter_active', { name: 'GENERAL ENG STARTER ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['throttle_lower_limit', { name: 'THROTTLE LOWER LIMIT', type: SimVarValueType.Number }],
        ];
        const engineIndexedSimVars = [
            ['rpm', { name: 'GENERAL ENG RPM', type: SimVarValueType.RPM }],
            ['prop_rpm', { name: 'PROP RPM', type: SimVarValueType.RPM }],
            ['n1', { name: 'TURB ENG CORRECTED N1', type: SimVarValueType.Percent }],
            ['n1_uncorrected', { name: 'TURB ENG N1', type: SimVarValueType.Percent }],
            ['n2', { name: 'TURB ENG CORRECTED N2', type: SimVarValueType.Percent }],
            ['n2_uncorrected', { name: 'TURB ENG N2', type: SimVarValueType.Percent }],
            ['torque', { name: 'TURB ENG MAX TORQUE PERCENT', type: SimVarValueType.Percent }],
            ['fuel_flow', { name: 'ENG FUEL FLOW GPH', type: SimVarValueType.GPH }],
            ['recip_ff', { name: 'RECIP ENG FUEL FLOW', type: SimVarValueType.PPH }],
            ['oil_press', { name: 'ENG OIL PRESSURE', type: SimVarValueType.PSI }],
            ['oil_temp', { name: 'ENG OIL TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['itt', { name: 'TURB ENG ITT', type: SimVarValueType.Celsius }],
            ['egt', { name: 'ENG EXHAUST GAS TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['eng_hyd_press', { name: 'ENG HYDRAULIC PRESSURE', type: SimVarValueType.PSI }],
            ['eng_starter_on', { name: 'GENERAL ENG STARTER', type: SimVarValueType.Bool }],
            ['eng_combustion', { name: 'GENERAL ENG COMBUSTION', type: SimVarValueType.Bool }],
            ['eng_ignition_switch_state', { name: 'TURB ENG IGNITION SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_igniting', { name: 'TURB ENG IS IGNITING', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_on', { name: 'GENERAL ENG FUEL PUMP ON', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_switch_state', { name: 'GENERAL ENG FUEL PUMP SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_vibration', { name: 'ENG VIBRATION', type: SimVarValueType.Number }],
            ['fuel_flow_pph', { name: 'ENG FUEL FLOW PPH', type: SimVarValueType.PPH }],
            ['torque_moment', { name: 'ENG TORQUE', type: SimVarValueType.FtLb }],
            ['eng_manifold_pressure', { name: 'ENG MANIFOLD PRESSURE', type: SimVarValueType.PSI }],
            ['reverse_thrust_engaged', { name: 'GENERAL ENG REVERSE THRUST ENGAGED', type: SimVarValueType.Bool }],
            ['cylinder_head_temp_avg', { name: 'ENG CYLINDER HEAD TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['recip_turbine_inlet_temp_avg', { name: 'RECIP ENG TURBINE INLET TEMPERATURE', type: SimVarValueType.Farenheit }],
        ];
        const simvars = new Map(nonIndexedSimVars);
        // add engine-indexed simvars
        const engineCount = SimVar.GetSimVarValue('NUMBER OF ENGINES', SimVarValueType.Number);
        for (const [topic, simvar] of [...engineIndexedSimVars]) {
            // describe the indexed engine topics
            for (let i = 1; i <= engineCount; i++) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
        this.engineCount = engineCount;
        this.subscribed.add('fuel_flow_total');
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.subscribed.has('fuel_flow_total')) {
            let totalFuelFlow = 0;
            for (let i = 1; i <= this.engineCount; i++) {
                totalFuelFlow += SimVar.GetSimVarValue(`ENG FUEL FLOW GPH:${i}`, SimVarValueType.GPH);
            }
            this.publish('fuel_flow_total', totalFuelFlow);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Engine information.
 */
class WeightBalanceSimvarPublisher extends SimVarPublisher {
    /**
     * Create a WeightAndBalancePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['cg_percent', { name: 'CG PERCENT', type: SimVarValueType.Percent }],
            ['total_weight', { name: 'TOTAL WEIGHT', type: SimVarValueType.Pounds }],
            ['payload_station_weight', { name: 'PAYLOAD STATION WEIGHT:#index#', type: SimVarValueType.Pounds, indexed: true }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * Flight timer modes.
 */
var FlightTimerMode;
(function (FlightTimerMode) {
    FlightTimerMode[FlightTimerMode["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode[FlightTimerMode["CountingUp"] = 1] = "CountingUp";
})(FlightTimerMode || (FlightTimerMode = {}));
/**
 * A utility class for working with flight timers.
 */
class FlightTimerUtils {
    /**
     * Gets the event bus topic suffix for a flight timer ID.
     * @param id The ID for which to get the suffix.
     * @returns The event bus topic suffix for the specified flight timer ID.
     */
    static getIdSuffix(id) {
        return (id === '' ? '' : `_${id}`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static onEvent(id, index, arg2, baseTopic) {
        return (arg2 instanceof EventBus ? arg2.getSubscriber() : arg2).on(`${baseTopic}${FlightTimerUtils.getIdSuffix(id)}_${index}`);
    }
}
/**
 * A publisher for flight timer information.
 */
class FlightTimerPublisher extends SimVarPublisher {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(bus, arg2, pacer) {
        var _a;
        const id = (typeof arg2 === 'number' ? '' : ((_a = arg2 === null || arg2 === void 0 ? void 0 : arg2.id) !== null && _a !== void 0 ? _a : ''));
        const suffix = FlightTimerUtils.getIdSuffix(id);
        const entries = [
            [`timer_mode${suffix}`, { name: `L:WTFltTimer_Mode${suffix}:#index#`, type: SimVarValueType.Number, indexed: true, defaultIndex: null }],
            [`timer_is_running${suffix}`, { name: `L:WTFltTimer_Running${suffix}:#index#`, type: SimVarValueType.Bool, indexed: true, defaultIndex: null }],
            [`timer_initial_value_ms${suffix}`, { name: `L:WTFltTimer_Initial_Value${suffix}:#index#`, type: SimVarValueType.Number, indexed: true, defaultIndex: null }],
            [`timer_value_ms${suffix}`, { name: `L:WTFltTimer_Value${suffix}:#index#`, type: SimVarValueType.Number, indexed: true, defaultIndex: null }]
        ];
        super(entries, bus, pacer);
    }
}

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * A publisher for global positioning and inertial data.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['zulu_time', { name: 'E:ZULU TIME', type: SimVarValueType.Seconds }],
            ['time_of_day', { name: 'E:TIME OF DAY', type: SimVarValueType.Number }],
            ['ground_speed', { name: 'GROUND VELOCITY', type: SimVarValueType.Knots }],
            ['ground_altitude', { name: 'GROUND ALTITUDE', type: SimVarValueType.Feet }],
            ['above_ground_height', { name: 'PLANE ALT ABOVE GROUND', type: SimVarValueType.Feet }],
            ['inertial_vertical_speed', { name: 'VELOCITY WORLD Y', type: SimVarValueType.FPM }]
        ]), this.bus, this.pacer);
        this.needPublish = {
            'gps-position': false,
            'track_deg_true': false,
            'track_deg_magnetic': false,
            'magvar': false,
            'inertial_speed': false,
            'inertial_acceleration': false,
            'inertial_track_acceleration': false
        };
        for (const topic in this.needPublish) {
            this.needPublish[topic] = bus.getTopicSubscriberCount(topic) > 0;
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle(this.onTopicSubscribed.bind(this));
    }
    /**
     * Responds to when a topic is first subscribed to on the event bus.
     * @param topic The subscribed topic.
     */
    onTopicSubscribed(topic) {
        if (topic in this.needPublish) {
            this.needPublish[topic] = true;
            if (this.publishActive) {
                switch (topic) {
                    case 'gps-position':
                        this.publishPosition();
                        break;
                    case 'track_deg_true':
                        this.publishTrack(true, false, false);
                        break;
                    case 'track_deg_magnetic':
                        this.publishTrack(false, true, false);
                        break;
                    case 'magvar':
                        this.publishTrack(false, false, true);
                        break;
                    case 'inertial_speed':
                        this.publishInertialData(true, false, false);
                        break;
                    case 'inertial_acceleration':
                        this.publishInertialData(false, true, false);
                        break;
                    case 'inertial_track_acceleration':
                        this.publishInertialData(false, false, true);
                        break;
                }
            }
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        this.needPublish['gps-position'] && this.publishPosition();
        this.publishTrack(this.needPublish['track_deg_true'], this.needPublish['track_deg_magnetic'], this.needPublish['magvar']);
        this.publishInertialData(this.needPublish['inertial_speed'], this.needPublish['inertial_acceleration'], this.needPublish['inertial_track_acceleration']);
        this.simVarPublisher.onUpdate();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Meters);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the `track_deg_true`, `track_deg_magnetic`, and `magvar` topics.
     * @param publishTrue Whether to publish the `track_deg_true` topic.
     * @param publishMagnetic Whether to publish the `track_deg_magnetic` topic.
     * @param publishMagvar Whether to publish the `magvar` topic.
     */
    publishTrack(publishTrue, publishMagnetic, publishMagvar) {
        let trueTrack = 0;
        let magneticTrack = 0;
        let magvar = 0;
        if (publishTrue || publishMagnetic) {
            const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
            trueTrack = GNSSPublisher.getInstantaneousTrack(headingTrue);
        }
        if (publishMagvar || publishMagnetic) {
            magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
            if (publishMagnetic) {
                magneticTrack = NavMath.normalizeHeading(trueTrack - magvar);
            }
        }
        publishTrue && this.publish('track_deg_true', trueTrack);
        publishMagnetic && this.publish('track_deg_magnetic', magneticTrack);
        publishMagvar && this.publish('magvar', magvar);
    }
    /**
     * Publishes the `inertial_speed`, `inertial_acceleration`, and `inertial_track_acceleration` topics.
     * @param publishSpeed Whether to publish the `inertial_speed` topic.
     * @param publishAcceleration Whether to publish the `inertial_acceleration` topic.
     * @param publishTrackAcceleration Whether to publish the `inertial_track_acceleration` topic.
     */
    publishInertialData(publishSpeed, publishAcceleration, publishTrackAcceleration) {
        const velocityVec = this.vec3Cache[0];
        const accelerationVec = this.vec3Cache[1];
        let speed = 0;
        let acceleration = 0;
        if (publishSpeed || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('VELOCITY BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Z', SimVarValueType.MetersPerSecond), velocityVec);
            speed = Vec3Math.abs(velocityVec);
        }
        if (publishAcceleration || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('ACCELERATION BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Z', SimVarValueType.MetersPerSecond), accelerationVec);
            acceleration = Vec3Math.abs(accelerationVec);
        }
        publishSpeed && this.publish('inertial_speed', speed);
        publishAcceleration && this.publish('inertial_acceleration', acceleration);
        publishTrackAcceleration && this.publish('inertial_track_acceleration', speed === 0 ? acceleration : Vec3Math.dot(accelerationVec, velocityVec) / speed);
    }
    /**
     * Gets the instantaneous true track.
     * @param headingTrue The true heading, in degrees.
     * @returns The true track, in degrees.
     */
    static getInstantaneousTrack(headingTrue = 0) {
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(Math.atan2(velocityEW, velocityNS) * Avionics.Utils.RAD2DEG);
        }
        return track;
    }
}

/**
 * SBAS group names.
 */
var SBASGroupName;
(function (SBASGroupName) {
    /** Wide Area Augmentation System (USA). */
    SBASGroupName["WAAS"] = "WAAS";
    /** European Geostationary Navigation Overlay Service (EU). */
    SBASGroupName["EGNOS"] = "EGNOS";
    /** GPS Aided Geo Augmented Navigation System (India). */
    SBASGroupName["GAGAN"] = "GAGAN";
    /** Multi-functional Satellite Augmentation System (Japan). */
    SBASGroupName["MSAS"] = "MSAS";
})(SBASGroupName || (SBASGroupName = {}));
/**
 * Possible state on GPS satellites.
 */
var GPSSatelliteState;
(function (GPSSatelliteState) {
    /** There is no current valid state. */
    GPSSatelliteState["None"] = "None";
    /** The satellite is out of view and cannot be reached. */
    GPSSatelliteState["Unreachable"] = "Unreachable";
    /** The satellite has been found and data is being downloaded. */
    GPSSatelliteState["Acquired"] = "Acquired";
    /** The satellite is faulty. */
    GPSSatelliteState["Faulty"] = "Faulty";
    /** The satellite has been found, data is downloaded, but is not presently used in the GPS solution. */
    GPSSatelliteState["DataCollected"] = "DataCollected";
    /** The satellite is being active used in the GPS solution. */
    GPSSatelliteState["InUse"] = "InUse";
    /** The satellite is being active used in the GPS solution and SBAS differential corrections are being applied. */
    GPSSatelliteState["InUseDiffApplied"] = "InUseDiffApplied";
})(GPSSatelliteState || (GPSSatelliteState = {}));
/**
 * Possible {@link GPSSatComputer} states.
 */
var GPSSystemState;
(function (GPSSystemState) {
    /** The GPS receiver is searching for any visible satellites to acquire. */
    GPSSystemState["Searching"] = "Searching";
    /** The GPS receiver is in the process of acquiring satellites. */
    GPSSystemState["Acquiring"] = "Acquiring";
    /** A 3D solution has been acquired. */
    GPSSystemState["SolutionAcquired"] = "SolutionAcquired";
    /** A 3D solution using differential computations has been acquired. */
    GPSSystemState["DiffSolutionAcquired"] = "DiffSolutionAcquired";
})(GPSSystemState || (GPSSystemState = {}));
/**
 * Possible SBAS connection states.
 */
var GPSSystemSBASState;
(function (GPSSystemSBASState) {
    /** SBAS is disabled. */
    GPSSystemSBASState["Disabled"] = "Disabled";
    /** SBAS is enabled but not receiving differential corrections. */
    GPSSystemSBASState["Inactive"] = "Inactive";
    /** SBAS is enabled and is receiving differential corrections. */
    GPSSystemSBASState["Active"] = "Active";
})(GPSSystemSBASState || (GPSSystemSBASState = {}));
/**
 * An instrument that computes GPS satellite information.
 */
class GPSSatComputer {
    /**
* Gets the current satellites that are being tracked by this computer.
     * @returns The collection of current satellites.
     */
    get sats() {
        return this.satellites;
    }
    /**
     * Gets the current GPS system state.
     * @returns The current GPS system state.
     */
    get state() {
        return this._state;
    }
    /**
     * Gets the current GPS system SBAS state.
     * @returns The current GPS system SBAS state.
     */
    get sbasState() {
        return this._sbasState;
    }
    /**
     * Gets this system's current position dilution of precision value (PDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current position dilution of precision value (PDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get pdop() {
        return this._pdop;
    }
    /**
     * Gets this system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get hdop() {
        return this._hdop;
    }
    /**
     * Gets this system's current vertical dilution of precision value (VDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current vertical dilution of precision value (VDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get vdop() {
        return this._vdop;
    }
    /**
     * Creates an instance of GPSSatComputer.
     * @param index The index of this computer.
     * @param bus An instance of the event bus.
     * @param ephemerisFile The HTTP path to the ephemeris file to use for computations.
     * @param sbasFile The HTTP path to the SBAS definitions file.
     * @param updateInterval The interval in milliseconds to update the satellite positions.
     * @param enabledSBASGroups The names of the SBAS satellite groups for which signal reception is enabled. If the
     * computer's sync role is `replica`, then this parameter is ignored and the computer will sync enabled SBAS groups
     * from the primary instance.
     * @param syncRole This computer's sync role. A `primary` computer will broadcast sync events through the event bus
     * that allow corresponding `replica` computers to sync their state with the primary. A computer with a sync role of
     * `none` neither broadcasts sync events nor receives them; it maintains its own independent state. Defaults to
     * `none`.
     * @param options Options with which to configure the computer.
     */
    constructor(index, bus, ephemerisFile, sbasFile, updateInterval, enabledSBASGroups, syncRole = 'none', options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        var _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7;
        this.index = index;
        this.bus = bus;
        this.ephemerisFile = ephemerisFile;
        this.sbasFile = sbasFile;
        this.updateInterval = updateInterval;
        this.syncRole = syncRole;
        this.publisher = this.bus.getPublisher();
        this.syncPublisher = this.bus.getPublisher();
        this.nominalChannelCountTopic = `gps_system_nominal_channel_count_${this.index}`;
        this.stateChangedTopic = `gps_system_state_changed_${this.index}`;
        this.satStateChangedTopic = `gps_sat_state_changed_${this.index}`;
        this.satPosCalcTopic = `gps_sat_pos_calculated_${this.index}`;
        this.sbasStateChangedTopic = `gps_system_sbas_state_changed_${this.index}`;
        this.pdopTopic = `gps_system_pdop_${this.index}`;
        this.hdopTopic = `gps_system_hdop_${this.index}`;
        this.vdopTopic = `gps_system_vdop_${this.index}`;
        this.channelStateSyncTopic = `gps_system_sync_channel_state_changed_${this.index}`;
        this.satCalcSyncTopic = `gps_system_sync_sat_calc_${this.index}`;
        this.satStateSyncTopic = `gps_system_sync_sat_state_changed_${this.index}`;
        this.enabledSbasSyncTopic = `gps_system_sync_enabled_sbas_changed_${this.index}`;
        this.resetSyncTopic = `gps_system_sync_reset_${this.index}`;
        this.stateRequestSyncTopic = `gps_system_sync_state_request_${this.index}`;
        this.stateResponseSyncTopic = `gps_system_sync_state_response_${this.index}`;
        this.ephemerisData = {};
        this.sbasData = [];
        this.sbasServiceAreas = new Map();
        this.currentAvailableSbasGroups = new Set();
        this.satellites = [];
        this.publishedSatStates = [];
        this.channels = [];
        this.ppos = new GeoPoint(0, 0);
        this.pposVec = new Float64Array(2);
        this.lastKnownPosition = new GeoPoint(NaN, NaN);
        this.distanceFromLastKnownPos = 0;
        this.altitude = 0;
        this.simTime = 0;
        this.previousSimTime = 0;
        this.lastUpdateTime = undefined;
        this._state = GPSSystemState.Searching;
        this._sbasState = GPSSystemSBASState.Disabled;
        this.dops = Vec3Math.create();
        this._pdop = -1;
        this._hdop = -1;
        this._vdop = -1;
        this.isInit = false;
        this.needAcquireAndUse = false;
        this.needSatCalc = false;
        this.pendingChannelStateUpdates = new Map();
        this.pendingSatStateUpdates = new Map();
        this.almanacProgress = 0;
        this.lastAlamanacTime = undefined;
        this._isAlmanacValid = false;
        this.covarMatrix = [
            new Float64Array(4),
            new Float64Array(4),
            new Float64Array(4),
            new Float64Array(4),
        ];
        this.ephemerisCollectedSatelliteFilter = (sat) => {
            return GPSSatComputer.EPHEMERIS_COLLECTED_SATELLITE_STATES.has(sat.state.get());
        };
        this.losSatelliteFilter = (sat) => {
            return sat.signalStrength.get() > 0.05
                && ((this.distanceFromLastKnownPos < 0.0290367 // 100 nautical miles
                    && (this._isAlmanacValid || sat.isCachedEphemerisValid(this.simTime)))
                    || GPSSatComputer.EPHEMERIS_COLLECTED_SATELLITE_STATES.has(sat.state.get()));
        };
        this.losSatelliteFilterOmniscient = (sat) => {
            return sat.signalStrength.get() > 0.05;
        };
        this.untrackedSatelliteFilter = (sat) => {
            return !this.channels.includes(sat) && sat.state.get() !== GPSSatelliteState.Unreachable;
        };
        this.satelliteCosts = [];
        this.satelliteCostCompare = (indexA, indexB) => {
            return this.satelliteCosts[indexA] - this.satelliteCosts[indexB];
        };
        this.collectingDataSatelliteFilter = (sat) => {
            return sat !== null && GPSSatComputer.COLLECTING_DATA_SATELLITE_STATES.has(sat.state.get());
        };
        const desiredChannelCount = Math.max((_a = options === null || options === void 0 ? void 0 : options.channelCount) !== null && _a !== void 0 ? _a : Infinity, 4);
        this.nominalChannelCount = isFinite(desiredChannelCount) ? desiredChannelCount : null;
        this._channelCount = desiredChannelCount;
        this.satInUseMaxCount = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.satInUseMaxCount) !== null && _b !== void 0 ? _b : Infinity, true);
        this.satInUsePdopTarget = SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.satInUsePdopTarget) !== null && _c !== void 0 ? _c : -1, true);
        this.satInUseOptimumCount = SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.satInUseOptimumCount) !== null && _d !== void 0 ? _d : 4, true);
        this.satelliteTimingOptions = Object.assign({}, options === null || options === void 0 ? void 0 : options.timingOptions);
        (_e = (_u = this.satelliteTimingOptions).almanacExpireTime) !== null && _e !== void 0 ? _e : (_u.almanacExpireTime = 7776000000);
        (_f = (_v = this.satelliteTimingOptions).ephemerisExpireTime) !== null && _f !== void 0 ? _f : (_v.ephemerisExpireTime = 7200000);
        (_g = (_w = this.satelliteTimingOptions).acquisitionTimeout) !== null && _g !== void 0 ? _g : (_w.acquisitionTimeout = 30000);
        (_h = (_x = this.satelliteTimingOptions).acquisitionTime) !== null && _h !== void 0 ? _h : (_x.acquisitionTime = 30000);
        (_j = (_y = this.satelliteTimingOptions).acquisitionTimeRange) !== null && _j !== void 0 ? _j : (_y.acquisitionTimeRange = 15000);
        (_k = (_z = this.satelliteTimingOptions).acquisitionTimeWithEphemeris) !== null && _k !== void 0 ? _k : (_z.acquisitionTimeWithEphemeris = 15000);
        (_l = (_0 = this.satelliteTimingOptions).acquisitionTimeRangeWithEphemeris) !== null && _l !== void 0 ? _l : (_0.acquisitionTimeRangeWithEphemeris = 5000);
        (_m = (_1 = this.satelliteTimingOptions).unreachableExpireTime) !== null && _m !== void 0 ? _m : (_1.unreachableExpireTime = 3600000);
        (_o = (_2 = this.satelliteTimingOptions).ephemerisDownloadTime) !== null && _o !== void 0 ? _o : (_2.ephemerisDownloadTime = 30000);
        (_p = (_3 = this.satelliteTimingOptions).almanacDownloadTime) !== null && _p !== void 0 ? _p : (_3.almanacDownloadTime = 750000);
        (_q = (_4 = this.satelliteTimingOptions).sbasEphemerisDownloadTime) !== null && _q !== void 0 ? _q : (_4.sbasEphemerisDownloadTime = 60500);
        (_r = (_5 = this.satelliteTimingOptions).sbasEphemerisDownloadTimeRange) !== null && _r !== void 0 ? _r : (_5.sbasEphemerisDownloadTimeRange = 59500);
        (_s = (_6 = this.satelliteTimingOptions).sbasCorrectionDownloadTime) !== null && _s !== void 0 ? _s : (_6.sbasCorrectionDownloadTime = 150500);
        (_t = (_7 = this.satelliteTimingOptions).sbasCorrectionDownloadTimeRange) !== null && _t !== void 0 ? _t : (_7.sbasCorrectionDownloadTimeRange = 149500);
        if (syncRole === 'replica') {
            this.enabledSBASGroups = Value.create(this.enabledSBASGroupsSet = new Set());
        }
        else {
            this.enabledSBASGroups = enabledSBASGroups !== undefined && 'isSubscribableSet' in enabledSBASGroups
                ? enabledSBASGroups
                : SetSubject.create(enabledSBASGroups);
        }
        // Initialize these properties directly from SimVars in case the computer is created before values are published
        // to the bus.
        this.ppos.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this.altitude = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Meters);
        this.simTime = (SimVar.GetSimVarValue('E:ABSOLUTE TIME', SimVarValueType.Seconds) - 62135596800) * 1000;
        this.bus.getSubscriber().on('gps-position').handle(pos => {
            this.ppos.set(pos.lat, pos.long);
            Vec2Math.set(pos.lat, pos.long, this.pposVec);
            this.altitude = pos.alt;
        });
        this.bus.getSubscriber().on('simTime').handle(time => this.simTime = time);
    }
        /**
     * Adds the defined SBAS satellites to the tracked satellites.
     */
    addSbasSatellites() {
        const tempVec = new Float64Array(3);
        const tempGeoPoint = new GeoPoint(0, 0);
        const orbitHeight = UnitType.KILOMETER.convertTo(35785, UnitType.GA_RADIAN);
        for (let i = 0; i < this.sbasData.length; i++) {
            const sbasDef = this.sbasData[i];
            this.sbasServiceAreas.set(sbasDef.group, sbasDef.coverage);
            for (const satDef of sbasDef.constellation) {
                const sat = new GPSSatellite(satDef.prn, sbasDef.group, undefined, this.satelliteTimingOptions);
                tempGeoPoint.set(0, satDef.lon);
                const positionCartesian = Vec3Math.multScalar(tempGeoPoint.toCartesian(tempVec), orbitHeight, tempVec);
                sat.positionCartesian.set(positionCartesian);
                this.satellites.push(sat);
            }
        }
    }
    /** @inheritdoc */
    init() {
        // Publish initial state.
        this.publisher.pub(this.nominalChannelCountTopic, this.nominalChannelCount, false, true);
        this.publisher.pub(this.stateChangedTopic, this._state, false, true);
        this.publisher.pub(this.sbasStateChangedTopic, this._sbasState, false, true);
        this.publisher.pub(this.pdopTopic, this._pdop, false, true);
        this.publisher.pub(this.hdopTopic, this._hdop, false, true);
        this.publisher.pub(this.vdopTopic, this._vdop, false, true);
        this.loadEphemerisData().then(() => this.loadSbasData()).then(() => {
        this.publishedSatStates.length = this.satellites.length;
            for (let i = 0; i < this.satellites.length; i++) {
                const sat = this.satellites[i];
                this.publishedSatStates[i] = { prn: sat.prn, state: GPSSatelliteState.None, areDiffCorrectionsDownloaded: false };
            }
            this._channelCount = Math.min(this._channelCount, this.satellites.length);
            this.channels.length = this._channelCount;
            this.channels.fill(null);
            this.isInit = true;
            // Setup sync logic.
            if (this.syncRole === 'replica') {
                const sub = this.bus.getSubscriber();
                const copyEnabledSbasGroups = (groups) => {
                    this.enabledSBASGroupsSet.clear();
                    for (const group of groups) {
                        this.enabledSBASGroupsSet.add(group);
                    }
                };
                sub.on(this.channelStateSyncTopic).handle(data => { this.pendingChannelStateUpdates.set(data.index, data); });
                sub.on(this.satCalcSyncTopic).handle(() => { this.needSatCalc = true; });
                sub.on(this.satStateSyncTopic).handle(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                sub.on(this.enabledSbasSyncTopic).handle(copyEnabledSbasGroups);
                sub.on(this.resetSyncTopic).handle(() => { this.reset(); });
                sub.on(this.stateResponseSyncTopic).handle(response => {
                    this.needSatCalc = true;
                    for (const channelState of response.channels) {
                        this.pendingChannelStateUpdates.set(channelState.index, channelState);
                    }
                    for (const satState of response.satStates) {
                        this.pendingSatStateUpdates.set(satState.prn, satState);
                    }
                    copyEnabledSbasGroups(response.enabledSbasGroups);
                });
                // Request initial state.
                this.syncPublisher.pub(this.stateRequestSyncTopic, undefined, true, false);
            }
            else if (this.syncRole === 'primary') {
                const sub = this.bus.getSubscriber();
                sub.on(this.stateRequestSyncTopic).handle(() => {
                    this.syncPublisher.pub(this.stateResponseSyncTopic, {
                        channels: this.channels.map((sat, index) => { return { index, prn: sat === null ? null : sat.prn }; }),
                        satStates: this.satellites.map(sat => { return { prn: sat.prn, state: sat.state.get(), areDiffCorrectionsDownloaded: sat.areDiffCorrectionsDownloaded }; }),
                        enabledSbasGroups: Array.from(this.enabledSBASGroups.get())
                    }, true, false);
                });
                this.enabledSBASGroups.sub(groups => {
                    this.syncPublisher.pub(this.enabledSbasSyncTopic, Array.from(groups), true, false);
                });
            }
            if (this.needAcquireAndUse) {
                this.needAcquireAndUse = false;
                this.acquireAndUseSatellites();
            }
            else {
                this.reset();
            }
        });
    }
    /**
     * Loads the GPS ephemeris data file.
     */
    loadEphemerisData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.ephemerisData = JSON.parse(request.responseText);
                        for (const prn in this.ephemerisData) {
                            this.satellites.push(new GPSSatellite(parseInt(prn), undefined, this.ephemerisData[prn], this.satelliteTimingOptions));
                        }
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with ephemeris data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.ephemerisFile);
            request.send();
        });
    }
    /**
     * Loads the GPS SBAS data file.
     */
    loadSbasData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.sbasData = JSON.parse(request.responseText);
                        this.addSbasSatellites();
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with sbas data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.sbasFile);
            request.send();
        });
    }
    /**
     * Gets the index of a satellite with a given PRN identifier.
     * @param prn The PRN identifier for which to get the satellite index.
     * @returns The index of the satellite with the specified PRN identifier, or `-1` if the PRN does not belong to any
     * satellite.
     */
    getSatelliteIndexFromPrn(prn) {
        for (let i = 0; i < this.satellites.length; i++) {
            if (this.satellites[i].prn === prn) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Calculates the horizon zenith angle.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    calcHorizonAngle() {
        return Math.acos(6378100 / (6378100 + this.altitude));
    }
    /**
     * Syncs this computer's last known position with a given value.
     * @param pos The position with which to sync the last known position. Defaults to the airplane's current position.
     */
    syncLastKnownPosition(pos = this.ppos) {
        this.lastKnownPosition.set(pos);
    }
    /**
     * Erases this computer's last known position.
     */
    eraseLastKnownPosition() {
        this.lastKnownPosition.set(NaN, NaN);
    }
    /**
     * Checks whether this computer's downloaded almanac data is valid at a given simulation time.
     * @param simTime The simulation time at which to check for almanac validity, as a Javascript timestamp. Defaults to
     * the current simulation time.
     * @returns Whether this computer's downloaded almanac data is valid at the specified simulation time.
     */
    isAlmanacValid(simTime = this.simTime) {
        return this.lastAlamanacTime !== undefined && Math.abs(simTime - this.lastAlamanacTime) < this.satelliteTimingOptions.almanacExpireTime;
    }
    /**
     * Forces this computer to immediately download a complete alamanac.
     * @param simTime The simulation time at which the almanac is considered to have been downloaded, as a Javascript
     * timestamp. Defaults to the current simulation time.
     */
    downloadAlamanac(simTime = this.simTime) {
        this.almanacProgress = 0;
        this.lastAlamanacTime = simTime;
    }
    /**
     * Erases this computer's downloaded almanac and any partial download progress.
     */
    eraseAlamanac() {
        this.almanacProgress = 0;
        this.lastAlamanacTime = undefined;
    }
    /**
     * Erases this computer's cached ephemeris data for all satellites.
     */
    eraseCachedEphemeris() {
        for (let i = 0; i < this.satellites.length; i++) {
            this.satellites[i].eraseCachedEphemeris();
        }
    }
    /**
     * Instantly chooses the optimal satellites to track for all receiver channels, then acquires and downloads all data
     * (ephemeris, almanac, and differential corrections) from tracked satellites with sufficient signal strength. If
     * this system is not initialized, the operation will be delayed until just after initialization, unless `reset()` is
     * called in the interim.
     *
     * Has no effect if this system is a replica.
     */
    acquireAndUseSatellites() {
        if (this.syncRole === 'replica') {
            return;
        }
        if (this.isInit) {
            this.updateSatellites(this.simTime, 0, true, true);
        }
        else {
            this.needAcquireAndUse = true;
        }
    }
    /**
     * Resets the GPSSatComputer system. This will set the state of the system to {@link GPSSystemState.Searching},
     * unassign all receiver channels, and set the state of every satellite to {@link GPSSatelliteState.None}.
     *
     * If this system is not initialized, this method has no effect other than to cancel any pending operations triggered
     * by previous calls to `acquireAndUseSatellites()`.
     */
    reset() {
        this.needAcquireAndUse = false;
        if (!this.isInit) {
            return;
        }
        for (let i = 0; i < this.channels.length; i++) {
            this.channels[i] = null;
        }
        for (const sat of this.satellites) {
            const oldState = sat.state.get();
            sat.setTracked(false);
            sat.state.set(GPSSatelliteState.None);
            if (oldState !== GPSSatelliteState.None) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
            }
        }
        const currentState = this._state;
        this._state = GPSSystemState.Searching;
        if (currentState !== GPSSystemState.Searching) {
            this.publisher.pub(this.stateChangedTopic, GPSSystemState.Searching, false, true);
        }
        this.setDop(-1, -1, -1);
        if (this.syncRole === 'primary') {
            this.syncPublisher.pub(this.resetSyncTopic, undefined, true, false);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isInit) {
            return;
        }
        const deltaTime = this.simTime - this.previousSimTime;
        if (this.syncRole !== 'replica') {
            if (deltaTime < 0 || deltaTime > (this.updateInterval * 2)) {
                this.previousSimTime = this.simTime;
                if (this.lastUpdateTime !== undefined) {
                this.lastUpdateTime = this.simTime;
                }
                return;
            }
        }
        const shouldUpdatePositions = this.syncRole === 'replica'
            ? this.needSatCalc
            : this.lastUpdateTime === undefined || this.simTime >= this.lastUpdateTime + this.updateInterval;
        this.needSatCalc = false;
        this.updateSatellites(this.simTime, deltaTime, shouldUpdatePositions, false);
    }
    /**
     * Updates the states and optionally the orbital positions of all satellites.
* @param simTime The current simulation time, as a Javascript timestamp.
     * @param deltaTime The time elapsed, in milliseconds, since the last satellite update.
     * @param shouldUpdatePositions Whether to update the orbital positions of the satellites.
     * @param forceAcquireAndUse Whether to immediately choose the optimal satellites to track for all receiver channels,
     * then acquire and download all data (ephemeris, almanac, and differential corrections) from tracked satellites with
     * sufficient signal strength.
     */
    updateSatellites(simTime, deltaTime, shouldUpdatePositions, forceAcquireAndUse) {
        var _a, _b;
        let numAcquiring = 0;
        let canApplyDiffCorrections = false;
        let shouldUpdateDop = shouldUpdatePositions;
        if (shouldUpdatePositions && this.syncRole === 'primary') {
            (_a = this.syncPublisher) === null || _a === void 0 ? void 0 : _a.pub(this.satCalcSyncTopic, undefined, true, false);
        }
        if (forceAcquireAndUse) {
            this.lastKnownPosition.set(this.ppos);
        }
        this.distanceFromLastKnownPos = isNaN(this.lastKnownPosition.lat) || isNaN(this.lastKnownPosition.lon)
            ? Infinity
            : this.ppos.distance(this.lastKnownPosition);
        this._isAlmanacValid = this.isAlmanacValid();
        this.updateAvailableSbasGroups();
        const enabledSBASGroups = this.enabledSBASGroups.get();
        for (let i = 0; i < this.satellites.length; i++) {
            const sat = this.satellites[i];
            if (shouldUpdatePositions) {
                sat.computeSatellitePositions(this.simTime);
                sat.applyProjection(this.ppos, this.altitude);
            }
            sat.calculateSignalStrength(this.altitude);
        }
        if (this.syncRole === 'replica') {
            for (const update of this.pendingChannelStateUpdates.values()) {
                const sat = update.prn === null ? null : ((_b = this.satellites[this.getSatelliteIndexFromPrn(update.prn)]) !== null && _b !== void 0 ? _b : null);
                this.assignSatelliteToChannel(update.index, sat);
            }
        }
        else if (shouldUpdatePositions) {
            this.updateChannelAssignments(forceAcquireAndUse);
        }
        this.pendingChannelStateUpdates.clear();
        for (let i = 0; i < this.satellites.length; i++) {
            const sat = this.satellites[i];
            let updatedState;
            if (this.syncRole === 'replica') {
                const stateUpdate = this.pendingSatStateUpdates.get(sat.prn);
                updatedState = sat.forceUpdateState(simTime, stateUpdate === null || stateUpdate === void 0 ? void 0 : stateUpdate.state, stateUpdate === null || stateUpdate === void 0 ? void 0 : stateUpdate.areDiffCorrectionsDownloaded);
            }
            else {
                updatedState = sat.updateState(simTime, deltaTime, this.distanceFromLastKnownPos, forceAcquireAndUse);
}
            if (updatedState) {
                                shouldUpdateDop = true;
            }
            const satState = sat.state.get();
            if (satState === GPSSatelliteState.DataCollected
                || satState === GPSSatelliteState.InUse
                || satState === GPSSatelliteState.InUseDiffApplied) {
                numAcquiring++;
                if (sat.areDiffCorrectionsDownloaded && this.currentAvailableSbasGroups.has(sat.sbasGroup)) {
                    canApplyDiffCorrections = true;
                }
            }
            else if (satState === GPSSatelliteState.Acquired) {
                numAcquiring++;
            }
        }
        this.pendingSatStateUpdates.clear();
        const newSBASState = canApplyDiffCorrections
            ? GPSSystemSBASState.Active
            : enabledSBASGroups.size === 0 ? GPSSystemSBASState.Disabled : GPSSystemSBASState.Inactive;
                let pdop = this._pdop, hdop = this._hdop, vdop = this._vdop;
        if (shouldUpdateDop) {
            if (this.syncRole !== 'replica') {
                [pdop, hdop, vdop] = this.selectSatellites(this.dops);
            }
            else if (shouldUpdateDop) {
            [pdop, hdop, vdop] = this.calculateDop(this.dops);
        }
        }
        let newSystemState = GPSSystemState.Searching;
        if (pdop >= 0) {
            newSystemState = canApplyDiffCorrections ? GPSSystemState.DiffSolutionAcquired : GPSSystemState.SolutionAcquired;
            this.lastKnownPosition.set(this.ppos);
        }
        else if (numAcquiring > 0) {
            newSystemState = GPSSystemState.Acquiring;
        }
        else if (this.distanceFromLastKnownPos < 0.0290367 /* 100 nautical miles */) {
            // Set system state to 'Acquiring' if we are attempting to acquire at least one satellite for which we have
            // predicted geometry data (either from the almanac or cached ephemeris data).
            for (let i = 0; i < this.channels.length; i++) {
                const sat = this.channels[i];
                if (sat && sat.state.get() === GPSSatelliteState.None && (this._isAlmanacValid || sat.isCachedEphemerisValid(this.simTime))) {
                    newSystemState = GPSSystemState.Acquiring;
                    break;
                }
            }
        }
        if (this.syncRole !== 'replica') {
            for (let i = 0; i < this.channels.length; i++) {
                const sat = this.channels[i];
                if (sat) {
                    sat.updateDiffCorrectionsApplied(canApplyDiffCorrections);
                }
            }
            this.updateAlmanacState(simTime, deltaTime, forceAcquireAndUse);
        }
this.diffAndPublishSatelliteStates();
        if (this._state !== newSystemState) {
            this._state = newSystemState;
            this.publisher.pub(this.stateChangedTopic, newSystemState, false, true);
        }
        if (this._sbasState !== newSBASState) {
            this._sbasState = newSBASState;
            this.publisher.pub(this.sbasStateChangedTopic, newSBASState, false, true);
        }
        if (shouldUpdatePositions) {
            this.lastUpdateTime = this.simTime;
            this.publisher.pub(this.satPosCalcTopic, undefined, false, false);
        }
        this.setDop(pdop, hdop, vdop);
        this.previousSimTime = this.simTime;
    }
    /**
     * Updates which SBAS groups are enabled and whose coverage area contain the airplane's current position.
     */
    updateAvailableSbasGroups() {
        const enabledSBASGroups = this.enabledSBASGroups.get();
        for (let i = 0; i < this.sbasData.length; i++) {
            const sbasData = this.sbasData[i];
            if (enabledSBASGroups.has(sbasData.group) && Vec2Math.pointWithinPolygon(sbasData.coverage, this.pposVec)) {
                this.currentAvailableSbasGroups.add(sbasData.group);
            }
            else {
                this.currentAvailableSbasGroups.delete(sbasData.group);
            }
        }
    }
    /**
     * Updates the satellites assigned to be tracked by this computer's receiver channels.
     * @param forceAcquireAndUse Whether to immediately choose the optimal satellites to track and acquire all data from
     * tracked satellites if signal strength is sufficient.
     */
    updateChannelAssignments(forceAcquireAndUse) {
        // If we have at least one channel for every satellite, then we will simply assign each satellite to its own
        // channel.
        if (this._channelCount >= this.satellites.length) {
            const end = Math.min(this._channelCount, this.satellites.length);
            for (let i = 0; i < end; i++) {
                if (this.channels[i] === null) {
                    this.assignSatelliteToChannel(i, this.satellites[i]);
                }
            }
            return;
        }
        const losSatellites = this.satellites.filter(forceAcquireAndUse ? this.losSatelliteFilterOmniscient : this.losSatelliteFilter);
        let losSatellitesNotTrackedIndexes;
        let openChannelIndexes;
        let isTrackingSbasSatelliteInLos = false;
        if (forceAcquireAndUse) {
            losSatellitesNotTrackedIndexes = ArrayUtils.range(losSatellites.length);
            openChannelIndexes = ArrayUtils.range(this._channelCount, this._channelCount - 1, -1);
        }
        else {
            losSatellitesNotTrackedIndexes = [];
            for (let i = 0; i < losSatellites.length; i++) {
                const sat = losSatellites[i];
                if (this.channels.includes(sat)) {
                    if (sat.sbasGroup !== undefined && this.currentAvailableSbasGroups.has(sat.sbasGroup)) {
                        isTrackingSbasSatelliteInLos = true;
                    }
                }
                else {
                    losSatellitesNotTrackedIndexes.push(i);
                }
            }
            openChannelIndexes = [];
            for (let i = this.channels.length - 1; i >= 0; i--) {
                const sat = this.channels[i];
                if (!sat || sat.state.get() === GPSSatelliteState.Unreachable) {
                    openChannelIndexes.push(i);
                }
            }
        }
        if (openChannelIndexes.length === 0 && this.channels.every(this.ephemerisCollectedSatelliteFilter)) {
            // There are no open channels and we have collected ephemeris data from every tracked satellite.
            const trackedLosMatrix = GPSSatComputer.getLosMatrix(this.channels);
            const trackedCovarMatrix = GPSSatComputer.calculateCovarMatrix(trackedLosMatrix, this.covarMatrix);
            if (!isFinite(trackedCovarMatrix[0][0]) || !isFinite(trackedCovarMatrix[1][1]) || !isFinite(trackedCovarMatrix[2][2])) {
                // The currently tracked satellites are not sufficient to produce a 3D position solution. In this case we
                // will replace a random tracked satellite with an untracked.
                openChannelIndexes.push(Math.trunc(Math.random() * this._channelCount));
            }
            else {
                // The currently tracked satellites are sufficient to produce a 3D position solution. In this case we will
                // only try to replace a tracked satellite if we are tracking at least one redundant satellite, we are not
                // tracking an SBAS satellite within LOS, and there is a SBAS satellite within LOS available for us to track.
                // If the above is true, then we will replace the tracked satellite with the smallest contribution to reducing
                // PDOP with the SBAS satellite with highest signal strength.
                if (this._channelCount > 4 && !isTrackingSbasSatelliteInLos) {
                    let highestSbasSignal = 0;
                    let highestSbasSignalIndex = -1;
                    for (let i = 0; i < losSatellitesNotTrackedIndexes.length; i++) {
                        const index = losSatellitesNotTrackedIndexes[i];
                        const sat = losSatellites[index];
                        const signalStrength = sat.signalStrength.get();
                        if (sat.sbasGroup !== undefined && this.currentAvailableSbasGroups.has(sat.sbasGroup) && signalStrength > highestSbasSignal) {
                            highestSbasSignal = signalStrength;
                            highestSbasSignalIndex = index;
                        }
                    }
                    if (highestSbasSignalIndex >= 0) {
                        const sTranspose = this.channels.map(GPSSatComputer.createVec4);
                        GPSSatComputer.calculateDowndateSTranspose(trackedLosMatrix, trackedCovarMatrix, sTranspose);
                        const pDiag = GPSSatComputer.calculateDowndatePDiag(trackedLosMatrix, sTranspose, new Float64Array(trackedLosMatrix.length));
                        GPSSatComputer.calculateSatelliteCosts(sTranspose, pDiag, this.satelliteCosts);
                        let satToReplaceCost = Infinity;
                        let satToReplaceChannelIndex = -1;
                        for (let i = 0; i < this.channels.length; i++) {
                            const cost = this.satelliteCosts[i];
                            if (cost < satToReplaceCost) {
                                satToReplaceCost = cost;
                                satToReplaceChannelIndex = i;
                            }
                        }
                        if (satToReplaceChannelIndex >= 0) {
                            this.assignSatelliteToChannel(satToReplaceChannelIndex, losSatellites[highestSbasSignalIndex]);
                        }
                    }
                }
                return;
            }
        }
        if (openChannelIndexes.length > 0) {
            if (openChannelIndexes.length < losSatellitesNotTrackedIndexes.length) {
                // We don't have enough open channels to begin tracking all satellites currently within line-of-sight.
                // Therefore, we will choose those with the largest contribution to reducing PDOP.
                const losMatrix = GPSSatComputer.getLosMatrix(losSatellites);
                const covarMatrix = GPSSatComputer.calculateCovarMatrix(losMatrix, this.covarMatrix);
                const sTranspose = losSatellites.map(GPSSatComputer.createVec4);
                GPSSatComputer.calculateDowndateSTranspose(losMatrix, covarMatrix, sTranspose);
                const pDiag = GPSSatComputer.calculateDowndatePDiag(losMatrix, sTranspose, new Float64Array(losMatrix.length));
                GPSSatComputer.calculateSatelliteCosts(sTranspose, pDiag, this.satelliteCosts);
                // If we are not already tracking an SBAS satellite within LOS, we will prioritize adding the SBAS satellite
                // with the highest cost over non-SBAS satellites.
                if (!isTrackingSbasSatelliteInLos) {
                    let highestSbasCost = -Infinity;
                    let highestSbasCostIndex = -1;
                    for (let i = 0; i < this.satelliteCosts.length; i++) {
                        const sbasGroup = losSatellites[i].sbasGroup;
                        if (sbasGroup !== undefined && this.currentAvailableSbasGroups.has(sbasGroup)) {
                            const cost = this.satelliteCosts[i];
                            if (cost > highestSbasCost) {
                                highestSbasCost = cost;
                                highestSbasCostIndex = i;
                            }
                        }
                    }
                    if (highestSbasCostIndex >= 0) {
                        this.satelliteCosts[highestSbasCostIndex] = Infinity;
                    }
                }
                const satelliteIndexes = ArrayUtils.range(losSatellites.length);
                satelliteIndexes.sort(this.satelliteCostCompare);
                for (let i = satelliteIndexes.length - 1; i >= 0; i--) {
                    const satIndex = satelliteIndexes[i];
                    if (losSatellitesNotTrackedIndexes.includes(satIndex)) {
                        const sat = losSatellites[satIndex];
                        const channelIndex = openChannelIndexes.pop();
                        this.assignSatelliteToChannel(channelIndex, sat);
                        if (openChannelIndexes.length === 0) {
                            break;
                        }
                    }
                }
            }
            else {
                // We have enough open channels to begin tracking all satellites currently within LOS.
                for (let i = 0; i < losSatellitesNotTrackedIndexes.length; i++) {
                    const satIndex = losSatellitesNotTrackedIndexes[i];
                    const channelIndex = openChannelIndexes.pop();
                    this.assignSatelliteToChannel(channelIndex, losSatellites[satIndex]);
                }
            }
            // If we still have open channels available, fill them with random satellites that have not been marked as
            // unreachable.
            if (openChannelIndexes.length > 0) {
                const untrackedSatellites = this.satellites.filter(this.untrackedSatelliteFilter);
                let untrackedIndex = 0;
                while (openChannelIndexes.length > 0 && untrackedIndex < untrackedSatellites.length) {
                    const channelIndex = openChannelIndexes.pop();
                    this.assignSatelliteToChannel(channelIndex, untrackedSatellites[untrackedIndex++]);
                }
            }
        }
    }
    /**
     * Assigns a satellite to a receiver channel.
     * @param channelIndex The index of the receiver channel.
     * @param sat The satellite to assign, or `null` if the channel is to be assigned no satellite.
     */
    assignSatelliteToChannel(channelIndex, sat) {
        const oldSat = this.channels[channelIndex];
        if (oldSat === sat) {
            return;
        }
        if (oldSat) {
            oldSat.setTracked(false);
        }
        this.channels[channelIndex] = sat;
        if (sat) {
            sat.setTracked(true);
        }
        if (this.syncRole === 'primary') {
            this.syncPublisher.pub(this.channelStateSyncTopic, { index: channelIndex, prn: sat === null ? null : sat.prn }, true, false);
        }
    }
    /**
     * Calculates dilution of precision values (PDOP, HDOP, VDOP) for the satellite constellation consisting of all
     * satellites that are currently in-use.
     * @param out The vector to which to write the results.
     * @returns Dilution of precision values for the current in-use satellite constellation, as `[PDOP, HDOP, VDOP]`. If
     * the constellation is insufficient to provide a 3D position solution, then `[-1, -1, -1]` will be returned.
     */
    calculateDop(out) {
        Vec3Math.set(-1, -1, -1, out);
        const satsInUse = this.satellites.filter(GPSSatComputer.inUseSatelliteFilter);
        if (satsInUse.length < 4) {
            return out;
        }
const losMatrix = GPSSatComputer.getLosMatrix(satsInUse);
        const covarMatrix = GPSSatComputer.calculateCovarMatrix(losMatrix, this.covarMatrix);
        // Grab the variance terms var(x), var(y), var(z) along the diagonal of the covariance matrix
        const varX = covarMatrix[0][0];
        const varY = covarMatrix[1][1];
        const varZ = covarMatrix[2][2];
        if (!isFinite(varX) || !isFinite(varY) || !isFinite(varZ)) {
            return out;
        }
        const horizSumVar = varX + varY;
        const pdop = Math.sqrt(horizSumVar + varZ);
        const hdop = Math.sqrt(horizSumVar);
        const vdop = Math.sqrt(varZ);
        return Vec3Math.set(pdop, hdop, vdop, out);
    }
    /**
     * Selects satellites to use for calculating position solutions and returns the dilution of precision values for
     * the selected constellation.
     * @param out The vector to which to write the dilution of precision values.
     * @returns Dilution of precision values for the selected satellite constellation, as `[PDOP, HDOP, VDOP]`. If the
     * constellation is insufficient to provide a 3D position solution, then `[-1, -1, -1]` will be returned.
     */
    selectSatellites(out) {
        Vec3Math.set(-1, -1, -1, out);
        const satellitesToUse = this.satellites.filter(GPSSatComputer.readySatelliteFilter);
        if (satellitesToUse.length < 4) {
            this.updateSatelliteInUseStates(satellitesToUse, []);
            return out;
        }
        const losMatrix = GPSSatComputer.getLosMatrix(satellitesToUse);
        const covarMatrix = GPSSatComputer.calculateCovarMatrix(losMatrix, this.covarMatrix);
        const maxCount = MathUtils.clamp(this.satInUseMaxCount.get(), 4, this._channelCount);
        if (!VecNMath.isFinite(covarMatrix[0])
            || !VecNMath.isFinite(covarMatrix[1])
            || !VecNMath.isFinite(covarMatrix[2])
            || !VecNMath.isFinite(covarMatrix[3])) {
            const satellitesToDiscard = satellitesToUse.splice(maxCount);
            this.updateSatelliteInUseStates(satellitesToUse, satellitesToDiscard);
            return out;
        }
        const satellitesToDiscard = [];
        const pdopTarget = this.satInUsePdopTarget.get();
        const optimumCount = Math.max(this.satInUseOptimumCount.get(), 4);
        const pdopTargetSq = pdopTarget < 0 ? -1 : pdopTarget * pdopTarget;
        let pdopSq = covarMatrix[0][0] + covarMatrix[1][1] + covarMatrix[2][2];
        if (satellitesToUse.length > maxCount || (satellitesToUse.length > optimumCount && pdopSq < pdopTargetSq)) {
            // There are more in-sight satellites than we can select. Therefore we will attempt to discard excess satellites
            // in manner that minimizes the increase to PDOP relative to selecting all in-sight satellites.
            // We will use the "downdate" selection algorithm presented in Walter, T, Blanch, J and Kropp, V, 2016.
            // Define Sᵀ = LC and P = I - LCLᵀ, where L is the line-of-sight matrix and C is the covariance matrix.
            // Then Ci = C + (Si)(Si)ᵀ / P(i, i), where Ci is the covariance matrix after removing the ith satellite and
            // Si is the ith column of S.
            // If PDOP = sqrt(C(1, 1) + C(2, 2) + C(3, 3)), then from the above it can be seen that removing the ith
            // satellite increases PDOP² by (S(1, i)² + S(2, i)² + S(3, i)²) / P(i, i). Defining this to be the cost of
            // removing satellite i, we are then guaranteed that removing the satellite with the lowest cost will result
            // in the smallest increase to PDOP.
            const sTranspose = satellitesToUse.map(GPSSatComputer.createVec4);
            GPSSatComputer.calculateDowndateSTranspose(losMatrix, covarMatrix, sTranspose);
            const pDiag = GPSSatComputer.calculateDowndatePDiag(losMatrix, sTranspose, new Float64Array(losMatrix.length));
            GPSSatComputer.calculateSatelliteCosts(sTranspose, pDiag, this.satelliteCosts);
            const satelliteIndexes = ArrayUtils.range(satellitesToUse.length);
            satelliteIndexes.sort(this.satelliteCostCompare);
            pdopSq = covarMatrix[0][0] + covarMatrix[1][1] + covarMatrix[2][2];
            let indexToRemove = satelliteIndexes[0];
            while (satellitesToUse.length > maxCount
                || (satellitesToUse.length > optimumCount
                    && pdopSq + this.satelliteCosts[indexToRemove] <= pdopTargetSq)) {
                satellitesToDiscard.push(satellitesToUse[indexToRemove]);
                satellitesToUse.splice(indexToRemove, 1);
                losMatrix.splice(indexToRemove, 1);
                // Reset satellite index array.
                satelliteIndexes.length--;
                for (let i = 0; i < satelliteIndexes.length; i++) {
                    satelliteIndexes[i] = i;
                }
                // Update covariance matrix after removing a satellite.
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        covarMatrix[i][j] += sTranspose[indexToRemove][i] * sTranspose[indexToRemove][j] / pDiag[indexToRemove];
                    }
                }
                // Recompute satellite costs.
                sTranspose.length--;
                GPSSatComputer.calculateDowndateSTranspose(losMatrix, covarMatrix, sTranspose);
                GPSSatComputer.calculateDowndatePDiag(losMatrix, sTranspose, pDiag);
                GPSSatComputer.calculateSatelliteCosts(sTranspose, pDiag, this.satelliteCosts);
                satelliteIndexes.sort(this.satelliteCostCompare);
                pdopSq = covarMatrix[0][0] + covarMatrix[1][1] + covarMatrix[2][2];
                indexToRemove = satelliteIndexes[0];
            }
        }
        this.updateSatelliteInUseStates(satellitesToUse, satellitesToDiscard);
        // Grab the variance terms var(x), var(y), var(z) along the diagonal of the covariance matrix
        const varX = covarMatrix[0][0];
        const varY = covarMatrix[1][1];
        const varZ = covarMatrix[2][2];
        if (!isFinite(varX) || !isFinite(varY) || !isFinite(varZ)) {
            return out;
        }
        const horizSumVar = varX + varY;
        const pdop = Math.sqrt(horizSumVar + varZ);
        const hdop = Math.sqrt(horizSumVar);
        const vdop = Math.sqrt(varZ);
        return Vec3Math.set(pdop, hdop, vdop, out);
    }
    /**
     * Updates the in-use state of satellites.
     * @param satellitesToUse The satellites to use for position solution calculations.
     * @param satellitesToNotUse The satellites to not use for position solution calculations.
     */
    updateSatelliteInUseStates(satellitesToUse, satellitesToNotUse) {
        for (let i = 0; i < satellitesToUse.length; i++) {
            satellitesToUse[i].updateInUse(true);
        }
        for (let i = 0; i < satellitesToNotUse.length; i++) {
            satellitesToNotUse[i].updateInUse(false);
        }
    }
    /**
     * Updates the almanac download state.
     * @param simTime The current simulation time, as a Javascript timestamp.
     * @param deltaTime The time elapsed, in milliseconds, since the last update.
     * @param forceDownload Whether to force the entire almanac to be instantly downloaded.
     */
    updateAlmanacState(simTime, deltaTime, forceDownload) {
        if (forceDownload) {
            this.lastAlamanacTime = simTime;
            this.almanacProgress = 0;
        }
        else {
            const isCollectingData = this.channels.some(this.collectingDataSatelliteFilter);
            if (isCollectingData) {
                this.almanacProgress += deltaTime / this.satelliteTimingOptions.almanacDownloadTime;
                if (this.almanacProgress >= 1) {
                    this.lastAlamanacTime = simTime;
                    this.almanacProgress -= 1;
                }
            }
            else {
                this.almanacProgress = 0;
            }
        }
    }
    /**
     * For each satellite, checks if its state is different from the most recently published state, and if so publishes
     * the new state. If this computer's sync role is `primary`, then a satellite state sync event will be published
     * alongside any regular state events.
     */
    diffAndPublishSatelliteStates() {
        for (let i = 0; i < this.satellites.length; i++) {
            const publishedState = this.publishedSatStates[i];
            const sat = this.satellites[i];
            const state = sat.state.get();
            const areDiffCorrectionsDownloaded = sat.areDiffCorrectionsDownloaded;
            const needPublishState = publishedState.state !== state;
            const needSyncState = needPublishState || publishedState.areDiffCorrectionsDownloaded !== areDiffCorrectionsDownloaded;
            if (needSyncState) {
                publishedState.state = state;
                publishedState.areDiffCorrectionsDownloaded = areDiffCorrectionsDownloaded;
                if (needPublishState) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
                }
                if (this.syncRole === 'primary') {
                    this.syncPublisher.pub(this.satStateSyncTopic, { prn: sat.prn, state, areDiffCorrectionsDownloaded }, true, false);
                }
            }
        }
    }
    /**
     * Sets this system's dilution of precision values, and if they are different from the current values, publishes the
     * new values to the event bus.
     * @param pdop The position DOP value to set.
     * @param hdop The horizontal DOP value to set.
     * @param vdop The vertical DOP value to set.
     */
    setDop(pdop, hdop, vdop) {
        if (this._pdop !== pdop) {
            this._pdop = pdop;
            this.publisher.pub(this.pdopTopic, pdop, false, true);
        }
        if (this._hdop !== hdop) {
            this._hdop = hdop;
            this.publisher.pub(this.hdopTopic, hdop, false, true);
        }
        if (this._vdop !== vdop) {
            this._vdop = vdop;
            this.publisher.pub(this.vdopTopic, vdop, false, true);
        }
    }
    /**
     * Creates a line-of-sight position matrix for a satellite constellation. Each row in the matrix is a 4-vector of
     * a satellite's position relative to the airplane, as `[x, y, z, 1]`. The index of the matrix row containing a
     * satellite's position vector matches the index of the satellite in the provided array.
     * @param satellites The satellites in the constellation.
     * @returns The line-of-sight position matrix for the specified satellite constellation.
     */
    static getLosMatrix(satellites) {
        const los = [];
        // Get unit line-of-sight vectors for each satellite
        for (let i = 0; i < satellites.length; i++) {
            const [zenith, hour] = satellites[i].position.get();
            los[i] = Vec3Math.setFromSpherical(1, zenith, hour, new Float64Array(4));
            los[i][3] = 1;
        }
        return los;
    }
    /**
     * Calculates a position-covariance matrix for a satellite constellation.
     * @param los The line-of-sight position matrix for the satellite constellation.
     * @param out The matrix to which to write the result.
     * @returns The position-covariance matrix for the specified satellite constellation.
     */
    static calculateCovarMatrix(los, out) {
        if (los.length < 4) {
            for (let i = 0; i < 4; i++) {
                out[i].fill(NaN, 0, 4);
            }
            return out;
        }
        // The covariance matrix is defined as C = (LᵀL)⁻¹, where L is the satellite line-of-sight matrix.
        // P = LᵀL is guaranteed to be symmetric, so we need only compute the upper triangular part of the product.
        const P11 = los.reduce(GPSSatComputer.covarMultiplyFuncs[0][0], 0);
        const P12 = los.reduce(GPSSatComputer.covarMultiplyFuncs[0][1], 0);
        const P13 = los.reduce(GPSSatComputer.covarMultiplyFuncs[0][2], 0);
        const P14 = los.reduce(GPSSatComputer.covarMultiplyFuncs[0][3], 0);
        const P22 = los.reduce(GPSSatComputer.covarMultiplyFuncs[1][0], 0);
        const P23 = los.reduce(GPSSatComputer.covarMultiplyFuncs[1][1], 0);
        const P24 = los.reduce(GPSSatComputer.covarMultiplyFuncs[1][2], 0);
        const P33 = los.reduce(GPSSatComputer.covarMultiplyFuncs[2][0], 0);
        const P34 = los.reduce(GPSSatComputer.covarMultiplyFuncs[2][1], 0);
        const P44 = los.length;
        // Perform block-wise inversion of LᵀL (which is 4x4, so neatly decomposes into four 2x2 matrices) with optimizations
        // presented in Ingemarsson, C and Gustafsson O, 2015.
        // P = [A  B]
        //     [Bᵀ D]
        // C = P⁻¹ = [E  F]
        //           [Fᵀ H]
                // V = A⁻¹ (A is symmetric, therefore V is also symmetric, so we only need to compute the upper triangular part)
        const detA = 1 / (P11 * P22 - P12 * P12);
        const V11 = P22 * detA;
        const V12 = -P12 * detA;
        const V22 = P11 * detA;
        // X = VB
        const X11 = V11 * P13 + V12 * P23;
        const X12 = V11 * P14 + V12 * P24;
        const X21 = V12 * P13 + V22 * P23;
        const X22 = V12 * P14 + V22 * P24;
        // H = (D - BᵀX)⁻¹ (H and D are symmetric, which means BᵀX is also symmetric)
        const Hi11 = P33 - (P13 * X11 + P23 * X21);
        const Hi12 = P34 - (P13 * X12 + P23 * X22);
        const Hi22 = P44 - (P14 * X12 + P24 * X22);
        const detHi = 1 / (Hi11 * Hi22 - Hi12 * Hi12);
        const H11 = Hi22 * detHi;
        const H12 = -Hi12 * detHi;
        const H22 = Hi11 * detHi;
        // Z = XH, F = -Z
        const Z11 = X11 * H11 + X12 * H12;
        const Z12 = X11 * H12 + X12 * H22;
        const Z21 = X21 * H11 + X22 * H12;
        const Z22 = X21 * H12 + X22 * H22;
        // E = V + ZXᵀ (E is symmetric, so we only need to compute the upper triangular part)
        const E11 = V11 + Z11 * X11 + Z12 * X12;
        const E12 = V12 + Z11 * X21 + Z12 * X22;
        const E22 = V22 + Z21 * X21 + Z22 * X22;
        out[0][0] = E11;
        out[0][1] = E12;
        out[0][2] = -Z11;
        out[0][3] = -Z12;
        out[1][0] = E12; // E is symmetric, so E21 = E12
        out[1][1] = E22;
        out[1][2] = -Z21;
        out[1][3] = -Z22;
        out[2][0] = -Z11;
        out[2][1] = -Z21;
        out[2][2] = H11;
        out[2][3] = H12;
        out[3][0] = -Z12;
        out[3][1] = -Z22;
        out[3][2] = H12; // H is symmetric, so H21 = H12
        out[3][3] = H22;
            return out;
        }
        /**
     * Calculates the transpose of the `S` matrix in the downdate satellite selection algorithm for a satellite
     * constellation. The index of a satellite's corresponding row in the `Sᵀ` matrix matches the index of its position
     * vector in the provided line-of-sight position matrix.
     * @param los The line-of-sight position matrix for the satellite constellation.
     * @param covar The position-covariance matrix for the satellite constellation.
     * @param out The matrix to which to write the result.
     * @returns The transpose of the `S` matrix in the downdate satellite selection algorithm for the specified satellite
     * constellation.
     */
    static calculateDowndateSTranspose(los, covar, out) {
        for (let i = 0; i < los.length; i++) {
            for (let j = 0; j < 4; j++) {
                out[i][j] = 0;
                for (let k = 0; k < 4; k++) {
                    out[i][j] += los[i][k] * covar[k][j];
                }
            }
        }
        return out;
    }
    /**
     * Calculates the diagonal of the `P` matrix in the downdate satellite selection algorithm for a satellite
     * constellation.
     * @param los The line-of-sight position matrix for the satellite constellation.
     * @param sTranspose The transpose of the `S` matrix in the downdate satellite selection algorithm for the satellite
     * constellation.
     * @param out The vector to which to write the result.
     * @returns The diagonal of the `P` matrix in the downdate satellite selection algorithm for the specified satellite
     * constellation.
     */
    static calculateDowndatePDiag(los, sTranspose, out) {
        out.fill(1);
        for (let i = 0; i < los.length; i++) {
            for (let j = 0; j < 4; j++) {
                out[i] -= sTranspose[i][j] * los[i][j];
            }
        }
        return out;
    }
    /**
     * Calculates the costs of removing each satellite from a constellation. The cost of removing a satellite is defined
     * as the amount by which `PDOP²` will increase when the satellite is removed relative to the full constellation. The
     * index of a satellite's cost in the returned array matches the index of the satellite's corresponding row in the
     * provided `Sᵀ` matrix.
     * @param sTranspose The transpose of the `S` matrix in the downdate satellite selection algorithm for the satellite
     * constellation.
     * @param pDiag The diagonal of the `P` matrix in the downdate satellite selection algorithm for the satellite
     * constellation.
     * @param out The array to which to write the results.
     * @returns The costs of removing each satellite from a constellation.
     */
    static calculateSatelliteCosts(sTranspose, pDiag, out) {
        out.length = sTranspose.length;
        for (let i = 0; i < sTranspose.length; i++) {
            out[i] = (sTranspose[i][0] * sTranspose[i][0] + sTranspose[i][1] * sTranspose[i][1] + sTranspose[i][2] * sTranspose[i][2]) / pDiag[i];
        }
        return out;
    }
        }
GPSSatComputer.EPHEMERIS_COLLECTED_SATELLITE_STATES = new Set([GPSSatelliteState.DataCollected, GPSSatelliteState.InUse, GPSSatelliteState.InUseDiffApplied]);
GPSSatComputer.inUseSatelliteFilter = (sat) => {
    const state = sat.state.get();
    return state === GPSSatelliteState.InUse || state === GPSSatelliteState.InUseDiffApplied;
};
GPSSatComputer.readySatelliteFilter = (sat) => {
    const state = sat.state.get();
    return state === GPSSatelliteState.DataCollected || state === GPSSatelliteState.InUse || state === GPSSatelliteState.InUseDiffApplied;
};
GPSSatComputer.createVec4 = () => new Float64Array(4);
GPSSatComputer.COLLECTING_DATA_SATELLITE_STATES = new Set([
    GPSSatelliteState.Acquired,
    GPSSatelliteState.DataCollected,
    GPSSatelliteState.InUse,
    GPSSatelliteState.InUseDiffApplied
]);
GPSSatComputer.covarMultiplyFuncs = [
    [0, 1, 2, 3].map(col => (sum, vec) => sum + vec[0] * vec[col]),
    [1, 2, 3].map(col => (sum, vec) => sum + vec[1] * vec[col]),
    [2, 3].map(col => (sum, vec) => sum + vec[2] * vec[col])
];
/**
 * A tracked GPS satellite.
 */
class GPSSatellite {
// eslint-disable-next-line jsdoc/require-returns
    /**
     * The most recent simulation time at which this satellite's ephemeris was downloaded, as a Javascript timestamp, or
     * `undefined` if this satellite's ephemeris has not yet been downloaded.
     */
    get lastEphemerisTime() {
        return this._lastEphemerisTime;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The most recent simulation time at which this satellite was confirmed to be unreachable, as a Javascript
     * timestamp, or `undefined` if this satellite has not been confirmed to be unreachable.
     */
    get lastUnreachableTime() {
        return this._lastUnreachableTime;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether SBAS differential correction data have been downloaded from this satellite. */
    get areDiffCorrectionsDownloaded() {
        return this._areDiffCorrectionsDownloaded;
    }
    /**
     * Creates an instance of a GPSSatellite.
     * @param prn The GPS PRN number for this satellite.
     * @param sbasGroup Whether or not this satellite is a SBAS satellite.
     * @param ephemeris The ephemeris data to use for position calculation.
* @param timingOptions Options with which to configure the timing of this satellite's state changes.
     */
    constructor(prn, sbasGroup, ephemeris, timingOptions) {
        this.prn = prn;
        this.sbasGroup = sbasGroup;
        this.ephemeris = ephemeris;
        this.timingOptions = timingOptions;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        /** The current satellite state. */
        this.state = Subject.create(GPSSatelliteState.None);
        /** The current satellite position, in zenith angle radians and hour angle radians. */
        this.position = Vec2Subject.create(new Float64Array(2));
        /** The current satellite position, in cartesian coordinates. */
        this.positionCartesian = Vec3Subject.create(new Float64Array(3));
        /** The current satellite signal strength. */
        this.signalStrength = Subject.create(0);
        this.isTracked = false;
        this.hasComputedPosition = false;
        this._lastEphemerisTime = undefined;
        this._lastUnreachableTime = undefined;
        this._areDiffCorrectionsDownloaded = false;
        this.timeSpentAcquiring = undefined;
        this.timeToAcquire = undefined;
        this.timeToDownloadEphemeris = undefined;
        this.timeToDownloadCorrections = undefined;
    }
        /**
     * Computes the current satellite positions given the loaded ephemeris data.
     * @param simTime The current simulator time, in milliseconds UNIX epoch
     */
    computeSatellitePositions(simTime) {
        const record = this.ephemeris;
        if (record !== undefined) {
            const mu = 3.986005e14; //WGS84 gravitational constant for GPS user (meters3/sec2)
            const omegae_dot = 7.2921151467e-5; //WGS84 earth rotation rate (rad/sec)
            // Restore semi-major axis
            const a = record.sqrtA * record.sqrtA;
            // Computed mean motion
            const n0 = Math.sqrt(mu / (a * a * a));
            // Time from ephemeris reference epoch
            const now = simTime / 1000;
            const t = (now - (86400 * 3) + 1735) % 604800;
            let tk = t - record.toeTimeEphemeris;
            if (tk > 302400) {
                tk -= 604800;
            }
            else if (tk < -302400) {
                tk += 604800;
            }
            // Corrected mean motion
            const n = n0 + record.deltaN;
            // Mean anomaly
            const M = record.m0 + n * tk;
            // Initial guess of eccentric anomaly
            let E = M;
            let E_old;
            let dE;
            // Iterative computation of eccentric anomaly
            for (let i = 1; i < 20; i++) {
                E_old = E;
                E = M + record.eEccentricity * Math.sin(E);
                dE = E - E_old % (2.0 * Math.PI);
                if (Math.abs(dE) < 1e-12) {
                    // Necessary precision is reached, exit from the loop
                    break;
                }
            }
            const sek = Math.sin(E);
            const cek = Math.cos(E);
            const OneMinusecosE = 1.0 - record.eEccentricity * cek;
            const sq1e2 = Math.sqrt(1.0 - record.eEccentricity * record.eEccentricity);
            // Compute the true anomaly
            const tmp_Y = sq1e2 * sek;
            const tmp_X = cek - record.eEccentricity;
            const nu = Math.atan2(tmp_Y, tmp_X);
            // Compute angle phi (argument of Latitude)
            const phi = nu + record.omegaS;
            // Reduce phi to between 0 and 2*pi rad
            const s2pk = Math.sin(2.0 * phi);
            const c2pk = Math.cos(2.0 * phi);
            // Correct argument of latitude
            const u = phi + record.cuc * c2pk + record.cus * s2pk;
            const suk = Math.sin(u);
            const cuk = Math.cos(u);
            // Correct radius
            const r = a * OneMinusecosE + record.crc * c2pk + record.crs * s2pk;
            // Correct inclination
            const i = record.i0 + record.idot * tk + record.cic * c2pk + record.cis * s2pk;
            const sik = Math.sin(i);
            const cik = Math.cos(i);
            // Compute the angle between the ascending node and the Greenwich meridian
            const Omega_dot = record.omegaLDot - omegae_dot;
            const Omega = record.omegaL + Omega_dot * tk - omegae_dot * record.toeTimeEphemeris;
            const sok = Math.sin(Omega);
            const cok = Math.cos(Omega);
            //Compute satellite coordinates in Earth-fixed coordinates
            const xprime = r * cuk;
            const yprime = r * suk;
            const x = xprime * cok - yprime * cik * sok;
            const y = xprime * sok + yprime * cik * cok;
            const z = yprime * sik;
            this.positionCartesian.set(UnitType.METER.convertTo(x, UnitType.GA_RADIAN), UnitType.METER.convertTo(y, UnitType.GA_RADIAN), UnitType.METER.convertTo(z, UnitType.GA_RADIAN));
        }
    }
    /**
     * Applies a projection to the satellite cartesian coordinates to convert to zenith and hour angles.
     * @param ppos The current plane position.
     * @param altitude The current plane altitude in meters.
     */
    applyProjection(ppos, altitude) {
        const satPos = this.positionCartesian.get();
        const altRadians = UnitType.METER.convertTo(altitude, UnitType.GA_RADIAN);
        const pposCartesian = Vec3Math.multScalar(ppos.toCartesian(this.vec3Cache[0]), 1 + altRadians, this.vec3Cache[0]);
        const delta = Vec3Math.normalize(Vec3Math.sub(satPos, pposCartesian, this.vec3Cache[1]), this.vec3Cache[1]);
        const zenithAngle = Math.acos(Vec3Math.dot(delta, Vec3Math.normalize(pposCartesian, this.vec3Cache[2])));
        const satPos0 = Vec3Math.normalize(satPos, this.vec3Cache[1]);
        const northPole = Vec3Math.set(0, 0, 1, this.vec3Cache[2]);
        if (Math.abs(zenithAngle) < 1e-8 || Math.abs(zenithAngle - 180) < 1e-8) {
            this.position.set(zenithAngle, 0);
        }
        else {
            const A = Vec3Math.normalize(Vec3Math.cross(pposCartesian, northPole, this.vec3Cache[3]), this.vec3Cache[3]);
            const B = Vec3Math.normalize(Vec3Math.cross(pposCartesian, satPos0, this.vec3Cache[4]), this.vec3Cache[4]);
            const signBz = B[2] >= 0 ? 1 : -1;
            const hourAngle = Math.acos(Vec3Math.dot(A, B)) * signBz;
            this.position.set(zenithAngle, -hourAngle);
        }
        this.hasComputedPosition = true;
    }
    /**
     * Calculates the current signal strength.
     * @param altitude The current plane altitude in meters.
     */
    calculateSignalStrength(altitude) {
        if (this.hasComputedPosition) {
            const maxZenithAngle = GPSSatellite.calcHorizonAngle(altitude) + (Math.PI / 2);
            const signalStrength = Math.max(0, 1 - (this.position.get()[0] / maxZenithAngle));
            this.signalStrength.set(signalStrength);
        }
    }
    /**
     * Calculates the horizon zenith angle.
     * @param altitude The altitude, in meters.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    static calcHorizonAngle(altitude) {
        return Math.acos(6378100 / (6378100 + Math.max(altitude, 0)));
    }
/**
     * Checks whether this satellite's cached ephemeris data is valid at a given simulation time.
     * @param simTime The simulation time at which to check for ephemeris validity, as a Javascript timestamp.
     * @returns Whether this satellite's cached ephemeris data is valid at the specified simulation time.
     */
    isCachedEphemerisValid(simTime) {
        return this._lastEphemerisTime !== undefined && Math.abs(simTime - this._lastEphemerisTime) < this.timingOptions.ephemerisExpireTime;
    }
    /**
     * Erases this satellite's cached ephemeris data.
     */
    eraseCachedEphemeris() {
        this._lastEphemerisTime = undefined;
    }
    /**
     * Sets whether this satellite is being tracked by a receiver channel.
     * @param tracked Whether this satellite is being tracked by a receiver channel.
     */
    setTracked(tracked) {
        if (this.isTracked === tracked) {
            return;
        }
        this.isTracked = tracked;
        this.timeSpentAcquiring = undefined;
        this.timeToAcquire = undefined;
        this.timeToDownloadEphemeris = undefined;
        this._areDiffCorrectionsDownloaded = false;
        this.timeToDownloadCorrections = undefined;
        if (tracked || this.state.get() !== GPSSatelliteState.Unreachable) {
            this.state.set(GPSSatelliteState.None);
        }
    }
    /**
     * Updates the state of the satellite.
     * @param simTime The current simulation time, as a Javascript timestamp.
     * @param deltaTime The amount of sim time that has elapsed since the last update, in milliseconds.
     * @param distanceFromLastKnownPos The distance, in great-arc radians, from the airplane's current actual position to
     * its last known position.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.DataCollected}) if signal strength is sufficient.
     * @returns Whether this satellite's state changed as a result of the update.
     */
    updateState(simTime, deltaTime, distanceFromLastKnownPos, forceAcquireAndUse) {
        const stateChanged = this.isTracked
            ? this.updateStateTracked(simTime, deltaTime, distanceFromLastKnownPos, forceAcquireAndUse)
            : this.updateStateUntracked(simTime);
        switch (this.state.get()) {
            case GPSSatelliteState.Unreachable:
                if (this.isTracked) {
                    this._lastUnreachableTime = simTime;
                }
                break;
            case GPSSatelliteState.DataCollected:
            case GPSSatelliteState.InUse:
            case GPSSatelliteState.InUseDiffApplied:
                this._lastEphemerisTime = simTime;
                break;
        }
        return stateChanged;
    }
    /**
     * Updates the state of the satellite while it is being tracked.
     * @param simTime The current simulation time, as a Javascript timestamp.
     * @param deltaTime The amount of sim time that has elapsed since the last update, in milliseconds.
     * @param distanceFromLastKnownPos The distance, in great-arc radians, from the airplane's current actual position to
     * its last known position.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.DataCollected}) if signal strength is sufficient.
     * @returns Whether this satellite's state changed as a result of the update.
     */
    updateStateTracked(simTime, deltaTime, distanceFromLastKnownPos, forceAcquireAndUse) {
        const reachable = this.signalStrength.get() > 0.05;
                if (forceAcquireAndUse) {
                        const state = this.state.get();
            if (reachable) {
                if (this.sbasGroup !== undefined) {
                    this._areDiffCorrectionsDownloaded = true;
                    this.timeToDownloadCorrections = undefined;
                }
                if (state !== GPSSatelliteState.DataCollected) {
                    this.timeSpentAcquiring = undefined;
                    this.timeToAcquire = undefined;
                    this.timeToDownloadEphemeris = undefined;
                    this.state.set(GPSSatelliteState.DataCollected);
                    return true;
                }
            }
            else {
                if (state !== GPSSatelliteState.Unreachable) {
                    this.timeSpentAcquiring = undefined;
                    this.timeToAcquire = undefined;
                    this.timeToDownloadEphemeris = undefined;
                    this._areDiffCorrectionsDownloaded = false;
                    this.timeToDownloadCorrections = undefined;
                    this.state.set(GPSSatelliteState.Unreachable);
                    return true;
                }
            }
        }
        else {
            switch (this.state.get()) {
                case GPSSatelliteState.None:
                    if (this.timeSpentAcquiring === undefined) {
                        this.timeSpentAcquiring = 0;
                    }
                    this.timeSpentAcquiring += deltaTime;
                    if (reachable) {
                    if (this.timeToAcquire === undefined) {
                            this.timeToAcquire = distanceFromLastKnownPos < 5.80734e-4 /* 2 nautical miles */ && this.isCachedEphemerisValid(simTime)
                                ? this.timingOptions.acquisitionTimeWithEphemeris + (Math.random() - 0.5) * this.timingOptions.acquisitionTimeRangeWithEphemeris
                                : this.timingOptions.acquisitionTime + (Math.random() - 0.5) * this.timingOptions.acquisitionTimeRange;
                        }
                        this.timeToAcquire -= deltaTime;
                        if (this.timeToAcquire <= 0) {
                            this.timeSpentAcquiring = undefined;
                            this.timeToAcquire = undefined;
                            // If we have valid cached ephemeris data for this satellite, then we can use the cached data for
                            // calculating position solutions immediately instead of having to wait to download new ephemeris data.
                            if (this.isCachedEphemerisValid(simTime)) {
                                this.state.set(GPSSatelliteState.DataCollected);
                            }
                            else {
                        this.state.set(GPSSatelliteState.Acquired);
                        }
                        return true;
                    }
}
                    else {
                        this.timeToAcquire = undefined;
                        if (this.timeSpentAcquiring >= this.timingOptions.acquisitionTimeout) {
                            this.timeSpentAcquiring = undefined;
                        this.state.set(GPSSatelliteState.Unreachable);
                                                return true;
                    }
}
                    break;
                case GPSSatelliteState.Unreachable:
                    if (this._lastUnreachableTime === undefined) {
                        this._lastUnreachableTime = simTime;
                    }
                    else if (Math.abs(simTime - this._lastUnreachableTime) >= this.timingOptions.unreachableExpireTime) {
                        this._lastUnreachableTime = undefined;
                        this.state.set(GPSSatelliteState.None);
                                                return true;
                    }
                    break;
                case GPSSatelliteState.Acquired:
                    if (!reachable) {
                        this.timeToDownloadEphemeris = undefined;
                        this._areDiffCorrectionsDownloaded = false;
                        this.timeToDownloadCorrections = undefined;
                        this.state.set(GPSSatelliteState.None);
                        return true;
                    }
                    else {
                        if (this.timeToDownloadEphemeris === undefined) {
                            this.timeToDownloadEphemeris = this.sbasGroup === undefined
                                ? this.timingOptions.ephemerisDownloadTime
                                : this.timingOptions.sbasEphemerisDownloadTime + (Math.random() - 0.5) * this.timingOptions.sbasEphemerisDownloadTimeRange;
                        }
                        this.timeToDownloadEphemeris -= deltaTime;
                        this.updateSbasCorrectionsDownload(deltaTime);
                        if (this.timeToDownloadEphemeris <= 0) {
                            this.timeToDownloadEphemeris = undefined;
                        this.state.set(GPSSatelliteState.DataCollected);
                                                return true;
                    }
}
                    break;
                case GPSSatelliteState.DataCollected:
                    if (!reachable) {
                        this._areDiffCorrectionsDownloaded = false;
                        this.timeToDownloadCorrections = undefined;
                        this.state.set(GPSSatelliteState.None);
                        return true;
                    }
                    else {
                        this.updateSbasCorrectionsDownload(deltaTime);
                    }
                    break;
                case GPSSatelliteState.InUse:
                    if (!reachable) {
                        this._areDiffCorrectionsDownloaded = false;
                        this.timeToDownloadCorrections = undefined;
                        this.state.set(GPSSatelliteState.None);
                        return true;
                    }
                    else {
                        this.updateSbasCorrectionsDownload(deltaTime);
                    }
                    break;
                case GPSSatelliteState.InUseDiffApplied:
                    if (!reachable) {
                        this._areDiffCorrectionsDownloaded = false;
                        this.timeToDownloadCorrections = undefined;
                        this.state.set(GPSSatelliteState.None);
                        return true;
                    }
                    else {
                        this.updateSbasCorrectionsDownload(deltaTime);
                    }
                    break;
            }
        }
        return false;
    }
    /**
     * Updates the download state of SBAS differential corrections from this satellite.
     * @param deltaTime The amount of sim time that has elapsed since the last update, in milliseconds.
     */
    updateSbasCorrectionsDownload(deltaTime) {
        if (this.sbasGroup === undefined || this._areDiffCorrectionsDownloaded) {
            return;
        }
        if (this.timeToDownloadCorrections === undefined) {
            this.timeToDownloadCorrections = this.timingOptions.sbasCorrectionDownloadTime + (Math.random() - 0.5) * this.timingOptions.sbasCorrectionDownloadTimeRange;
        }
        this.timeToDownloadCorrections -= deltaTime;
        if (this.timeToDownloadCorrections <= 0) {
            this._areDiffCorrectionsDownloaded = true;
            this.timeToDownloadCorrections = undefined;
        }
    }
    /**
     * Updates the state of the satellite while it is not being tracked.
     * @param simTime The current simulation time, as a Javascript timestamp.
     * @returns Whether this satellite's state changed as a result of the update.
     */
    updateStateUntracked(simTime) {
        if (this.state.get() === GPSSatelliteState.Unreachable) {
            if (this._lastUnreachableTime === undefined) {
                this._lastUnreachableTime = simTime;
            }
            else if (Math.abs(simTime - this._lastUnreachableTime) >= this.timingOptions.unreachableExpireTime) {
                this._lastUnreachableTime = undefined;
                this.state.set(GPSSatelliteState.None);
                return true;
            }
        }
        return false;
    }
    /**
     * Forces an update of this satellite's state to a specific value.
     * @param simTime The current simulation time, as a Javascript timestamp.
     * @param state The state to which to update this satellite. Defaults to this satellite's current state.
     * @param areDiffCorrectionsDownloaded Whether to force differential corrections to be downloaded. Defaults to the
     * satellite's current differential corrections download state.
     * @returns Whether this satellite's state changed as a result of the update.
     */
    forceUpdateState(simTime, state = this.state.get(), areDiffCorrectionsDownloaded = this._areDiffCorrectionsDownloaded) {
        switch (state) {
            case GPSSatelliteState.Unreachable:
                this.timeSpentAcquiring = undefined;
                this.timeToAcquire = undefined;
                if (this.isTracked) {
                    this._lastUnreachableTime = simTime;
                }
            // fallthrough
            case GPSSatelliteState.None:
                this.timeToDownloadEphemeris = undefined;
                this._areDiffCorrectionsDownloaded = false;
                this.timeToDownloadCorrections = undefined;
                break;
            case GPSSatelliteState.DataCollected:
            case GPSSatelliteState.InUse:
            case GPSSatelliteState.InUseDiffApplied:
                this.timeToDownloadEphemeris = undefined;
                this._lastEphemerisTime = simTime;
                break;
        }
        this._areDiffCorrectionsDownloaded = this.sbasGroup !== undefined && areDiffCorrectionsDownloaded;
        if (this.state.get() !== state) {
            this.state.set(state);
            return true;
        }
        else {
            return false;
        }
    }
    /**
 * Updates whether this satellite is being used to calculate a position solution.
     * @param inUse Whether the satellite is being used to calculate a position solution.
     * @returns Whether this satellite's state changed as a result of the update.
     */
    updateInUse(inUse) {
        if (inUse) {
            if (this.state.get() === GPSSatelliteState.DataCollected) {
                this.state.set(GPSSatelliteState.InUse);
                return true;
            }
        }
        else {
            switch (this.state.get()) {
                case GPSSatelliteState.InUse:
                case GPSSatelliteState.InUseDiffApplied:
                    this.state.set(GPSSatelliteState.DataCollected);
                    return true;
            }
        }
        return false;
    }
    /**
     * Updates whether differential corrections are applied to this satellite's ranging data when they are used to
     * calculate a position solution.
     * @param apply Whether differential corrections are applied.
     * @returns Whether this satellite's state changed as a result of the update.
     */
    updateDiffCorrectionsApplied(apply) {
        switch (this.state.get()) {
            case GPSSatelliteState.InUse:
                if (apply) {
                    this.state.set(GPSSatelliteState.InUseDiffApplied);
                    return true;
                }
                break;
            case GPSSatelliteState.InUseDiffApplied:
                if (!apply) {
                    this.state.set(GPSSatelliteState.InUse);
                    return true;
                }
                break;
        }
        return false;
    }
}

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/baseinstrument" />
/**
 * A publisher for VCockpit BaseInstrument events.
 */
class BaseInstrumentPublisher extends BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument, bus, pacer = undefined) {
        super(bus, pacer);
        this.instrument = instrument;
        this.lastGameState = undefined;
        this.lastIsPowered = undefined;
        this.lastScreenState = undefined;
        this.hasFlightStarted = false;
        instrument.addEventListener('mouseleave', (e) => {
            this.publish('vc_mouse_leave', e, false, false);
        });
        instrument.addEventListener('mouseenter', (e) => {
            this.publish('vc_mouse_enter', e, false, false);
        });
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isPublishing()) {
            return;
        }
        this.updateFromGameState(this.instrument.getGameState());
        this.updateFromPowered(this.instrument.isStarted); // Big hack here since there is no other way to get the isStarted state from BaseInstrument
        this.updateFromScreenState(this.instrument.screenState); // Another big hack
    }
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    updateFromGameState(gameState) {
        if (this.lastGameState === gameState) {
            return;
        }
        this.lastGameState = gameState;
        this.publish('vc_game_state', gameState);
        if (!this.hasFlightStarted && gameState === GameState.ingame) {
            this.publish('vc_flight_start', true);
        }
    }
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    updateFromPowered(isPowered) {
        if (this.lastIsPowered === isPowered) {
            return;
        }
        this.lastIsPowered = isPowered;
        this.publish('vc_powered', isPowered);
    }
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    updateFromScreenState(screenState) {
        if (this.lastScreenState === screenState) {
            return;
        }
        const lastScreenState = this.lastScreenState;
        this.lastScreenState = screenState;
        this.publish('vc_screen_state', { current: screenState, previous: lastScreenState });
    }
}

/**
 * A simple timer for handling debounce.
 */
class DebounceTimer {
    constructor() {
        this.timer = null;
    }
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending() {
        return this.timer !== null;
    }
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action, delay) {
        this.clear();
        this.timer = setTimeout(() => {
            this.timer = null;
            action();
        }, delay);
    }
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear() {
        if (this.timer === null) {
            return;
        }
        clearTimeout(this.timer);
        this.timer = null;
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));
/** A publiher to poll transponder simvars. */
class XPDRSimVarPublisher extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus, pacer = undefined, transponderCount = 1) {
        const vars = [];
        for (let i = 0; i < transponderCount; i++) {
            vars.push([`xpdr_mode_${i + 1}`, { name: `TRANSPONDER STATE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_code_${i + 1}`, { name: `TRANSPONDER CODE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_ident_${i + 1}`, { name: `TRANSPONDER IDENT:${i + 1}`, type: SimVarValueType.Bool }]);
        }
        super(new Map(vars), bus, pacer);
    }
}
/** A transponder. */
class XPDRInstrument {
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus, transponderCount = 1) {
        this.bus = bus;
        this.transponderCount = transponderCount;
        this.identDebounceTimers = Array.from({ length: this.transponderCount }, () => new DebounceTimer());
        this.bus = bus;
        this.simVarPublisher = new XPDRSimVarPublisher(bus);
        this.controlSubscriber = bus.getSubscriber();
    }
    /** Initialize the instrument. */
    init() {
        this.simVarPublisher.startPublish();
        for (let i = 0; i < this.transponderCount; i++) {
            this.controlSubscriber.on(`publish_xpdr_code_${i + 1}`).handle(this.setXpdrCode.bind(this, i + 1));
            this.controlSubscriber.on(`publish_xpdr_mode_${i + 1}`).handle(this.setXpdrMode.bind(this, i + 1));
            this.controlSubscriber.on(`xpdr_send_ident_${i + 1}`).handle(this.sendIdent.bind(this, i + 1));
            // force standby on plane load when off
            if (this.getXpdrMode(i + 1) === XPDRMode.OFF) {
                this.setXpdrMode(i + 1, XPDRMode.STBY);
            }
        }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        // Currently, we just need to update our simvar publisher so it polls.
        this.simVarPublisher.onUpdate();
    }
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    setXpdrCode(index, code) {
        const bcdCode = Avionics.Utils.make_xpndr_bcd16(code);
        SimVar.SetSimVarValue(`K:${index}:XPNDR_SET`, 'Frequency BCD16', bcdCode);
    }
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    setXpdrMode(index, mode) {
        SimVar.SetSimVarValue(`TRANSPONDER STATE:${index}`, 'number', mode);
    }
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    getXpdrMode(index) {
        return SimVar.GetSimVarValue(`TRANSPONDER STATE:${index}`, 'number');
    }
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    sendIdent(index) {
        if (this.getXpdrMode(index) > XPDRMode.STBY) {
            SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_ON`, 'number', 1);
            this.identDebounceTimers[index - 1].schedule(() => {
                SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_OFF`, 'number', 0);
            }, 18000);
        }
    }
}

/**
 * A utility class for generating Promises that wait for certain conditions before they are fulfilled.
 */
class Wait {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    static awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    /**
     * Waits for a certain number of frames to elapse.
     * @param count The number of frames to wait.
     * @param glassCockpitRefresh Whether to wait for glass cockpit refresh frames instead of CoherentGT frames. Defaults
     * to `false`.
     */
    static awaitFrames(count, glassCockpitRefresh = false) {
        let elapsedFrameCount = 0;
        if (glassCockpitRefresh) {
            return new Promise(resolve => {
                const callback = () => {
                    if (++elapsedFrameCount > count) {
                        resolve();
                    }
                    else {
                        requestAnimationFrame(callback);
                    }
                };
                requestAnimationFrame(callback);
            });
        }
        else {
            return new Promise(resolve => {
                const id = setInterval(() => {
                    if (++elapsedFrameCount > count) {
                        clearInterval(id);
                        resolve();
                    }
                }, 0);
            });
        }
    }
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    static awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    /**
     * Waits for a notification from a {@link Subscribable}, with an optional condition to end the wait based on the value
     * of the subscribable.
     * @param subscribable The subscribable to wait for.
     * @param predicate A function which evaluates whether the value of the subscribable satisfies the condition for the
     * wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive a notification from the subscribable at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the subscribable when a notification is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = subscribable.sub(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, false, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link Consumer}, with an optional condition to end the wait based on the value of the
     * consumed event.
     * @param consumer The event consumer to wait for.
     * @param predicate A function which evaluates whether the value of the consumed event satisfies the condition for
     * the wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive an event from the event consumer at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the consumed event when an event is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = consumer.handle(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link ReadonlySubEvent}, with an optional condition to end the wait based on the sender
     * and data of the event.
     * @param event The event to wait for.
     * @param predicate A function which evaluates whether the sender and data of the event satisfy the condition for
     * the wait to end. If not defined, any sender/data is considered satisfactory.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the data of the event when an event is received with a sender and data
     * that satisfy the condition for the wait to end.
     */
    static awaitSubEvent(event, predicate, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = event.on((sender, data) => {
                if (predicate === undefined || predicate(data, sender)) {
                    sub.destroy();
                    resolve(data);
                }
            }, true);
            sub.resume();
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
}

/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
class TrafficInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
        return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
        this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
        this.bus.getSubscriber()
            .on('simTime')
            .whenChanged()
            .handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
        const contact = new TrafficContactClass(entry.uId, 1000 / this.options.simTimeUpdateFreq * 5);
        this.tracked.set(contact.uid, contact);
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_added', contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_updated', contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
        this.tracked.forEach(contact => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uid);
                this.bus.pub('traffic_contact_removed', contact.uid, false, false);
            }
        });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy
            || Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_AIR_TRAFFIC'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
        }
        this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
        // noop
    }
}
/**
 * An aircraft contact that is being tracked. Each contact tracks its last reported position, altitude, and heading.
 * Successively updating these values will allow ground speed, ground track, and vertical speed to be calculated based
 * on changes in the values over time. The calculated values are exponentially smoothed to reduce artifacts from
 * potentially noisy data.
 */
class TrafficContactClass {
// eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
        return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
        return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
        return this._groundTrack;
    }
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
        this.uid = uid;
        this.contactTimeResetThreshold = contactTimeResetThreshold;
        // reported data
        this._lastPosition = new GeoPoint(NaN, NaN);
        this.lastPosition = this._lastPosition.readonly;
        this._lastAltitude = UnitType.FOOT.createNumber(NaN);
        this.lastAltitude = this._lastAltitude.readonly;
        this._lastHeading = NaN;
        this._lastContactTime = NaN;
        // computed data
        this._groundSpeed = UnitType.KNOT.createNumber(NaN);
        this.groundSpeed = this._groundSpeed.readonly;
        this._groundTrack = NaN;
        this._verticalSpeed = UnitType.FPM.createNumber(NaN);
        this.verticalSpeed = this._verticalSpeed.readonly;
        this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
    }
        // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
        if (this.groundSpeed.isNaN()) {
            positionOut.set(NaN, NaN);
            altitudeOut.set(NaN);
            return;
        }
        const dt = simTime - this.lastContactTime;
        const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 3600000), UnitType.GA_RADIAN);
        this._lastPosition.offset(this._groundTrack, distance, positionOut);
        const deltaAlt = this._verticalSpeed.number * (dt / 60000);
        this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
        const dt = simTime - this._lastContactTime;
        if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
            this.reset(lat, lon, altitude, heading, simTime);
            return;
        }
        if (!isNaN(dt) && dt > 0) {
            this.updateComputedValues(dt / 1000, lat, lon, altitude);
        }
        this.setReportedValues(lat, lon, altitude, heading);
        if (this.areComputedValuesValid()) {
            this._lastContactTime = simTime;
        }
        else {
            this.reset(lat, lon, altitude, heading, simTime);
        }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
        this.setReportedValues(lat, lon, altitude, heading);
        this._groundSpeed.set(NaN);
        this._groundTrack = NaN;
        this._verticalSpeed.set(NaN);
        this.groundSpeedSmoother.reset();
        this.groundTrackSmoother.reset();
        this.verticalSpeedSmoother.reset();
        this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
        this._lastPosition.set(lat, lon);
        this._lastAltitude.set(altitude);
        this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
        const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
        const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
        const track = pos.bearingFrom(this._lastPosition);
        this.updateGroundSpeed(dt, distanceNM);
        this.updateGroundTrack(dt, track, distanceNM);
        this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
        const dtHours = dt / 3600;
        const speedKnots = distanceNM / dtHours;
        this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
        const last = this.groundTrackSmoother.last();
        if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
        }
        else {
            // if distance between current and last position is too small, computed ground track will be unreliable
            // (and if distance = 0 the track will be meaningless), so we just copy forward the last computed track,
            // or NaN if there is no previously computed track
            track = last === null ? NaN : last;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        this._groundTrack = (next + 360) % 360; // enforce range 0-359
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
        const dtMin = dt / 60;
        const deltaAltFeet = altitude - this._lastAltitude.number;
        const vsFPM = deltaAltFeet / dtMin;
        this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
        const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
        const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
        return isGroundSpeedValid && isVerticalSpeedValid;
    }
}
TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500; // knots
TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 10000; // fpm
TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852; // nautical miles
TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for fuel system information.
 */
class FuelSystemSimVarPublisher extends SimVarPublisher {
    /**
     * Create an FuelSystemSimvarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['fuel_system_valve_switch', { name: 'FUELSYSTEM VALVE SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_valve_open', { name: 'FUELSYSTEM VALVE OPEN:#index#', type: SimVarValueType.Number, indexed: true }],
            ['fuel_system_pump_switch', { name: 'FUELSYSTEM PUMP SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_pump_active', { name: 'FUELSYSTEM PUMP ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_engine_pressure', { name: 'FUELSYSTEM ENGINE PRESSURE:#index#', type: SimVarValueType.PSI, indexed: true }],
            ['fuel_system_line_pressure', { name: 'FUELSYSTEM LINE FUEL PRESSURE:#index#', type: SimVarValueType.PSI, indexed: true }],
            ['fuel_system_line_flow', { name: 'FUELSYSTEM LINE FUEL FLOW:#index#', type: SimVarValueType.GPH, indexed: true }],
            ['fuel_system_tank_quantity', { name: 'FUELSYSTEM TANK QUANTITY:#index#', type: SimVarValueType.GAL, indexed: true }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        /** The context on this component, if any. */
        this.context = undefined;
        /** The type of context for this component, if any. */
        this.contextType = undefined;
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterRender(node) { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    getContext(context) {
        if (this.context !== undefined && this.contextType !== undefined) {
            const index = this.contextType.indexOf(context);
            return this.context[index];
        }
        throw new Error('Could not find the provided context type.');
    }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
class Context {
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue) {
        this.defaultValue = defaultValue;
        /**
         * The provider component that can be set to a specific context value.
         * @param props The props of the provider component.
         * @returns A new context provider.
         */
        this.Provider = (props) => new ContextProvider(props, this);
    }
}
/**
 * A provider component that can be set to a specific context value.
 */
class ContextProvider extends DisplayComponent {
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props, parent) {
        super(props);
        this.parent = parent;
    }
    /** @inheritdoc */
    render() {
        var _a;
        const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
        return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true,
        'tspan': true,
    };
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props) {
        return props.children;
    }
    FSComponent.Fragment = Fragment;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (key === 'class' && typeof prop === 'object' && 'isSubscribableSet' in prop) {
                            // Bind CSS classes to a subscribable set
                            prop.sub((set, eventType, modifiedKey) => {
                                if (eventType === SubscribableSetEventType.Added) {
                                    element.classList.add(modifiedKey);
                                }
                                else {
                                    element.classList.remove(modifiedKey);
                                }
                            }, true);
                        }
                        else if (key === 'style' && typeof prop === 'object' && 'isSubscribableMap' in prop) {
                            // Bind CSS styles to a subscribable map.
                            prop.sub((map, eventType, modifiedKey, modifiedValue) => {
                                switch (eventType) {
                                    case SubscribableMapEventType.Added:
                                    case SubscribableMapEventType.Changed:
                                        element.style.setProperty(modifiedKey, modifiedValue);
                                        break;
                                    case SubscribableMapEventType.Deleted:
                                        element.style.setProperty(modifiedKey, null);
                                        break;
                                }
                            }, true);
                        }
                        else if (typeof prop === 'object' && 'isSubscribable' in prop) {
                            if (key === 'style' && prop instanceof ObjectSubject) {
                                // Bind CSS styles to an object subject.
                                prop.sub((v, style, newValue) => {
                                    element.style.setProperty(style.toString(), newValue);
                                }, true);
                            }
                            else {
                                // Bind an attribute to a subscribable.
                                prop.sub((v) => {
                                    element.setAttribute(key, v);
                                }, true);
                            }
                        }
                        else if (key === 'class' && typeof prop === 'object') {
                            // Bind CSS classes to an object of key value pairs where the values can be boolean | Subscribable<boolean>
                            for (const className in prop) {
                                if (className.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[className];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub((showClass) => {
                                        element.classList.toggle(className, !!showClass);
                                    }, true);
                                }
                                else {
                                    element.classList.toggle(className, !!value);
                                }
                            }
                        }
                        else if (key === 'style' && typeof prop === 'object') {
                            // Bind styles to an object of key value pairs
                            for (const style in prop) {
                                if (style.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[style];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub(newValue => {
                                        element.style.setProperty(style, newValue !== null && newValue !== void 0 ? newValue : '');
                                    }, true);
                                }
                                else {
                                    element.style.setProperty(style, value !== null && value !== void 0 ? value : '');
                                }
                            }
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            if (typeof type === 'function' && type.name === Fragment.name) {
                let fragmentChildren = type(props);
                //Handle the case where the single fragment children is an array of nodes passsed down from above
                while (fragmentChildren && fragmentChildren.length === 1 && Array.isArray(fragmentChildren[0])) {
                    fragmentChildren = fragmentChildren[0];
                }
                vnode = {
                    instance: null,
                    props,
                    children: null
                };
                if (fragmentChildren) {
                    vnode.children = createChildNodes(vnode, fragmentChildren);
                }
            }
            else {
                let instance;
                const pluginSystem = (window._pluginSystem);
                try {
                    instance = type(props);
                }
                catch (_a) {
                    let pluginInstance = undefined;
                    if (pluginSystem !== undefined) {
                        pluginInstance = pluginSystem.onComponentCreating(type, props);
                    }
                    if (pluginInstance !== undefined) {
                        instance = pluginInstance;
                    }
                    else {
                        instance = new type(props);
                    }
                }
                if (props !== null && props.ref !== null && props.ref !== undefined) {
                    props.ref.instance = instance;
                }
                if (instance.contextType !== undefined) {
                    instance.context = instance.contextType.map(c => Subject.create(c.defaultValue));
                }
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentCreated(instance);
                }
                vnode = {
                    instance,
                    props,
                    children: [instance.render()]
                };
            }
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'object') {
                        if ('isSubscribable' in child) {
                            const node = {
                                instance: child,
                                children: null,
                                props: null,
                                root: undefined,
                            };
                            child.sub((v) => {
                                if (node.root !== undefined) {
                                    // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                    node.root.nodeValue = (v === '' || v === null || v === undefined)
                                        ? ' '
                                        : v.toString();
                                }
                            });
                            vnodes.push(node);
                        }
                        else {
                            vnodes.push(child);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            if (element !== null) {
                insertNode(node, position, element);
            }
        }
        else if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance !== null && componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (position === RenderPosition.After) {
                for (let i = node.children.length - 1; i >= 0; i--) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            else {
                for (let i = 0; i < node.children.length; i++) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            const instance = node.instance;
            if (instance instanceof ContextProvider) {
                visitNodes(node, (n) => {
                    if (n === undefined || n === null) {
                        return false;
                    }
                    const nodeInstance = n.instance;
                    if (nodeInstance !== null && nodeInstance.contextType !== undefined) {
                        const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
                        if (contextSlot >= 0) {
                            if (nodeInstance.context === undefined) {
                                nodeInstance.context = [];
                            }
                            nodeInstance.context[contextSlot].set(instance.props.value);
                        }
                        if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            if (componentInstance !== null && componentInstance.onAfterRender !== undefined) {
                const pluginSystem = (window._pluginSystem);
                componentInstance.onAfterRender(node);
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentRendered(node);
                }
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string'
            || (typeof node.instance === 'object'
                && node.instance !== null &&
                'isSubscribable' in node.instance)) {
            let toRender;
            if (typeof node.instance === 'string') {
                toRender = node.instance;
            }
            else {
                toRender = node.instance.get();
                if (toRender === '') {
                    toRender = ' '; // prevent disappearing text node
                }
            }
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', toRender);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', toRender);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', toRender);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else if (Array.isArray(node)) {
            if (position === RenderPosition.After) {
                for (let i = node.length - 1; i >= 0; i--) {
                    render(node[i], element, position);
                }
            }
            else {
                for (let i = 0; i < node.length; i++) {
                    render(node[i], element, position);
                }
            }
        }
        else {
            render(node, element, position);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext(defaultValue) {
        return new Context(defaultValue);
    }
    FSComponent.createContext = createContext;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     */
    function visitNodes(node, visitor) {
        if (node === undefined || node === null) {
            return;
        }
        const stopVisitation = visitor(node);
        if (!stopVisitation && node.children !== undefined && node.children !== null) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (Array.isArray(child)) {
                    for (let childIndex = 0; childIndex < child.length; childIndex++) {
                        visitNodes(child[childIndex], visitor);
                    }
                }
                else {
                    visitNodes(child, visitor);
                }
            }
        }
        return;
    }
    FSComponent.visitNodes = visitNodes;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @param filter A function which filters parsed classes. For each class, the function should return `true` if the
     * class should be included in the output array and `false` otherwise.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString, filter) {
        return classString.split(' ').filter(str => str !== '' && (filter === undefined || filter(str)));
    }
    FSComponent.parseCssClassesFromString = parseCssClassesFromString;
    // eslint-disable-next-line jsdoc/require-jsdoc
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
        const reservedClassSet = new Set(reservedClasses);
        if (classesToSubscribe.isSubscribableSet === true) {
            return bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet);
        }
        else {
            return bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet);
        }
    }
    FSComponent.bindCssClassSet = bindCssClassSet;
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet) {
        if (reservedClassSet.size === 0) {
            return classesToSubscribe.sub((set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
        else {
            return classesToSubscribe.sub((set, type, key) => {
                if (reservedClassSet.has(key)) {
                    return;
                }
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
    }
    /**
     * Binds a {@link MutableSubscribableSet} to a record of CSS classes. CSS classes toggled in the record will also be
     * added to and removed from the bound set, with the exception of a set of reserved classes. The presence or absence
     * of any of the reserved classes in the bound set is not affected by the subscribed record.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A record of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscriptions to the CSS class record.
     */
    function bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet) {
        const subs = [];
        for (const cssClass in classesToSubscribe) {
            if (reservedClassSet.has(cssClass)) {
                continue;
            }
            const value = classesToSubscribe[cssClass];
            if (typeof value === 'object') {
                subs.push(value.sub(setToBind.toggle.bind(setToBind, cssClass), true));
            }
            else if (value === true) {
                setToBind.add(cssClass);
            }
            else {
                setToBind.delete(cssClass);
            }
        }
        return subs;
    }
    /**
     * Adds CSS classes to a {@link ToggleableClassNameRecord}.
     * @param record The CSS class record to which to add the new classes. The record will be mutated as classes are
     * added.
     * @param classesToAdd The CSS classes to add to the record, as a space-delimited class string, an iterable of
     * individual class names, or a {@link ToggleableClassNameRecord}.
     * @param allowOverwrite Whether to allow the new classes to overwrite existing entries in the CSS class record.
     * Defaults to `true`.
     * @param filter A function which filters the classes to add. For each class, the function should return `true` if
     * the class should be included in the record and `false` otherwise.
     * @returns The mutated CSS class record, after the new classes have been added.
     */
    function addCssClassesToRecord(record, classesToAdd, allowOverwrite = true, filter) {
        if (classesToAdd === '') {
            return record;
        }
        if (typeof classesToAdd === 'string') {
            classesToAdd = FSComponent.parseCssClassesFromString(classesToAdd, filter);
            filter = undefined;
        }
        if (typeof classesToAdd[Symbol.iterator] === 'function') {
            for (const cssClass of classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = true;
                }
            }
        }
        else {
            for (const cssClass in classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = classesToAdd[cssClass];
                }
            }
        }
        return record;
    }
    FSComponent.addCssClassesToRecord = addCssClassesToRecord;
    // eslint-disable-next-line jsdoc/require-jsdoc
    function bindStyleMap(mapToBind, stylesToSubscribe, reservedStyles) {
        const reservedStyleSet = new Set(reservedStyles);
        if (stylesToSubscribe.isSubscribableMap === true) {
            return bindStyleMapToSubscribableMap(mapToBind, stylesToSubscribe, reservedStyleSet);
        }
        else if (stylesToSubscribe instanceof ObjectSubject) {
            return bindStyleMapToObjectSubject(mapToBind, stylesToSubscribe, reservedStyleSet);
        }
        else {
            return bindStyleMapToRecord(mapToBind, stylesToSubscribe, reservedStyleSet);
        }
    }
    FSComponent.bindStyleMap = bindStyleMap;
    /**
     * Binds a {@link MutableSubscribableMap} to a subscribable map of CSS styles. Modifications to the CSS styles in the
     * subscribed map will be reflected in the bound map, with the exception of a set of reserved styles. The values of
     * any of the reserved styles in the bound map is not affected by the subscribed map.
     * @param mapToBind The map to bind.
     * @param stylesToSubscribe A key-value map of CSS styles to which to subscribe.
     * @param reservedStyleSet A set of reserved styles.
     * @returns The newly created subscription to the subscribed CSS style map.
     */
    function bindStyleMapToSubscribableMap(mapToBind, stylesToSubscribe, reservedStyleSet) {
        if (reservedStyleSet.size === 0) {
            return stylesToSubscribe.pipe(mapToBind);
        }
        else {
            return stylesToSubscribe.sub((set, type, key, value) => {
                if (reservedStyleSet.has(key)) {
                    return;
                }
                switch (type) {
                    case SubscribableMapEventType.Added:
                    case SubscribableMapEventType.Changed:
                        mapToBind.setValue(key, value);
                        break;
                    case SubscribableMapEventType.Deleted:
                        mapToBind.delete(key);
                        break;
                }
            }, true);
        }
    }
    /**
     * Binds a {@link MutableSubscribableMap} to an {@link ObjectSubject} of CSS styles. Modifications to the CSS styles
     * in the subject will be reflected in the bound map, with the exception of a set of reserved styles. The values of
     * any of the reserved styles in the bound map is not affected by the subscribed subject.
     * @param mapToBind The map to bind.
     * @param stylesToSubscribe An ObjectSubject of CSS styles to which to subscribe.
     * @param reservedStyleSet A set of reserved styles.
     * @returns The newly created subscription to the CSS style ObjectSubject.
     */
    function bindStyleMapToObjectSubject(mapToBind, stylesToSubscribe, reservedStyleSet) {
        return stylesToSubscribe.sub((obj, style, value) => {
            if (reservedStyleSet.has(style)) {
                return;
            }
            if (value) {
                mapToBind.setValue(style, value);
            }
            else {
                mapToBind.delete(style);
            }
        }, true);
    }
    /**
     * Binds a {@link MutableSubscribableMap} to a record of CSS styles. Modifications to the CSS styles in the record
     * will be reflected in the bound map, with the exception of a set of reserved styles. The values of any of the
     * reserved styles in the bound map is not affected by the subscribed record.
     * @param mapToBind The map to bind.
     * @param stylesToSubscribe A record of CSS styles to which to subscribe.
     * @param reservedStyleSet A set of reserved styles.
     * @returns The newly created subscriptions to the CSS style record.
     */
    function bindStyleMapToRecord(mapToBind, stylesToSubscribe, reservedStyleSet) {
        const subs = [];
        for (const style in stylesToSubscribe) {
            if (reservedStyleSet.has(style)) {
                continue;
            }
            const value = stylesToSubscribe[style];
            if (typeof value === 'object') {
                subs.push(value.sub(styleValue => {
                    if (styleValue) {
                        mapToBind.setValue(style, styleValue);
                    }
                    else {
                        mapToBind.delete(style);
                    }
                }, true));
            }
            else if (value) {
                mapToBind.setValue(style, value);
            }
            else {
                mapToBind.delete(style);
            }
        }
        return subs;
    }
    /**
     * Traverses a VNode tree in depth-first order and destroys the first {@link DisplayComponent} encountered in each
     * branch of the tree.
     * @param root The root of the tree to traverse.
     */
    function shallowDestroy(root) {
        FSComponent.visitNodes(root, node => {
            if (node !== root && node.instance instanceof DisplayComponent) {
                node.instance.destroy();
                return true;
            }
            return false;
        });
    }
    FSComponent.shallowDestroy = shallowDestroy;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));
FSComponent.Fragment;

/**
 * TCAS operating modes.
 */
var TcasOperatingMode;
(function (TcasOperatingMode) {
    TcasOperatingMode["Off"] = "Off";
    TcasOperatingMode["Standby"] = "Standby";
    TcasOperatingMode["TAOnly"] = "TAOnly";
    TcasOperatingMode["TA_RA"] = "TA/RA";
    TcasOperatingMode["Test"] = "Test";
    TcasOperatingMode["Failed"] = "Failed";
})(TcasOperatingMode || (TcasOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TcasAlertLevel;
(function (TcasAlertLevel) {
    TcasAlertLevel[TcasAlertLevel["None"] = 0] = "None";
    TcasAlertLevel[TcasAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel[TcasAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel[TcasAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TcasAlertLevel || (TcasAlertLevel = {}));
/**
 * Bit flags describing TCAS resolution advisories.
 */
var TcasResolutionAdvisoryFlags;
(function (TcasResolutionAdvisoryFlags) {
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Corrective"] = 1] = "Corrective";
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["UpSense"] = 2] = "UpSense";
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DownSense"] = 4] = "DownSense";
    /** A resolution advisory which crosses an intruder's altitude. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Crossing"] = 8] = "Crossing";
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Climb"] = 16] = "Climb";
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Descend"] = 32] = "Descend";
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Increase"] = 64] = "Increase";
    /** A CLIMB or DESCEND resolution advisory that reverses sense. Commands a vertical speed above 1500 FPM or below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Reversal"] = 128] = "Reversal";
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceClimb"] = 256] = "ReduceClimb";
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceDescent"] = 512] = "ReduceDescent";
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotClimb"] = 1024] = "DoNotClimb";
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotDescend"] = 2048] = "DoNotDescend";
})(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
/**
 * Types of TCAS resolution advisories.
 */
var TcasResolutionAdvisoryType;
(function (TcasResolutionAdvisoryType) {
    /** Upward sense, positive, corrective, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["Climb"] = "Climb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingClimb"] = "CrossingClimb";
    /** Upward sense, positive, corrective, required vertical speed 1500 to 4400 fpm. */
    TcasResolutionAdvisoryType["MaintainClimb"] = "MaintainClimb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    /** Upward sense, positive, corrective, required vertical speed 2500 to 3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseClimb"] = "IncreaseClimb";
    /** Upward sense, positive, corrective, transition from downward sense, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["ReversalClimb"] = "ReversalClimb";
    /** Upward sense, negative, corrective, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceDescent"] = "ReduceDescent";
    /** Upward sense, negative, preventative, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend0"] = "DoNotDescend0";
    /** Upward sense, negative, preventative, required vertical speed >= -500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend500"] = "DoNotDescend500";
    /** Upward sense, negative, preventative, required vertical speed >= -1000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1000"] = "DoNotDescend1000";
    /** Upward sense, negative, preventative, required vertical speed >= -1500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1500"] = "DoNotDescend1500";
    /** Upward sense, negative, preventative, required vertical speed >= -2000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend2000"] = "DoNotDescend2000";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["Descend"] = "Descend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["CrossingDescend"] = "CrossingDescend";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["MaintainDescend"] = "MaintainDescend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    /** Downward sense, positive, corrective, required vertical speed -2500 to -3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseDescend"] = "IncreaseDescend";
    /** Downward sense, positive, corrective, transition from upward sense, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["ReversalDescend"] = "ReversalDescend";
    /** Downward sense, negative, corrective, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceClimb"] = "ReduceClimb";
    /** Downward sense, negative, preventative, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb0"] = "DoNotClimb0";
    /** Downward sense, negative, preventative, required vertical speed <= 500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb500"] = "DoNotClimb500";
    /** Downward sense, negative, preventative, required vertical speed <= 1000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1000"] = "DoNotClimb1000";
    /** Downward sense, negative, preventative, required vertical speed <= 1500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1500"] = "DoNotClimb1500";
    /** Downward sense, negative, preventative, required vertical speed <= 2000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb2000"] = "DoNotClimb2000";
    /** Clear of conflict. */
    TcasResolutionAdvisoryType["Clear"] = "Clear";
})(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
/**
 * A TCAS-II-like system.
 */
class Tcas {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.bus = bus;
        this.tfcInstrument = tfcInstrument;
                this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.intrudersRA = new Set();
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.ownAirplaneSubs = {
            position: GeoPointSubject.create(new GeoPoint(0, 0)),
            altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            groundTrack: ConsumerSubject.create(null, 0),
            groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
            verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
            radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            isOnGround: ConsumerSubject.create(null, false)
        };
        this.simTime = ConsumerSubject.create(null, 0);
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.alertLevelSubs = new Map();
        this.eventPublisher = this.bus.getPublisher();
        this.eventSubscriber = this.bus.getSubscriber();
        this.paSeparationCache = {
            horizontal: UnitType.NMILE.createNumber(0),
            vertical: UnitType.FOOT.createNumber(0)
        };
        this.maxIntruderCount = SubscribableUtils.toSubscribable(maxIntruderCount, true);
        this.realTimeUpdateFreq = SubscribableUtils.toSubscribable(realTimeUpdateFreq, true);
        this.simTimeUpdateFreq = SubscribableUtils.toSubscribable(simTimeUpdateFreq, true);
        this.sensitivity = this.createSensitivity();
        this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
        const fullRAOptions = {
            initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
            initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
            subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
            subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
            allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : (() => true),
            allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : (() => true),
            allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100),
            allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450)
        };
        this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
        return this.intrudersFiltered;
    }
    /**
     * Gets this system's resolution advisory host.
     * @returns This system's resolution advisory host.
     */
    getResolutionAdvisoryHost() {
        return this.resolutionAdvisoryHost;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
        // init contact listeners
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('traffic_contact_added');
        this.contactRemovedConsumer = sub.on('traffic_contact_removed');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        // add all existing contacts
        this.tfcInstrument.forEachContact(contact => { this.onContactAdded(contact.uid); });
        // init own airplane subjects
        const atFreqSubs = [];
        this.realTimeUpdateFreq.sub(freq => {
            for (const atFreqSub of atFreqSubs) {
                atFreqSub.destroy();
            }
            atFreqSubs.length = 0;
            atFreqSubs.push(sub.on('gps-position').atFrequency(freq).handle(lla => {
            this.ownAirplaneSubs.position.set(lla.lat, lla.long);
            this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
        }), sub.on('ground_speed').atFrequency(freq).handle(gs => { this.ownAirplaneSubs.groundSpeed.set(gs); }), sub.on('vertical_speed').atFrequency(freq).handle(vs => { this.ownAirplaneSubs.verticalSpeed.set(vs); }), sub.on('radio_alt').atFrequency(freq).handle(alt => { this.ownAirplaneSubs.radarAltitude.set(alt); }));
        }, true);
        this.ownAirplaneSubs.groundTrack.setConsumer(sub.on('track_deg_true'));
        this.ownAirplaneSubs.isOnGround.setConsumer(sub.on('on_ground'));
        // init sim time subject
        this.simTime.setConsumer(sub.on('simTime'));
        // init operating mode notifier
        this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
        // init update loop
        sub.on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    onOperatingModeChanged(mode) {
        this.bus.pub('tcas_operating_mode', mode, false, true);
        if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
            // We are in a mode where TCAS is not operating normally.
            // Cancel any active resolution advisories.
            this.resolutionAdvisoryHost.cancel(this.simTime.get());
            // Clean up all intruders.
            for (let i = 0; i < this.intrudersFiltered.length; i++) {
                this.cleanUpIntruder(this.intrudersFiltered[i]);
            }
            this.intrudersFiltered = [];
        }
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
        // always sort intruders with valid predictions first
        if (a.isPredictionValid && !b.isPredictionValid) {
            return -1;
        }
        else if (!a.isPredictionValid && b.isPredictionValid) {
            return 1;
        }
        else if (a.isPredictionValid) {
            let tcaPredictionA, tcaPredictionB;
            // Always sort intruders predicted to violate RA protected volume first (or for whom an RA has been issued), then
            // TA protected volume (or for whom a TA has been issued)
            const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (a.tcaRA.isValid && a.tcaRA.isThreat);
            const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (b.tcaRA.isValid && b.tcaRA.isThreat);
            if (aRA && !bRA) {
                return -1;
            }
            else if (!aRA && bRA) {
                return 1;
            }
            else if (aRA && bRA) {
                tcaPredictionA = a.tcaRA;
                tcaPredictionB = b.tcaRA;
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (a.tcaTA.isValid && a.tcaTA.isThreat);
                const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (b.tcaTA.isValid && b.tcaTA.isThreat);
                if (aTA && !bTA) {
                    return -1;
                }
                else if (!aTA && bTA) {
                    return 1;
                }
                else if (aTA && bTA) {
                    tcaPredictionA = a.tcaTA;
                    tcaPredictionB = b.tcaTA;
                }
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
                    return -1;
                }
                else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            // If both are predicted to violate the RA or TA protected volume, sort by time to CPA.
            // Otherwise sort by how close they approach the protected volume at CPA.
            const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
            const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
            let firstComparison;
            let secondComparison;
            if (tcaPredictionA.isThreat) {
                firstComparison = tcaComparison;
                secondComparison = normComparison;
            }
            else {
                firstComparison = normComparison;
                secondComparison = tcaComparison;
            }
            if (firstComparison === 0) {
                return secondComparison;
            }
            else {
                return firstComparison;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
        const contact = this.tfcInstrument.getContact(uid);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
        const sortedIndex = this.intrudersSorted.findIndex(intruder => intruder.contact.uid === uid);
        const culledIndex = this.intrudersFiltered.findIndex(intruder => intruder.contact.uid === uid);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
        switch (this.operatingModeSub.get()) {
            case TcasOperatingMode.Off:
            case TcasOperatingMode.Standby:
            case TcasOperatingMode.Failed:
            case TcasOperatingMode.Test: // TODO: support TEST mode
                return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq.get()
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq.get()) {
            return;
        }
        this.doUpdate(simTime);
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    doUpdate(simTime) {
        this.updateSensitivity();
        this.updateIntruderPredictions(simTime);
        this.updateIntruderArrays();
        this.updateFilteredIntruderAlertLevels(simTime);
        this.updateResolutionAdvisory(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateIntruderPredictions(simTime) {
        this.ownAirplane.update(simTime);
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            const sensitivity = this.sensitivity.selectParameters(intruder);
            intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
        }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount.get(); i++) {
            const intruder = this.intrudersSorted[i];
            if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filterIntruder(intruder) {
        return true;
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateFilteredIntruderAlertLevels(simTime) {
        let taCount = 0, raCount = 0;
        const len = this.intrudersFiltered.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersFiltered[i];
            this.updateIntruderAlertLevel(simTime, intruder);
            switch (intruder.alertLevel.get()) {
                case TcasAlertLevel.TrafficAdvisory:
                    taCount++;
                    break;
                case TcasAlertLevel.ResolutionAdvisory:
                    raCount++;
                    break;
            }
        }
        this.eventPublisher.pub('tcas_ta_intruder_count', taCount, false, true);
        this.eventPublisher.pub('tcas_ra_intruder_count', raCount, false, true);
    }
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    updateIntruderAlertLevel(simTime, intruder) {
        const currentAlertLevel = intruder.alertLevel.get();
        if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
            if (this.canIssueResolutionAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory
            && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat)
            && !this.canCancelResolutionAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
            if (this.canIssueTrafficAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory
            && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat)
            && !this.canCancelTrafficAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.isPredictionValid) {
            const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
            const radius = parametersPA.protectedRadius;
            const height = parametersPA.protectedHeight;
            if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
                intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
                if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0
                    && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
                    intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
                    return;
                }
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
            return;
        }
        intruder.alertLevel.set(TcasAlertLevel.None);
    }
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() === TcasOperatingMode.TA_RA
            && intruder.tcaRA.isValid
            && intruder.tcaRA.tcpa.number > 0
            && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA
            || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateResolutionAdvisory(simTime) {
        if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
            this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
        }
        else {
            this.resolutionAdvisoryHost.cancel(simTime);
        }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
        this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
        this.eventPublisher.pub('tcas_intruder_added', intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
        var _a;
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.delete(intruder);
        }
        (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
        this.eventPublisher.pub('tcas_intruder_removed', intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.add(intruder);
        }
        else {
            this.intrudersRA.delete(intruder);
        }
        this.eventPublisher.pub('tcas_intruder_alert_changed', intruder, false, false);
    }
}
Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
};
/**
 * An airplane managed by TCAS.
 */
class TcasAirplane {
    constructor() {
        this._position = new GeoPoint(0, 0);
        /** The position of this airplane at the time of the most recent update. */
        this.position = this._position.readonly;
        /** The altitude of this airplane at the time of the most recent update. */
        this._altitude = UnitType.FOOT.createNumber(0);
        this.altitude = this._altitude.readonly;
        this._groundTrack = 0;
        /** The ground speed of this airplane at the time of the most recent update. */
        this._groundSpeed = UnitType.KNOT.createNumber(0);
        this.groundSpeed = this._groundSpeed.readonly;
        /** The vertical speed of this airplane at the time of the most recent update. */
        this._verticalSpeed = UnitType.FPM.createNumber(0);
        this.verticalSpeed = this._verticalSpeed.readonly;
        /**
         * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
         * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
         * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
         * airplane.
         */
        this.positionVec = new Float64Array(3);
        /**
         * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters per second. The coordinate system is defined the same as for position vectors.
         */
        this.velocityVec = new Float64Array(3);
        this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
        return this._groundTrack;
    }
}
/**
 * The own airplane managed by TCAS.
 */
class OwnAirplane extends TcasAirplane {
// eslint-disable-next-line jsdoc/require-returns
    /** Whether this airplane is on the ground. */
    get isOnGround() {
        return this._isOnGround;
    }
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
        super();
        this.subs = subs;
        /** The radar altitude of this airplane at the time of the most recent update. */
        this._radarAltitude = UnitType.FOOT.createNumber(0);
        this.radarAltitude = this._radarAltitude.readonly;
        this._isOnGround = false;
    }
        /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime, out) {
        const dt = (simTime - this.lastUpdateTime) / 1000;
        return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
        this.updateParameters();
        this.updateVectors();
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    updateParameters() {
        this._position.set(this.subs.position.get());
        this._altitude.set(this.subs.altitude.get());
        this._groundTrack = this.subs.groundTrack.get();
        this._groundSpeed.set(this.subs.groundSpeed.get());
        this._verticalSpeed.set(this.subs.verticalSpeed.get());
        this._radarAltitude.set(this.subs.radarAltitude.get());
        this._isOnGround = this.subs.isOnGround.get();
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
        Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
}
/**
 * An abstract implementation of {@link TcasIntruder}.
 */
class AbstractTcasIntruder extends TcasAirplane {
// eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
        return this._isPredictionValid;
    }
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
        super();
        this.contact = contact;
        this.alertLevel = Subject.create(TcasAlertLevel.None);
        /** The 3D position vector of this intruder relative to own airplane. */
        this.relativePositionVec = new Float64Array(3);
        /** The 3D velocity vector of this intruder relative to own airplane. */
        this.relativeVelocityVec = new Float64Array(3);
        this._isPredictionValid = false;
        /** @inheritdoc */
        this.tcaTA = new TcasTcaPredictionClass(this);
        /** @inheritdoc */
        this.tcaRA = new TcasTcaPredictionClass(this);
    }
        /** @inheritdoc */
    predictDisplacement(simTime, out) {
        if (!this._isPredictionValid) {
            return Vec3Math.set(NaN, NaN, NaN, out);
        }
        const dt = (simTime - this.contact.lastContactTime) / 1000;
        return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    /** @inheritdoc */
    predictSeparation(simTime, horizontalOut, verticalOut) {
        if (!this._isPredictionValid) {
            horizontalOut.set(NaN);
            verticalOut.set(NaN);
            return;
        }
        const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
        AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
        AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime, ownAirplane, sensitivity) {
        this.updateParameters(simTime, ownAirplane);
        if (this.isPredictionValid) {
            const taParams = sensitivity.parametersTA;
            const raParams = sensitivity.parametersRA;
            this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
            this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
        }
        else {
            this.invalidatePredictions();
        }
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
        if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
            this._isPredictionValid = false;
            this._position.set(NaN, NaN);
            this._altitude.set(NaN);
            this._groundTrack = NaN;
            this._groundSpeed.set(NaN);
            this._verticalSpeed.set(NaN);
            Vec3Math.set(NaN, NaN, NaN, this.positionVec);
            Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
        }
        else {
            this.updatePosition(simTime, ownAirplane);
            this.updateVelocity(ownAirplane);
            this._groundSpeed.set(this.contact.groundSpeed);
            this._verticalSpeed.set(this.contact.verticalSpeed);
            this._isPredictionValid = true;
        }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
        this.contact.predict(simTime, this._position, this._altitude);
        this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
        const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
        const bearing = ownAirplane.position.bearingTo(this._position);
        Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
        const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
        this.positionVec[2] = verticalPosition;
        Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    updateVelocity(ownAirplane) {
        Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
        Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePredictions() {
        this.tcaTA.invalidate();
        this.tcaRA.invalidate();
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
        return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
        return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
}
AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
/**
 * An default implementation of {@link TcasIntruder}.
 */
class DefaultTcasIntruder extends AbstractTcasIntruder {
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
class TcasTcaPredictionClass {
/** @inheritdoc */
    get isValid() {
        return this._isValid;
    }
    /** @inheritdoc */
    get time() {
        return this._time;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get isThreat() {
        return this._isThreat;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get cpaNorm() {
        return this._cpaNorm;
    }
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder) {
        this.intruder = intruder;
        this._isValid = false;
        this._time = NaN;
        this._tcpa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcpa = this._tcpa.readonly;
        this._tcoa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcoa = this._tcoa.readonly;
        this._isThreat = false;
        /** @inheritdoc */
        this.cpaDisplacement = new Float64Array(3);
        this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
        /** @inheritdoc */
        this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
        this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
        /** @inheritdoc */
        this.cpaVerticalSep = this._cpaVerticalSep.readonly;
        this._cpaNorm = NaN;
    }
        /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tau The maximum lookahead time.
     * @param dmod The radius of the own airplane's protected volume.
     * @param zthr The half-height of the own airplane's protected volume.
     * @param hmd The distance threshold for the horizontal miss distance filter. If not defined, the HMD filter will
     * not be applied.
     */
    update(simTime, tau, dmod, zthr, hmd) {
        var _a;
        this._time = simTime;
        if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
            this.invalidate();
            return;
        }
        // Source: Munoz, CA and Narkawicz, AJ. "A TCAS-II Resolution Advisory Detection Algorithm."
        // https://ntrs.nasa.gov/api/citations/20140002736/downloads/20140002736.pdf
        const tauSeconds = tau.asUnit(UnitType.SECOND);
        const s = this.intruder.relativePositionVec;
        const v = this.intruder.relativeVelocityVec;
        const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
        const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
        const h = zthr.asUnit(UnitType.METER);
        const r = dmod.asUnit(UnitType.METER);
        const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
        const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
        const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
        const rSquared = r * r;
        // Time to closest horizontal approach
        const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
        // Modified tau
        const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
        // Time to co-altitude
        const tcoa = -s[2] / v[2];
        const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
        const isVerticalThreat = Math.abs(s[2]) <= h || (tcoa >= 0 && tcoa <= tauSeconds);
        let passHmdFilter = true;
        if (hmd !== undefined && isHorizontalThreat && isVerticalThreat) {
            const d = hmd.asUnit(UnitType.METER);
            const dSquared = d * d;
            if (vHorizSquared === 0) {
                passHmdFilter = sHorizSquared <= dSquared;
            }
            else {
                const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
                if (delta < 0) {
                    passHmdFilter = false;
                }
                else {
                    const a = vHorizSquared;
                    const b = 2 * dotSHorizVHoriz;
                    const c = sHorizSquared - dSquared;
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant < 0) {
                        passHmdFilter = false;
                    }
                    else {
                        passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
                    }
                }
            }
        }
        this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
        this._tcpa.set(tcpa);
        this._tcoa.set(tcoa);
        TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
        AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
        AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
        this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
        this._isValid = true;
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate() {
        this._isValid = false;
        this._isThreat = false;
        this._tcpa.set(NaN);
        this._tcoa.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
        this._cpaHorizontalSep.set(NaN);
        this._cpaVerticalSep.set(NaN);
        this._cpaNorm = NaN;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
        return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
        const horizLength = Math.hypot(vector[0], vector[1]);
        return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
}
TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
/**
 * An implementation of {@link TcasResolutionAdvisoryHost}.
 */
class TcasResolutionAdvisoryHostClass {
/** @inheritdoc */
    get flags() {
        return this._flags;
    }
    /** @inheritdoc */
    get primaryType() {
        return this._primaryType;
    }
    /** @inheritdoc */
    get secondaryType() {
        return this._secondaryType;
    }
    /** @inheritdoc */
    get primaryFlags() {
        return this._primaryFlags;
    }
    /** @inheritdoc */
    get secondaryFlags() {
        return this._secondaryFlags;
    }
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how the host should calculate resolution advisories.
     * @param ownAirplane The own airplane.
     */
    constructor(bus, options, ownAirplane) {
        this.options = options;
        this.ownAirplane = ownAirplane;
        this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
        this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
        this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.intruders = new Set();
        this.intruderArray = [];
        this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
        this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.minVerticalSpeed = this._minVerticalSpeed.readonly;
        this._flags = 0;
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._secondaryType = null;
        this._primaryFlags = 0;
        this._secondaryFlags = 0;
        this.vsConstraints = [];
        this.lastStateChangeTime = 0;
        this.stateChangeDelay = 0;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher = bus.getPublisher();
    }
        /**
     * Checks whether this host can issue a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder The query intruder.
     * @returns Whether this host can issue a resolution advisory for an intruder.
     */
    canIssueResolutionAdvisory(simTime, intruder) {
        // Inhibit resolution advisories for intruders whose time to closest horizontal approach is less than or equal to
        // zero (indicating the closest point of approach has already been passed) and whose horizontal separation from the
        // own airplane is increasing.
        if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
            return false;
        }
        if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Checks whether this host can cancel a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @returns Whether this host can cancel a resolution advisory for an intruder.
     */
    canCancelResolutionAdvisory(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Updates this host's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    update(simTime, alim, intruders) {
        if (this.intruderArray.length === 0 && intruders.size === 0) {
            return;
        }
        if (simTime < this.lastStateChangeTime) {
            this.lastStateChangeTime = simTime;
        }
        if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
            return;
        }
        if (intruders.size === 0) {
            this.cancel(simTime);
        }
        else {
            const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
            const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
            const alimMeters = alim.asUnit(UnitType.METER);
            const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
            const responseTimeSecondsRemaining = isInitial
                ? responseTimeSeconds
                : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1000, 0, responseTimeSeconds);
            const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
            this.updateIntruders(intruders);
            this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
            if (isInitial) {
                this.selectInitialState(simTime, ownAirplaneVsMps);
            }
            else {
                if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
                    this.updatePositive(simTime);
                }
                else if (this._secondaryType === null) {
                    this.updateNegative(simTime, ownAirplaneVsMps);
                }
                else {
                    this.updateComposite(simTime, ownAirplaneVsMps);
                }
            }
        }
    }
    /**
     * Updates this host's resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    updateIntruders(intruders) {
        // Remove one sense reversal used for every intruder that was removed from the RA.
        for (let i = 0; i < this.intruderArray.length; i++) {
            if (!intruders.has(this.intruderArray[i])) {
                this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
            }
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        for (const intruder of intruders) {
            this.intruders.add(intruder);
            this.intruderArray.push(intruder);
        }
        this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    /**
     * Updates the vertical speed constraints associated with the intruders participating in this host's current
     * resolution advisory.
     * @param alimMeters The value of ALIM (the minimum desired vertical separation between the own airplane and an
     * intruder at time of closest approach), in meters.
     * @param responseTimeSeconds The predicted amount of time, in seconds, for the own airplane to respond to the most
     * recently issued resolution advisory, relative to the present.
     * @param accelMps The predicted vertical acceleration, in meters per second squared, of the own airplane when
     * responding to the most recently issued resolution advisory.
     */
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
        var _a;
        var _b;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        for (let i = 0; i < this.intruderArray.length; i++) {
            const intruder = this.intruderArray[i];
            let above = -Infinity;
            let below = Infinity;
            if (intruder.tcaRA.isValid) {
                const t0 = intruder.tcaRA.time;
                const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
                const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1000;
                const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
                const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                // The altitude own airplane needs to be above in order to pass above the intruder with ALIM vertical separation at CPA.
                const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
                // The altitude own airplane needs to be below in order to pass below the intruder with ALIM vertical separation at CPA.
                const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
                const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
                const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
                if (aboveAlimSense === 1) {
                    // Own airplane needs to adjust vertical speed in the positive direction in order to pass above the intruder with
                    // ALIM vertical separation at CPA.
                    above = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters)
                        : NaN;
                    if (isNaN(above)) {
                        above = Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass above the intruder with ALIM vertical separation at CPA.
                    above = tcpaSeconds > 0
                        ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : -Infinity;
                }
                if (belowAlimSense === -1) {
                    // Own airplane needs to adjust vertical speed in the negative direction in order to pass below the intruder with
                    // ALIM vertical separation at CPA
                    below = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters)
                        : NaN;
                    if (isNaN(below)) {
                        below = -Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass below the intruder with ALIM vertical separation at CPA.
                    below = tcpaSeconds > 0
                        ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : Infinity;
                }
            }
            const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : (_b[i] = { above: 0, below: 0 });
            constraint.above = above;
            constraint.below = below;
        }
        this.vsConstraints.length = this.intruderArray.length;
    }
    /**
     * Selects an initial state for a new resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    selectInitialState(simTime, ownAirplaneVsMps) {
        // We need to first select either upward or downward sense.
        // The minimum vertical speed own airplane can target while still achieving ALIM separation ABOVE all intruders
        let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
        // The maximum vertical speed own airplane can target while still achieving ALIM separation BELOW all intruders
        let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
        // The strongest initial upward and downward sense RAs are CLIMB and DESCEND, respectively (or their crossing/maintain
        // variants, but all have the same vertical speed target).
        let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
        const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
        const canClimb = this.options.allowClimb(simTime);
        const canDescend = this.options.allowDescend(simTime);
        const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
        const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
        minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
        maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
        let sense;
        let senseIsCrossing = false;
        let doesSenseAchieveAlim = false;
        let senseRequiredVs = 0;
        // If one sense RA achieves ALIM separation and the other does not, choose the one that achieves ALIM separation.
        if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
            sense = 1;
        }
        else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
            sense = -1;
        }
        else {
            // If both or neither sense RA achieves ALIM separation, choose the non-crossing sense. Only the closest intruder
            // is evaluated, since in a multi-intruder RA there is the opportunity to reverse sense with each intruder.
            const closestIntruder = this.intruderArray[0];
            const t0 = closestIntruder.tcaRA.time;
            const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
            const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
            const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
            const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
            if (crossingSense === -1 && !isUpSenseInhibited) {
                sense = 1;
            }
            else if (crossingSense === 1 && !isDownSenseInhibited) {
                sense = -1;
            }
            else {
                // If neither sense is crossing or the non-crossing sense is inhibited, choose the one that is not inhibited.
                if (!isUpSenseInhibited && isDownSenseInhibited) {
                    sense = 1;
                }
                else if (isUpSenseInhibited && !isDownSenseInhibited) {
                    sense = -1;
                }
                else {
                    // If neither or both senses are inhibited, choose the one that gives the greatest potential separation at
                    // CPA (i.e. the one that requires the least change in vertical speed). Again, only the closest intruder is evaluated.
                    if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
                        sense = 1;
                    }
                    else {
                        sense = -1;
                    }
                }
                senseIsCrossing = sense === crossingSense;
            }
        }
        doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
        doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
        doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
        senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
        // For multi-intruder RAs, there is the option to choose an initial composite RA which combines two negative RAs of
        // opposite senses.
        if (this.intruderArray.length > 1) {
            // Because the composite RA always includes a vertical speed of 0 within its vertical speed target range, it
            // achieves ALIM separation from all intruders if and only if a vertical speed of 0 does.
            const doesCompositeAchieveAlim = this.vsConstraints.every(constraint => constraint.above <= 0 || constraint.below >= 0);
            // If the composite RA achieves ALIM separation from all intruders and the selected up/down sense RA does not,
            // choose the composite RA.
            if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
                sense = 0;
                doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
            else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
                // If both or neither the composite RA or the selected up/down sense RA achieves ALIM separation from all
                // intruders, choose the composite RA if the up/down sense RA is crossing.
                if (senseIsCrossing) {
                    sense = 0;
                    doesSenseAchieveAlim = doesCompositeAchieveAlim;
                }
                else {
                    // If both or neither the composite RA or the selected up/down sense RA is crossing, choose the one that
                    // provides the greatest potential vertical separation at CPA. Again, only the closest intruder is
                    // evaluated.
                    if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
                        sense = 0;
                        doesSenseAchieveAlim = doesCompositeAchieveAlim;
                    }
                }
            }
        }
        // Now that we have selected the sense, we need to choose the appropriate initial RA type.
        let primaryType;
        let secondaryType = null;
        switch (sense) {
            case 0: // Composite RA
                if (doesSenseAchieveAlim) {
                    // Find the vertical speed limits required to achieve ALIM separation.
                    const maxVsMps = this.getCompositeRequiredMaxVs();
                    const minVsMps = this.getCompositeRequiredMinVs();
                    if (ownAirplaneVsMps > maxVsMps) {
                        // Downward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                    }
                    else if (ownAirplaneVsMps < minVsMps) {
                        // Upward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                    else {
                        // Preventative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                }
                else {
                    primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
                }
                break;
            case 1: // Upward sense single RA
                if (ownAirplaneVsMps < minUpSenseVsMps) {
                    // Corrective
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    }
                }
                else {
                    // Preventative
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
                    }
                }
                break;
            case -1: // Downward sense single RA
                if (ownAirplaneVsMps > maxDownSenseVsMps) {
                    // Corrective
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                    }
                }
                else {
                    // Preventative
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
                    }
                }
                break;
        }
        this.setState(simTime, primaryType, secondaryType, true);
    }
    /**
     * Updates an existing positive resolution advisory. Positive resolution advisories include the CLIMB and DESCEND and
     * related types (CROSSING, MAINTAIN, INCREASE, REVERSAL).
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updatePositive(simTime) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
        // Check if we are inhibited, if so -> convert the current RA to its negative preventative counterpart.
        const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        if (isInhibited) {
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
            return;
        }
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, attempt to
        // weaken the RA. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            // If weakening to a REDUCE CLIMB/DESCENT RA would still provide ALIM separation, do so.
            if (requiredVsMps * sense <= 0) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
            }
        }
        else {
            // Check if strengthening to an INCREASE CLIMB/DESCENT RA would provide ALIM separation
            const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
            let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
            }
        }
    }
    /**
     * Updates an existing negative resolution advisory. Negative resolution advisories include the REDUCE CLIMB/DESCENT
     * and DO NOT CLIMB/DESCEND types.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    updateNegative(simTime, ownAirplaneVsMps) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, we do nothing since
        // negative RAs cannot be weakened. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            return;
        }
        const requirePositive = requiredVsMps * sense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // negative RA we can.
        }
        if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
            // We need to issue a corrective negative RA.
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            this.setState(simTime, sense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
        }
    }
    /**
     * Updates an existing composite resolution advisory. Composite resolution advisories consist of a (corrective or
     * preventative) negative resolution advisory combined with a negative preventative resolution advisory of the
     * opposite sense.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     * @throws Error if a composite resolution advisory is not active.
     */
    updateComposite(simTime, ownAirplaneVsMps) {
        if (this._secondaryType === null) {
            throw new Error('TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active');
        }
        const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
        const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredMinVsMps = this.getCompositeRequiredMinVs();
        const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
        const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
        if (primarySense === 1) {
            primaryCurrentVsMps = currentMinVsMps;
            primaryRequiredVsMps = requiredMinVsMps;
            secondaryCurrentVsMps = currentMaxVsMps;
            secondaryRequiredVsMps = requiredMaxVsMps;
        }
        else {
            primaryCurrentVsMps = currentMaxVsMps;
            primaryRequiredVsMps = requiredMaxVsMps;
            secondaryCurrentVsMps = currentMinVsMps;
            secondaryRequiredVsMps = requiredMinVsMps;
        }
        const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
        const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
        const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0
            || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // pair of negative RAs we can.
        }
        let primaryType;
        if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
            // We need to issue a corrective negative RA.
            primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            primaryType = primarySense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
        }
        const secondaryType = primarySense === 1
            ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps)
            : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
        this.setState(simTime, primaryType, secondaryType);
    }
    /**
     * Sets the state of this host's current resolution advisory. If the specified state is equal to the current state
     * of the resolution advisory, this method does nothing. If the state is successfully set, the `tcas_ra_issued`
     * event will be published if `isInitial` is `true`, or the `tcas_ra_updated` event if `isInitial` is `false`.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param primaryType The primary type of the resolution advisory.
     * @param secondaryType The secondary type of the resolution advisory.
     * @param isInitial Whether the state to set is for an initial resolution advisory.
     */
    setState(simTime, primaryType, secondaryType, isInitial = false) {
        if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
            return;
        }
        let minSpeed, maxSpeed;
        const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
        this._primaryType = primaryType;
        this._primaryFlags = primaryTypeDef.flags;
        this._secondaryType = secondaryType;
        if (secondaryType !== null) {
            const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
            this._secondaryFlags = secondaryTypeDef.flags;
            minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
            maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
        }
        else {
            this._secondaryFlags = 0;
            minSpeed = primaryTypeDef.minVerticalSpeed;
            maxSpeed = primaryTypeDef.maxVerticalSpeed;
        }
        this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
        this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
        this.isInitial = isInitial;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE
            + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1000;
        if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
            this.senseReversalCount++;
        }
        if (isInitial) {
            this.publisher.pub('tcas_ra_issued', this, false, false);
        }
        else {
            this.publisher.pub('tcas_ra_updated', this, false, false);
        }
    }
    /**
     * Cancels this host's current resolution advisory. If there is no currently active resolution advisory, this
     * method does nothing. If the resolution advisory is successfully cancelled, the `tcas_ra_canceled` event will be
     * published.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    cancel(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
            return;
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        this._maxVerticalSpeed.set(NaN);
        this._minVerticalSpeed.set(NaN);
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._primaryFlags = 0;
        this._secondaryType = null;
        this._secondaryFlags = 0;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher.pub('tcas_ra_canceled', undefined, false, false);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * above all current RA intruders.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation above all current RA intruders.
     */
    getUpSenseRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * below all current RA intruders.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation below all current RA intruders.
     */
    getDownSenseRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tcpa The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
        const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
        if (signedAccel === 0) {
            return vs;
        }
        const y0 = currentAlt + vs * responseTime;
        const tc = tcpa - responseTime;
        const a = signedAccel / 2;
        const b = -signedAccel * tc;
        const c = targetAlt - y0 - vs * tc;
        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
            return NaN;
        }
        const sqrtDiscr = Math.sqrt(discriminant);
        const t1 = (-b + sqrtDiscr) / (2 * a);
        const t2 = (-b - sqrtDiscr) / (2 * a);
        if (t1 <= tc && t1 >= 0) {
            return vs + signedAccel * t1;
        }
        if (t2 <= tc && t2 >= 0) {
            return vs + signedAccel * t2;
        }
        return NaN;
    }
    /**
     * Gets the least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for a given minimum
     * vertical speed requirement.
     * @param minVsMps A minimum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for the specified
     * minimum vertical speed requirement.
     */
    static getDoNotDescendType(minVsMps) {
        if (minVsMps > -500) {
            return TcasResolutionAdvisoryType.DoNotDescend0;
        }
        else if (minVsMps > -1000) {
            return TcasResolutionAdvisoryType.DoNotDescend500;
        }
        else if (minVsMps > -1500) {
            return TcasResolutionAdvisoryType.DoNotDescend1000;
        }
        else if (minVsMps > -2000) {
            return TcasResolutionAdvisoryType.DoNotDescend1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotDescend2000;
        }
    }
    /**
     * Gets the least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for a given maximum
     * vertical speed requirement.
     * @param maxVsMps A maximum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for the specified
     * maximum vertical speed requirement.
     */
    static getDoNotClimbType(maxVsMps) {
        if (maxVsMps < 500) {
            return TcasResolutionAdvisoryType.DoNotClimb0;
        }
        else if (maxVsMps < 1000) {
            return TcasResolutionAdvisoryType.DoNotClimb500;
        }
        else if (maxVsMps < 1500) {
            return TcasResolutionAdvisoryType.DoNotClimb1000;
        }
        else if (maxVsMps < 2000) {
            return TcasResolutionAdvisoryType.DoNotClimb1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotClimb2000;
        }
    }
}
/** The base amount of delay between state changes, in milliseconds, before predicted response time is taken into account. */
TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5000;
TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
        return -1;
    }
    else if (tcpaComparison > 0) {
        return 1;
    }
    else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
        return -1;
    }
    else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
        return 1;
    }
    else {
        return 0;
    }
};
TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
        flags: 0,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 2500,
        maxVerticalSpeed: 3000
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -3000,
        maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1000
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 2000
    },
};
TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];

/**
 * Standard TCAS-II sensitivity parameters.
 */
class TcasIISensitivityParameters {
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude, radarAltitude) {
        const altFeet = altitude.asUnit(UnitType.FOOT);
        const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
        let level;
        if (radarAltFeet > 2350) {
            if (altFeet > 42000) {
                level = 6;
            }
            else if (altFeet > 20000) {
                level = 5;
            }
            else if (altFeet > 10000) {
                level = 4;
            }
            else if (altFeet > 5000) {
                level = 3;
            }
            else {
                level = 2;
            }
        }
        else if (radarAltFeet > 1000) {
            level = 1;
        }
        else {
            level = 0;
        }
        return level;
    }
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    altitude, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    radarAltitude) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPA(level) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level) {
        return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
}
TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
};
TcasIISensitivityParameters.TA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.33),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.48),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(40),
        protectedRadius: UnitType.NMILE.createNumber(0.75),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(45),
        protectedRadius: UnitType.NMILE.createNumber(1),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(1200)
    }
];
TcasIISensitivityParameters.RA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.35),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.55),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(350),
        hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.8),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(400),
        hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(700),
        alim: UnitType.FOOT.createNumber(600),
        hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(800),
        alim: UnitType.FOOT.createNumber(700),
        hmd: UnitType.NMILE.createNumber(0.98)
    }
];
/**
 * An implementation of {@link TCASSensitivity} which provides sensitivity parameters as defined in the official
 * TCAS II specification.
 */
class TcasIISensitivity {
    constructor() {
        this.sensitivity = new TcasIISensitivityParameters();
        this.level = 0;
        this.params = {
            parametersPA: this.sensitivity.getPA(0),
            parametersTA: this.sensitivity.getTA(0),
            parametersRA: this.sensitivity.getRA(0)
        };
    }
    /** @inheritdoc */
    selectParameters() {
        return this.params;
    }
    /** @inheritdoc */
    selectRAAlim() {
        return this.sensitivity.getRAAlim(this.level);
    }
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude, radarAltitude) {
        this.level = this.sensitivity.selectLevel(altitude, radarAltitude);
        this.params.parametersPA = this.sensitivity.getPA(this.level);
        this.params.parametersTA = this.sensitivity.getTA(this.level);
        this.params.parametersRA = this.sensitivity.getRA(this.level);
    }
}

/**
 * A utility class for working with VNAV.
 */
class VNavUtils {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg) {
        if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc
            || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1
            || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
            return true;
        }
        return false;
    }
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
        const delta = targetAltitude - currentAltitude;
        const minutesToConstraint = distance / groundSpeed * 60;
        return delta / minutesToConstraint;
    }
    /**
     * Gets the vertical speed required to maintain a given flight path angle and groundspeed.
     * @param fpa The flight path angle, in degrees. Positive angles represent an ascending flight path.
     * @param groundspeed The groundspeed, in knots.
     * @returns The vertical speed required to maintain the specified flight path angle and groundspeed.
     */
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
        return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    /**
     * Gets the equivalent flight path angle for a given vertical speed and groundspeed. For this calculation, positive
     * flight path angles represent an ascending flight path.
     * @param vs The vertical speed, in feet per minute.
     * @param groundspeed The groundspeed, in knots.
     * @returns The flight path angle equivalent to the specified vertical speed and ground speed.
     */
    static getFpaFromVerticalSpeed(vs, groundspeed) {
        return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    /**
     * Gets the flight path angle required to travel a given lateral distance and altitude. Positive flight path angles
     * represent an ascending flight path. By convention, the flight path angle required to travel zero altitude equals
     * zero degrees for all distances.
     * @param distance The lateral distance to travel, in the same units as `altitude`.
     * @param altitude The altitude to travel, in the same units as `distance`.
     * @returns The flight path angle, in degrees, required to travel the specified altitude and distance.
     */
    static getFpa(distance, altitude) {
        if (altitude === 0) {
            return 0;
        }
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Gets the change in altitude along a flight path angle for a given lateral distance traveled.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param distance The lateral distance traveled.
     * @returns The change in altitude along the specified flight path angle for the specified lateral distance traveled,
     * expressed in the same units as `distance`.
     */
    static altitudeForDistance(fpa, distance) {
        return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    /**
     * Gets the lateral distance traveled along a flight path angle for a given change in altitude.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param altitude The change in the altitude.
     * @returns The lateral distance traveled along the specified flight path angle for the specified change in altitude,
     * expressed in the same units as `altitude`.
     */
    static distanceForAltitude(fpa, altitude) {
        return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    return l;
                }
            }
        }
        return Math.max(0, plan.length - 1);
    }
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan, iterator) {
        let fafIndex = -1;
        iterator.iterateReverse(lateralPlan, cursor => {
            if (fafIndex === -1 && cursor.legDefinition && (cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF)) {
                fafIndex = cursor.legIndex + cursor.segment.offset;
            }
        });
        fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
        return fafIndex;
    }
    /**
     * Gets the index of the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint that contains the specified flight plan leg, or `-1` if one could not
     * be found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
            if (verticalPlan.constraints[c].index >= globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint that contains the specified flight plan leg, or `undefined` if one could not be
     * found.
     */
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets the index of the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint immediately prior to the constraint that contains the specified flight
     * plan leg, or `-1` if one could nto be found.
     */
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            if (verticalPlan.constraints[c].index < globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint immediately prior to the constraint that contains the specified flight plan leg, or
     * `undefined` if one could nto be found.
     */
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan, globalLegIndex) {
        const constraintIndex = verticalPlan.constraints.findIndex(c => c.index === globalLegIndex);
        if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
            return true;
        }
        return false;
    }
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromConstraint(constraint) {
        let distance = 0;
        for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
            distance += constraint.legs[legIndex].distance;
        }
        return distance;
    }
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
        let distance = 0;
        const startGlobalIndex = previousConstraint !== undefined ? previousConstraint.index + 1 : 0;
        for (let i = startGlobalIndex; i <= constraint.index; i++) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
            distance += verticalLeg.distance;
        }
        return distance;
    }
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
        if (activeLegIndex > constraint.index) {
            return 0;
        }
        let distance = 0;
        let index = activeLegIndex;
        for (const leg of lateralPlan.legs(false, activeLegIndex)) {
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
                return Number.POSITIVE_INFINITY;
            }
            else if (leg.calculated !== undefined) {
                distance += leg.calculated.distanceWithTransitions;
            }
            if (++index > constraint.index) {
                break;
            }
        }
        distance -= distanceAlongLeg;
        return distance;
    }
    /**
     * Gets VNAV Constraint Details from a constraint.
     * @param constraint The constraint to get details from.
     * @param out The object to which write the results.
     * @returns The VNav Constraint Details.
     */
    static getConstraintDetails(constraint, out) {
        if (constraint.maxAltitude === constraint.minAltitude) {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
            switch (constraint.type) {
                case 'climb':
                case 'missed':
                    if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    break;
                default:
                    if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
            }
        }
        else {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        return out;
    }
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
        if (verticalPlan.constraints.length > 0) {
            if (selectedGlobalLegIndex < activeLegIndex) {
                return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
            }
            for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
                const constraint = verticalPlan.constraints[c];
                if (constraint.index === selectedGlobalLegIndex || (c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index)) {
                    return constraint;
                }
                else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
                    return verticalPlan.constraints[c + 1];
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the index of the next descent constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next descent constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextDescentConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next climb constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next climb constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextClimbConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'climb') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next missed approach constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next missed approach constraint at or after the specified flight plan leg, or `-1` if
     * one could not be found.
     */
    static getNextMaprConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the next descent constraint with a defined minimum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint with a defined minimum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if ((constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next descent constraint minimum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint defined minimum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.minAltitude : undefined;
    }
    /**
     * Gets the next climb constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint with a defined maximum altitude at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint) {
            if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return currentConstraint;
            }
            else if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
                const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== undefined ?
                    VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
                for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
                    const constraint = verticalPlan.constraints[c];
                    if (constraint.type === 'climb' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        return constraint;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the current climb constraint, if one exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The current climb constraint, or `undefined` if no such constraint exists.
     */
    static getCurrentClimbConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.type === 'climb') {
            return currentConstraint;
        }
        return undefined;
    }
    /**
     * Gets the next climb constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the next missed approach constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint with a defined maximum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next missed approach constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.targetAltitude;
        }
        const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan) {
        if (verticalPlan.fafLegIndex !== undefined) {
            return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
        }
        return undefined;
    }
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
        var _a;
        out.todLegIndex = -1;
        out.bodLegIndex = -1;
        out.todLegDistance = 0;
        out.distanceFromTod = 0;
        out.distanceFromBod = 0;
        out.currentConstraintLegIndex = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no TOD/BOD if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active constraint contains a VNAV-ineligible leg after the active leg.
            || ((activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== undefined && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex)) {
            return out;
        }
        out.currentConstraintLegIndex = activeConstraint.index;
        // Find the next BOD, which will be at the end of the earliest non-flat descent constraint subsequent to and
        // including the active constraint that ends in a level-off at a lower altitude than the aircraft's current
        // altitude. Note that we are guaranteed to not go through a VNAV discontinuity, since all constraints that end in
        // a discontinuity also end in a level-off.
        // lag altitude by ~3 seconds so that we aren't continuously pushing TOD in front of the plane while descending.
        const altitude = currentAltitude - currentVS / 20;
        let bodConstraintIndex, bodConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a climb constraint, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
                bodConstraintIndex = i;
                bodConstraint = constraint;
                break;
            }
        }
        if (!bodConstraint) {
            return out;
        }
        out.bodLegIndex = bodConstraint.index;
        // Find the TOD associated with the BOD. To do this, we need to first find the earliest non-flat descent constraint
        // between the active constraint and the BOD constraint (inclusive) that is connected to the BOD constraint with no
        // intervening flat constraints or VNAV path discontinuities and whose target altitude less than the aircraft's
        // current altitude.
        let todConstraintIndex = bodConstraintIndex;
        for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const prevConstraint = verticalPlan.constraints[i + 1];
            if (!prevConstraint
                || prevConstraint.index < activeLegIndex
                || prevConstraint.type === 'climb'
                || prevConstraint.type === 'missed'
                || prevConstraint.targetAltitude > altitude
                || prevConstraint.fpa <= 0
                || prevConstraint.isPathEnd) {
                todConstraintIndex = i;
                break;
            }
        }
        const todConstraint = verticalPlan.constraints[todConstraintIndex];
        // Now that we have found the TOD constraint, we need to find the TOD leg: the leg on which the TOD actually lies.
        // To do this, we calculate the along-track distance from the end of the TOD constraint to the TOD, then iterate
        // through the legs in the constraint backwards while keeping track of the total along-track distance covered by
        // each leg.
        let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
        let constraintIndex = todConstraintIndex;
        let todLegIndex = todConstraint.index;
        let todLegDistance = 0;
        let todLeg = todConstraint.legs[0];
        while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
            const constraint = verticalPlan.constraints[constraintIndex];
            // Remember that flight plan legs in a VNAV constraint appear in reverse order relative to how they are ordered
            // in the flight plan.
            for (let i = 0; i < constraint.legs.length; i++) {
                if (!constraint.legs[i].isEligible) {
                    // We've encounted a VNAV-ineligible leg. Since we cannot calculate a vertical path through this leg, we have
                    // to stop iterating now so that the TOD gets set to the most recent VNAV-eligible leg.
                    constraintIndex = verticalPlan.constraints.length;
                    break;
                }
                todLeg = constraint.legs[i];
                distance -= todLeg.distance;
                if (distance <= 0) {
                    todLegIndex = constraint.index - i;
                    todLegDistance = todLeg.distance + distance;
                    break;
                }
            }
            constraintIndex++;
        }
        if (distance > 0) {
            // If we still haven't found the TOD yet, set it to the beginning of the earliest VNAV leg that was iterated.
            todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
            todLegDistance = todLeg.distance;
        }
        out.todLegIndex = todLegIndex;
        out.todLegDistance = todLegDistance;
        // calculate distance to TOD/BOD
        let globalLegIndex = bodConstraint.index;
        let distanceToBOD = 0, distanceToTOD = 0;
        let hasReachedTOD = false;
        let isDone = false;
        for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const constraint = verticalPlan.constraints[i];
            for (let j = 0; j < constraint.legs.length; j++) {
                const leg = constraint.legs[j];
                if (globalLegIndex === todLegIndex) {
                    distanceToTOD -= todLegDistance;
                    hasReachedTOD = true;
                }
                if (globalLegIndex > activeLegIndex) {
                    distanceToBOD += leg.distance;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance;
                    }
                }
                else if (globalLegIndex === activeLegIndex) {
                    distanceToBOD += leg.distance - distanceAlongLeg;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance - distanceAlongLeg;
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= distanceAlongLeg;
                    }
                }
                else {
                    if (hasReachedTOD) {
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= leg.distance;
                    }
                }
                if (isDone) {
                    break;
                }
                else {
                    globalLegIndex--;
                }
            }
            if (isDone) {
                break;
            }
        }
        out.distanceFromBod = distanceToBOD;
        out.distanceFromTod = distanceToTOD;
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
        var _a, _b;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no BOC/TOC if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active VNAV constraint is not a climb-type constraint.
            || (activeConstraint.type !== 'climb' && activeConstraint.type !== 'missed')) {
            return out;
        }
        // Find the TOC. To do this, we need to first find the earliest climb constraint subsequent to and including the
        // active constraint that has a maximum altitude (i.e. is an AT, AT OR BELOW, or BETWEEN constraint). Additionally,
        // the TOC must not be separated from the active constraint by a descent-type constraint.
        let tocConstraintIndex, tocConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (isFinite(constraint.maxAltitude)) {
                tocConstraintIndex = i;
                tocConstraint = constraint;
                break;
            }
        }
        // If there is no next TOC, there also can be no next BOC since the next BOC must follow the next TOC.
        if (!tocConstraint) {
            return out;
        }
        out.tocConstraintIndex = tocConstraintIndex;
        out.tocAltitude = tocConstraint.maxAltitude;
        // Calculate distance to TOC.
        const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies.
        const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
        let tocLegIndex;
        let currentConstraintIndex = activeConstraintIndex;
        let currentConstraint;
        let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
        let currentLeg = activeLeg;
        const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
        if (distanceRemaining > activeLegDistanceRemaining) {
            distanceRemaining -= activeLegDistanceRemaining;
            if (currentConstraintLegIndex <= 0) {
                --currentConstraintIndex;
            }
            else {
                currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
            }
            while (currentConstraintIndex >= tocConstraintIndex) {
                currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                currentLeg = currentConstraint.legs[currentConstraintLegIndex];
                if (currentLeg !== undefined) {
                    if (distanceRemaining > currentLeg.distance) {
                        out.distanceFromToc += currentLeg.distance;
                        distanceRemaining -= currentLeg.distance;
                    }
                    else {
                        out.distanceFromToc += distanceRemaining;
                        tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
                        distanceRemaining -= currentLeg.distance;
                        break;
                    }
                }
                if (currentConstraintLegIndex <= 0) {
                    --currentConstraintIndex;
                }
                else {
                    currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
                }
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last leg of the TOC constraint.
            out.tocLegIndex = tocConstraint.index;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        // Find the next BOC, which is located at the beginning of the earliest climb constraint subsequent to (and not
        // including) the TOC constraint with a maximum altitude greater than the TOC constraint. Additionally, the BOC
        // must not be separated from the TOC constraint by a descent-type constraint.
        let lastClimbConstraintIndex = tocConstraintIndex;
        let bocConstraintIndex, bocConstraint;
        for (let i = tocConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (constraint.maxAltitude > tocConstraint.maxAltitude) {
                bocConstraintIndex = i;
                bocConstraint = constraint;
                break;
            }
            lastClimbConstraintIndex = i;
        }
        let bocDistanceStopConstraintIndex = undefined;
        if (bocConstraint) {
            out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
            bocDistanceStopConstraintIndex = bocConstraintIndex;
        }
        else {
            // If we did not find a climb constraint subsequent to the TOC constraint with a maximum altitude greater than the
            // the TOC constraint, then the BOC will be located at the last climb constraint.
            const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
            if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
                out.bocLegIndex = lastClimbConstraint.index + 1;
                bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
            }
        }
        // Calculate distance to BOC
        if (bocDistanceStopConstraintIndex !== undefined) {
            let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
            for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
                distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
            }
            out.distanceFromBoc = distanceToEndOfActiveConstraint;
            for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
                out.distanceFromBoc += verticalPlan.constraints[i].distance;
            }
        }
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC to cruise altitude details for a vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param cruiseAltitude The cruise altitude, in meters.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC to cruise altitude details.
     */
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        // Find the last climb constraint
        const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        // If the active leg is past the first descent constraint, both cruise BOC and cruise TOC are undefined.
        if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
            return out;
        }
        const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
        const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        // Cruise BOC will always be located at the beginning of the first leg after the last climb constraint. If there
        // are no climb constraints in the plan, then cruise BOC is undefined.
        if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
            const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
            out.bocLegIndex = lastClimbConstraint.index + 1;
            out.distanceFromBoc = activeLegDistanceRemaining
                + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
        // Calculate distance to TOC.
        const deltaAltitude = cruiseAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies. The TOC is restricted to legs prior to the first descent constraint.
        let tocLegIndex;
        const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
        if (distanceRemaining > activeLegDistanceRemaining) {
            let legIndex = activeLegIndex + 1;
            for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
                const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                if (distanceRemaining > legDistance) {
                    out.distanceFromToc += legDistance;
                    distanceRemaining -= legDistance;
                }
                else {
                    out.distanceFromToc += distanceRemaining;
                    tocLegIndex = legIndex;
                    distanceRemaining -= legDistance;
                    break;
                }
                legIndex++;
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last viable leg.
            out.tocLegIndex = lastLegIndex;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        out.tocAltitude = cruiseAltitude;
        return out;
    }
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset] !== undefined;
            }
        }
        return false;
    }
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset];
            }
        }
        throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
        const segment = verticalPlan.segments[segmentIndex];
        const leg = segment.legs[legIndex];
        if (segment && leg) {
            return leg;
        }
        else {
            throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
        }
    }
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
        return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan) {
        return verticalPlan.segments;
    }
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
        if (lateralLeg.leg !== undefined) {
            switch (lateralLeg.leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    return true;
            }
        }
        return false;
    }
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index, minAltitude, maxAltitude, name, type = 'descent') {
        return {
            index,
            minAltitude,
            maxAltitude,
            targetAltitude: 0,
            name,
            isTarget: false,
            isPathEnd: false,
            distance: 0,
            fpa: 0,
            legs: [],
            type,
            isBeyondFaf: false
        };
    }
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
        return {
            segmentIndex,
            legIndex,
            fpa: 0,
            altitude: 0,
            isUserDefined: false,
            isDirectToTarget: false,
            distance: distance,
            isEligible: true,
            isBod: false,
            isAdvisory: true,
            name
        };
    }
    /**
     * Finds the index of the first climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getFirstClimbConstraintIndex(verticalPlan) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the last climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getLastClimbConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the first descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getFirstDescentConstraintIndex(verticalPlan) {
        let index = -1;
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            const type = verticalPlan.constraints[c].type;
            if (type === 'descent' || type === 'manual') {
                index = c;
            }
            if (type === 'direct') {
                return c;
            }
        }
        return index;
    }
    /**
     * Finds the index of the last descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getLastDescentConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            const type = verticalPlan.constraints[i].type;
            if (type === 'descent' || type === 'direct' || type === 'manual') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Checks whether two speed constraints are equal.
     * @param a The first speed constraint.
     * @param b The second speed constraint.
     * @returns Whether the two speed constraints are equal.
     */
    static speedConstraintEquals(a, b) {
        return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    /**
     * Checks whether two altitude constraint details are equal.
     * @param a The first altitude constraint details.
     * @param b The second altitude constraint details.
     * @returns Whether the two altitude constraint details are equal.
     */
    static altitudeConstraintDetailsEquals(a, b) {
        return a.type === b.type && a.altitude === b.altitude;
    }
    /**
     * Checks whether two speed constraint details are equal.
     * @param a The first speed constraint details.
     * @param b The second speed constraint details.
     * @returns Whether the two speed constraint details are equal.
     */
    static speedConstraintDetailsEquals(a, b) {
        return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint
            && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint)
            && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    /**
     * Computes the path error distance that should be used given the groundspeed.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The path error distance to use.
     */
    static getPathErrorDistance(groundSpeed) {
        if (groundSpeed <= 190) {
            return 100;
        }
        else if (groundSpeed >= 210) {
            return 250;
        }
        else {
            return 100 + (((groundSpeed - 190) / 20) * 150);
        }
    }
/**
 * Checks whether an index is a valid VNAV index.
     * @param index The index to check.
     * @returns Whether the specified index is a valid VNAV index.
     */
    static isValidVNavIndex(index) {
        return Number.isInteger(index) && index >= 0;
    }
    /**
     * Gets the suffix for event bus topics published by VNAV with a given index.
     * @param index The index of the VNAV for which to get the suffix.
     * @returns The suffix for event bus topics published by VNAV with the specified index.
     */
    static getEventBusTopicSuffix(index) {
        return (index === 0 ? '' : `_${index}`);
    }
}

/**
 * SimVar names for VNAV data.
 */
var VNavVars;
(function (VNavVars) {
    /** The vertical deviation in feet. */
    VNavVars["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    /** The VNAV target altitude in feet. */
    VNavVars["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    /** The VNAV path mode. */
    VNavVars["PathMode"] = "L:WTAP_VNav_Path_Mode";
    /** The VNAV State. */
    VNavVars["VNAVState"] = "L:WTAP_VNav_State";
    /** Whether a VNAV Path Exists for the current leg. */
    VNavVars["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    /** The VNAV current altitude capture type. */
    VNavVars["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    /** The distance to the next TOD in meters, or -1 if one does not exist. */
    VNavVars["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    /** The distance to the next BOD in meters, or -1 if one does not exist. */
    VNavVars["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    /** The index of the leg for the next TOD. */
    VNavVars["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    /** The distance from the end of the TOD leg that the TOD is, in meters. */
    VNavVars["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    /** The index of the leg for the next BOD. */
    VNavVars["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    /** The distance to the next TOC in meters, or -1 if one does not exist. */
    VNavVars["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    /** The distance to the next BOC in meters, or -1 if one does not exist. */
    VNavVars["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    /** The index of the leg for the next TOC. */
    VNavVars["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    /** The distance from the end of the TOC leg that the TOC is, in meters. */
    VNavVars["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    /** The index of the leg for the next BOC. */
    VNavVars["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    /** The index of the leg for the next constraint. */
    VNavVars["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    /** The current constraint altitude, in feet. */
    VNavVars["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    /** The next constraint altitude, in feet. */
    VNavVars["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    /** The current required flight path angle, in degrees. */
    VNavVars["FPA"] = "L:WTAP_VNav_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    /** The VNAV approach guidance mode. */
    VNavVars["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    /** The current LPV vertical deviation in feet. */
    VNavVars["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    /** The current remaining LPV distance in meters. */
    VNavVars["GPDistance"] = "L:WTAP_GP_Distance";
    /** The current LPV FPA, in degrees. */
    VNavVars["GPFpa"] = "L:WTAP_GP_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    /** The approach glidepath service level. */
    VNavVars["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
})(VNavVars || (VNavVars = {}));
/**
 * A publisher for VNAV events derived from SimVars.
 */
class VNavSimVarPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of VNavSimVarPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        const defs = [
            ['gp_approach_mode', { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
            ...ArrayUtils.flatMap([
    ['vnav_vertical_deviation', { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ['vnav_target_altitude', { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ['vnav_path_mode', { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ['vnav_path_available', { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ['vnav_state', { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ['vnav_altitude_capture_type', { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ['vnav_tod_distance', { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_leg_distance', { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_bod_distance', { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_global_leg_index', { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ['vnav_bod_global_leg_index', { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ['vnav_toc_distance', { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_leg_distance', { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_boc_distance', { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_global_leg_index', { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_boc_global_leg_index', { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_global_leg_index', { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_altitude', { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_next_constraint_altitude', { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_fpa', { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ['vnav_required_vs', { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ['gp_vertical_deviation', { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ['gp_distance', { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ['gp_fpa', { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ['gp_required_vs', { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ['gp_service_level', { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }],
            ], pair => {
                const [topic, entry] = pair;
                const indexedEntry = {
                    name: `${entry.name}:#index#`,
                    type: entry.type,
                    indexed: true,
                    defaultIndex: null
                };
                return [
                    pair,
                    [topic, indexedEntry]
                ];
            })
        ];
        super(defs, bus);
    }
}

/**
 * SimVar names for LNAV data.
 */
var LNavVars;
(function (LNavVars) {
    /** The current desired track, in degrees true. */
    LNavVars["DTK"] = "L:WTAP_LNav_DTK";
    /**
     * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavVars["XTK"] = "L:WTAP_LNav_XTK";
    /** Whether LNAV is tracking a path. */
    LNavVars["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    LNavVars["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    /** The currently active LNAV transition mode. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    LNavVars["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    /** The index of the vector LNAV is currently tracking. */
    LNavVars["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    /** The current course LNAV is attempting to steer, in degrees true. */
    LNavVars["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    /** Whether LNAV sequencing is suspended. */
    LNavVars["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
     * distance indicates the plane is before the start of the leg.
     */
    LNavVars["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
     * the end of the leg.
     */
    LNavVars["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position. A
     * negative distance indicates the plane is before the start of the vector.
     */
    LNavVars["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
     * past the end of the vector.
     */
    LNavVars["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    LNavVars["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    /** The current along-track ground speed of the airplane. */
    LNavVars["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
})(LNavVars || (LNavVars = {}));
/**
 * A publisher for LNAV events derived from SimVars.
 */
class LNavSimVarPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of LNavSimVarPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        const defs = ArrayUtils.flatMap([
            ['lnav_dtk', { name: LNavVars.DTK, type: SimVarValueType.Degree }],
            ['lnav_xtk', { name: LNavVars.XTK, type: SimVarValueType.NM }],
            ['lnav_is_tracking', { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
            ['lnav_tracked_leg_index', { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
            ['lnav_transition_mode', { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
            ['lnav_tracked_vector_index', { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
            ['lnav_course_to_steer', { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
            ['lnav_is_suspended', { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
            ['lnav_leg_distance_along', { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
            ['lnav_leg_distance_remaining', { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
            ['lnav_vector_distance_along', { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
            ['lnav_vector_distance_remaining', { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
            ['lnav_vector_anticipation_distance', { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
            ['lnav_along_track_speed', { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }],
        ], pair => {
            const [topic, entry] = pair;
            const indexedEntry = {
                name: `${entry.name}:#index#`,
                type: entry.type,
                indexed: true,
                defaultIndex: null
            };
            return [
                pair,
                [topic, indexedEntry]
            ];
        });
        super(defs, bus);
    }
}

/**
 * Handles the calculation of the VNAV flight path for Path Smoothing VNAV Implementations.
 */
class SmoothingPathCalculator {
    /**
     * Creates an instance of SmoothingPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.primaryPlanIndex = primaryPlanIndex;
        /** The Vertical Flight Plans managed by this Path Calculator */
        this.verticalFlightPlans = [];
        /** @inheritdoc */
        this.planBuilt = new SubEvent();
        /** @inheritdoc */
        this.vnavCalculated = new SubEvent();
        this.legAltitudes = [0, 0];
        this.applyPathValuesResult = [undefined, 0];
        this.index = (_a = options === null || options === void 0 ? void 0 : options.index) !== null && _a !== void 0 ? _a : 0;
        this.flightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
        this.minFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MIN_FPA;
        this.maxFlightPathAngle = (_d = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _d !== void 0 ? _d : SmoothingPathCalculator.DEFAULT_MAX_FPA;
        this.forceFirstApproachAtConstraint = (_e = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _e !== void 0 ? _e : false;
        this.directToLegOffset = (_f = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
        this.isLegEligibleFunc = (_g = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _g !== void 0 ? _g : SmoothingPathCalculator.isLegVnavEligible;
        this.shouldUseConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _h !== void 0 ? _h : (() => true);
        this.invalidateClimbConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateClimbConstraint;
        this.invalidateDescentConstraintFunc = (_k = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _k !== void 0 ? _k : SmoothingPathCalculator.invalidateDescentConstraint;
        this.flightPlanner.onEvent('fplCreated').handle(e => this.createVerticalPlan(e.planIndex));
        this.flightPlanner.onEvent('fplCopied').handle(e => this.onPlanChanged(e.targetPlanIndex));
        this.flightPlanner.onEvent('fplLoaded').handle(e => this.onPlanChanged(e.planIndex));
        this.flightPlanner.onEvent('fplLegChange').handle(e => this.onPlanChanged(e.planIndex, e));
        this.flightPlanner.onEvent('fplSegmentChange').handle(e => this.onPlanChanged(e.planIndex, undefined, e));
        this.flightPlanner.onEvent('fplIndexChanged').handle(e => this.onPlanChanged(e.planIndex));
        this.flightPlanner.onEvent('fplCalculated').handle(e => this.onPlanCalculated(e));
        const vnavTopicSuffix = VNavUtils.getEventBusTopicSuffix(this.index);
        const sub = bus.getSubscriber();
        sub.on(`vnav_set_default_fpa${vnavTopicSuffix}`).handle(this.setDefaultFpa.bind(this));
        sub.on(`vnav_set_vnav_direct_to${vnavTopicSuffix}`).handle(data => {
            if (data.globalLegIndex < 0) {
                this.cancelVerticalDirect(data.planIndex);
            }
            else {
                this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
            }
        });
    }
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex) {
        var _a;
        var _b;
        return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : (_b[planIndex] = this.createVerticalPlan(planIndex));
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /** @inheritdoc */
    requestPathCompute(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== undefined) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            this.computePathAndNotify(lateralPlan, verticalPlan);
            return true;
        }
        return false;
    }
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for a flight plan leg, or `-1` if one
     * could not be found.
     */
    getTargetConstraintIndex(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== undefined && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
                const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
                if (priorConstraint && priorConstraint.type !== 'climb' && priorConstraint.type !== 'missed') {
                    return priorConstraintIndex;
                }
                else {
                    return -1;
                }
            }
            let i = verticalPlan.constraints.length - 1;
            while (i >= 0) {
                const constraint = verticalPlan.constraints[i];
                if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== 'climb' && constraint.type !== 'missed') {
                    return i;
                }
                i--;
            }
        }
        else {
            const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraintIndex >= 0) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isMissed = currentConstraint.type === 'missed';
                for (let i = currentConstraintIndex; i >= 0; i--) {
                    const constraint = verticalPlan.constraints[i];
                    if (constraint.type === 'climb' || (isMissed && constraint.type === 'missed')) {
                        if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                            return i;
                        }
                    }
                    else {
                        return -1;
                    }
                }
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for a flight plan leg, or `undefined` if one could
     * not be found.
     */
    getTargetConstraint(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    /** @inheritdoc */
    getTargetAltitude(planIndex, globalLegIndex) {
        var _a, _b;
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
        }
        else {
            return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
        }
    }
    /** @inheritdoc */
    getFlightPhase(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex)) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
            if (globalLegIndex > -1) {
                const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
                switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
                    case 'climb':
                    case 'missed':
                        return VerticalFlightPhase.Climb;
                }
            }
        }
        return VerticalFlightPhase.Descent;
    }
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return undefined;
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
        }
        else {
            return currentConstraint.targetAltitude;
        }
    }
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            if (priorConstraint) {
                return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
            }
            else {
                return { type: AltitudeRestrictionType.Unused, altitude: 0 };
            }
        }
        else {
            return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        }
    }
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        // added check for climb or descent for smoothing path calc
        if (currentConstraint !== undefined) {
            if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    return currentConstraint.maxAltitude;
                }
                else {
                    return currentConstraint.minAltitude;
                }
            }
            else {
                if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
                    return currentConstraint.minAltitude;
                }
                else {
                    return currentConstraint.maxAltitude;
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
        if (currentConstraint) {
            const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
            if (currentConstraintIndex > -1) {
                if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'climb' || constraint.type === 'missed') {
                            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
                else {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
        if (constraintGlobalLegIndex < 0) {
            return;
        }
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
        verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Cancels the existing VNAV direct-to for a vertical flight plan.
     * @param planIndex The index of the vertical flight plan for which to cancel the VNAV direct-to.
     */
    cancelVerticalDirect(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex === undefined) {
            return;
        }
        verticalPlan.verticalDirectIndex = undefined;
        verticalPlan.verticalDirectFpa = undefined;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sets this calculator's default flight path angle.
     * @param fpa The new default flight path angle, in degrees. Increasingly positive values indicate steeper descents.
     */
    setDefaultFpa(fpa) {
        const newFpa = Math.max(0, fpa);
        if (newFpa !== this.flightPathAngle) {
            this.flightPathAngle = newFpa;
            for (let i = 0; i < this.verticalFlightPlans.length; i++) {
                const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : undefined;
                const verticalPlan = this.verticalFlightPlans[i];
                if (lateralPlan && verticalPlan) {
                    this.computePathAndNotify(lateralPlan, verticalPlan);
                }
            }
        }
    }
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex !== undefined) {
            if (legChangeEvent !== undefined) {
                const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
                if (globalIndex <= verticalPlan.verticalDirectIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
            else if (segmentChangeEvent !== undefined) {
                const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
                if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
        }
        verticalPlan.planChanged = true;
        verticalPlan.currentAlongLegDistance = undefined;
    }
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    onPlanCalculated(event) {
        this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
    }
    /**
     * Builds a vertical flight plan if its corresponding lateral flight plan has been changed since the last rebuild,
     * then computes the vertical path sends events notifying subscribers that the plan was built and calculated.
     * @param planIndex The index of the plan to build and compute.
     */
    buildVerticalFlightPlanAndComputeAndNotify(planIndex) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.planChanged) {
            this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        }
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    notifyBuilt(planIndex) {
        this.planBuilt.notify(this, planIndex);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    notifyCalculated(planIndex) {
        this.vnavCalculated.notify(this, planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan and sends an event notifying subscribers that the plan
     * was built.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
        this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.notifyBuilt(verticalPlan.planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
        SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
        verticalPlan.planChanged = false;
    }
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
        var _a, _b, _c, _d, _e, _f, _g;
        // Reset the constraints array.
        verticalPlan.constraints.length = 0;
        // Reset the segments array.
        verticalPlan.segments.length = 0;
        verticalPlan.destLegIndex = undefined;
        verticalPlan.firstDescentConstraintLegIndex = undefined;
        verticalPlan.lastDescentConstraintLegIndex = undefined;
        verticalPlan.missedApproachStartIndex = undefined;
        // Find the FAF in the lateral plan, if any.
        verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
        const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
        let firstApproachGlobalLegIndex;
        // Iterate forward through the lateral plan to build the constraints
        for (const segment of lateralPlan.segments()) {
            // Add the plan segments to the VNav Path Calculator Segments
            verticalPlan.segments[segment.segmentIndex] = {
                offset: segment.offset,
                legs: []
            };
            if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === undefined) {
                firstApproachGlobalLegIndex = segment.offset;
            }
            for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                const globalLegIndex = segment.offset + segmentLegIndex;
                const lateralLeg = segment.legs[segmentLegIndex];
                const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '', (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : undefined);
                // Check if the leg is part of the missed approach, and set the missed approach start index.
                if (verticalPlan.missedApproachStartIndex === undefined
                    && segment.segmentType === FlightPlanSegmentType.Approach
                    && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
                    verticalPlan.missedApproachStartIndex = globalLegIndex;
                }
                // Check if the leg contains a constraint
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
                verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                // Check if the leg precedes a defined vertical direct for this vertical flight plan.
                const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== undefined && globalLegIndex < verticalPlan.verticalDirectIndex;
                const legPrecedesDirectTo = directToTargetLegIndex !== undefined && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
                if (constraintAltitudes !== undefined
                    && !legPrecedesVerticalDirectIndex
                    && !legPrecedesDirectTo
                    && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
                    verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
                    const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    // Add the new vertical constraint to the array of constraints in reverse order.
                    verticalPlan.constraints.unshift(verticalConstraint);
                }
                // Add the new vertical leg to the vertical flight plan
                verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
            }
        }
        verticalPlan.length = lateralPlan.length;
        if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== undefined) {
            const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
            if (firstApproachConstraint && firstApproachConstraint.type !== 'climb' && firstApproachConstraint.type !== 'missed') {
                SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
            }
        }
        verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
        verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    /**
     * Builds a VNAV constraint for a lateral flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the lateral flight plan leg for which to build the constraint.
     * @param lateralLeg The lateral flight plan leg for which to build the constraint.
     * @param constraintAltitudes The constraint altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @param name The name of the new constraint.
     * @returns A new VNAV constraint for the specified lateral flight plan leg.
     */
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
        var _a;
        const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? 'missed' : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? 'descent' : 'climb');
        constraint.isBeyondFaf = verticalPlan.fafLegIndex === undefined ? false : globalLegIndex > verticalPlan.fafLegIndex;
        // Check if this constraint is a vertical direct.
        if (verticalPlan.verticalDirectIndex === globalLegIndex) {
            constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
            constraint.type = 'direct';
        }
        const userFpa = lateralLeg.verticalData.fpa;
        if (userFpa !== undefined && constraint.type !== 'climb' && constraint.type !== 'missed') {
            constraint.fpa = userFpa;
            constraint.type = 'manual';
        }
        return constraint;
    }
    /**
     * Computes the vertical path for a flight plan and sends an event notifying subscribers that the plan was
     * calculated.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePathAndNotify(lateralPlan, verticalPlan) {
        this.computePath(lateralPlan, verticalPlan);
        this.notifyCalculated(lateralPlan.planIndex);
    }
    /**
     * Computes the vertical path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePath(lateralPlan, verticalPlan) {
        this.computeDescentPath(lateralPlan, verticalPlan);
    }
    /**
     * Computes the descent path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computeDescentPath(lateralPlan, verticalPlan) {
        this.fillLegDistances(lateralPlan, verticalPlan);
        // Updated leg distances could cause some invalidated constraints to become valid, so we will re-insert all
        // invalidated constraints and filter them again.
        this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
        this.findAndRemoveInvalidConstraints(verticalPlan);
        if (verticalPlan.constraints.length < 1) {
            return;
        }
        this.populateConstraints(verticalPlan);
        if (this.computeFlightPathAngles(verticalPlan)) {
            for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
                const constraint = verticalPlan.constraints[constraintIndex];
                if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                    let altitude = constraint.targetAltitude;
                    let constraintIsBod = true;
                    if (constraintIndex > 0) {
                        const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
                        if (nextConstraint !== undefined && nextConstraint.type !== 'climb') {
                            const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                            if ((nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25) || constraint.fpa === 0) {
                                constraintIsBod = false;
                            }
                        }
                    }
                    if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
                        constraint.isPathEnd = true;
                        constraint.isTarget = true;
                        constraintIsBod = true;
                    }
                    for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
                        const leg = constraint.legs[legIndex];
                        leg.fpa = constraint.fpa;
                        leg.altitude = altitude;
                        altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
                        if (legIndex === 0) {
                            leg.isAdvisory = false;
                        }
                        else {
                            leg.isAdvisory = true;
                        }
                        if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                            leg.isBod = true;
                        }
                        else {
                            leg.isBod = false;
                        }
                    }
                }
            }
        }
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    fillLegDistances(lateralPlan, verticalPlan) {
        var _a, _b, _c;
        if (lateralPlan.length > 0) {
            for (const segment of lateralPlan.segments()) {
                if (segment) {
                    const vnavSegment = verticalPlan.segments[segment.segmentIndex];
                    for (let l = 0; l < segment.legs.length; l++) {
                        const leg = segment.legs[l];
                        if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                            vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
                        }
                        else if (leg && leg.calculated && leg.calculated.endLat !== undefined && leg.calculated.endLon !== undefined) {
                            let prevLeg;
                            for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                                if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== undefined && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== undefined) {
                                    prevLeg = checkLeg;
                                    break;
                                }
                            }
                            if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                                vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                            }
                        }
                        else {
                            vnavSegment.legs[l].distance = 0;
                        }
                    }
                }
            }
        }
    }
    /**
     * Finds and removes invalid constraints from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    findAndRemoveInvalidConstraints(verticalPlan) {
        var _a, _b, _c;
        let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all constraints prior to the
        // direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? firstDescentConstraintIndex
            : verticalPlan.constraints.length - 1;
        let phase = 'climb';
        let priorMinAltitude = -Infinity;
        let priorMaxAltitude = Infinity;
        let distanceFromPriorMinAltitude = 0;
        let requiredFpa = 0;
        for (let i = startIndex; i >= 0; i--) {
            const currentConstraint = verticalPlan.constraints[i];
            const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
            let currentPhase;
            switch (currentConstraint.type) {
                case 'climb':
                case 'missed':
                    currentPhase = currentConstraint.type;
                    break;
                default:
                    currentPhase = 'descent';
            }
            if (currentPhase !== phase) {
                // Reset prior altitudes when switching phases.
                phase = currentPhase;
                priorMinAltitude = -Infinity;
                priorMaxAltitude = Infinity;
                distanceFromPriorMinAltitude = currentConstraintDistance;
            }
            else {
                distanceFromPriorMinAltitude += currentConstraintDistance;
            }
            let isDescentConstraint;
            let shouldInvalidate;
            switch (phase) {
                case 'climb':
                case 'missed':
                    isDescentConstraint = false;
                    shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
                    break;
                default:
                    isDescentConstraint = true;
                    if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
                        requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
                    }
                    else {
                        requiredFpa = 0;
                    }
                    shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
            }
            const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
            if (shouldInvalidate) {
                constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
                verticalPlan.constraints.splice(i, 1);
                // Need to subtract current constraint distance because it will get added again at the beginning of the next iteration.
                // (The next constraint inherits the legs that belonged to the current constraint after it is removed.)
                distanceFromPriorMinAltitude -= currentConstraintDistance;
                // If we invalidated the first descent constraint, we need to find the new one.
                if (isDescentConstraint && i === firstDescentConstraintIndex) {
                    firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
                    verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
                }
            }
            else {
                constraintLeg.invalidConstraintAltitude = undefined;
                if (isFinite(currentConstraint.minAltitude)) {
                    priorMinAltitude = currentConstraint.minAltitude;
                    distanceFromPriorMinAltitude = 0;
                }
                if (isFinite(currentConstraint.maxAltitude)) {
                    priorMaxAltitude = currentConstraint.maxAltitude;
                }
            }
        }
        // Update last descent leg in case we invalidated some descent constraints
        verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    /**
     * Finds previously invalidated constraints and re-inserts them into the vertical flight plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
        var _a;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all legs prior to and including
        // the direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? (verticalPlan.firstDescentConstraintLegIndex + 1)
            : 0;
        let globalLegIndex = startIndex;
        for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
            if (verticalLeg.invalidConstraintAltitude !== undefined) {
                const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                if (constraintAltitudes !== undefined) {
                    const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
                    // If we re-validated a descent constraint, we need to update the first/last descent constraint when appropriate.
                    if (proposedConstraint.type === 'descent'
                        || proposedConstraint.type === 'manual'
                        || proposedConstraint.type === 'direct'
                        || proposedConstraint.type === 'dest') {
                        if (verticalPlan.firstDescentConstraintLegIndex === undefined || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
                        }
                        if (verticalPlan.lastDescentConstraintLegIndex === undefined || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                            verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
                        }
                    }
                }
            }
            globalLegIndex++;
        }
    }
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    populateConstraints(verticalPlan) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
            const constraint = verticalPlan.constraints[constraintIndex];
            const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
            constraint.legs.length = 0;
            constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
            let eligibleLegIndex;
            let ineligibleLegIndex;
            for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== undefined ? previousConstraint.index : -1); globalLegIndex--) {
                const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
                constraint.legs.push(verticalLeg);
                if (ineligibleLegIndex === undefined && verticalLeg.isEligible) {
                    eligibleLegIndex = globalLegIndex;
                }
                if (ineligibleLegIndex === undefined && !verticalLeg.isEligible) {
                    ineligibleLegIndex = globalLegIndex;
                }
            }
            if (ineligibleLegIndex !== undefined && eligibleLegIndex !== undefined) {
                constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
            }
        }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    computeFlightPathAngles(verticalPlan) {
        // Iterate through all descent constraints in reverse flight plan order and attempt to assign one as a "target"
        // constraint, which is a constraint that anchors a constant FPA path connecting it to one or more prior
        // constraints.
        // Once a target constraint is found, the iteration continues as we attempt to build a constant FPA path backwards
        // from the target constraint that meets all the iterated constraints. Once we reach a constraint that cannot be
        // met with a constant FPA path from the target constraint that also meets all intermediate constraints, we assign
        // a new target constraint at the point where the FPA must change. Certain constraints must also be designated as
        // target constraints regardless of whether a constant FPA path through them is possible. In any case, once we
        // designate a new target constraint, the process is repeated until we run out of descent constraints.
        let currentTargetConstraint;
        let currentPathSegmentDistance = 0;
        let currentPathSegmentMinFpa = this.minFlightPathAngle;
        let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        let currentTargetConstraintHasFixedFpa = false;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
            // There are no descent constraints, so no FPAs to be calculated
            return false;
        }
        for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
            const constraint = verticalPlan.constraints[targetConstraintIndex];
            // If the current constraint is climb or missed, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            // If we haven't found a target constraint yet, attempt to make the current constraint the target constraint,
            // if it defines either a minimum or maximum altitude. The target altitude is preferentially set to the minimum
            // altitude, if it exists. If the current constraint has neither a minimum nor maximum altitude (which should
            // technically never happen), skip it.
            if (!currentTargetConstraint) {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    currentTargetConstraint = constraint;
                    currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
                    currentTargetConstraint.isTarget = true;
                }
                else {
                    continue;
                }
            }
            // Reset the method variables
            currentPathSegmentMinFpa = this.minFlightPathAngle;
            currentPathSegmentMaxFpa = this.maxFlightPathAngle;
            currentPathSegmentDistance = currentTargetConstraint.distance;
            const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
            if (currentTargetConstraintIsFirstDescentConstraint) {
                if (currentTargetConstraint.type === 'descent') {
                    // If this is the first descent constraint and it is not a direct or manual, set the FPA to the default value.
                    currentTargetConstraint.fpa = this.flightPathAngle;
                }
                // If currentTargetConstraintIsFirstDescentConstraint is true, then after this logic, we're done with this method.
                return true;
            }
            // If the current target constraint is a manual or direct type, then honor the FPA by not allowing any other FPAs.
            if (currentTargetConstraint.type === 'manual') {
                currentPathSegmentMinFpa = currentTargetConstraint.fpa;
                currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
                currentTargetConstraintHasFixedFpa = true;
            }
            else {
                currentTargetConstraintHasFixedFpa = false;
            }
            let pathSegmentIsFlat = false;
            for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
                const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
                const isCurrentConstraintClimb = currentConstraint.type === 'climb' || currentConstraint.type === 'missed';
                const isCurrentConstraintManual = currentConstraint.type === 'manual';
                const isCurrentConstraintDirect = currentConstraint.type === 'direct';
                if (isCurrentConstraintClimb) {
                    // We have reached a climb constraint.
                    if (currentConstraintIndex - 1 > targetConstraintIndex) {
                        // There is at least one constraint between the existing target constraint and the current climb
                        // constraint. Attempt to extend the constant-FPA path through the constraint immediately following the
                        // current climb constraint (which is guaranteed to be a descent constraint).
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                        const maxAltitude = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
                        const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude, false);
                        if (terminatedIndex < currentConstraintIndex) {
                            // The path was terminated early, which means there is a new target constraint.
                            targetConstraintIndex = terminatedIndex - 1; // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                            break;
                        }
                    }
                    else {
                        // The existing target constraint immediately follows the current climb constraint. Treat the target
                        // constraint as if it were the first descent constraint and apply the default FPA. Note that we are
                        // guaranteed the target constraint is not a direct constraint.
                        currentTargetConstraint.fpa = this.flightPathAngle;
                    }
                    // Do not designate a new target constraint in order to allow the outer loop to find the new one.
                    targetConstraintIndex = currentConstraintIndex;
                    currentTargetConstraint = undefined;
                    break;
                }
                const minAltitude = currentConstraint.minAltitude;
                const maxAltitude = currentConstraint.maxAltitude;
                if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
                    // We are in a flat segment (all constraints with FPA = 0) and the current constraint would allow a
                    // non-zero FPA to the constraint immediately following it. Therefore, we set the new target constraint
                    // to the constraint immediately following the current one (because it is at the end of that constraint
                    // where the FPA can potentially change from non-zero to zero). Note that we are guaranteed that the
                    // new target constraint lies prior to the existing target constraint.
                    const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                    const newTargetConstraintIndex = currentConstraintIndex - 1;
                    SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, 
                    // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                    // constraints are equal to the flat segment altitude.
                    Infinity, this.applyPathValuesResult);
                    // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                    targetConstraintIndex = newTargetConstraintIndex - 1;
                    currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
                    currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                    currentTargetConstraint.isTarget = true;
                    break;
                }
                else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
                    // The current constraint does not allow a non-zero FPA to the target constraint, and the target constraint
                    // does not have a fixed FPA. We will mark the current segment as flat and set the target constraint FPA to 0.
                    pathSegmentIsFlat = true;
                    currentTargetConstraint.fpa = 0;
                    if (isCurrentConstraintFirstDescent) {
                        // If the current constraint is the first descent constraint, then we need to make it the new target
                        // constraint because the first descent constraint is never flat.
                        const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                        SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, 
                        // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                        // constraints are equal to the flat segment altitude.
                        Infinity, this.applyPathValuesResult);
                        // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                        targetConstraintIndex = currentConstraintIndex - 1;
                        currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
                        currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                        currentTargetConstraint.isTarget = true;
                        break;
                    }
                    continue;
                }
                // Get the min and max FPA from the current target constraint to the current constraint.
                const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
                const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
                const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
                // A new target constraint needs to be created under the following conditions:
                // - The current constraint cannot be met with a constant FPA path from the current target constraint within
                //   this calculator's FPA limits.
                // - The current constraint is the final approach fix.
                // - The current constraint is a vertical direct constraint.
                // - The current constraint is a manual constraint.
                if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
                    // We need to choose a FPA for the constant-FPA smoothed path.
                    if (isFpaOutOfBounds) {
                        // If we are creating a new target constraint because the current constraint can't be met with a
                        // constant-FPA path, then we set the FPA of the smoothed path to the value that brings the new
                        // target constraint's target altitude as close to meeting the current constraint as possible.
                        if (minFpa > currentPathSegmentMaxFpa) {
                            currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
                        }
                        else {
                            currentTargetConstraint.fpa = currentPathSegmentMinFpa;
                        }
                    }
                    else {
                        // If the new target constraint can be met with a constant-FPA path, then we choose a valid FPA that is
                        // as close to the calculator's default FPA as possible.
                        currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                        currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    }
                    // Find the next constraint with a max altitude
                    const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
                    // Attempt to extend a constant-FPA path from the existing target constraint to the current constraint and
                    // make the current constraint the new target constraint.
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
                    targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                    currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                    break;
                }
                else if (isCurrentConstraintFirstDescent) {
                    // We have reached the first descent constraint without needing to create a new target constraint, so
                    // attempt to extend the constant-FPA path from the existing target constraint through the first descent
                    // constraint.
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
                    if (terminatedIndex < currentConstraintIndex + 1) {
                        // The path was terminated early, which means there is a new target constraint.
                        targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                        currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                        break;
                    }
                    else {
                        // The path was not terminated early, so we are done.
                        return true;
                    }
                }
                else {
                    // Extend the current constant-FPA path and update the FPA limits
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentPathSegmentDistance += currentConstraint.distance;
                }
            }
        }
        return true;
    }
    /**
     * Attempts to extend and terminate a constant-FPA path from an existing target constraint at another constraint,
     * applying flight path angles and target altitudes to each constraint along the path. The target constraint defines
     * the FPA of the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param terminatingConstraintIndex The index of the constraint at which to terminate the path.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param terminatingConstraintIsTarget Whether to designate the terminating constraint as a target constraint if the
     * path is not terminated early. If the path is terminated early, this argument is ignored and the constraint at
     * which the path was terminated early is always designated as a target constraint.
     * @returns The index of the constraint at which the constant-FPA path was actually terminated.
     */
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
        const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
        if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== undefined) {
            // A constant-FPA path was not able to be extended from the existing target constraint to the first descent
            // constraint, so we need to designate a new target constraint where the path terminated.
            const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
            // Establish the proposed next target constraint target altitude
            const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
            const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
            // Set the new target constraint values
            const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            newTargetConstraint.isTarget = true;
            newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
        }
        return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.constraints.length > 0) {
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                const constraint = verticalPlan.constraints[i];
                if (constraint.type !== 'climb') {
                    return constraint.targetAltitude;
                }
            }
        }
        return undefined;
    }
    // Start of buildVerticalFlightPlan helper methods
    /**
     * Gets the constraint altitudes for a lateral flight plan leg.
     * @param leg A lateral flight plan leg.
     * @param out The tuple to which to write the altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @returns The constraint altitudes, in meters, for the specified flight plan leg, as
     * `[minimum_altitude, maximum_altitude]`, or `undefined` if the leg does not define any altitude constraints.
     */
    static getConstraintAltitudes(leg, out) {
        if (leg.verticalData !== undefined) {
            switch (leg.verticalData.altDesc) {
                case AltitudeRestrictionType.At:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.AtOrAbove:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = Number.POSITIVE_INFINITY;
                    return out;
                case AltitudeRestrictionType.AtOrBelow:
                    out[0] = Number.NEGATIVE_INFINITY;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.Between:
                    out[0] = leg.verticalData.altitude2;
                    out[1] = leg.verticalData.altitude1;
                    return out;
            }
        }
        return undefined;
    }
    /**
     * Forces a constraint to an AT constraint.
     * @param constraint The constraint to force to an AT constraint.
     */
    static forceAtConstraint(constraint) {
        if (constraint.minAltitude !== constraint.maxAltitude) {
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                constraint.maxAltitude = constraint.minAltitude;
            }
            else {
                constraint.minAltitude = constraint.maxAltitude;
            }
        }
    }
    /**
     * Gets the global index of a flight plan's lateral direct-to target leg.
     * @param lateralPlan A flight plan.
     * @returns The global index of the flight plan's lateral direct-to target leg, or `undefined` if the plan does not
     * have an existing lateral direct-to.
     */
    static getDirectToTargetLegIndex(lateralPlan) {
        const directToData = lateralPlan.directToData;
        if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
            const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
            if (segment !== null) {
                return segment.offset + directToData.segmentLegIndex;
            }
        }
        return undefined;
    }
    /**
     * Checks if there is a lateral direct-to leg in the flight plan and if so, flags the corresponding vertical flight
     * plan leg as such and marks the first descent constraint
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param directToLegOffset The offset of the lateral direct-to leg from the direct-to target leg.
     */
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
        // Check for a direct to in the lateral plan
        if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
            const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
            if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
                const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
                directVerticalLeg.isDirectToTarget = true;
                const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
                if (segment !== undefined) {
                    const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
                    for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type !== 'climb' && constraint.type !== 'missed' && constraint.index >= globalLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                            return;
                        }
                    }
                    verticalPlan.firstDescentConstraintLegIndex = undefined;
                }
            }
        }
    }
    /**
     * Checks whether a leg constraint is part of the missed approach.
     * @param lateralSegment The lateral flight plan segment to which the constraint's leg belongs.
     * @param lateralLeg The lateral flight plan leg to which the constraint belongs.
     * @returns Whether the leg constraint is part of the missed approach.
     */
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
        if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
        const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
        const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
        if (currentMinWithPrecision > priorMaxWithPrecision) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
        if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
            const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
            const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
            if (minFpaTempValue > maxFpa) {
                return true;
            }
        }
        return false;
    }
    /**
     * The default function which checks whether a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVnavEligible(lateralLeg) {
        switch (lateralLeg.leg.type) {
            case LegType.VM:
            case LegType.FM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * The default function which checks whether a climb constraint should be invalidated. This function always returns
     * `false`.
     * @returns Whether the specified climb constraint should be invalidated (always `false`).
     */
    static invalidateClimbConstraint() {
        return false;
    }
    /**
     * The default function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
        return (isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10)) || requiredFpa > maxFpa;
    }
    // Start of computeFlightPathAngles helper methods
    /**
     * Finds the maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to a
     * given constraint, among all constraints prior to and including (in flight plan order) the given constraint. If a
     * vertical direct constraint is among the candidates, its minimum altitude is used if it does not define a maximum
     * altitude.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the constraint for which to find the closest prior maximum altitude.
     * @param firstDescentConstraintIndex The index of the first descent constraint.
     * @returns The maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to the
     * specified constraint, among all constraints prior to and including (in flight plan order) the specified
     * constraint, or `Infinity` if there is no such altitude.
     */
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
        for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.maxAltitude < Infinity) {
                return constraint.maxAltitude;
            }
            if (i === firstDescentConstraintIndex && constraint.type === 'direct') {
                if (constraint.minAltitude > -Infinity) {
                    return constraint.minAltitude;
                }
            }
        }
        return Infinity;
    }
    /**
     * Applies flight path angle and target altitude values to a sequence of constraints connected to a target constraint
     * by a constant-FPA path extending backwards from the target constraint. The target constraint defines the FPA of
     * the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param endConstraintIndex The index of the constraint at which the constant-FPA path ends, exclusive.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param out The tuple to which to write the result of the operation.
     * @returns `[index, distance]`, where `index` is the index of the constraint at which the path was terminated due to
     * violation of the maximum target altitude, or `undefined` if no constraint violated the maximum altitude, and
     * `distance` is the total distance of the path, in meters.
     */
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        let distance = currentTargetConstraint.distance;
        for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
            const smoothedConstraint = verticalPlan.constraints[i];
            const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
            // The path can continue past the current constraint if the target altitude at the current constraint is less
            // than the maximum altitude.
            if (targetAltitude < maxAltitude) {
                smoothedConstraint.fpa = currentTargetConstraint.fpa;
                smoothedConstraint.targetAltitude = targetAltitude;
                distance += smoothedConstraint.distance;
            }
            else {
                out[0] = i;
                out[1] = distance;
                return out;
            }
        }
        out[0] = undefined;
        out[1] = distance;
        return out;
    }
}
SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;

/**
 * Sim var names for LNAV-related data.
 */
var LNavDataVars;
(function (LNavDataVars) {
    /** The current nominal desired track, in degrees true. */
    LNavDataVars["DTKTrue"] = "L:WT_LNavData_DTK_True";
    /** The current nominal desired track, in degrees magnetic. */
    LNavDataVars["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    /**
     * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavDataVars["XTK"] = "L:WT_LNavData_XTK";
    /** The current CDI scale. */
    LNavDataVars["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    LNavDataVars["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */
    LNavDataVars["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV. */
    LNavDataVars["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    /** The nominal distance remaining to the destination. */
    LNavDataVars["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
})(LNavDataVars || (LNavDataVars = {}));

/**
 * {@link Validator} for parsing raw string values
 */
/**
 * {@link Formatter} for displaying raw string values
 */
const RawFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        if (typeof value === 'number') {
            return value.toString();
        }
        return value !== null && value !== void 0 ? value : '';
    },
};

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     * @param keepLocal If present and true, values will be kept local to the instrument on which they're set.
     */
    constructor(bus, settingDefs, keepLocal = false) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.subscriber = this.bus.getSubscriber();
        this.syncPublisher = this.bus.getPublisher();
        this.syncSubscriber = this.bus.getSubscriber();
        this.keepLocal = keepLocal;
        this.settings = new Map(settingDefs.map(def => {
            const initTopic = `usersetting_init_${def.name}`;
            const syncTopic = `usersetting_sync_${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0,
                initUid: Math.round(Math.random() * Number.MAX_SAFE_INTEGER)
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            entry.initSub = this.syncSubscriber.on(initTopic).handle(data => {
                // Do not respond to our own initialization sync.
                if (data.uid === entry.initUid) {
                    return;
                }
                // If we receive an initialization sync event for a setting, that means a manager on another instrument tried
                // to initialize the same setting to its default value. However, since the setting already exists here, we will
                // send a response to override the initialized value with the existing value.
                this.syncPublisher.pub(entry.syncTopic, { value: entry.setting.value, syncTime: entry.syncTime, initUid: data.uid }, !this.keepLocal, true);
            }, true);
            // Because sync events are cached, the initial subscriptions to the sync topic below will grab the synced value
            // of the new setting if it exists on the local instrument (e.g. if the value was synced from another instrument
            // after the local instrument was created but before this manager and local setting were created).
            this.syncSubscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            if (entry.syncTime === 0) {
                // If the new setting has no synced value on the local instrument, we will try to grab an initialization value
                // instead. If one exists, we will use it, but keep the local sync time at 0. If there is a pending response
                // to this initialization value, we want to be ready to accept the response when it arrives, which we can't do
                // if the local sync time is non-zero).
                const sub = this.syncSubscriber.on(initTopic).handle(data => {
                    this.onSettingValueSynced(entry, { value: data.value, syncTime: 0 });
                });
                sub.destroy();
            }
            if (entry.syncTime === 0) {
                // An existing synced value does not exist for the new setting on the local instrument, so we will go ahead
                // and initialize the new setting value to its default and send an initialization sync event. If the setting
                // exists on other instruments, their managers will send an initialization response to override our initialized
                // value.
                this.syncPublisher.pub(initTopic, { value: entry.setting.value, syncTime: Date.now(), uid: entry.initUid }, !this.keepLocal, true);
                this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
            }
            entry.initSub.resume();
            return [def.name, entry];
        }));
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        return (_a = this.settings.get(name)) === null || _a === void 0 ? void 0 : _a.setting;
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.syncPublisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, !this.keepLocal, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // If the sync event is an initialization response, ignore it if the local setting value has already been synced.
        // Otherwise, protect against race conditions by not responding to sync events older than the last time this
        // manager synced the setting.
        if ((data.initUid !== undefined && entry.syncTime !== 0)
            || (data.initUid === undefined && data.syncTime < entry.syncTime)) {
            return;
        }
        this.syncSettingFromEvent(entry, data);
    }
    /**
     * Syncs a setting using data received from a sync event.
     * @param entry The entry for the setting to sync.
     * @param data The sync event data.
     */
    syncSettingFromEvent(entry, data) {
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // Publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
    }
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.tryGetSetting(mappedName);
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
    /** @inheritdoc */
    getAllSettings() {
        return this.parent.getAllSettings();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting extends AbstractSubscribable {
        // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this._value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.valueChangedCallback(v);
        this.notify();
    }
/**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        super();
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isMutableSubscribable = true;
        this._value = definition.defaultValue;
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        if (this._value === value) {
            return;
        }
        this._value = value;
        this.notify();
    }
    /** @inheritdoc */
    get() {
        return this._value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * The state of an avionics system.
 */
var AvionicsSystemState;
(function (AvionicsSystemState) {
    AvionicsSystemState["Off"] = "Off";
    AvionicsSystemState["Initializing"] = "Initializing";
    AvionicsSystemState["On"] = "On";
    AvionicsSystemState["Failed"] = "Failed";
})(AvionicsSystemState || (AvionicsSystemState = {}));

/**
 * A basic avionics system with a fixed initialization time and logic.
 */
class BasicAvionicsSystem {
/** @inheritdoc */
    get state() {
        return this._state;
    }
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index, bus, stateEvent) {
        this.index = index;
        this.bus = bus;
        this.stateEvent = stateEvent;
        /** The time it takes in milliseconds for the system to initialize. */
        this.initializationTime = 0;
        /** A timeout after which initialization will be complete. */
        this.initializationTimer = new DebounceTimer();
        this.publisher = this.bus.getPublisher();
        /** Whether power data consumed by this system is valid. */
        this.isPowerValid = false;
        this.bus.pub(this.stateEvent, { previous: undefined, current: undefined });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.isPowerValid = true;
                this.onPowerValid();
            }
        }, false, true);
        gameStateSub.resume(true);
    }
        /**
     * Responds to when power data becomes valid.
     */
    onPowerValid() {
        var _a;
        (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic, electricity logic element, or
     * {@link Subscribable}.
     * @param source The source to which to connect this system's power state.
     */
    connectToPower(source) {
        var _a;
        (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.electricalPowerSub = undefined;
        this.electricalPowerLogic = undefined;
        if (typeof source === 'string') {
            this.electricalPowerSub = this.bus.getSubscriber()
                .on(source)
                .whenChanged()
                .handle(this.onPowerChanged.bind(this), !this.isPowerValid);
        }
        else if (SubscribableUtils.isSubscribable(source)) {
            this.electricalPowerSub = source.sub(this.onPowerChanged.bind(this), true, !this.isPowerValid);
        }
        else {
            this.electricalPowerLogic = source;
            this.updatePowerFromLogic();
        }
    }
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    setState(state) {
        if (this._state !== state) {
            const previous = this._state;
            this._state = state;
            this.onStateChanged(previous, state);
            this.bus.pub(this.stateEvent, { previous, current: state });
        }
    }
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        // noop
    }
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Off);
            }
        }
        else {
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(() => this.setState(AvionicsSystemState.On), this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        this.updatePowerFromLogic();
    }
    /**
     * Updates this system's power state from an electricity logic element.
     */
    updatePowerFromLogic() {
        if (!this.isPowerValid || this.electricalPowerLogic === undefined) {
            return;
        }
        const isPowered = this.electricalPowerLogic.getValue() !== 0;
        if (isPowered !== this.isPowered) {
            this.onPowerChanged(isPowered);
        }
    }
}

/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
class FsBaseInstrument extends BaseInstrument {
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.fsInstrument = this.constructInstrument();
    }
    /**
     * Update method called by BaseInstrument
     */
    Update() {
        super.Update();
        if (this.fsInstrument) {
            this.fsInstrument.Update();
        }
    }
    /** @inheritdoc */
    onInteractionEvent(_args) {
        if (this.fsInstrument) {
            this.fsInstrument.onInteractionEvent(_args);
        }
    }
    /** @inheritdoc */
    onGameStateChanged(oldState, newState) {
        super.onGameStateChanged(oldState, newState);
        if (this.fsInstrument) {
            this.fsInstrument.onGameStateChanged(oldState, newState);
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
        if (this.fsInstrument) {
            this.fsInstrument.onFlightStart();
        }
    }
    /** @inheritdoc */
    onSoundEnd(soundEventId) {
        super.onSoundEnd(soundEventId);
        if (this.fsInstrument) {
            this.fsInstrument.onSoundEnd(soundEventId);
        }
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return false;
    }
}

/** Type for whether ND is in HDG up or TRK up mode. */
var BoeingNdHdgTrkUpMode;
(function (BoeingNdHdgTrkUpMode) {
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["HDG"] = 0] = "HDG";
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["TRK"] = 1] = "TRK";
})(BoeingNdHdgTrkUpMode || (BoeingNdHdgTrkUpMode = {}));
/** Type for whether ND is in HDG up or TRK up mode. */
var BoeingFuelIndicatorStyle;
(function (BoeingFuelIndicatorStyle) {
    BoeingFuelIndicatorStyle[BoeingFuelIndicatorStyle["DIGITAL"] = 0] = "DIGITAL";
    BoeingFuelIndicatorStyle[BoeingFuelIndicatorStyle["ANALOG"] = 1] = "ANALOG";
})(BoeingFuelIndicatorStyle || (BoeingFuelIndicatorStyle = {}));
/**
 * IRS alignment time modes.
 */
var BoeingIrsAlignTimeMode;
(function (BoeingIrsAlignTimeMode) {
    /** IRS aligns instantly. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Instant"] = 0] = "Instant";
    /** IRS attitude alignment finishes in 30 seconds and full alignment finishes in 60 seconds. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Accelerated"] = 1] = "Accelerated";
    /**
     * IRS attitude alignment finishes in 30 seconds and full alignment finishes in an amount of time approximating the
     * real unit (5 minutes at the equator to 17 minutes near the poles).
     */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Realistic"] = 2] = "Realistic";
})(BoeingIrsAlignTimeMode || (BoeingIrsAlignTimeMode = {}));
/**
 * Auto fuel management modes
 */
var BoeingAutoFuelMode;
(function (BoeingAutoFuelMode) {
    /** Auto fuel management on */
    BoeingAutoFuelMode[BoeingAutoFuelMode["ON"] = 0] = "ON";
    /** Auto fuel management off */
    BoeingAutoFuelMode[BoeingAutoFuelMode["OFF"] = 1] = "OFF";
})(BoeingAutoFuelMode || (BoeingAutoFuelMode = {}));
const boeingMsfsUserSettings = [
    {
        name: 'boeingMsfsNdHdgTrkUpMode',
        defaultValue: BoeingNdHdgTrkUpMode.TRK,
    },
    {
        name: 'boeingMsfsFuelIndicatorStyle',
        defaultValue: BoeingFuelIndicatorStyle.ANALOG,
    },
    {
        name: 'boeingMsfsIrsAlignTime',
        defaultValue: BoeingIrsAlignTimeMode.Accelerated,
    },
    {
        name: 'boeingMsfsSelcal',
        defaultValue: 'HS-DA',
    },
    {
        name: 'boeingMsfsAutoFuelManagement',
        defaultValue: BoeingAutoFuelMode.OFF,
    },
    {
        name: 'boeingMsfsSimbriefUserID',
        defaultValue: -1,
    },
    {
        name: 'boeingMsfsSimbriefUsername',
        defaultValue: '',
    },
];
/**
 * Utility class for retrieving boeing msfs user setting managers.
 * These are user settings for Boeing aircraft and are meant to be persistent.
 */
class BoeingMsfsUserSettings {
    /**
     * Retrieves a manager for boeing msfs user settings.
     * @param bus The event bus.
     * @returns a manager for boeing msfs user settings.
     */
    static getManager(bus) {
        if (BoeingMsfsUserSettings.INSTANCE === undefined) {
            BoeingMsfsUserSettings.INSTANCE = new DefaultUserSettingManager(bus, boeingMsfsUserSettings);
        }
        return BoeingMsfsUserSettings.INSTANCE;
    }
}

/**
 * TCAS operating mode setting values.
 */
var TcasOperatingModeSetting;
(function (TcasOperatingModeSetting) {
    TcasOperatingModeSetting["TA_RA"] = "TA_RA";
    TcasOperatingModeSetting["TAOnly"] = "TAOnly";
    TcasOperatingModeSetting["Standby"] = "Standby";
})(TcasOperatingModeSetting || (TcasOperatingModeSetting = {}));
const trafficSettings = [
    {
        name: 'trafficOperatingMode',
        defaultValue: TcasOperatingModeSetting.TAOnly
    },
    {
        name: 'trafficShowOther',
        defaultValue: true
    },
    {
        name: 'trafficAltitudeRelative',
        defaultValue: true
    },
    {
        name: 'trafficShowAbove',
        defaultValue: false
    },
    {
        name: 'trafficShowBelow',
        defaultValue: false
    }
];
/**
 * Utility class for retrieving the traffic user setting manager.
 */
class TrafficUserSettings {
    /**
     * Retrieves a setting manager with traffic user settings.
     * @param bus The event bus.
     * @returns A setting manager with traffic user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, trafficSettings));
    }
}

var VSpeedType;
(function (VSpeedType) {
    VSpeedType["V1"] = "V1";
    VSpeedType["Vr"] = "Vr";
    VSpeedType["V2"] = "V2";
    // Venr = 'Venr',
    // Vapp = 'Vapp',
    VSpeedType["Vref"] = "Vref";
})(VSpeedType || (VSpeedType = {}));

/** Takeoff thrust modes. */
var OptimumRequest;
(function (OptimumRequest) {
    OptimumRequest["OPTIMUM"] = "OPTIMUM";
    OptimumRequest["EXIT"] = "EXIT";
})(OptimumRequest || (OptimumRequest = {}));

/** Takeoff thrust modes. To be used in the FMC */
var TakeoffThrustMode;
(function (TakeoffThrustMode) {
    TakeoffThrustMode["TO"] = "TO";
    TakeoffThrustMode["TO1"] = "TO 1";
    TakeoffThrustMode["TO2"] = "TO 2";
    TakeoffThrustMode["DTO"] = "D-TO";
    TakeoffThrustMode["DTO1"] = "D-TO 1";
    TakeoffThrustMode["DTO2"] = "D-TO 2";
})(TakeoffThrustMode || (TakeoffThrustMode = {}));
/** Possible takeoff thrust ratings for selection in the EFB. */
var EFBTakeoffThrustMode;
(function (EFBTakeoffThrustMode) {
    EFBTakeoffThrustMode["OPTIMUM"] = "OPTIMUM";
    EFBTakeoffThrustMode["TO"] = "TO";
    EFBTakeoffThrustMode["TO1"] = "TO 1 -10";
    EFBTakeoffThrustMode["TO2"] = "TO 2 -20";
    EFBTakeoffThrustMode["WINDSHEAR"] = "WINDSHEAR";
    EFBTakeoffThrustMode["EXIT"] = "EXIT";
})(EFBTakeoffThrustMode || (EFBTakeoffThrustMode = {}));
var EFBTIMEZONES;
(function (EFBTIMEZONES) {
    EFBTIMEZONES["UTC"] = "(UTC) Coordinated Universal Time)";
    EFBTIMEZONES["GMT"] = "(GMT)";
    EFBTIMEZONES["GMT1"] = "(GMT+ 01:00)";
    EFBTIMEZONES["GMT2"] = "(GMT+ 02:00)";
    EFBTIMEZONES["GMT3"] = "(GMT+ 03:00)";
    EFBTIMEZONES["GMT4"] = "(GMT+ 04:00)";
    EFBTIMEZONES["GMT5"] = "(GMT+ 05:00)";
    EFBTIMEZONES["GMT6"] = "(GMT+ 06:00)";
    EFBTIMEZONES["GMT7"] = "(GMT+ 07:00)";
    EFBTIMEZONES["GMT8"] = "(GMT+ 08:00)";
    EFBTIMEZONES["GMT9"] = "(GMT+ 09:00)";
    EFBTIMEZONES["GMT10"] = "(GMT+ 10:00)";
    EFBTIMEZONES["GMT11"] = "(GMT+ 11:00)";
    EFBTIMEZONES["GMT12"] = "(GMT+ 12:00)";
    
})(EFBTIMEZONES || (EFBTIMEZONES = {}));
/** Modes of the take performance calculation result. */
var EFBTakeoffCalculationMode;
(function (EFBTakeoffCalculationMode) {
    EFBTakeoffCalculationMode["ATM"] = "ATM";
    EFBTakeoffCalculationMode["FULL"] = "FULL";
    EFBTakeoffCalculationMode["RTOW"] = "RTOW";
})(EFBTakeoffCalculationMode || (EFBTakeoffCalculationMode = {}));
/** Climb thrust modes. */
var ClimbThrustMode;
(function (ClimbThrustMode) {
    ClimbThrustMode["CLB"] = "CLB";
    ClimbThrustMode["CLB1"] = "CLB 1";
    ClimbThrustMode["CLB2"] = "CLB 2";
})(ClimbThrustMode || (ClimbThrustMode = {}));
/** Airborne thrust modes. */
var AirborneThrustMode;
(function (AirborneThrustMode) {
    /** Go-around thrust limit. */
    AirborneThrustMode["GA"] = "GA";
    /** Maximum continuous thrust limit. */
    AirborneThrustMode["CON"] = "CON";
    /** Cruise thrust limit. */
    AirborneThrustMode["CRZ"] = "CRZ";
})(AirborneThrustMode || (AirborneThrustMode = {}));
var GlideslopeStatus;
(function (GlideslopeStatus) {
    GlideslopeStatus[GlideslopeStatus["ON"] = 0] = "ON";
    GlideslopeStatus[GlideslopeStatus["OFF"] = 1] = "OFF";
})(GlideslopeStatus || (GlideslopeStatus = {}));
/** Speed modes. */
var SpeedMode;
(function (SpeedMode) {
    /** Economy speed. */
    SpeedMode["ECON"] = "ECON SPD";
    /** Select speed. Manually entered speed on the CDU or the VNAV speed target is the maneuvering speed for flaps zero. */
    SpeedMode["SEL"] = "SEL SPD";
    /** Long-range cruise speed. */
    SpeedMode["LRC"] = "LRC SPD";
    /** Engine-out long-range cruise speed. */
    SpeedMode["EOLRC"] = "EO LRC";
    /** Engine-out speed. */
    SpeedMode["EO"] = "EO SPD";
    /** Engine-out operations at airline specified engine out company speed. */
    SpeedMode["CO"] = "CO SPD";
    /** Speed is limited by VMO, MMO, flap limit, or buffet limit. */
    SpeedMode["LIM"] = "LIM SPD";
    /** Speed intervention entered on the MCP IAS/MACH indicator. */
    SpeedMode["MCP"] = "MCP SPD";
    /** Required time of arrival speed. */
    SpeedMode["RTA"] = "RTA";
})(SpeedMode || (SpeedMode = {}));
/** Runway conditions, the short list is for the FMC */
var RunwayCondition;
(function (RunwayCondition) {
    /** Dry */
    RunwayCondition["DRY"] = "DRY";
    /** Wet */
    RunwayCondition["WET"] = "WET";
    /** Wet, skid resistant */
    RunwayCondition["WET_SKID_RES"] = "WET SK-R";
})(RunwayCondition || (RunwayCondition = {}));
/** Runway conditions, longer list for the EFB takeoff performance calculation */
var EfbRunwayCondition;
(function (EfbRunwayCondition) {
    /** Dry */
    EfbRunwayCondition["DRY"] = "DRY";
    /** Wet */
    EfbRunwayCondition["WET"] = "WET";
    /** Standing water */
    EfbRunwayCondition["STNDNG_WTR"] = "STNDNG WTR";
    /** Slush */
    EfbRunwayCondition["SLUSH"] = "SLUSH WTR";
    /** Compact snow */
    EfbRunwayCondition["CMPCT_SNOW"] = "CMPCT SNOW";
    /** Dry snow */
    EfbRunwayCondition["DRY_SNOW"] = "DRY SNOW";
    /** Ice */
    EfbRunwayCondition["ICE"] = "ICE";
    /** Breaking action good */
    EfbRunwayCondition["GOOD"] = "GOOD";
    /** Breaking action Medium */
    EfbRunwayCondition["MEDIUM"] = "MEDIUM";
    /** Breaking action Poor */
    EfbRunwayCondition["POOR"] = "POOR";
    EfbRunwayCondition["EXIT"] = "EXIT";
})(EfbRunwayCondition || (EfbRunwayCondition = {}));
var EfbRunwayList;
(function (EfbRunwayList) {
    
    EfbRunwayList["EXIT"] = "EXIT";
   
})(EfbRunwayList || (EfbRunwayList = {}));
var EFBAntiIceSetting;
(function (EFBAntiIceSetting) {
    /** OFF */
    EFBAntiIceSetting["OFF"] = "OFF";
    /** ENGINE */
    EFBAntiIceSetting["ENGINE"] = "ENGINE";
    /** ENG AUTO */
    EFBAntiIceSetting["ENGINE_AUTO"] = "ENG AUTO";
    EFBAntiIceSetting["EXIT"] = "EXIT";
})(EFBAntiIceSetting || (EFBAntiIceSetting = {}));

// TODO consider getting limits from game vars
// add game var to get slat angles for each handle position => no config needed?
/**
 * Flap Position Computer
 * @deprecated Needs refactored into BoeingFlapSystem
 */
class FlapComputer {
    /**
     * Constructor a new FlapComputer
     * @param bus Event bus
     * @param config Flap Computer configuration
     */
    constructor(bus, config) {
        this.bus = bus;
        this.flapsHandleIndex = ConsumerSubject.create(null, 0);
        this.flapsLeftAngle = ConsumerSubject.create(null, 0);
        this.flapsRightAngle = ConsumerSubject.create(null, 0);
        this.slatsLeftAngle = ConsumerSubject.create(null, 0);
        this.slatsRightAngle = ConsumerSubject.create(null, 0);
        /** total gross weight in lbs */
        this.grossWeight = ConsumerSubject.create(null, 0);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.flapInterpolatedPosition = Subject.create(0);
        this.flapInterpolatedLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapLimitIndex = Subject.create(0);
        this.flapLimitPosition = Subject.create(0);
        this.flapLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapManeuverSpeed = Subject.create(0);
        this.holdingSpeed = Subject.create(0);
        this.needUpdate = true;
        this.flapPositionConfig = [...config.flap_positions].sort((a, b) => a.flapAngle === b.flapAngle ? a.slatAngle - b.slatAngle : a.flapAngle - b.flapAngle);
        this.flapSpeedLimitLookup = new LerpLookupTable(this.flapPositionConfig.filter((c) => isFinite(c.speedLimit)).map((c) => [c.speedLimit, c.label]));
        this.speedData = config.speed_data;
        this.flapsHandlePosition = this.flapsHandleIndex.map(index => this.flapPositionConfig[index]);
        const leadingEdgeInTransit = MappedSubject.create(([slatsLeftAngle, flapsHandlePosition]) => {
            return Math.abs(flapsHandlePosition.slatAngle - slatsLeftAngle) > 0.01;
        }, this.slatsLeftAngle, this.flapsHandlePosition);
        const pub = this.bus.getPublisher();
        this.flapInterpolatedPosition.sub((pos) => pub.pub('flap_computer_interpolated_position', pos));
        this.flapInterpolatedLimitSpeed.sub((pos) => pub.pub('flap_computer_interpolated_limit_speed', pos));
        this.flapLimitIndex.sub((index) => pub.pub('flap_computer_limit_index', index));
        this.flapLimitPosition.sub((pos) => pub.pub('flap_computer_limit_position', pos));
        this.flapLimitSpeed.sub((speed) => pub.pub('flap_computer_limit_speed', speed));
        this.flapManeuverSpeed.sub((speed) => pub.pub('flap_computer_maneuver_speed', speed));
        this.holdingSpeed.sub((speed) => pub.pub('flap_computer_holding_speed', speed));
        leadingEdgeInTransit.sub((x) => pub.pub('flap_computer_leading_edge_in_transit', x));
        this.listenToEvents();
    }
    /** Update the flap setting from the flap and slat angles */
    updateFlapPosition() {
        if (!this.needUpdate) {
            return;
        }
        this.needUpdate = false;
        // we consider the highest out of the two sides
        const actualFlapAngle = Math.max(this.flapsLeftAngle.get(), this.flapsRightAngle.get());
        const actualSlatAngle = Math.max(this.slatsLeftAngle.get(), this.slatsRightAngle.get());
        // find the flap position used for speed limit calculation (increments just after passing each position)
        let flapLimitIndex = this.flapPositionConfig.findIndex((p) => actualFlapAngle <= p.flapAngle + FlapComputer.ANGLE_TOLERANCE);
        const firstFlapPos = this.flapPositionConfig[flapLimitIndex];
        for (; flapLimitIndex < this.flapPositionConfig.length - 1; flapLimitIndex++) {
            const nextLimitPos = this.flapPositionConfig[flapLimitIndex + 1];
            if (nextLimitPos.flapAngle !== firstFlapPos.flapAngle) {
                break;
            }
            const limitPos = this.flapPositionConfig[flapLimitIndex];
            if (actualSlatAngle <= limitPos.slatAngle + FlapComputer.ANGLE_TOLERANCE) {
                break;
            }
        }
        const flapLimitPosition = this.flapPositionConfig[flapLimitIndex];
        this.flapLimitIndex.set(flapLimitIndex);
        this.flapLimitPosition.set(flapLimitPosition.label);
        this.flapLimitSpeed.set(isFinite(flapLimitPosition.speedLimit) ? flapLimitPosition.speedLimit : -1);
        this.flapManeuverSpeed.set(this.speedData.getFlapManeuverSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        this.holdingSpeed.set(this.speedData.getHoldingSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        // interpolate a position for display on the EICAS
        let interpolatedLabel = 0;
        // if we're clean, no need for interpolation
        if (flapLimitIndex > 0) {
            // choose the next index (lower flap position/angle)
            const nextLowerFlapPosition = this.flapPositionConfig[flapLimitIndex - 1];
            let k;
            if ((flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle) < FlapComputer.ANGLE_TOLERANCE) {
                // flap position doesn't change... interpolate slat angle
                k = (flapLimitPosition.slatAngle - actualSlatAngle) / (flapLimitPosition.slatAngle - nextLowerFlapPosition.slatAngle);
            }
            else {
                k = (flapLimitPosition.flapAngle - actualFlapAngle) / (flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle);
            }
            interpolatedLabel = MathUtils.clamp(Avionics.Utils.lerpAngle(flapLimitPosition.label, nextLowerFlapPosition.label, k), nextLowerFlapPosition.label, flapLimitPosition.label);
        }
        this.flapInterpolatedPosition.set(interpolatedLabel);
        if (interpolatedLabel > 0) {
            this.flapInterpolatedLimitSpeed.set(this.flapSpeedLimitLookup.get(interpolatedLabel));
        }
        else {
            this.flapInterpolatedLimitSpeed.set(-1);
        }
    }
    /** Setup event listeners */
    listenToEvents() {
        const sub = this.bus.getSubscriber();
        this.flapsHandleIndex.setConsumer(sub.on('flaps_handle_index'));
        this.flapsLeftAngle.setConsumer(sub.on('flaps_left_angle').withPrecision(2));
        this.flapsRightAngle.setConsumer(sub.on('flaps_right_angle').withPrecision(2));
        this.slatsLeftAngle.setConsumer(sub.on('slats_left_angle').withPrecision(2));
        this.slatsRightAngle.setConsumer(sub.on('slats_right_angle').withPrecision(2));
        this.grossWeight.setConsumer(sub.on('total_weight').withPrecision(-3));
        this.pressureAlt.setConsumer(sub.on('pressure_alt').withPrecision(-3));
        sub.on('realTime').atFrequency(5).handle(this.updateFlapPosition.bind(this));
        MappedSubject.create(() => this.needUpdate = true, this.flapsLeftAngle, this.flapsRightAngle, this.slatsLeftAngle, this.slatsRightAngle, this.grossWeight, this.pressureAlt);
    }
}
FlapComputer.ANGLE_TOLERANCE = 0.25;

/**
 * Standard Boeing 787-10 names for backplane instruments and publishers.
 */
var InstrumentBackplaneNames;
(function (InstrumentBackplaneNames) {
    InstrumentBackplaneNames["Adc"] = "Adc";
    InstrumentBackplaneNames["Ahrs"] = "Ahrs";
    InstrumentBackplaneNames["Ai"] = "AI";
    InstrumentBackplaneNames["Alert"] = "Alert";
    InstrumentBackplaneNames["Ambient"] = "Ambient";
    InstrumentBackplaneNames["AntiIce"] = "AntiIce";
    InstrumentBackplaneNames["Autopilot"] = "Autopilot";
    InstrumentBackplaneNames["AutopilotRadioNav"] = "AutopilotRadioNav";
    InstrumentBackplaneNames["B78Apu"] = "B78Apu";
    InstrumentBackplaneNames["B78Door"] = "B78Door";
    InstrumentBackplaneNames["B78Gear"] = "B78Gear";
    InstrumentBackplaneNames["B78Hydraulics"] = "B78Hydraulics";
    InstrumentBackplaneNames["Base"] = "Base";
    InstrumentBackplaneNames["BoeingAutopilot"] = "BoeingAutopilot";
    InstrumentBackplaneNames["Brakes"] = "Brakes";
    InstrumentBackplaneNames["Clock"] = "Clock";
    InstrumentBackplaneNames["ControlSurfaces"] = "ControlSurfaces";
    InstrumentBackplaneNames["CockpitVars"] = "CockpitVars";
    InstrumentBackplaneNames["Eis"] = "Eis";
    InstrumentBackplaneNames["Electrical"] = "Electrical";
    InstrumentBackplaneNames["Engine"] = "Engine";
    InstrumentBackplaneNames["Fadec"] = "Fadec";
    InstrumentBackplaneNames["FuelSystem"] = "FuelSystem";
    InstrumentBackplaneNames["FuelTotalizer"] = "FuelTotalizer";
    InstrumentBackplaneNames["FmsOperatingPhase"] = "FmsOperatingPhase";
    InstrumentBackplaneNames["Gnss"] = "Gnss";
    InstrumentBackplaneNames["HEvents"] = "HEvents";
    InstrumentBackplaneNames["Hydraulics"] = "Hydraulics";
    InstrumentBackplaneNames["LNav"] = "LNav";
    InstrumentBackplaneNames["LNavData"] = "LNavData";
    InstrumentBackplaneNames["Minimums"] = "Minimums";
    InstrumentBackplaneNames["NavCom"] = "NavCom";
    InstrumentBackplaneNames["NavEvents"] = "NavEvents";
    InstrumentBackplaneNames["NavProc"] = "NavProc";
    InstrumentBackplaneNames["Pressurization"] = "Pressurization";
    InstrumentBackplaneNames["SpeedLimit"] = "SpeedLimit";
    InstrumentBackplaneNames["Sound"] = "Sound";
    InstrumentBackplaneNames["Timer"] = "Timer";
    InstrumentBackplaneNames["Traffic"] = "Traffic";
    InstrumentBackplaneNames["VNav"] = "VNav";
    InstrumentBackplaneNames["BoeingVNav"] = "BoeingVNav";
    InstrumentBackplaneNames["WeightFuel"] = "WeightFuel";
    InstrumentBackplaneNames["Xpdr"] = "Xpdr";
    InstrumentBackplaneNames["WeightAndBalance"] = "WeightAndBalance";
    InstrumentBackplaneNames["Units"] = "Units";
})(InstrumentBackplaneNames || (InstrumentBackplaneNames = {}));

/**
 * A Garmin marker beacon receiver system.
 */
class MarkerBeaconSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a marker beacon system.
     * @param index The index of the marker beacon system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `marker_state_${index}`);
        const radioAltTopic = `marker_mkr_bcn_state_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's marker beacon state data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `marker_mkr_bcn_state_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.beaconStateSub = this.bus.getSubscriber().on('marker_beacon_state').handle(val => {
            this.publisher.pub(topic, val);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.beaconStateSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.beaconStateSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

const SHORT_LLA_FORMAT_REGEX = /^([NS])(\d{2})([WE])(\d{3})$/;
const LONG_LLA_FORMAT_REGEX = /^([NS])(\d{4}(?:\.\d)?)([WE])(\d{5}(?:\.\d)?)$/;
/**
 * Utilities for parsing coordinates in the WT21 supported formats
 */
class BoeingCoordinatesUtils {
    /**
     * Parses a string according to the LAT LONG format
     *
     * @param str             the string to parse
     * @param acceptShortForm whether to accept the short (XYYZUU/XYYUUZ) formats
     *
     * @returns a {@link LatLongInterface} object if a valid LL definition and `null` otherwise
     */
    static parseLatLong(str, acceptShortForm = true) {
        if (acceptShortForm) {
            const shortMatch = SHORT_LLA_FORMAT_REGEX.exec(str);
            if (shortMatch) {
                const latDir = shortMatch[1];
                const latNum = shortMatch[2];
                const lonDir = shortMatch[3];
                const lonNum = shortMatch[4];
                const parsedLat = this.parseLatitude(latDir, latNum);
                const parsedLon = this.parseLongitude(lonDir, lonNum);
                if (parsedLat === null || parsedLon === null) {
                    return null;
                }
                return new GeoPoint(parsedLat, parsedLon);
            }
        }
        const fullMatch = LONG_LLA_FORMAT_REGEX.exec(str);
        if (!fullMatch) {
            return null;
        }
        const latDir = fullMatch[1];
        const latNum = fullMatch[2];
        const lonDir = fullMatch[3];
        const lonNum = fullMatch[4];
        // if either has a decimal, both must
        if (latNum.includes('.') !== lonNum.includes('.')) {
            return null;
        }
        const parsedLat = this.parseLatitude(latDir, latNum);
        const parsedLon = this.parseLongitude(lonDir, lonNum);
        if (parsedLat === null || parsedLon === null) {
            return null;
        }
        return new GeoPoint(parsedLat, parsedLon);
    }
    /**
     * Parses a latitude string
     *
     * @param dirStr the N or S string part
     * @param numStr the numerical string part
     *
     * @returns the latitude in degrees
     */
    static parseLatitude(dirStr, numStr) {
        let lat;
        const splitLatNum = numStr.split('.');
        const latLeft = splitLatNum[0];
        const latRight = splitLatNum[1];
        // Parse latitude degrees + minutes
        if (latLeft.length > 2) {
            const deg = parseInt(latLeft.substring(0, 2));
            const min = parseInt(latLeft.substring(2));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lat = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lat = parseInt(latLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (latRight) {
            const secs = parseFloat(`0.${latRight}`);
            const add = secs / 60;
            lat += add;
        }
        // If direction is S, negate latitude
        if (dirStr === 'S') {
            lat *= -1;
        }
        if (Math.abs(lat) > 90) {
            return null;
        }
        return lat;
    }
    /**
     * Parses a longitude string
     *
     * @param dirStr the W or E string part
     * @param numStr the numerical string part
     *
     * @returns the longitude in degrees
     */
    static parseLongitude(dirStr, numStr) {
        let lon;
        const splitLonNum = numStr.split('.');
        const lonLeft = splitLonNum[0];
        const lonRight = splitLonNum[1];
        // Parse longitude degrees + minutes
        if (lonLeft.length > 3) {
            const deg = parseInt(lonLeft.substring(0, 3));
            const min = parseInt(lonLeft.substring(3));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lon = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lon = parseInt(lonLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (lonRight) {
            const secs = parseFloat(`0.${lonRight}`);
            const add = secs / 60;
            lon += add;
        }
        // If direction is W, negate longitude
        if (dirStr === 'W') {
            lon *= -1;
        }
        if (Math.abs(lon) > 180) {
            return null;
        }
        return lon;
    }
}

/** Example match would be: `DEN270/22.5` */
const PBD_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
/** Example match would be: `DEN090/DVV180` */
const PBPB_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\w+)(\d{3}(?:\.\d)?)(?:\/(\w+))?$/;
const ATO_REGEX = /^(\w+)\/([+-]?\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
// This should technically be only TF, but that doesn't make much sense and seems like a mistake
const ATO_VALID_PREVIOUS_LEG_TYPES = [LegType.CF, LegType.DF, LegType.IF, LegType.TF, LegType.RF];
const ATO_VALID_NEXT_LEG_TYPES = [LegType.IF, LegType.TF];
/**
 * Error that can occur when creating an ATO waypoint
 */
var AlongTrackOffsetError;
(function (AlongTrackOffsetError) {
    AlongTrackOffsetError[AlongTrackOffsetError["NotAvailable"] = 0] = "NotAvailable";
    AlongTrackOffsetError[AlongTrackOffsetError["DistanceTooLarge"] = 1] = "DistanceTooLarge";
})(AlongTrackOffsetError || (AlongTrackOffsetError = {}));
/**
 * Utilities for Boeing pilot defined waypoints
 */
class BoeingPilotWaypointUtils {
    /**
     * Returns whether the limit number of pilot defined waypoints is reached
     *
     * @param facilities the existing user facilities
     *
     * @returns a boolean
     */
    static isLimitReached(facilities) {
        return facilities.length >= 50; // TODO 50 for RTE 1, 50 for RTE 2
    }
    /**
     * Returns the next available auto-generated name, given existing user facilities and an ident
     *
     * @param facilities the existing user facilities
     * @param ident      the ident of the facility
     *
     * @returns a string to be used as an ident for a user facility
     */
    static nextAutoGeneratedName(facilities, ident) {
        let suffix = 1;
        for (const facility of facilities) {
            const facIdent = ICAO.getIdent(facility.icao);
            if (facIdent.match(`${ident.substring(0, 3)}\\d\\d`)) {
                suffix++;
            }
        }
        return `${ident.substring(0, 3)}${suffix.toString().padStart(2, '0')}`;
    }
    /**
     * Returns the name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(0).padStart(2, '0');
        const longitudeSign = coordinates.lon > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.lon).toFixed(0).padStart(3, '0');
        return `${latitudeSign}${latitudeStr}${longitudeSign}${longitudeStr}`;
    }
    /**
     * Returns the internal name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongInternalIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(3);
        const longitudeSign = coordinates.lon > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.lon).toFixed(3);
        return `${latitudeSign}${latitudeStr}|${longitudeSign}${longitudeStr}`;
    }
    /**
     * Converts a scratchpad entry to a {@link UserFacility} if applicable
     *
     * @param fms                  the {@link BoeingFms} instance
     * @param selectWptFromIdent   the function called to select a facility
     * @param scratchpadContents   the scratchpad contents
     * @param targetGlobalLegIndex the target global leg index, if applicable
     *
     * @returns a user facility, or null if none is parsed
     */
    static async createFromScratchpadEntry(fms, selectWptFromIdent, scratchpadContents, targetGlobalLegIndex) {
        var _a, _b, _c, _d;
        const pbdMatch = BoeingPilotWaypointUtils.parsePlaceBearingDistance(scratchpadContents);
        if (pbdMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facility = await selectWptFromIdent(pbdMatch.placeIdent, fms.ppos);
            if (facility) {
                const ident = (_a = pbdMatch.newIdent) !== null && _a !== void 0 ? _a : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facility.icao));
                const usrFacility = UserFacilityUtils.createFromRadialDistance(`U      ${ident}`, facility, pbdMatch.bearing, pbdMatch.distance);
                return [usrFacility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const pbpbMatch = BoeingPilotWaypointUtils.parsePlaceBearingPlaceBearing(scratchpadContents);
        if (pbpbMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facilityA = await selectWptFromIdent(pbpbMatch.placeAIdent, fms.ppos);
            const facilityB = await selectWptFromIdent(pbpbMatch.placeBIdent, fms.ppos);
            if (facilityA && facilityB) {
                const ident = (_b = pbpbMatch.newIdent) !== null && _b !== void 0 ? _b : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facilityA.icao));
                const facility = UserFacilityUtils.createFromRadialRadial(`U      ${ident}`, facilityA, pbpbMatch.bearingA, facilityB, pbpbMatch.bearingB);
                if (!facility) {
                    return Promise.reject('NO INTERSECTION');
                }
                return [facility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const atoMatch = BoeingPilotWaypointUtils.parseAlongTrackOffset(scratchpadContents);
        if (atoMatch) {
            if (targetGlobalLegIndex === undefined) {
                throw new Error('Along-track offset can only be created by createFromScratchpadEntry is a target global leg index is specified');
            }
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const plan = fms.getPlanForFmcRender();
            const lnavActiveLegIndex = SimVar.GetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number);
            const lnavActiveLegDistanceAlong = SimVar.GetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM);
            const result = await BoeingPilotWaypointUtils.createAlongTrackOffset(fms.facLoader, plan, targetGlobalLegIndex, lnavActiveLegIndex, lnavActiveLegDistanceAlong, atoMatch.distance);
            if (!Array.isArray(result)) {
                if (result === AlongTrackOffsetError.DistanceTooLarge) {
                    return Promise.reject('DISTANCE TOO LARGE');
                }
                else {
                    return Promise.reject('ALONG TRK WPT N/A');
                }
            }
            const [usrPos, insertAfter] = result;
            const leg = plan.getLeg(targetGlobalLegIndex);
            const ident = (_c = atoMatch.newIdent) !== null && _c !== void 0 ? _c : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, (_d = leg.name) !== null && _d !== void 0 ? _d : 'USR');
            return [UserFacilityUtils.createFromLatLon(`U      ${ident}`, usrPos.lat, usrPos.lon), insertAfter];
        }
        const coordinatesMatch = BoeingCoordinatesUtils.parseLatLong(scratchpadContents);
        if (coordinatesMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
            // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
            // needed - in BoeingFmsUtils.buildBoeingLegName, we extract the values to reconstruct the short name
            const ident = BoeingPilotWaypointUtils.latLongInternalIdent(coordinatesMatch);
            return [UserFacilityUtils.createFromLatLon(`ULL    ${ident}`, coordinatesMatch.lat, coordinatesMatch.lon), false];
        }
        return null;
    }
    /**
     * Parses a string according to the PB/D format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingDistanceInput} object if a valid PBD definition and `null` otherwise
     */
    static parsePlaceBearingDistance(str) {
        const match = str.match(PBD_REGEX);
        if (!match) {
            return null;
        }
        const bearing = parseFloat(match[2]);
        if (bearing < 0 || bearing > 360) {
            return null;
        }
        return {
            placeIdent: match[1],
            bearing,
            distance: parseFloat(match[3]),
            newIdent: match[4],
        };
    }
    /**
     * Parses a string according to the PB/PB format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingPlaceBearingInput} object if a valid PBPB definition and `null` otherwise
     */
    static parsePlaceBearingPlaceBearing(str) {
        const match = str.match(PBPB_REGEX);
        if (!match) {
            return null;
        }
        const bearingA = parseFloat(match[2]);
        const bearingB = parseFloat(match[4]);
        if (bearingA < 0 || bearingA > 360 || bearingA < 0 || bearingB > 360) {
            return null;
        }
        return {
            placeAIdent: match[1],
            bearingA,
            placeBIdent: match[3],
            bearingB,
            newIdent: match[5],
        };
    }
    /**
     * Parses a string according to the along-track offset format
     *
     * @param str the string to parse
     *
     * @returns a {@link AlongTrackOffsetInput} object if a valid ATO definition and `null` otherwise
     */
    static parseAlongTrackOffset(str) {
        const match = str.match(ATO_REGEX);
        if (!match) {
            return null;
        }
        return {
            placeIdent: match[1],
            distance: parseFloat(match[2]),
            newIdent: match[3],
        };
    }
    /**
     * Creates an along-track offset position with input data
     *
     * @param facLoader                  the facility loader
     * @param plan                       the flight plan the ATO is being created from
     * @param globalLegIndex             the global leg index in the plan the ATO is being created from (WT21: LSK position)
     * @param lnavActiveLegIndex         the active lnav leg index (not nominal)
     * @param lnavDistanceAlongActiveLeg the distance flown along the active lnav leg
     * @param distance                   the distance input
     *
     * @returns a {@link GeoPoint}
     */
    static async createAlongTrackOffset(facLoader, plan, globalLegIndex, lnavActiveLegIndex, lnavDistanceAlongActiveLeg, distance) {
        const planLeg = plan.tryGetLeg(globalLegIndex);
        if (planLeg) {
            const distanceNegative = distance < 0;
            // Check for the previous leg type being valid if the distance is negative
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    if (!ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType)) {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
                else {
                    return AlongTrackOffsetError.NotAvailable;
                }
            }
            let fixIcao1 = undefined;
            let fixIcao2 = undefined;
            let facility1 = undefined;
            let facility2 = undefined;
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    const legType = planLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType) && ATO_VALID_NEXT_LEG_TYPES.includes(legType)) {
                        let maxDistance = planLeg.calculated ? UnitType.NMILE.convertFrom(planLeg.calculated.distance, UnitType.METER) : -1;
                        if (lnavActiveLegIndex === globalLegIndex) {
                            maxDistance -= lnavDistanceAlongActiveLeg;
                            maxDistance = Math.max(0, maxDistance);
                        }
                        if (Math.abs(distance) < maxDistance) {
                            fixIcao1 = previousPlanLeg.leg.fixIcao;
                            fixIcao2 = planLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                }
            }
            else {
                const nextPlanLeg = plan.tryGetLeg(globalLegIndex + 1);
                if (nextPlanLeg) {
                    const legType = planLeg.leg.type;
                    const nextLegType = nextPlanLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(legType) && ATO_VALID_NEXT_LEG_TYPES.includes(nextLegType)) {
                        const maxDistance = nextPlanLeg.calculated ? UnitType.NMILE.convertFrom(nextPlanLeg.calculated.distance, UnitType.METER) : -1;
                        let minDistance = 0;
                        if (lnavActiveLegIndex === globalLegIndex + 1) {
                            minDistance = lnavDistanceAlongActiveLeg;
                        }
                        if (distance > minDistance && distance < maxDistance) {
                            fixIcao1 = planLeg.leg.fixIcao;
                            fixIcao2 = nextPlanLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                    else {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
            }
            if (fixIcao1 && fixIcao1 !== ICAO.emptyIcao && fixIcao2 && fixIcao2 !== ICAO.emptyIcao) {
                facility1 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao1), fixIcao1);
                facility2 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao2), fixIcao2);
                if (facility1 && facility2) {
                    const circle = GeoCircle.createGreatCircle(facility1, facility2);
                    const offsetOut = new Float64Array(3);
                    circle.offsetDistanceAlong(distanceNegative ? facility2 : facility1, UnitType.GA_RADIAN.convertFrom(distance, UnitType.NMILE), offsetOut);
                    const geoPoint = new GeoPoint(0, 0);
                    geoPoint.setFromCartesian(offsetOut);
                    return [geoPoint, !distanceNegative];
                }
            }
        }
        return AlongTrackOffsetError.NotAvailable;
    }
}

/**
 * Utility Methods for the Boeing FMS.
 */
class BoeingFmsUtils {
    /**
     * Gets the active segment in the Lateral Flight Plan.
     * @param plan The Lateral Flight Plan.
     * @returns The Active Flight Plan Segment or undefined.
     */
    static getActiveSegment(plan) {
        if (plan.length > 0 && plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            return plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
        }
        return undefined;
    }
    /**
     * Checks whether a leg exists in a segment with the specified ICAO and, if so, returns the leg index of that leg.
     * @param segment The segment to check for the icao.
     * @param icao The ICAO to check for in the segment.
     * @returns The segment leg index of the leg with the matching icao, or -1.
     */
    static findIcaoInSegment(segment, icao) {
        if (icao !== undefined) {
            for (let l = 0; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                if (leg !== undefined && leg.leg !== undefined && leg.leg.fixIcao && leg.leg.fixIcao === icao) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        return FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: isOriginRunway
                ? oneWayRunway.elevation
                : oneWayRunway.elevation + UnitType.METER.convertFrom(50, UnitType.FOOT) // Arrival runway leg altitude should be 50 feet above threshold
        });
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param facRepo is a facility repository in which to store the created faf leg facility
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param finalLegVpa is the vertical path angle selected for the final approach, or undefined if not applicable.
     * @returns an approach procedure.
     */
    static buildVisualApproach(facRepo, airport, runway, finalLegDistance, finalLegVpa) {
        const runwayVec = GeoPoint.sphericalToCartesian(runway.latitude, runway.longitude, BoeingFmsUtils.vec3Cache[0]);
        const approachPath = BoeingFmsUtils.geoCircleCache[0].setAsGreatCircle(runwayVec, runway.course);
        const runwayCode = RunwayUtils.getRunwayCode(runway.direction);
        const runwayLetter = RunwayUtils.getDesignatorLetter(runway.runwayDesignator).padStart(1, ' ');
        const fafLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(-finalLegDistance, UnitType.GA_RADIAN), BoeingFmsUtils.geoPointCache[0]);
        const runwayIdent = RunwayUtils.getRunwayNameString(runway.direction, runway.runwayDesignator);
        const finalLegIdent = `${finalLegVpa !== undefined ? 'FA' : 'RX'}${runwayIdent}`;
        const icao = `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`;
        // Add facility to facRepo
        const fafFacility = UserFacilityUtils.createFromLatLon(icao, fafLatLon.lat, fafLatLon.lon);
        facRepo.add(fafFacility);
        const fafLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: icao,
            course: MagVar.trueToMagnetic(approachPath.bearingAt(fafLatLon), fafLatLon),
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + (Math.tan(UnitType.DEGREE.convertTo(finalLegVpa !== null && finalLegVpa !== void 0 ? finalLegVpa : 3, UnitType.RADIAN)) * UnitType.NMILE.convertTo(finalLegDistance, UnitType.METER)),
        });
        const runwayLeg = BoeingFmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.verticalAngle = finalLegVpa !== undefined ? 360 - Math.abs(finalLegVpa) : 0;
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        return {
            name: `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [],
            finalLegs: finalLegs,
            missedLegs: [],
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approachType The approach type.
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a tunable localizer.
     * @param approachType The approach type.
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets the procedure index and transition index from procedure details of the lateral plan based on segment type.
     * @param segmentType The segment type.
     * @param lateralPlan The lateral flight plan.
     * @returns an array of procedureIndex, transitionIndex.
     */
    static getProcedureIndexAndTransitionIndexFromSegmentType(segmentType, lateralPlan) {
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return [lateralPlan.procedureDetails.departureIndex, lateralPlan.procedureDetails.departureTransitionIndex];
            case FlightPlanSegmentType.Arrival:
                return [lateralPlan.procedureDetails.arrivalIndex, lateralPlan.procedureDetails.arrivalTransitionIndex];
            case FlightPlanSegmentType.Approach:
                return [lateralPlan.procedureDetails.approachIndex, lateralPlan.procedureDetails.approachTransitionIndex];
        }
        return [-1, -1];
    }
    /**
     * Combiner method to get a procedure name as a string for the FPLN Page.
     * @param segmentType The segment type.
     * @param facility The facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The transition index.
     * @returns the name as a string.
     */
    static getProcedureNameAsString(segmentType, facility, procedureIndex, transitionIndex) {
        if (facility === undefined) {
            return 'NO FACILITY';
        }
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return this.getDepartureNameAsString(facility, procedureIndex);
            case FlightPlanSegmentType.Arrival:
                if (transitionIndex !== undefined) {
                    return this.getArrivalNameAsString(facility, procedureIndex, transitionIndex);
                }
                break;
            case FlightPlanSegmentType.Approach:
                if (procedureIndex === -1 && transitionIndex === -1) {
                    // must be visual
                    return 'VISUAL';
                }
                else if (transitionIndex !== undefined) {
                    return this.getApproachNameAsString(facility, procedureIndex, transitionIndex);
                }
        }
        return 'PROC NAME ERROR';
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @returns The name of the departure procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getDepartureNameAsString(facility, procedureIndex) {
        // let name = '';
        const departure = facility.departures[procedureIndex];
        // if (runway) {
        //   name += `RW${runway.designation}.`;
        // }
        // const transition = departure.enRouteTransitions[transitionIndex];
        // if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        // } else if (departure.commonLegs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        // } else {
        //   name += `${departure.name}`;
        // }
        return `${departure.name}`;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param facility The airport to which the arrival belongs.
     * @param procedureIndex An arrival procedure index.
     * @param transitionIndex The index of the arrival enroute transition.
     * @returns The name of the arrival procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getArrivalNameAsString(facility, procedureIndex, transitionIndex) {
        const arrival = facility.arrivals[procedureIndex];
        // TODO We may need to add back the transition name
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            return `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            return `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        // else if (arrival.commonLegs.length > 0) {
        //   name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival?.name}`;
        // }
        // if (runway) {
        //   name += `.RW${runway.designation}`;
        // }
        // return `${arrival?.name}`;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @param transitionIndex The transition index.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc, transitionIndex) {
        let type;
        // let subtype: string | undefined;
        // let rnavType: string | undefined;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNV';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'BCS';
                break; // no idea if this is the real format
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        let transition = undefined;
        if (transitionIndex > -1 && proc.transitions.length > 0) {
            transition = proc.transitions[transitionIndex].name;
        }
        return {
            type: type,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            transition: transition
        };
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    /**
     * Utility method that gets an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param facility The Facility.
     * @param procedureIndex The approach index.
     * @param transitionIndex The index of the approach transition.
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(facility, procedureIndex, transitionIndex) {
        const approach = facility.approaches[procedureIndex];
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, transitionIndex);
        let name = parts.transition ? parts.transition + '.' + parts.type : parts.type;
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        // parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Get the name of an approach in the format used on the EFIS
     * @param facilityOrApproach Either an airport facility (if combined with a procedure as the second arg) or an approach procedure
     * @param procedureIndex Index of the desired approach if the first arg is an airport facility
     * @returns formatted approach name ready for EFIS display
     */
    static getApproachNameAsEfisString(facilityOrApproach, procedureIndex) {
        var _a, _b;
        const approach = 'airportPrivateType' in facilityOrApproach ? facilityOrApproach.approaches[procedureIndex !== null && procedureIndex !== void 0 ? procedureIndex : -1] : facilityOrApproach;
        if (!approach) {
            return '???';
        }
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, -1);
        if (parts.runway) {
            return `${parts.type}${(_a = parts.suffix) !== null && _a !== void 0 ? _a : ''} ${parts.runway}`;
        }
        else {
            return `${parts.type}${(_b = parts.suffix) !== null && _b !== void 0 ? _b : ''}`;
        }
    }
    /**
     * Checks whether an approach has a primary NAV frequency based on its type. Only approaches of the following types
     * have primary NAV frequencies: ILS, LOC (BC), LDA, SDF, VOR(DME).
     * @param approach The approach to check.
     * @returns Whether the specified approach has a primary NAV frequency based on its type.
     */
    static approachHasNavFrequency(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
     * which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLeg(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return undefined;
        }
        for (leg of plan.legs(true, plan.getLegIndexFromLeg(leg))) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
     * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return -1;
        }
        let index = plan.getLegIndexFromLeg(leg);
        for (leg of plan.legs(true, index)) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return index;
            }
            index--;
        }
        return -1;
    }
    /**
     * Gets an altitude for display with padding, Flight Level Handling
     * @param altitudeMeters the altitude IN METERS to evaluate
     * @param transitionAltitudeFeet the transition altitude IN FEET to evaluate
     * @returns A display string
     */
    static parseAltitudeForDisplay(altitudeMeters, transitionAltitudeFeet) {
        const altitudeFeet = Math.round(UnitType.METER.convertTo(altitudeMeters, UnitType.FOOT));
        transitionAltitudeFeet = Math.round(transitionAltitudeFeet);
        if (altitudeFeet >= transitionAltitudeFeet) {
            return 'FL' + (altitudeFeet / 100).toFixed(0).padStart(3, '0');
        }
        return altitudeFeet.toFixed(0).padStart(5, ' ');
    }
    /**
     * Checks if leg type is an "arc" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isArcLeg(legType) {
        return arcLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "heading to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return headingToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "hold at" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "hold at" leg type.
     */
    static isHoldAtLeg(legType) {
        return holdAtLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is an "to altitude" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return altitudeLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "course to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "course to" leg type.
     */
    static isCourseToLeg(legType) {
        return courseToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "discontinuity" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "discontinuity" leg type.
     */
    static isDiscontinuityLeg(legType) {
        return discontinuityLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "vectors" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "vectors" leg type.
     */
    static isVectorsLeg(legType) {
        return vectorsTypes.includes(legType);
    }
    /**
     * Gets the direct to magnetic course from the leg vectors.
     * @param leg The Leg Definition
     * @returns the magnetic course.
     */
    static getDirectToCourse(leg) {
        let course = 360;
        if (leg.leg.type === LegType.DF && leg.calculated !== undefined) {
            const vector = leg.calculated.flightPath[leg.calculated.flightPath.length - 1];
            if (vector !== undefined) {
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                // If it is a great circle, then it's basically the "straight" part of the path, so we want to get the bearing at the start,
                // otherwise it's the turn, so we want the bearing from the end of the turn.
                const point = circle.isGreatCircle()
                    ? BoeingFmsUtils.geoPointCache[0].set(vector.startLat, vector.startLon)
                    : BoeingFmsUtils.geoPointCache[0].set(vector.endLat, vector.endLon);
                course = circle.bearingAt(point, Math.PI);
                course = MagVar.trueToMagnetic(course, MagVar.get(point));
            }
        }
        else if (leg.leg.type === LegType.CF && leg.calculated !== undefined) {
            course = leg.leg.course;
        }
        return course;
    }
    /**
     * Checks for an airway at a leg and returns the airway or undefined
     * @param facLoader The facility loader.
     * @param icao The icao of the entry to check.
     * @param airwayName The airway to search for.
     * @returns The airway object or undefined
     */
    static async isAirwayAtLeg(facLoader, icao, airwayName) {
        const facility = await facLoader.getFacility(FacilityType.Intersection, icao);
        if (facility) {
            const matchedRoute = facility.routes.find((r) => r.name === airwayName);
            if (matchedRoute) {
                const airway = await facLoader.getAirway(matchedRoute.name, matchedRoute.type, icao);
                return airway;
            }
        }
        return undefined;
    }
    /**
     * Looks for an airway with name {@link airwayBName} crossing one of the fixes of airway {@link airwayA}
     *
     * @param facLoader the facility loader
     * @param airwayA the airway to look for intersections in
     * @param airwayBName the name of the second airway
     *
     * @returns a tuple of the found airway and the fix ICAO where the two airways cross
     */
    static async findAirwayCrossingAirway(facLoader, airwayA, airwayBName) {
        for (const fac of airwayA.waypoints) {
            const airwayBFacRoute = fac.routes.find((it) => it.name === airwayBName);
            if (airwayBFacRoute) {
                const airway = await facLoader.getAirway(airwayBFacRoute.name, airwayBFacRoute.type, fac.icao);
                return [airway, fac.icao];
            }
        }
    }
    /**
     * Checks for an airway exit at a given icao.
     * @param airway The Airway Object.
     * @param icao The icao of the entry to check.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static isLegValidAirwayExit(airway, icao) {
        return airway.waypoints.find((w) => w.icao === icao);
    }
    /**
     * Checks for an airway exit matching an input ident
     * @param airway The AirwayObject.
     * @param ident The Ident to search for.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static matchIdentToAirway(airway, ident) {
        return airway.waypoints.find((w) => ICAO.getIdent(w.icao) === ident);
    }
    /**
     * Checks whether a leg should appear on the Direct To Page based on leg type.
     * @param leg The FlightPlanLeg to evaluate.
     * @returns whether or not the leg should appear on the Direct To page.
     */
    static canLegBeSelectedOnDirectPage(leg) {
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
            case LegType.PI:
            case LegType.CI:
            case LegType.VI:
            case LegType.CR:
            case LegType.VR:
                return false;
            default:
                return true;
        }
    }
    /**
     * Checks whether a leg with a given type being active should cause LNAV to be auto unsuspended
     * @param legType the leg type
     * @returns a boolean
     */
    static canLegBeAutoUnsuspended(legType) {
        switch (legType) {
            case LegType.HM:
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * Builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildBoeingLegName(leg) {
        // Name for PPOS hold leg
        if (leg.fixIcao === ICAO.emptyIcao && BoeingFmsUtils.isHoldAtLeg(leg.type)) {
            return 'PPOS';
        }
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `(${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0).padEnd(5, ' ')})`;
            case LegType.FM:
            case LegType.VM:
                return 'VECTORS';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
            case LegType.PI:
                return '(INTC)';
            default:
                if (leg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(leg.fixIcao) === FacilityType.USR) {
                    const regionStr = ICAO.getRegionCode(leg.fixIcao);
                    // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
                    // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
                    // needed - here, we extract the values to reconstruct the short name
                    if (regionStr === 'LL') {
                        const ident = ICAO.getIdent(leg.fixIcao);
                        const [latStr, longStr] = ident.split('|');
                        const lat = parseFloat(latStr.replace('N', '').replace('S', '-'));
                        const long = parseFloat(longStr.replace('E', '').replace('W', '-'));
                        return BoeingPilotWaypointUtils.latLongIdent(BoeingFmsUtils.geoPointCache[1].set(lat, long));
                    }
                }
                return ICAO.getIdent(leg.fixIcao);
        }
    }
    /**
     * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
     * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
     * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
     * @param plan A flight plan.
     */
    static reconcileDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.directToData.segmentIndex = i;
                    plan.directToData.segmentLegIndex = j - 1;
                    return;
                }
            }
        }
        plan.directToData.segmentIndex = -1;
        plan.directToData.segmentLegIndex = -1;
    }
    /**
     * Removes all of a flight plan's Direct-To data, but from the DirectToData object and from any legs in the plan.
     * Scans the legs of the flight plan for Direct-To legs and removes them.
     * @param plan A flight plan.
     */
    static removeAllDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
        plan.setDirectToData(-1, true);
    }
    /**
     * Removes all of a flight plan's Displaced Active Legs,
     * which are flagged when a procedure is added and the active leg array is moved to enroute.
     * @param plan A flight plan.
     */
    static removeDisplacedActiveLegs(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = segment.legs.length - 1; j >= 0; j--) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
    }
    /**
     * Writes the calculated end coordinates of a leg to {@link out}, if the necessary calculated data exists
     *
     * @param leg the leg to find the end point for
     * @param out the {@link GeoPoint} to write the result to
     *
     * @returns whether anything was written
     */
    static writeLegCalculatedEndPoint(leg, out) {
        if (leg.calculated && leg.calculated.endLat && leg.calculated.endLon) {
            out.set(leg.calculated.endLat, leg.calculated.endLon);
            return true;
        }
        return false;
    }
    /**
     * Returns true if a leg is a vector of discontinuity.
     * @param leg The FlightPlanLeg
     * @returns Whether the leg is a vector of discontinuity
     */
    static isLegVectOrDisco(leg) {
        switch (leg.type) {
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return true;
            default:
                return false;
        }
    }
    /**
     * Returns hold legs in the flight plan. Used to determine and show appropriate HOLD pages.
     *
     * @param plan     the flight plan in question
     * @param inMissed whether to only include missed approach holds
     *
     * @returns the result
     */
    static getPlanHolds(plan, inMissed = false) {
        var _a;
        const holdLegs = [];
        for (const leg of plan.legs()) {
            const legSegment = (_a = plan.getSegmentFromLeg(leg)) === null || _a === void 0 ? void 0 : _a.segmentType;
            if (!inMissed && legSegment === FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (inMissed && legSegment !== FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (this.isHoldAtLeg(leg.leg.type)) {
                holdLegs.push(leg);
            }
        }
        return holdLegs;
    }
    /**
     * Returns the first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`.
     * @param plan The flight plan.
     * @param fixIcao The fix's ICAO.
     * @returns The first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`, or -1 if not found.
     * */
    static findHoldInPlan(plan, fixIcao) {
        let index = -1;
        for (const leg of plan.legs()) {
            if (leg.leg.type !== LegType.HM) {
                continue;
            }
            if (leg.leg.fixIcao === fixIcao) {
                index = plan.getLegIndexFromLeg(leg);
                break;
            }
        }
        return index;
    }
    /**
     * Calculates time in seconds to fly a certain distance at a ground speed
     *
     * @param distance distance to fly
     * @param groundSpeed GS to predict with
     *
     * @returns time in number of seconds
     */
    static estimateSecondsForDistance(distance, groundSpeed) {
        return (distance / groundSpeed) * 3600;
    }
    /**
     * Calculates distance flown for a number of seconds at a ground speed
     *
     * @param seconds time flown in number of seconds
     * @param groundSpeed GS to predict with
     *
     * @returns distance in nautical miles
     */
    static estimateDistanceForSeconds(seconds, groundSpeed) {
        return (seconds / 3600) * groundSpeed;
    }
    /**
     * Returns the index of the last non-missed approach leg in the flight plan
     *
     * @param plan the plan to use for lookup
     *
     * @returns array of index and ident, or undefined if no approach segment
     */
    static getLastNonMissedApproachLeg(plan) {
        if (plan.length === 0) {
            return -1;
        }
        let legIndex = plan.length - 1;
        while (BitFlags.isAll(plan.getLeg(legIndex).flags, LegDefinitionFlags.MissedApproach)) {
            legIndex--;
        }
        return legIndex;
    }
    /**
     * Returns the distance between the end of a leg before a discontinuity and the start of the leg after that discontinuity
     *
     * @param prevLeg the leg before the discontinuity
     * @param nextLeg the leg after the discontinuity
     *
     * @returns the great circle distance between the end of the previous leg and the start of the next leg, in metres
     */
    static distanceBetweenDiscontinuedLegs(prevLeg, nextLeg) {
        var _a, _b;
        let distance;
        if (prevLeg && nextLeg && ((_a = prevLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) && prevLeg.calculated.endLon && ((_b = nextLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLat) && nextLeg.calculated.endLon) {
            const term = new GeoPoint(prevLeg.calculated.endLat, prevLeg.calculated.endLon);
            const start = new GeoPoint(nextLeg.calculated.endLat, nextLeg.calculated.endLon);
            distance = UnitType.GA_RADIAN.convertTo(term.distance(start), UnitType.METER);
        }
        else {
            distance = 0;
        }
        return distance;
    }
    /**
     * Formats a facility frequency's type for display on the FMC
     *
     * @param frequency  the frequency
     * @param noneString (optional) the string to return when the type is "None"
     *
     * @returns a string
     */
    static formatFacilityFrequencyType(frequency, noneString = 'UNKNOWN') {
        switch (frequency.type) {
            case FacilityFrequencyType.ASOS:
                return 'ASOS';
            case FacilityFrequencyType.ATIS:
                return 'ATIS';
            case FacilityFrequencyType.AWOS:
                return 'AWOS';
            case FacilityFrequencyType.Approach:
                return 'APR';
            case FacilityFrequencyType.CPT:
            case FacilityFrequencyType.Clearance:
                return 'CLEARANCE';
            case FacilityFrequencyType.CTAF:
                return 'CTAF';
            case FacilityFrequencyType.Center:
                return 'CTR';
            case FacilityFrequencyType.Departure:
                return 'DEP';
            case FacilityFrequencyType.FSS:
                return 'FSS';
            case FacilityFrequencyType.GCO:
                return 'GCO';
            case FacilityFrequencyType.Ground:
                return 'GND';
            case FacilityFrequencyType.Multicom:
                return 'MULTICOM';
            case FacilityFrequencyType.Tower:
                return 'TWR';
            case FacilityFrequencyType.Unicom:
                return 'UNICOM';
            default:
                return noneString;
        }
    }
    /**
     * Formats a facility type (and, if applicable, VOR type) into a string
     *
     * Used on the SELECT DESIRED XXX page
     *
     * @param facility the facility
     *
     * @returns a string
     */
    static formatFacilityType(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            switch (facility.type) {
                default:
                case VorType.VOR:
                    return 'VOR';
                case VorType.VORDME:
                    return 'VORDME';
                case VorType.VORTAC:
                    return 'VORTAC';
                case VorType.TACAN:
                    return 'TACAN';
                case VorType.ILS:
                    return 'ILS';
                case VorType.DME:
                    return 'DME';
            }
        }
        else {
            switch (ICAO.getFacilityType(facility.icao)) {
                case FacilityType.Airport:
                    return 'APRT';
                case FacilityType.NDB:
                    return 'NDB';
                case FacilityType.Intersection:
                    return 'WAYPOINT';
                case FacilityType.RWY:
                    return 'RUNWAY';
                case FacilityType.USR:
                    return 'PILOT';
                case FacilityType.VIS:
                    return 'VISUAL';
                default:
                    return 'UNKNOWN';
            }
        }
    }
    /**
     * Returns the distance from PPOS to the end of a leg, given a lateral plan and a global leg index
     * @param lateralPlan the lateral plan
     * @param globalLegIndex the global leg index
     * @returns the distance, in metres
     */
    static getDistanceFromPposToLegEnd(lateralPlan, globalLegIndex) {
        var _a, _b;
        const legDistanceRemaining = SimVar.GetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM);
        const legDistanceRemainingMetres = UnitType.METER.convertFrom(legDistanceRemaining, UnitType.NMILE);
        const currentLeg = lateralPlan.getLeg(lateralPlan.activeLateralLeg);
        const targetLeg = lateralPlan.getLeg(globalLegIndex);
        if (currentLeg.calculated && targetLeg.calculated) {
            const cumulativeDistanceToCurrentLeg = (_a = currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTransitions;
            const cumulativeDistanceToTargetLeg = (_b = targetLeg.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions;
            const distanceBetweenLegs = cumulativeDistanceToTargetLeg - cumulativeDistanceToCurrentLeg;
            return legDistanceRemainingMetres + distanceBetweenLegs;
        }
        return undefined;
    }
    /**
     * Toggle assumed temp takeoff derate.
     * @param mode The takeoff thrust mode.
     * @returns The opposite derate mode of the passed fixed thrust mode.
     */
    static toggleAssumedTempDerate(mode) {
        switch (mode) {
            case TakeoffThrustMode.TO: return TakeoffThrustMode.DTO;
            case TakeoffThrustMode.TO1: return TakeoffThrustMode.DTO1;
            case TakeoffThrustMode.TO2: return TakeoffThrustMode.DTO2;
            case TakeoffThrustMode.DTO: return TakeoffThrustMode.TO;
            case TakeoffThrustMode.DTO1: return TakeoffThrustMode.TO1;
            case TakeoffThrustMode.DTO2: return TakeoffThrustMode.TO2;
        }
    }
    /**
     * Returns whether the passed takeoff thrust mode is an assumed temperature derate mode.
     * @param mode The takeoff thrust mode.
     * @returns Whether the passed takeoff thrust mode is an assumed temperature derate mode.
     */
    static thrustModeIsAssumedTemp(mode) {
        return (mode === TakeoffThrustMode.DTO ||
            mode === TakeoffThrustMode.DTO1 ||
            mode === TakeoffThrustMode.DTO2);
    }
    /**
     * Helper to set an assumed temp de-rate.
     * @param perfPlan The performance plan to set the values on.
     * @param assumedTemp The assumed temp in °C, or null to clear the assumed temp.
     * @param oat The outside air temp in °C.
     * @param mode The thrust mode to use, defaults to the current thrust mode.
     */
    static setAssumedTempDerate(perfPlan, assumedTemp, oat, mode) {
        perfPlan.takeoffAssumedTemp.set(assumedTemp);
        const assumedTempExceedsOAT = assumedTemp !== null && assumedTemp > oat;
        const takeoffThrustMode = mode !== null && mode !== void 0 ? mode : perfPlan.takeoffThrustMode.get();
        if ((assumedTempExceedsOAT && !BoeingFmsUtils.thrustModeIsAssumedTemp(takeoffThrustMode)) ||
            (!assumedTempExceedsOAT && BoeingFmsUtils.thrustModeIsAssumedTemp(takeoffThrustMode))) {
            perfPlan.takeoffThrustMode.set(BoeingFmsUtils.toggleAssumedTempDerate(takeoffThrustMode));
        }
    }
    /**
     * Checks if two VHF frequencies are equal
     * @param frequencyA The first frequency to compare
     * @param frequencyB The second frequency to compare
     * @returns true if the frequencies are equal
     */
    static vhfFrequenciesEqual(frequencyA, frequencyB) {
        return Math.abs(frequencyA - frequencyB) < 0.0025;
    }
    /**
     * Check if a leg can contain wind data
     * @param legType Leg Type
     * @returns true if the leg is eligible for wind data
     */
    static legTypeCanHaveWind(legType) {
        switch (legType) {
            case LegType.AF:
            case LegType.CF:
            case LegType.DF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.IF:
            case LegType.RF:
            case LegType.TF:
                return true;
            default:
                return false;
        }
    }
    /**
     * Get a basic facility with only the properties of {@link Facility} from any facility.
     * @param facility The facility.
     * @returns A facility instance with only the basic subset of properties.
     */
    static getBaseFacility(facility) {
        return {
            icao: facility.icao,
            name: facility.name,
            lat: facility.lat,
            lon: facility.lon,
            region: facility.region,
            city: facility.city,
            magvar: facility.magvar,
        };
    }
}
BoeingFmsUtils.vec3Cache = [new Float64Array(3)];
BoeingFmsUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingFmsUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
BoeingFmsUtils.DTO_LEG_OFFSET = 3;
BoeingFmsUtils.LEG_USER_DATA_KEY_CRUISE_STEP_ALTITUDE = 'wtboeing.cruise-step-altitude';
/**
 * Utility method to return a single RnavTypeFlag from multiple possible flags.
 * @param rnavTypeFlags The input RnavTypeFlags.
 * @returns A single RnavTypeFlag
 */
BoeingFmsUtils.getBestRnavType = ApproachUtils.getBestRnavType;
/**
 * Additional Bitflags describing a leg definition specific to the Boeing FMS
 */
var BoeingExtraLegDefinitionFlags;
(function (BoeingExtraLegDefinitionFlags) {
    /**
     * A leg that was part of the active leg pair in a procedure when the procedure was removed, and was subsequently
     * moved to another segment in the plan.
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DisplacedActiveLeg"] = 536870912] = "DisplacedActiveLeg";
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["ProcedureLeg"] = 1073741824] = "ProcedureLeg";
    /**
     * Applied to the target leg of a direct to
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DirectToTarget"] = -2147483648] = "DirectToTarget";
})(BoeingExtraLegDefinitionFlags || (BoeingExtraLegDefinitionFlags = {}));
/** Array of "arc" leg types. */
const arcLegTypes = [LegType.AF, LegType.RF];
/** Array of "heading to" leg types. */
const headingToLegTypes = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold at" leg types. */
const holdAtLegTypes = [LegType.HA, LegType.HF, LegType.HM];
/** Array of "to altitude" leg types. */
const altitudeLegTypes = [LegType.CA, LegType.FA, LegType.VA, LegType.HA];
/** Array of "course to" leg types. */
const courseToLegTypes = [LegType.CA, LegType.CF, LegType.CI];
/**
 * Array of "discontinuity" leg types
 */
const discontinuityLegTypes = [LegType.Discontinuity, LegType.ThruDiscontinuity];
/** Array of "vectors" leg types */
const vectorsTypes = [LegType.FM, LegType.VM];

/** FMS Operating Phases of flight */
var FmsOperatingPhase;
(function (FmsOperatingPhase) {
    FmsOperatingPhase[FmsOperatingPhase["PREFLIGHT"] = 0] = "PREFLIGHT";
    FmsOperatingPhase[FmsOperatingPhase["TAKEOFF"] = 1] = "TAKEOFF";
    FmsOperatingPhase[FmsOperatingPhase["CLIMB"] = 2] = "CLIMB";
    FmsOperatingPhase[FmsOperatingPhase["CRUISE"] = 3] = "CRUISE";
    FmsOperatingPhase[FmsOperatingPhase["DESCENT"] = 4] = "DESCENT";
    FmsOperatingPhase[FmsOperatingPhase["APPROACH"] = 5] = "APPROACH";
    FmsOperatingPhase[FmsOperatingPhase["COMPLETE"] = 6] = "COMPLETE";
})(FmsOperatingPhase || (FmsOperatingPhase = {}));
/**
 * L Var names for FMS phase-related data.
 */
var FmsOperatingPhaseDataVars;
(function (FmsOperatingPhaseDataVars) {
    /** The current nominal desired track, in degrees true. */
    FmsOperatingPhaseDataVars["FmsOperatingPhaseVar"] = "L:WT_Boeing_Fms_Operating_Phase";
})(FmsOperatingPhaseDataVars || (FmsOperatingPhaseDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class FmsOperatingPhasePublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(FmsOperatingPhasePublisher.simvars, bus);
    }
}
FmsOperatingPhasePublisher.simvars = new Map([
    ['fms_operating_phase', { name: FmsOperatingPhaseDataVars.FmsOperatingPhaseVar, type: SimVarValueType.Enum }],
]);

/**
 * Types of vertical flight path vectors.
 */
var VerticalFlightPathVectorType;
(function (VerticalFlightPathVectorType) {
    VerticalFlightPathVectorType["Climb"] = "Climb";
    VerticalFlightPathVectorType["ClimbLevel"] = "ClimbLevel";
    VerticalFlightPathVectorType["ClimbAcceleration"] = "ClimbAcceleration";
    VerticalFlightPathVectorType["ClimbLevelAcceleration"] = "ClimbLevelAcceleration";
    VerticalFlightPathVectorType["Cruise"] = "Cruise";
    VerticalFlightPathVectorType["CruiseAcceleration"] = "CruiseAcceleration";
    VerticalFlightPathVectorType["CruiseDeceleration"] = "CruiseDeceleration";
    VerticalFlightPathVectorType["CruiseStepClimb"] = "CruiseStepClimb";
    VerticalFlightPathVectorType["CruiseStepClimbAcceleration"] = "CruiseStepClimbAcceleration";
    VerticalFlightPathVectorType["CruiseStepClimbDeceleration"] = "CruiseStepClimbDeceleration";
    VerticalFlightPathVectorType["CruiseStepDescent"] = "CruiseStepDescent";
    VerticalFlightPathVectorType["CruiseStepDescentAcceleration"] = "CruiseStepDescentAcceleration";
    VerticalFlightPathVectorType["CruiseStepDescentDeceleration"] = "CruiseStepDescentDeceleration";
    VerticalFlightPathVectorType["LevelDeceleration"] = "LevelDeceleration";
    VerticalFlightPathVectorType["IdleDescent"] = "IdleDescent";
    VerticalFlightPathVectorType["IdleDescentDeceleration"] = "IdleDescentDeceleration";
    VerticalFlightPathVectorType["GeometricDescent"] = "GeometricDescent";
    VerticalFlightPathVectorType["GeometricDescentDeceleration"] = "GeometricDescentDeceleration";
})(VerticalFlightPathVectorType || (VerticalFlightPathVectorType = {}));
/**
 * Sources from which a flight path vector's target speed is derived.
 */
var VerticalFlightPathVectorSpeedSource;
(function (VerticalFlightPathVectorSpeedSource) {
    VerticalFlightPathVectorSpeedSource["None"] = "None";
    VerticalFlightPathVectorSpeedSource["Schedule"] = "Schedule";
    VerticalFlightPathVectorSpeedSource["FlightPlan"] = "FlightPlan";
    VerticalFlightPathVectorSpeedSource["Transition"] = "Transition";
    VerticalFlightPathVectorSpeedSource["Restriction"] = "Restriction";
})(VerticalFlightPathVectorSpeedSource || (VerticalFlightPathVectorSpeedSource = {}));
/**
 * The current VNAV altitude capture type.
 */
var BoeingVNavAltCaptureType;
(function (BoeingVNavAltCaptureType) {
    /** Altitude capture is not armed. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VNAV target altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["VNAV"] = 2] = "VNAV";
    /** Altitude will capture the cruise altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Cruise"] = 3] = "Cruise";
})(BoeingVNavAltCaptureType || (BoeingVNavAltCaptureType = {}));
/**
 * Boeing VNAV tracking phases.
 */
var BoeingVNavTrackingPhase;
(function (BoeingVNavTrackingPhase) {
    BoeingVNavTrackingPhase["None"] = "None";
    BoeingVNavTrackingPhase["Climb"] = "Climb";
    BoeingVNavTrackingPhase["Cruise"] = "Cruise";
    BoeingVNavTrackingPhase["Descent"] = "Descent";
    BoeingVNavTrackingPhase["MissedApproach"] = "MissedApproach";
})(BoeingVNavTrackingPhase || (BoeingVNavTrackingPhase = {}));
/** This enum begins at 100 so that it can be used in combination with APVerticalModes in BoeingFmaData for display on the FMA. */
var BoeingVNavModes;
(function (BoeingVNavModes) {
    BoeingVNavModes[BoeingVNavModes["NONE"] = 100] = "NONE";
    BoeingVNavModes[BoeingVNavModes["ARMED"] = 101] = "ARMED";
    BoeingVNavModes[BoeingVNavModes["SPD_CLIMB"] = 102] = "SPD_CLIMB";
    BoeingVNavModes[BoeingVNavModes["SPD_DESCENT"] = 103] = "SPD_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_DESCENT"] = 104] = "PATH_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_IDLE"] = 105] = "PATH_IDLE";
    BoeingVNavModes[BoeingVNavModes["PATH_LEVEL"] = 106] = "PATH_LEVEL";
    BoeingVNavModes[BoeingVNavModes["ALT"] = 107] = "ALT";
    BoeingVNavModes[BoeingVNavModes["THR_DESCENT"] = 108] = "THR_DESCENT";
})(BoeingVNavModes || (BoeingVNavModes = {}));
/** Path Deviation Mode for the Boeing Vnav Manager. */
var PathDeviationMode;
(function (PathDeviationMode) {
    PathDeviationMode[PathDeviationMode["NONE"] = 0] = "NONE";
    PathDeviationMode[PathDeviationMode["BELOW"] = 1] = "BELOW";
    PathDeviationMode[PathDeviationMode["ABOVE"] = 2] = "ABOVE";
})(PathDeviationMode || (PathDeviationMode = {}));
var BoeingVnavDescentPendingType;
(function (BoeingVnavDescentPendingType) {
    BoeingVnavDescentPendingType["DesDir"] = "des-dir";
    BoeingVnavDescentPendingType["DesNow"] = "des-now";
})(BoeingVnavDescentPendingType || (BoeingVnavDescentPendingType = {}));

/** Boeing VNAV Utilities */
class BoeingVNavUtils {
    /**
     * Utility method that checks if a mode is a vnav mode.
     * @param mode The BoeingVNavMode or APVerticalMode.
     * @returns True if the mode is an active vnav mode.
     */
    static isModeVnav(mode) {
        return mode === BoeingVNavModes.ALT ||
            mode === BoeingVNavModes.PATH_DESCENT ||
            mode === BoeingVNavModes.PATH_IDLE ||
            mode === BoeingVNavModes.PATH_LEVEL ||
            mode === BoeingVNavModes.SPD_CLIMB ||
            mode === BoeingVNavModes.SPD_DESCENT;
    }
    /**
     * Gets the index of the cruise step in effect at a given query point along a flight plan. The cruise step in effect
     * is defined as the the closest (as measured along the lateral flight path) cruise step in the flight plan at or
     * before the query point.
     * @param verticalPath The flight plan's associated vertical flight path.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance from the query point to the end of its containing leg, in meters.
     * @returns The index of the cruise step in effect at the specified query point.
     */
    static getCurrentCruiseStepIndex(verticalPath, globalLegIndex, distanceToLegEnd) {
        for (let i = verticalPath.cruiseSteps.length - 1; i >= 0; i--) {
            const step = verticalPath.cruiseSteps[i];
            if (step.globalLegIndex < globalLegIndex
                || (step.globalLegIndex === globalLegIndex && step.distanceToLegEnd >= distanceToLegEnd)) {
                return i;
            }
        }
        return -1;
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A manager and calculator for vertical flight plans for Boeing avionics systems.
 */
class BoeingPathCalculator extends SmoothingPathCalculator {
    /**
     * Creates an instance of BoeingPathCalculator.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param perfProvider A provider of airplane performance data.
     * @param engineDataProvider A provider of airplane engine data.
     * @param speedProvider A provider of airplane airspeed references.
     * @param perfPlanRepository The performance plan repository.
     * @param windPlanner The wind planner.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, perfProvider, engineDataProvider, speedProvider, perfPlanRepository, windPlanner, options) {
        var _a, _b, _c, _d;
        super(bus, flightPlanner, primaryPlanIndex, options);
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.speedProvider = speedProvider;
        this.perfPlanRepository = perfPlanRepository;
        this.windPlanner = windPlanner;
        this.speedConstraintLists = [];
        this.plannedCruiseStepList = [];
        this.verticalFlightPathEntries = [];
        this.perfPlanSubscriptions = [];
        this.accelerationResult = Vec2Math.create();
        this.enablePathCalc = (_a = options === null || options === void 0 ? void 0 : options.enablePathCalc) !== null && _a !== void 0 ? _a : false;
        this.engineCount = Math.max((_b = options === null || options === void 0 ? void 0 : options.engineCount) !== null && _b !== void 0 ? _b : 2, 1);
        this.performanceDescentIdleN1Offset = Math.max((_c = options === null || options === void 0 ? void 0 : options.performanceDescentIdleN1Offset) !== null && _c !== void 0 ? _c : 10, 0);
        this.cruiseStepCostBias = (_d = options === null || options === void 0 ? void 0 : options.cruiseStepCostBias) !== null && _d !== void 0 ? _d : 0;
        if (this.enablePathCalc) {
            const sub = bus.getSubscriber();
            this.fmsOperatingPhase = ConsumerValue.create(sub.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
            // TODO: Maybe support ADC system?
            this.indicatedAltitude = ConsumerValue.create(sub.on('indicated_alt'), 0);
            this.lnavIsAwaitingCalc = ConsumerSubject.create(sub.on('lnav_is_awaiting_calc'), false);
            this.lnavTrackedLegIndex = ConsumerSubject.create(sub.on('lnav_tracked_leg_index'), 0);
            this.lnavLegDistanceRemaining = ConsumerValue.create(sub.on('lnav_leg_distance_remaining'), 0);
            this.fob = ConsumerValue.create(sub.on('fuel_usable_total_weight'), 0);
            const legUserDataHandler = (e) => {
                if (e.key === BoeingFmsUtils.LEG_USER_DATA_KEY_CRUISE_STEP_ALTITUDE) {
                    this.getVerticalFlightPlan(e.planIndex).planChanged = true;
                    this.getVerticalFlightPath(e.planIndex).isPending = true;
                }
            };
            sub.on('fplLegUserDataSet').handle(legUserDataHandler);
            sub.on('fplLegUserDataDelete').handle(legUserDataHandler);
            // TODO: This is a massive hack that relies on LNAV's awaiting calculate logic as well as the fact that the only
            // way the active plan can change in the Boeings is through a plan copy. This needs to be replaced with a more
            // robust solution at some point and **UNDER NO CIRCUMSTANCES SHOULD IT BE REPLICATED ELSEWHERE**.
            const primaryPlanActiveLegIndex = Subject.create(0);
            sub.on('fplActiveLegChange').handle(event => {
                if (event.type === ActiveLegType.Lateral && event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(event.index);
                }
            });
            sub.on('fplCopied').handle(event => {
                if (event.targetPlanIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            sub.on('fplLoaded').handle(event => {
                if (event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            this.canUpdatePrimaryPlan = MappedSubject.create(([isAwaitingCalc, trackedLegIndex, planActiveLegIndex]) => !isAwaitingCalc && trackedLegIndex === planActiveLegIndex, this.lnavIsAwaitingCalc, this.lnavTrackedLegIndex, primaryPlanActiveLegIndex);
            // We need to update pending vertical plans on an update loop in order to guarantee that we don't perform the
            // update using an intermediate state from LNAV (specifically when the tracked leg index has been updated before
            // the remaining leg distance).
            sub.on('realTime').handle(this.update.bind(this));
        }
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /**
     * Gets the speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The speed constraint list for the specified flight plan.
     */
    getSpeedConstraintList(planIndex) {
        var _a;
        return (_a = this.speedConstraintLists[planIndex]) !== null && _a !== void 0 ? _a : this.createSpeedConstraintList(planIndex);
    }
    /**
     * Gets the planned cruise step list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The planned cruise step list for the specified flight plan.
     */
    getPlannedCruiseStepList(planIndex) {
        return this._getPlannedCruiseStepList(planIndex);
    }
    /**
     * Gets the planned cruise step list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The planned cruise step list for the specified flight plan.
     */
    _getPlannedCruiseStepList(planIndex) {
        var _a;
        return (_a = this.plannedCruiseStepList[planIndex]) !== null && _a !== void 0 ? _a : this.createPlannedCruiseStepList(planIndex);
    }
    /**
     * Gets the calculated vertical flight path for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The calculated vertical flight path for the specified flight plan.
     */
    getVerticalFlightPath(planIndex) {
        return this.getVerticalFlightPathEntry(planIndex).path;
    }
    /**
     * Gets the vertical flight path entry for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The vertical flight path entry for the specified flight plan.
     */
    getVerticalFlightPathEntry(planIndex) {
        var _a;
        return (_a = this.verticalFlightPathEntries[planIndex]) !== null && _a !== void 0 ? _a : this.createVerticalFlightPathEntry(planIndex);
    }
    /**
     * Gets the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The speed constraint in effect for the specified flight plan leg and vertical flight phase, or
     * `undefined` if there is no speed constraint in effect.
     */
    getCurrentSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        return speedConstraints[this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach)];
    }
    /**
     * Gets the next speed constraint to take effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The next speed constraint to take effect for the specified flight plan leg and vertical flight phase,
     * or `undefined` if there is no speed constraint in effect.
     */
    getNextSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        const currentIndex = this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach);
        if (currentIndex < 0) {
            if (flightPhase === VerticalFlightPhase.Climb) {
                // If there is no current constraint in effect during climb, there can be no next climb constraint because
                // either we have sequenced all climb constraints or there is at least one non-climb constraint to sequence
                // before the next climb constraint.
                return undefined;
            }
            else {
                // If there is no current constraint in effect during descent, it is still possible that the next upcoming
                // constraint to be sequenced is the next descent constraint. This constraint, if it exists, is located at the
                // index where the current constraint would be located if it existed, so we need to check if the constraint at
                // that index is a descent constraint and has yet to be sequenced.
                const constraint = speedConstraints[-currentIndex - 1];
                if (constraint !== undefined && flightPhase === constraint.flightPhase && constraint.globalLegIndex >= globalLegIndex) {
                    return constraint;
                }
                else {
                    return undefined;
                }
            }
        }
        const isMapr = speedConstraints[currentIndex].isMissedApproach;
        const constraint = speedConstraints[currentIndex + 1];
        if (constraint !== undefined && flightPhase === constraint.flightPhase && isMapr === constraint.isMissedApproach) {
            return constraint;
        }
        return undefined;
    }
    /**
     * Gets the index of the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param speedConstraintList The speed constraint list for the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The index of the speed constraint in effect for the specified flight plan leg and vertical flight phase.
     * If there is no speed constraint in effect, `-(i + 1)` is returned instead, where `i` is the index at which the
     * constraint would be located if it existed.
     */
    getCurrentSpeedConstraintIndex(planIndex, speedConstraintList, globalLegIndex, flightPhase, isMissedApproach) {
        var _a, _b;
        if (flightPhase === VerticalFlightPhase.Climb) {
            const inMissedApproach = isMissedApproach !== null && isMissedApproach !== void 0 ? isMissedApproach : (this.flightPlanner.hasFlightPlan(planIndex)
                && BitFlags.isAll((_b = (_a = this.flightPlanner.getFlightPlan(planIndex).tryGetLeg(globalLegIndex)) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, LegDefinitionFlags.MissedApproach));
            // During climb, the next upcoming climb speed constraint to be sequenced is in effect.
            for (let i = 0; i < speedConstraintList.length; i++) {
                const constraint = speedConstraintList[i];
                // Speed constraints in the missed approach are not active until we are in the missed approach.
                if (constraint.isMissedApproach && !inMissedApproach) {
                    return -(i + 1);
                }
                if (constraint.globalLegIndex >= globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 1);
                }
            }
            return -(speedConstraintList.length + 1);
        }
        else {
            // During descent, the last sequenced descent speed constraint is in effect.
            for (let i = speedConstraintList.length - 1; i >= 0; i--) {
                const constraint = speedConstraintList[i];
                if (constraint.globalLegIndex < globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 2);
                }
            }
            return -1;
        }
    }
    /**
     * Gets the next planned cruise step at or after a given flight plan leg.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the next planned cruise step.
     * @returns The next planned cruise step at or after the specified flight plan leg, or `undefined` if there is no
     * such cruise step.
     */
    getNextPlannedCruiseStep(planIndex, globalLegIndex) {
        const plannedCruiseSteps = this.getPlannedCruiseStepList(planIndex);
        return plannedCruiseSteps[this.getNextPlannedCruiseStepIndex(planIndex, globalLegIndex)];
    }
    /**
     * Gets the index of the next planned cruise step at or after a given flight plan leg.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the next planned cruise step.
     * @returns The index of the next planned cruise step at or after the specified flight plan leg, or `-1` if there is
     * no such cruise step.
     */
    getNextPlannedCruiseStepIndex(planIndex, globalLegIndex) {
        const plannedCruiseSteps = this.getPlannedCruiseStepList(planIndex);
        for (let i = 0; i < plannedCruiseSteps.length; i++) {
            const step = plannedCruiseSteps[i];
            if (step.globalLegIndex >= globalLegIndex) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Creates a new, empty speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created speed constraint list.
     */
    createSpeedConstraintList(planIndex) {
        return this.speedConstraintLists[planIndex] = [];
    }
    /**
     * Creates a new, empty planned cruise step list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created planned cruise step list.
     */
    createPlannedCruiseStepList(planIndex) {
        return this.plannedCruiseStepList[planIndex] = [];
    }
    /**
     * Creates a new vertical path entry for a flight plan. The new entry will be initialized with an empty vertical
     * path.
     * @param planIndex The index of the flight plan.
     * @returns The created vertical path entry.
     */
    createVerticalFlightPathEntry(planIndex) {
        const entry = {
            path: BoeingPathCalculator.createVerticalPath(planIndex),
            lastTocLegIndex: undefined,
            lastTocDistanceToLegEnd: undefined,
            isTocSequenced: false,
            lastCruiseStepStartLegIndex: undefined,
            lastCruiseStepStartDistanceToLegEnd: undefined,
            perfDescentWorkingPath: BoeingPathCalculator.createVerticalPath(planIndex),
            geoDescentCoarsePath: BoeingPathCalculator.createGeometricDescentCoarsePath(),
            needsRebuild: false,
            needsSetLastCruiseStepStart: false
        };
        this.verticalFlightPathEntries[planIndex] = entry;
        return entry;
    }
    /**
     * Request an immediate path computation for a specified flight plan. If this calculator does not support path
     * calculations, then this method does nothing and will always return `false`. If computation is requested for the
     * active flight plan but cannot be carried out when the method is called, then the computation will be pended until
     * the active flight plan path can be computed, and the method will return `false`.
     * @param planIndex The index of the flight plan for which to request a path computation.
     * @returns Whether the requested path computation was executed successfully.
     */
    requestPathCompute(planIndex) {
        if (!this.enablePathCalc || !this.flightPlanner.hasFlightPlan(planIndex) || this.verticalFlightPlans[planIndex] === undefined) {
            return false;
        }
        if (planIndex !== this.primaryPlanIndex || this.canUpdatePrimaryPlan.get()) {
            this.computePathAndNotify(this.flightPlanner.getFlightPlan(planIndex), this.verticalFlightPlans[planIndex]);
            return true;
        }
        else {
            this.getVerticalFlightPath(planIndex).isPending = true;
            return false;
        }
    }
    /** @inheritdoc */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        if (!this.enablePathCalc) {
            return;
        }
        super.onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent);
        this.getVerticalFlightPath(planIndex).isPending = true;
    }
    /** @inheritdoc */
    onPlanCalculated(event) {
        if (!this.enablePathCalc) {
            return;
        }
        if (event.planIndex !== this.primaryPlanIndex || this.canUpdatePrimaryPlan.get()) {
            this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
        }
        else {
            this.getVerticalFlightPath(event.planIndex).isPending = true;
        }
    }
    /**
     * Updates this calculator.
     */
    update() {
        if (this.canUpdatePrimaryPlan.get()
            && this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)
            && this.getVerticalFlightPath(this.primaryPlanIndex).isPending) {
            this.buildVerticalFlightPlanAndComputeAndNotify(this.primaryPlanIndex);
        }
    }
    /** @inheritdoc */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        super.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.buildSpeedConstraints(lateralPlan, this.getSpeedConstraintList(verticalPlan.planIndex));
        this.buildPlannedCruiseSteps(lateralPlan, this._getPlannedCruiseStepList(verticalPlan.planIndex));
        this.buildVerticalFlightPath(lateralPlan, this.getVerticalFlightPathEntry(verticalPlan.planIndex));
    }
    /**
     * Builds a speed constraint list from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param speedConstraints The speed constraint list to build.
     */
    buildSpeedConstraints(lateralPlan, speedConstraints) {
        var _a, _b;
        let speedConstraintIndex = 0;
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(lateralPlan.planIndex);
        for (let segmentIndex = 0; segmentIndex < lateralPlan.segmentCount; segmentIndex++) {
            const segment = lateralPlan.tryGetSegment(segmentIndex);
            if (segment) {
                for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                    const leg = segment.legs[segmentLegIndex];
                    const isDirectToLeg = BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo)
                        && lateralPlan.directToData.segmentIndex === segmentIndex
                        && lateralPlan.directToData.segmentLegIndex === segmentLegIndex - this.directToLegOffset;
                    const approachSpeed = (_a = perfPlan.approachFlapSpeed.get()) === null || _a === void 0 ? void 0 : _a[1];
                    const windCorrection = perfPlan.approachWindCorrection.get();
                    const hasAutoApproachSpeed = leg.verticalData.speedDesc === SpeedRestrictionType.Unused
                        && BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF)
                        && approachSpeed !== undefined;
                    // If the leg is a direct-to leg with an associated direct-to target leg, skip it since its constraint is
                    // duplicated from that of the target leg.
                    if ((leg.verticalData.speedDesc !== SpeedRestrictionType.Unused || hasAutoApproachSpeed) && !isDirectToLeg) {
                        const isMissedApproach = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
                        const isCursorDepartureOrMissedApproach = segment.segmentType === FlightPlanSegmentType.Departure || isMissedApproach;
                        // If the constraint leg is a direct-to target, shift the leg index to that of the direct-to leg.
                        const isDirectToTarget = lateralPlan.directToData.segmentIndex === segmentIndex
                            && lateralPlan.directToData.segmentLegIndex === segmentLegIndex;
                        const constraint = (_b = speedConstraints[speedConstraintIndex]) !== null && _b !== void 0 ? _b : (speedConstraints[speedConstraintIndex] = BoeingPathCalculator.createSpeedConstraintListItem());
                        constraint.globalLegIndex = segment.offset + segmentLegIndex + (isDirectToTarget ? this.directToLegOffset : 0);
                        constraint.flightPhase = isCursorDepartureOrMissedApproach ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent;
                        constraint.speedConstraint.speedDesc = hasAutoApproachSpeed ? SpeedRestrictionType.At : leg.verticalData.speedDesc;
                        constraint.speedConstraint.speed = hasAutoApproachSpeed ? (approachSpeed + windCorrection) : leg.verticalData.speed;
                        constraint.speedConstraint.speedUnit = hasAutoApproachSpeed ? SpeedUnit.IAS : leg.verticalData.speedUnit;
                        constraint.isMissedApproach = hasAutoApproachSpeed ? false : isMissedApproach;
                        let useMin = false;
                        let useMax = false;
                        switch (constraint.speedConstraint.speedDesc) {
                            case SpeedRestrictionType.At:
                            case SpeedRestrictionType.Between:
                                useMin = true;
                                useMax = true;
                                break;
                            case SpeedRestrictionType.AtOrAbove:
                                useMin = true;
                                break;
                            case SpeedRestrictionType.AtOrBelow:
                                useMax = true;
                                break;
                        }
                        constraint.minCas = -Infinity;
                        constraint.maxCas = Infinity;
                        constraint.minMach = -Infinity;
                        constraint.maxMach = Infinity;
                        if (useMin) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.minMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.minCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        if (useMax) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.maxMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.maxCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        speedConstraintIndex++;
                    }
                }
            }
        }
        speedConstraints.length = speedConstraintIndex;
    }
    /**
     * Builds a planned cruise step list from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param plannedCruiseSteps The planned cruise step list to build.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    buildPlannedCruiseSteps(lateralPlan, plannedCruiseSteps) {
        var _a;
        var _b;
        let plannedCruiseStepIndex = 0;
        for (let segmentIndex = 0; segmentIndex < lateralPlan.segmentCount; segmentIndex++) {
            const segment = lateralPlan.tryGetSegment(segmentIndex);
            if (segment) {
                for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                    // If the leg is a direct-to target leg, skip it since its planned cruise step will be duplicated in the
                    // associated direct-to leg.
                    if (lateralPlan.directToData.segmentIndex === segmentIndex
                        && lateralPlan.directToData.segmentLegIndex === segmentLegIndex) {
                        continue;
                    }
                    const plannedStepAltitude = segment.legs[segmentLegIndex].userData[BoeingFmsUtils.LEG_USER_DATA_KEY_CRUISE_STEP_ALTITUDE];
                    if (typeof plannedStepAltitude === 'number') {
                        const plannedCruiseStep = (_a = plannedCruiseSteps[_b = plannedCruiseStepIndex++]) !== null && _a !== void 0 ? _a : (plannedCruiseSteps[_b] = BoeingPathCalculator.createPlannedCruiseStep());
                        plannedCruiseStep.globalLegIndex = segment.offset + segmentLegIndex;
                        plannedCruiseStep.toAltitude = plannedStepAltitude;
                        plannedCruiseStep.deferredDistance = 0;
                        plannedCruiseStep.isInvalid = false;
                    }
                }
            }
        }
        plannedCruiseSteps.length = plannedCruiseStepIndex;
    }
    /**
     * Builds an empty vertical flight path from a lateral flight plan. After the path is built, it will contain one
     * leg (containing zero vectors) for each leg in the lateral flight plan, and all TOC/TOD data will be undefined.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to build.
     */
    buildVerticalFlightPath(lateralPlan, verticalPathEntry) {
        verticalPathEntry.needsRebuild = false;
        const verticalPath = verticalPathEntry.path;
        verticalPath.legs.length = lateralPlan.length;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            if (leg) {
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
            else {
                verticalPath.legs[i] = BoeingPathCalculator.createVerticalPathLeg();
            }
        }
        verticalPath.cruiseSteps.length = 0;
        verticalPath.isPending = true;
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocVectorIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.predictedCruiseDistance = undefined;
        verticalPath.predictedCruiseDuration = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todVectorIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        verticalPathEntry.lastTocLegIndex = undefined;
        verticalPathEntry.lastTocDistanceToLegEnd = undefined;
        verticalPathEntry.lastCruiseStepStartLegIndex = undefined;
        verticalPathEntry.lastCruiseStepStartDistanceToLegEnd = undefined;
        if (this.fmsOperatingPhase.get() < FmsOperatingPhase.CLIMB) {
            verticalPathEntry.isTocSequenced = false;
        }
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Initializes performance plan subscriptions for an indexed flight plan. Once these subscriptions are initialized,
     * the vertical path for the flight plan will be flagged to be rebuilt during the next flight plan calculation cycle
     * whenever certain performance plan values change. If subscriptions are already initialized for the specified flight
     * plan, then this method does nothing.
     * @param planIndex The index of the flight plan for which to initialize performance plan subscriptions.
     */
    initPerfPlanSubscriptions(planIndex) {
        if (this.perfPlanSubscriptions[planIndex]) {
            return;
        }
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(planIndex);
        const entry = this.getVerticalFlightPathEntry(planIndex);
        const handler = () => {
            entry.needsRebuild = true;
        };
        const speedHandler = (mode, activeMode) => {
            if (mode.get() === activeMode) {
                entry.needsRebuild = true;
            }
        };
        const approachSpeedHandler = () => {
            const verticalPlan = this.verticalFlightPlans[planIndex];
            verticalPlan && (verticalPlan.planChanged = true);
        };
        const climbSelSpeedHandler = speedHandler.bind(this, perfPlan.speedClimbMode, SpeedMode.SEL);
        const cruiseSelSpeedHandler = speedHandler.bind(this, perfPlan.speedCruiseMode, SpeedMode.SEL);
        const descentSelSpeedHandler = speedHandler.bind(this, perfPlan.speedDescentMode, SpeedMode.SEL);
        const cruiseAltHandler = () => {
            entry.needsRebuild = true;
            entry.needsSetLastCruiseStepStart = true;
        };
        this.perfPlanSubscriptions[planIndex] = [
            perfPlan.speedClimbMode.sub(handler),
            perfPlan.speedClimbSelectCas.sub(climbSelSpeedHandler),
            perfPlan.speedClimbSelectMach.sub(climbSelSpeedHandler),
            perfPlan.speedCruiseMode.sub(handler),
            perfPlan.speedCruiseSelectCas.sub(cruiseSelSpeedHandler),
            perfPlan.speedCruiseSelectMach.sub(cruiseSelSpeedHandler),
            perfPlan.speedDescentMode.sub(handler),
            perfPlan.speedDescentSelectCas.sub(descentSelSpeedHandler),
            perfPlan.speedDescentSelectMach.sub(descentSelSpeedHandler),
            perfPlan.cruiseAltitude.sub(cruiseAltHandler),
            perfPlan.stepSize.sub(handler),
            perfPlan.climbSpeedLimitAltitude.sub(handler),
            perfPlan.climbSpeedLimitCas.sub(handler),
            perfPlan.climbSpeedRestrAltitude.sub(handler),
            perfPlan.climbSpeedRestrCas.sub(handler),
            perfPlan.descentSpeedLimitAltitude.sub(handler),
            perfPlan.descentSpeedLimitCas.sub(handler),
            perfPlan.descentSpeedRestrAltitude.sub(handler),
            perfPlan.descentSpeedRestrCas.sub(handler),
            perfPlan.approachFlapSpeed.sub(approachSpeedHandler),
            perfPlan.approachWindCorrection.sub(approachSpeedHandler)
        ];
    }
    /** @inheritdoc */
    computePath(lateralPlan, verticalPlan) {
        var _a, _b, _c, _d, _e;
        const verticalPathEntry = this.getVerticalFlightPathEntry(verticalPlan.planIndex);
        this.initPerfPlanSubscriptions(verticalPlan.planIndex);
        if (verticalPathEntry.needsRebuild) {
            this.buildVerticalFlightPath(lateralPlan, verticalPathEntry);
        }
        const verticalPath = verticalPathEntry.path;
        verticalPath.isPending = false;
        const activeLegIndex = this.lnavTrackedLegIndex.get();
        const activeDistanceToLegEnd = Math.max(0, UnitType.NMILE.convertTo(this.lnavLegDistanceRemaining.get(), UnitType.METER));
        // TODO: Support engine-out ops.
        const engineCount = this.engineCount;
        // Compute FPAs for geometric descent segment.
        this.computeDescentPath(lateralPlan, verticalPlan);
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(verticalPlan.planIndex);
        const climbSpeedMode = perfPlan.speedClimbMode.get();
        const cruiseSpeedMode = perfPlan.speedCruiseMode.get();
        const descentSpeedMode = perfPlan.speedDescentMode.get();
        let initialCruiseAltitude = perfPlan.cruiseAltitude.get();
        const zfw = perfPlan.manualZfw.get();
        let climbCas, climbMach;
        let cruiseCas, cruiseMach;
        let descentCas, descentMach;
        if (climbSpeedMode === SpeedMode.SEL) {
            climbCas = perfPlan.speedClimbSelectCas.get();
            climbMach = perfPlan.speedClimbSelectMach.get();
        }
        else {
            climbCas = perfPlan.speedClimbEconCas.get();
            climbMach = perfPlan.speedClimbEconMach.get();
        }
        if (cruiseSpeedMode === SpeedMode.SEL) {
            cruiseCas = perfPlan.speedCruiseSelectCas.get();
            cruiseMach = perfPlan.speedCruiseSelectMach.get();
        }
        else {
            cruiseCas = perfPlan.speedCruiseEconCas.get();
            cruiseMach = perfPlan.speedCruiseEconMach.get();
        }
        if (descentSpeedMode === SpeedMode.SEL) {
            descentCas = perfPlan.speedDescentSelectCas.get();
            descentMach = perfPlan.speedDescentSelectMach.get();
        }
        else {
            descentCas = perfPlan.speedDescentEconCas.get();
            descentMach = perfPlan.speedDescentEconMach.get();
        }
        if (initialCruiseAltitude === null
            || zfw === null
            || (climbCas === null && climbMach === null)
            || (cruiseCas === null && cruiseMach === null)
            || (descentCas === null && descentMach === null)) {
            this.clearVerticalPath(verticalPathEntry);
            return;
        }
        const maprStartLegIndex = (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : -1;
        const firstDescentConstraintLegIndex = (_b = verticalPlan.firstDescentConstraintLegIndex) !== null && _b !== void 0 ? _b : -1;
        const lastSimulatedLegIndex = maprStartLegIndex < 0 ? lateralPlan.length : maprStartLegIndex;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const isPastCalculatedTod = verticalPath.todLegIndex !== undefined && verticalPath.todDistanceToLegEnd !== undefined
            && (activeLegIndex > verticalPath.todLegIndex
                || (activeLegIndex === verticalPath.todLegIndex && activeDistanceToLegEnd <= verticalPath.todDistanceToLegEnd));
        climbCas !== null && climbCas !== void 0 ? climbCas : (climbCas = Infinity);
        climbMach !== null && climbMach !== void 0 ? climbMach : (climbMach = Infinity);
        cruiseCas !== null && cruiseCas !== void 0 ? cruiseCas : (cruiseCas = Infinity);
        cruiseMach !== null && cruiseMach !== void 0 ? cruiseMach : (cruiseMach = Infinity);
        descentCas !== null && descentCas !== void 0 ? descentCas : (descentCas = Infinity);
        descentMach !== null && descentMach !== void 0 ? descentMach : (descentMach = Infinity);
        initialCruiseAltitude = UnitType.FOOT.convertTo(initialCruiseAltitude, UnitType.METER);
        climbCas = UnitType.KNOT.convertTo(climbCas, UnitType.MPS);
        cruiseCas = UnitType.KNOT.convertTo(cruiseCas, UnitType.MPS);
        descentCas = UnitType.KNOT.convertTo(descentCas, UnitType.MPS);
        const climbThrustMode = perfPlan.climbThrustMode.get();
        const currentAltitude = UnitType.FOOT.convertTo(this.indicatedAltitude.get(), UnitType.METER);
        const currentWeight = zfw + this.fob.get();
        const costIndex = (_c = perfPlan.costIndex.get()) !== null && _c !== void 0 ? _c : 180;
        let climbTransitionAltitude = perfPlan.climbSpeedLimitAltitude.get();
        if (climbTransitionAltitude !== null) {
            climbTransitionAltitude = UnitType.FOOT.convertTo(climbTransitionAltitude, UnitType.METER);
        }
        let climbTransitionCas = perfPlan.climbSpeedLimitCas.get();
        if (climbTransitionCas !== null) {
            climbTransitionCas = UnitType.KNOT.convertTo(climbTransitionCas, UnitType.MPS);
        }
        let climbRestrictionAltitude = perfPlan.climbSpeedRestrAltitude.get();
        if (climbRestrictionAltitude !== null) {
            climbRestrictionAltitude = UnitType.FOOT.convertTo(climbRestrictionAltitude, UnitType.METER);
        }
        let climbRestrictionCas = perfPlan.climbSpeedRestrCas.get();
        if (climbRestrictionCas !== null) {
            climbRestrictionCas = UnitType.KNOT.convertTo(climbRestrictionCas, UnitType.MPS);
        }
        let descentTransitionAltitude = perfPlan.descentSpeedLimitAltitude.get();
        if (descentTransitionAltitude !== null) {
            descentTransitionAltitude = UnitType.FOOT.convertTo(descentTransitionAltitude, UnitType.METER);
        }
        let descentTransitionCas = perfPlan.descentSpeedLimitCas.get();
        if (descentTransitionCas !== null) {
            descentTransitionCas = UnitType.KNOT.convertTo(descentTransitionCas, UnitType.MPS);
        }
        let descentRestrictionAltitude = perfPlan.descentSpeedRestrAltitude.get();
        if (descentRestrictionAltitude !== null) {
            descentRestrictionAltitude = UnitType.FOOT.convertTo(descentRestrictionAltitude, UnitType.METER);
        }
        let descentRestrictionCas = perfPlan.descentSpeedRestrCas.get();
        if (descentRestrictionCas !== null) {
            descentRestrictionCas = UnitType.KNOT.convertTo(descentRestrictionCas, UnitType.MPS);
        }
        const stepSize = perfPlan.stepSize.get();
        let stepSizeAltitude;
        switch (stepSize) {
            case 'ICAO':
                stepSizeAltitude = 4000;
                break;
            case 'RVSM':
                stepSizeAltitude = 2000;
                break;
            default:
                stepSizeAltitude = stepSize;
        }
        stepSizeAltitude = UnitType.FOOT.convertTo(stepSizeAltitude, UnitType.METER);
        const lateralLegs = [...lateralPlan.legs()];
        if (!isPastCalculatedTod) {
            const clearEndIndex = Math.min(verticalPath.legs.length, activeLegIndex);
            for (let i = 0; i < clearEndIndex; i++) {
                verticalPath.legs[i].vectors.length = 0;
                verticalPath.legs[i].simDistance = 0;
            }
            verticalPath.tocLegIndex = undefined;
            verticalPath.tocVectorIndex = undefined;
            verticalPath.tocDistanceToLegEnd = undefined;
            verticalPath.tocWeight = undefined;
            // Only simulate the climb if we have not yet sequenced the first descent constraint (if one exists).
            if (firstDescentConstraintLegIndex < 0 || activeLegIndex <= firstDescentConstraintLegIndex) {
                // If we are already past the TOC, then do not simulate climb. Instead, any deviation from the cruise altitude
                // will be treated as a cruise step climb or descent.
                if (!verticalPathEntry.isTocSequenced) {
                    this.simulateClimb(lateralLegs, verticalPlan, verticalPathEntry, climbThrustMode, climbCas, climbMach, climbTransitionAltitude, climbTransitionCas, climbRestrictionAltitude, climbRestrictionCas, initialCruiseAltitude, activeLegIndex, activeDistanceToLegEnd, currentAltitude, currentWeight, lastSimulatedLegIndex, false, engineCount);
                }
                if (verticalPathEntry.lastTocLegIndex === undefined) {
                    // If lastTocLegIndex is not defined, this means that this is the first time the path has been computed since
                    // it was (re)built and we are already at or above the cruise altitude. In this case, we will treat the
                    // airplane's current along-track position as the TOC.
                    verticalPathEntry.lastTocLegIndex = activeLegIndex;
                    verticalPathEntry.lastTocDistanceToLegEnd = activeDistanceToLegEnd;
                    verticalPathEntry.isTocSequenced = true;
                }
                else {
                    // We are considered to be past the TOC if the cruise simulation did not run, which can only happen if we
                    // were already past the TOC or if were not originally past the TOC but we are now at or above the cruise
                    // altitude.
                    verticalPathEntry.isTocSequenced = verticalPath.tocLegIndex === undefined;
                }
            }
            else {
                verticalPathEntry.isTocSequenced = true;
            }
            if (verticalPathEntry.needsSetLastCruiseStepStart) {
                if (verticalPathEntry.isTocSequenced) {
                    verticalPathEntry.lastCruiseStepStartLegIndex = activeLegIndex;
                    verticalPathEntry.lastCruiseStepStartDistanceToLegEnd = activeDistanceToLegEnd;
                }
                verticalPathEntry.needsSetLastCruiseStepStart = false;
            }
            const selCruiseCas = cruiseSpeedMode === SpeedMode.SEL ? cruiseCas : null;
            const selCruiseMach = cruiseSpeedMode === SpeedMode.SEL ? cruiseMach : null;
            this.computeCruiseSteps(lateralLegs, verticalPlan, verticalPathEntry, costIndex, initialCruiseAltitude, stepSizeAltitude, climbThrustMode, selCruiseCas, selCruiseMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
            this.simulateCruise(lateralLegs, verticalPlan, verticalPathEntry, costIndex, initialCruiseAltitude, climbThrustMode, selCruiseCas, selCruiseMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, currentAltitude, activeLegIndex, activeDistanceToLegEnd, currentWeight, lastSimulatedLegIndex, engineCount);
            let needResetComputedDescentData = true;
            // If there exists at least one descent constraint, then we need to simulate the performance descent.
            if (firstDescentConstraintIndex >= 0) {
                const firstDescentConstraintAltitude = firstDescentConstraint.legs[0].altitude;
                if (isFinite(firstDescentConstraintAltitude)) {
                    const finalCruiseAltitude = (_e = (_d = verticalPath.cruiseSteps[verticalPath.cruiseSteps.length - 1]) === null || _d === void 0 ? void 0 : _d.toAltitude) !== null && _e !== void 0 ? _e : initialCruiseAltitude;
                    if (finalCruiseAltitude > firstDescentConstraintAltitude) {
                        // Cruise altitude is above the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist of a level deceleration segment + an idle descent segment that
                        // intercepts the geometric descent path at the first descent constraint.
                        this.computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, finalCruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
                    }
                    else {
                        // Cruise altitude is at or below the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist only of a level deceleration segment that intercepts the geometric
                        // descent path at some point past the first descent constraint. Alternatively, if the geometric descent
                        // path never descends below the cruise altitude, there will be no descent.
                        this.computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, finalCruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
                    }
                    needResetComputedDescentData = false;
                }
            }
            if (needResetComputedDescentData) {
                this.resetVerticalPathComputedDescentData(verticalPathEntry);
            }
            // Compute predicted cruise distance and duration. Both values require a computed TOC and TOD. If the TOD is
            // before the TOC, then clamp the values to zero.
            if (verticalPath.tocLegIndex !== undefined && verticalPath.tocVectorIndex !== undefined
                && verticalPath.todLegIndex !== undefined && verticalPath.todVectorIndex !== undefined) {
                verticalPath.predictedCruiseDistance = 0;
                verticalPath.predictedCruiseDuration = 0;
                for (let i = verticalPath.tocLegIndex; i <= verticalPath.todLegIndex; i++) {
                    const leg = verticalPath.legs[i];
                    const vectorStartIndex = i === verticalPath.tocLegIndex ? verticalPath.tocVectorIndex + 1 : 0;
                    const vectorEndIndex = i === verticalPath.todLegIndex ? verticalPath.todVectorIndex : leg.vectors.length;
                    for (let j = vectorStartIndex; j < vectorEndIndex; j++) {
                        const vector = leg.vectors[j];
                        verticalPath.predictedCruiseDistance += vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
                        verticalPath.predictedCruiseDuration += vector.duration;
                    }
                }
            }
            else {
                verticalPath.predictedCruiseDistance = undefined;
                verticalPath.predictedCruiseDuration = undefined;
            }
        }
        else {
            // We are past the calculated TOD. In this case, we will not recalculate the TOD. However, if we are still in
            // the performance descent segment, we need to adjust the vertical path vectors to account for any changes in
            // lateral leg distances.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && (activeLegIndex < verticalPath.geoDescentSimInterceptLegIndex
                    || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex
                        && activeDistanceToLegEnd > verticalPath.geoDescentSimInterceptDistanceToLegEnd))) {
                this.adjustPerformanceDescent(lateralLegs, verticalPath);
            }
            // If we are past the TOD, then predicted cruise distance and duration are undefined.
            verticalPath.predictedCruiseDistance = undefined;
            verticalPath.predictedCruiseDuration = undefined;
        }
        if (maprStartLegIndex < 0 || activeLegIndex < maprStartLegIndex) {
            // We are not in the missed approach.
            this.simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
        }
    }
    /**
     * Clears a vertical flight path of all vectors and resets all computed data stored in the path.
     * @param verticalPathEntry The entry for the vertical flight path to clear.
     */
    clearVerticalPath(verticalPathEntry) {
        const verticalPath = verticalPathEntry.path;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            leg.vectors.length = 0;
            leg.simDistance = 0;
        }
        verticalPath.cruiseSteps.length = 0;
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocVectorIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.predictedCruiseDistance = undefined;
        verticalPath.predictedCruiseDuration = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todVectorIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptVectorIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        verticalPathEntry.lastTocLegIndex = undefined;
        verticalPathEntry.lastTocDistanceToLegEnd = undefined;
        verticalPathEntry.isTocSequenced = false;
        verticalPathEntry.lastCruiseStepStartLegIndex = undefined;
        verticalPathEntry.lastCruiseStepStartDistanceToLegEnd = undefined;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Resets stored computed TOD and descent data in a vertical flight path.
     * @param verticalPathEntry The entry for the vertical flight path to reset.
     */
    resetVerticalPathComputedDescentData(verticalPathEntry) {
        const verticalPath = verticalPathEntry.path;
        verticalPath.todLegIndex = undefined;
        verticalPath.todVectorIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptVectorIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
    }
    /**
     * Gets the name of the method in {@link BoeingEngineDataProvider} that provides the target climb N1 for a given
     * climb thrust mode.
     * @param mode The climb thrust mode for which to get the N1 method name.
     * @returns The name of the method in {@link BoeingEngineDataProvider} that provides the target climb N1 for the
     * specified climb thrust mode.
     */
    getClimbN1MethodName(mode) {
        switch (mode) {
            case ClimbThrustMode.CLB1:
                return 'getClb1N1';
            case ClimbThrustMode.CLB2:
                return 'getClb2N1';
            default:
                return 'getClbMaxN1';
        }
    }
    /**
     * Calculates cruise steps for a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation.
     * @param costIndex The cost index to use when converting time cost to fuel equivalents, in (dollars per hour) per
     * (cents per pound of fuel).
     * @param cruiseAltitude The initial cruise altitude, in meters above MSL.
     * @param stepSize The cruise step size, in meters.
     * @param climbThrustMode The climb thrust mode to use during step climbs.
     * @param selCruiseCas The selected cruise calibrated airspeed, in meters per second, or `null` if there is no such
     * speed.
     * @param selCruiseMach The selected cruise mach number, or `null` if there is no such speed.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    computeCruiseSteps(lateralLegs, verticalPlan, verticalPathEntry, costIndex, cruiseAltitude, stepSize, climbThrustMode, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        var _x, _y;
        const verticalPath = verticalPathEntry.path;
        const plannedCruiseSteps = this._getPlannedCruiseStepList(verticalPlan.planIndex);
        const activePlannedCruiseStepIndex = this.getNextPlannedCruiseStepIndex(verticalPlan.planIndex, activeLegIndex);
        const cruiseSteps = verticalPath.cruiseSteps;
        let startLegIndex = activeLegIndex;
        let startDistanceToLegEnd = activeDistanceToLegEnd;
        let startWeight = activeWeight;
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight) {
            startLegIndex = verticalPath.tocLegIndex;
            startDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
            startWeight = verticalPath.tocWeight;
        }
        let startLeg = lateralLegs[startLegIndex];
        while (startLegIndex < lateralLegs.length - 1 && startDistanceToLegEnd <= 0) {
            startLegIndex++;
            startLeg = lateralLegs[startLegIndex];
            startDistanceToLegEnd = (_b = (_a = startLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
        }
        let startPlannedCruiseStepIndex = activePlannedCruiseStepIndex;
        // Invalidate all planned cruise steps between the active leg and the starting leg.
        if (activePlannedCruiseStepIndex >= 0) {
            for (let i = activePlannedCruiseStepIndex; i < plannedCruiseSteps.length; i++) {
                const step = plannedCruiseSteps[i];
                if (step.globalLegIndex < startLegIndex) {
                    step.isInvalid = true;
                    step.deferredDistance = 0;
                }
                else {
                    startPlannedCruiseStepIndex = i;
                    break;
                }
            }
        }
        // Remove all cruise steps before the last-calculated TOC (or the airplane's along-track position if the
        // last-calculated TOC is undefined).
        let lastTocLegIndex;
        let lastTocDistanceToLegEnd;
        if (verticalPathEntry.lastTocLegIndex !== undefined && verticalPathEntry.lastTocDistanceToLegEnd !== undefined) {
            lastTocLegIndex = verticalPathEntry.lastTocLegIndex;
            lastTocDistanceToLegEnd = verticalPathEntry.lastTocDistanceToLegEnd;
        }
        else {
            lastTocLegIndex = activeLegIndex;
            lastTocDistanceToLegEnd = activeDistanceToLegEnd;
        }
        let startCruiseStepIndex = cruiseSteps.length;
        for (let i = 0; i < cruiseSteps.length; i++) {
            const step = cruiseSteps[i];
            if (step.globalLegIndex > lastTocLegIndex
                || (step.globalLegIndex === lastTocLegIndex && step.distanceToLegEnd < lastTocDistanceToLegEnd)) {
                startCruiseStepIndex = i;
                break;
            }
        }
        if (startCruiseStepIndex > 0) {
            cruiseSteps.splice(0, startCruiseStepIndex);
        }
        // Find the index at which to start writing cruise steps. We want to preserve all cruise steps between the
        // last-calculated TOC and the starting position.
        startCruiseStepIndex = cruiseSteps.length;
        for (let i = 0; i < cruiseSteps.length; i++) {
            const step = cruiseSteps[i];
            if (step.globalLegIndex > startLegIndex
                || (step.globalLegIndex === startLegIndex && step.distanceToLegEnd < startDistanceToLegEnd)) {
                startCruiseStepIndex = i;
                break;
            }
        }
        const endLegIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? ((_c = verticalPlan.missedApproachStartIndex) !== null && _c !== void 0 ? _c : lateralLegs.length)
            : verticalPlan.firstDescentConstraintLegIndex + 1;
        // If we are already past the last eligible leg to be simulated or there are no potential future cruise steps,
        // then we don't need to proceed any further.
        if (startLegIndex >= endLegIndex || (startPlannedCruiseStepIndex < 0 && stepSize === 0)) {
            // Invalidate all planned cruise steps after the starting leg.
            if (startPlannedCruiseStepIndex >= 0) {
                for (let i = startPlannedCruiseStepIndex; i < plannedCruiseSteps.length; i++) {
                    const step = plannedCruiseSteps[i];
                    step.isInvalid = true;
                    step.deferredDistance = 0;
                }
            }
            // Remove all cruise steps after the starting leg.
            cruiseSteps.length = startCruiseStepIndex;
            return;
        }
        const wingArea = this.perfProvider.getWingArea();
        const climbN1MethodName = this.getClimbN1MethodName(climbThrustMode);
        let distanceToEnd = startDistanceToLegEnd;
        for (let i = startLegIndex + 1; i < endLegIndex; i++) {
            distanceToEnd += (_e = (_d = lateralLegs[i].calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
        }
        let distanceFromLastCruiseStepStart = 0;
        let lastCruiseStepStartLegIndex;
        let lastCruiseStepStartDistanceToLegEnd;
        // Set the position of the start of the last cruise step to (in order of decreasing priority):
        // 1. The most recently sequenced predicted cruise step evaluated from the starting position. Such a cruise step is
        // guaranteed to be at or after the most recently initiated cruise step because initiating a cruise step clears
        // all predicted cruise steps.
        // 2. The point at which the most recent cruise step was initiated.
        // 3. The TOC.
        //
        // Additionally, set the starting cruise altitude to the target altitude of the sequenced predicted cruise step if
        // one exists.
        const lastCruiseStep = cruiseSteps[startCruiseStepIndex - 1];
        if (lastCruiseStep) {
            lastCruiseStepStartLegIndex = lastCruiseStep.globalLegIndex;
            lastCruiseStepStartDistanceToLegEnd = lastCruiseStep.distanceToLegEnd;
            cruiseAltitude = lastCruiseStep.toAltitude;
        }
        else if (verticalPathEntry.lastCruiseStepStartLegIndex !== undefined && verticalPathEntry.lastCruiseStepStartDistanceToLegEnd !== undefined) {
            lastCruiseStepStartLegIndex = verticalPathEntry.lastCruiseStepStartLegIndex;
            lastCruiseStepStartDistanceToLegEnd = verticalPathEntry.lastCruiseStepStartDistanceToLegEnd;
        }
        else {
            lastCruiseStepStartLegIndex = lastTocLegIndex;
            lastCruiseStepStartDistanceToLegEnd = lastTocDistanceToLegEnd;
        }
        if (lastCruiseStepStartLegIndex < startLegIndex) {
            distanceFromLastCruiseStepStart = lastCruiseStepStartDistanceToLegEnd;
            for (let i = lastCruiseStepStartLegIndex + 1; i < startLegIndex; i++) {
                distanceFromLastCruiseStepStart += (_g = (_f = lateralLegs[i].calculated) === null || _f === void 0 ? void 0 : _f.distanceWithTransitions) !== null && _g !== void 0 ? _g : 0;
            }
            distanceFromLastCruiseStepStart += ((_j = (_h = startLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0) - startDistanceToLegEnd;
        }
        else if (lastCruiseStepStartLegIndex === startLegIndex) {
            distanceFromLastCruiseStepStart = Math.max(0, lastCruiseStepStartDistanceToLegEnd - startDistanceToLegEnd);
        }
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        const isSelCruiseSpeed = selCruiseCas !== null || selCruiseMach !== null;
        let currentAltitude = cruiseAltitude;
        let targetAltitude = cruiseAltitude;
        let currentLegIndex = startLegIndex;
        let currentLeg = startLeg;
        let currentLegDistance = (_l = (_k = startLeg.calculated) === null || _k === void 0 ? void 0 : _k.distanceWithTransitions) !== null && _l !== void 0 ? _l : 0;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentWeight = startWeight;
        let nextPlannedCruiseStepIndex = startPlannedCruiseStepIndex;
        let nextPlannedCruiseStep = plannedCruiseSteps[nextPlannedCruiseStepIndex];
        let currentPlannedCruiseStepIndex = -1;
        let currentPlannedCruiseStep = undefined;
        let currentPlannedCruiseStepDeferredDistance = 0;
        let currentCruiseStepIndex = startCruiseStepIndex;
        let hasInitiatedStepDescent = false;
        let distanceToNextEvaluatePoint = Infinity;
        if (!nextPlannedCruiseStep) {
            distanceToNextEvaluatePoint = BoeingPathCalculator.CRUISE_STEP_START_MARGIN - distanceFromLastCruiseStepStart;
            if (distanceToNextEvaluatePoint < 0) {
                distanceToNextEvaluatePoint += Math.ceil(-distanceToNextEvaluatePoint / BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP) * BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP;
            }
        }
        let isLastValidPlannedCruiseStepDescend = false;
        if (startCruiseStepIndex > 0) {
            const lastSequencedCruiseStep = cruiseSteps[startCruiseStepIndex - 1];
            isLastValidPlannedCruiseStepDescend = lastSequencedCruiseStep.plannedStepIndex >= 0 && lastSequencedCruiseStep.toAltitude < lastSequencedCruiseStep.fromAltitude;
        }
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        // This is a very rough approximation, but our margins are large enough (hundreds of NM) to cushion the expected
        // error.
        let descentDistance = firstDescentConstraint
            ? VNavUtils.distanceForAltitude(-3, Math.min(firstDescentConstraint.legs[0].altitude, cruiseAltitude) - cruiseAltitude)
            : 0;
        let currentCruiseCas = selCruiseCas !== null && selCruiseCas !== void 0 ? selCruiseCas : Infinity;
        let currentCruiseMach = selCruiseMach !== null && selCruiseMach !== void 0 ? selCruiseMach : Infinity;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let legCourse = undefined;
        let legCourseIndex = undefined;
        let windDirection = undefined;
        let windSpeed = undefined;
        let headwind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        let lastWeatherAltitude = currentAltitude;
        while (distanceToEnd - descentDistance > BoeingPathCalculator.CRUISE_STEP_TOD_MARGIN && currentLegIndex < endLegIndex) {
            // ---- Update planned cruise step ----
            if (nextPlannedCruiseStep && currentLegIndex > nextPlannedCruiseStep.globalLegIndex) {
                if (currentPlannedCruiseStep) {
                    // If we still have not been able to execute the current planned cruise step, then invalidate it.
                    currentPlannedCruiseStep.isInvalid = true;
                    currentPlannedCruiseStep.deferredDistance = 0;
                }
                currentPlannedCruiseStepIndex = nextPlannedCruiseStepIndex;
                currentPlannedCruiseStep = nextPlannedCruiseStep;
                currentPlannedCruiseStepDeferredDistance = 0;
                nextPlannedCruiseStep = plannedCruiseSteps[++nextPlannedCruiseStepIndex];
            }
            // ---- Update speed constraint ----
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (currentLegDistance > 0) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                // ---- Update average leg course ----
                if (legCourseIndex !== currentLegIndex) {
                    legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    legCourseIndex = currentLegIndex;
                }
                // ---- Compute ambient conditions ----
                // Check if we need to update winds and delta ISA offset.
                if (currentLegIndex !== lastWeatherLegIndex || Math.abs(currentAltitude - lastWeatherAltitude) > 30.48) {
                    const windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, currentLegDistance - distanceToLegEnd, BoeingPathCalculator.windCache);
                    if (windVector !== null) {
                        [windDirection, windSpeed] = windVector;
                        if (legCourse !== undefined) {
                            headwind = -BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windDirection, windSpeed);
                        }
                        else {
                            headwind = 0;
                        }
                    }
                    else {
                        windDirection = undefined;
                        windSpeed = undefined;
                        headwind = 0;
                    }
                    deltaIsa = (_m = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, currentLegDistance - distanceToLegEnd)) !== null && _m !== void 0 ? _m : 0;
                    lastWeatherLegIndex = currentLegIndex;
                    lastWeatherAltitude = currentAltitude;
                }
                const pressure = AeroMath.isaPressure(currentAltitude);
                const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
                const density = AeroMath.densityAir(pressure, temperature);
                const soundSpeed = AeroMath.soundSpeedAir(temperature);
                // ---- Compute the current simulation step's target speed ----
                if (!isSelCruiseSpeed) {
                    [currentCruiseCas, currentCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, currentAltitudeFeet, currentWeight, headwind, BoeingPathCalculator.econSpeedCache, pressure);
                    currentCruiseCas = UnitType.KNOT.convertTo(currentCruiseCas, UnitType.MPS);
                }
                // Initiating a step descent will remove transition and restriction speed limits if stepping below their
                // respective altitudes, so neither speed limit will ever be in effect after a step descent (unless the pilot
                // takes action to restore them, but for the purposes of the simulation we will assume this doesn't happen).
                const useTransitionCas = canUseTransitionCas && !hasInitiatedStepDescent && currentAltitude < transitionAltitude;
                const useRestrictionCas = canUseRestrictionCas && !hasInitiatedStepDescent && currentAltitude < restrictionAltitude;
                const targetCas = BoeingPathCalculator.getTargetCas(currentCruiseCas, currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined);
                const targetMach = BoeingPathCalculator.getTargetMach(currentCruiseMach, currentSpeedConstraint);
                const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
                let mach = AeroMath.casToMach(casToTarget, pressure);
                let tas = AeroMath.machToTas(mach, soundSpeed);
                const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
                let cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                // ---- Evaluate planned cruise steps ----
                let targetAltitudeFeet;
                let pressureAtTarget;
                let temperatureAtTarget;
                let machAtTarget;
                if (targetAltitude === currentAltitude && currentPlannedCruiseStep) {
                    let executedPlannedStepIndex = -1;
                    if (currentPlannedCruiseStep.toAltitude !== currentAltitude) {
                        if (currentPlannedCruiseStep.toAltitude > currentAltitude) {
                            // If the current planned cruise step steps to a higher altitude, then we need to check if we can climb
                            // to the target altitude.
                            const maxAltitude = this.engineDataProvider.getMaximumAltitude(currentWeight);
                            targetAltitudeFeet = UnitType.METER.convertTo(targetAltitude, UnitType.FOOT);
                            if (targetAltitudeFeet <= maxAltitude) {
                                pressureAtTarget = AeroMath.isaPressure(targetAltitude);
                                temperatureAtTarget = AeroMath.isaTemperature(targetAltitude)
                                    + ((_o = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, targetAltitudeFeet, currentLegDistance - distanceToLegEnd)) !== null && _o !== void 0 ? _o : 0);
                                let targetCruiseCas = currentCruiseCas;
                                let targetCruiseMach = currentCruiseMach;
                                if (!isSelCruiseSpeed) {
                                    [targetCruiseCas, targetCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, targetAltitudeFeet, currentWeight, 0, BoeingPathCalculator.econSpeedCache, pressureAtTarget);
                                    targetCruiseCas = UnitType.KNOT.convertTo(targetCruiseCas, UnitType.MPS);
                                }
                                machAtTarget = Math.min(AeroMath.casToMach(BoeingPathCalculator.getTargetCas(targetCruiseCas, currentSpeedConstraint, canUseRestrictionCas && targetAltitude < restrictionAltitude ? restrictionCas : undefined, canUseTransitionCas && targetAltitude < transitionAltitude ? transitionCas : undefined), pressureAtTarget), BoeingPathCalculator.getTargetMach(targetCruiseMach, currentSpeedConstraint));
                                const residualVs = this.getClimbVerticalSpeed(climbN1MethodName, targetAltitude, wingArea, pressureAtTarget, temperatureAtTarget, machAtTarget, currentWeight, engineCount);
                                if (residualVs >= BoeingPathCalculator.CRUISE_STEP_CLIMB_RESIDUAL_VS_MPS) {
                                    executedPlannedStepIndex = currentPlannedCruiseStepIndex;
                                    currentPlannedCruiseStep.isInvalid = false;
                                    currentPlannedCruiseStep.deferredDistance = currentPlannedCruiseStepDeferredDistance;
                                    targetAltitude = currentPlannedCruiseStep.toAltitude;
                                    currentPlannedCruiseStepIndex = -1;
                                    currentPlannedCruiseStep = undefined;
                                }
                            }
                        }
                        else {
                            executedPlannedStepIndex = currentPlannedCruiseStepIndex;
                            currentPlannedCruiseStep.isInvalid = false;
                            currentPlannedCruiseStep.deferredDistance = currentPlannedCruiseStepDeferredDistance;
                            targetAltitude = currentPlannedCruiseStep.toAltitude;
                            currentPlannedCruiseStepIndex = -1;
                            currentPlannedCruiseStep = undefined;
                        }
                    }
                    else {
                        // If the current planned cruise step steps to the current altitude, then there is nothing to do except
                        // validate the cruise step.
                        currentPlannedCruiseStep.isInvalid = false;
                        currentPlannedCruiseStep.deferredDistance = 0;
                        currentPlannedCruiseStepIndex = -1;
                        currentPlannedCruiseStep = undefined;
                    }
                    if (executedPlannedStepIndex >= 0) {
                        const step = (_p = cruiseSteps[_x = currentCruiseStepIndex++]) !== null && _p !== void 0 ? _p : (cruiseSteps[_x] = BoeingPathCalculator.createCruiseStep());
                        step.globalLegIndex = currentLegIndex;
                        step.distanceToLegEnd = distanceToLegEnd;
                        step.fromAltitude = currentAltitude;
                        step.toAltitude = plannedCruiseSteps[executedPlannedStepIndex].toAltitude;
                        step.plannedStepIndex = executedPlannedStepIndex;
                        isLastValidPlannedCruiseStepDescend = step.toAltitude < step.fromAltitude;
                    }
                }
                // ---- Evaluate computed cruise steps ----
                // Computed cruise steps can only be evaluated after we have sequenced all planned cruise steps.
                if (!nextPlannedCruiseStep && !currentPlannedCruiseStep) {
                    if (stepSize <= 0 || isLastValidPlannedCruiseStepDescend) {
                        // If the step size is zero or the last valid planned cruise step was a step descent, then immediately exit
                        // the loop because we will not be evaluating any computed cruise steps.
                        break;
                    }
                    else if (
                    // To evaluate computed cruise steps...
                    // ... we must not be stepping to a different cruise altitude...
                    targetAltitude === currentAltitude
                        // ... and we must be at or past the next evaluation point.
                        && distanceToNextEvaluatePoint < 1) {
                        const simulateDistance = Math.min(distanceToEnd, BoeingPathCalculator.CRUISE_STEP_EVALUATE_LOOKAHEAD);
                        const currentAltitudeCost = this.evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, currentAltitude, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, currentLegIndex, distanceToLegEnd, currentWeight, endLegIndex, simulateDistance, engineCount);
                        // Evaluate all cruise altitudes we can step to from the current altitude from 9000 below the current
                        // altitude to the maximum cruise altitude.
                        // TODO: Determine if we need to limit the number of evaluated steps to e.g. 2 below + 2 above for perf reasons.
                        let recommendedAltitude = currentAltitude;
                        let recommendedAltitudeCost = currentAltitudeCost;
                        const minAltitude = Math.max(0, currentAltitude - 2743.2);
                        const maxAltitude = UnitType.FOOT.convertTo(this.engineDataProvider.getMaximumAltitude(currentWeight), UnitType.METER);
                        // Step descents.
                        let evaluateAltitude = currentAltitude - stepSize;
                        while (evaluateAltitude >= minAltitude) {
                            const evaluateAltitudeCost = this.evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, evaluateAltitude, selCruiseCas, selCruiseMach, 
                            // Initiating a step descent will remove transition and restriction speed limits if stepping below
                            // their respective altitudes, so neither speed limit will ever be in effect after a step descent
                            // (unless the pilot takes action to restore them, but for the purposes of the simulation we will
                            // assume this doesn't happen).
                            null, null, null, null, currentLegIndex, distanceToLegEnd, currentWeight, endLegIndex, simulateDistance, engineCount) + Math.abs(evaluateAltitude - currentAltitude) * this.cruiseStepCostBias;
                            if (evaluateAltitudeCost < recommendedAltitudeCost) {
                                recommendedAltitude = evaluateAltitude;
                                recommendedAltitudeCost = evaluateAltitudeCost;
                            }
                            evaluateAltitude -= stepSize;
                        }
                        // Step climbs.
                        evaluateAltitude = currentAltitude + stepSize;
                        while (evaluateAltitude <= maxAltitude) {
                            const pressureAtEval = AeroMath.isaPressure(evaluateAltitude);
                            const temperatureAtEval = AeroMath.isaTemperature(evaluateAltitude)
                                + ((_q = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, UnitType.METER.convertTo(evaluateAltitude, UnitType.FOOT), currentLegDistance - distanceToLegEnd)) !== null && _q !== void 0 ? _q : 0);
                            let evalCruiseCas = currentCruiseCas;
                            let evalCruiseMach = currentCruiseMach;
                            if (!isSelCruiseSpeed) {
                                [evalCruiseCas, evalCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, UnitType.METER.convertTo(evaluateAltitude, UnitType.FOOT), currentWeight, 0, BoeingPathCalculator.econSpeedCache, pressureAtEval);
                                evalCruiseCas = UnitType.KNOT.convertTo(evalCruiseCas, UnitType.MPS);
                            }
                            const machAtEval = Math.min(AeroMath.casToMach(BoeingPathCalculator.getTargetCas(evalCruiseCas, currentSpeedConstraint, canUseRestrictionCas && evaluateAltitude < restrictionAltitude ? restrictionCas : undefined, canUseTransitionCas && evaluateAltitude < transitionAltitude ? transitionCas : undefined), pressureAtEval), BoeingPathCalculator.getTargetMach(evalCruiseMach, currentSpeedConstraint));
                            const residualVs = this.getClimbVerticalSpeed(climbN1MethodName, evaluateAltitude, wingArea, pressureAtEval, temperatureAtEval, machAtEval, currentWeight, engineCount);
                            if (residualVs < BoeingPathCalculator.CRUISE_STEP_CLIMB_RESIDUAL_VS_MPS) {
                                break;
                            }
                            const evaluateAltitudeCost = this.evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, evaluateAltitude, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, currentLegIndex, distanceToLegEnd, currentWeight, endLegIndex, simulateDistance, engineCount) + Math.abs(evaluateAltitude - currentAltitude) * this.cruiseStepCostBias;
                            if (evaluateAltitudeCost < recommendedAltitudeCost) {
                                recommendedAltitude = evaluateAltitude;
                                recommendedAltitudeCost = evaluateAltitudeCost;
                            }
                            evaluateAltitude += stepSize;
                        }
                        if (recommendedAltitude !== currentAltitude) {
                            targetAltitude = recommendedAltitude;
                            const step = (_r = cruiseSteps[_y = currentCruiseStepIndex++]) !== null && _r !== void 0 ? _r : (cruiseSteps[_y] = BoeingPathCalculator.createCruiseStep());
                            step.globalLegIndex = currentLegIndex;
                            step.distanceToLegEnd = distanceToLegEnd;
                            step.fromAltitude = currentAltitude;
                            step.toAltitude = recommendedAltitude;
                            step.plannedStepIndex = -1;
                        }
                        else {
                            distanceToNextEvaluatePoint = BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP;
                        }
                    }
                }
                // ---- Compute simulation step deltas ----
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windDirection !== undefined && windSpeed !== undefined && legCourse !== undefined) {
                    wind = Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windDirection, windSpeed, tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                }
                let gs = tas + wind;
                let distanceStep;
                let altitudeStep;
                let engineFuelFlow;
                if (targetAltitude === currentAltitude) {
                    // We are currently holding the current cruise altitude.
                    distanceStep = distanceToNextEvaluatePoint;
                    altitudeStep = 0;
                    const engineGrossThrust = this.perfProvider.getLevelFlightRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, mach, 0, engineCount);
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                else {
                    // We are currently climbing or descending to another cruise altitude.
                    let vs;
                    let engineGrossThrust;
                    if (targetAltitude > currentAltitude) {
                        targetAltitudeFeet !== null && targetAltitudeFeet !== void 0 ? targetAltitudeFeet : (targetAltitudeFeet = UnitType.METER.convertTo(targetAltitude, UnitType.FOOT));
                        pressureAtTarget !== null && pressureAtTarget !== void 0 ? pressureAtTarget : (pressureAtTarget = AeroMath.isaPressure(targetAltitude));
                        temperatureAtTarget !== null && temperatureAtTarget !== void 0 ? temperatureAtTarget : (temperatureAtTarget = AeroMath.isaTemperature(targetAltitude)
                            + ((_s = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, targetAltitudeFeet, currentLegDistance - distanceToLegEnd)) !== null && _s !== void 0 ? _s : 0));
                        if (machAtTarget === undefined) {
                            let targetCruiseCas = currentCruiseCas;
                            let targetCruiseMach = currentCruiseMach;
                            if (!isSelCruiseSpeed) {
                                [targetCruiseCas, targetCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, UnitType.METER.convertTo(targetAltitudeFeet, UnitType.FOOT), currentWeight, 0, BoeingPathCalculator.econSpeedCache, pressureAtTarget);
                                targetCruiseCas = UnitType.KNOT.convertTo(targetCruiseCas, UnitType.MPS);
                            }
                            machAtTarget = Math.min(AeroMath.casToMach(BoeingPathCalculator.getTargetCas(targetCruiseCas, currentSpeedConstraint, canUseRestrictionCas && targetAltitude < restrictionAltitude ? restrictionCas : undefined, canUseTransitionCas && targetAltitude < transitionAltitude ? transitionCas : undefined), pressureAtTarget), BoeingPathCalculator.getTargetMach(targetCruiseMach, currentSpeedConstraint));
                        }
                        const temperatureK = temperature + 273.15;
                        const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(currentAltitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                        const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                        engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                        const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                        const currentVs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), 0);
                        const vsAtTarget = this.getClimbVerticalSpeed(climbN1MethodName, targetAltitude, wingArea, pressureAtTarget, temperatureAtTarget, machAtTarget, currentWeight, engineCount);
                        vs = Math.max((currentVs + vsAtTarget) / 2, BoeingPathCalculator.MIN_CLIMB_VS_MPS);
                    }
                    else {
                        hasInitiatedStepDescent = true;
                        // Transition and restriction speed limits are never in effect after a step descent is initiated, so if we
                        // had previously used them, we need to recalculate our speeds.
                        if (useTransitionCas || useRestrictionCas) {
                            const newTargetCas = BoeingPathCalculator.getTargetCas(currentCruiseCas, currentSpeedConstraint);
                            mach = Math.min(targetMach, AeroMath.casToMach(newTargetCas, pressure));
                            tas = AeroMath.machToTas(mach, soundSpeed);
                            cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                            if (windDirection !== undefined && windSpeed !== undefined && legCourse !== undefined) {
                                wind = Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windDirection, windSpeed, tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                            }
                            gs = tas + wind;
                        }
                        vs = BoeingPathCalculator.CRUISE_DESCENT_VS_MPS;
                        engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                    }
                    altitudeStep = targetAltitude - currentAltitude;
                    distanceStep = altitudeStep / vs * gs;
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                // Check if we reach the end of the current leg before the end of the simulation step. If so, end the simulation
                // step at the end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                const tolerance = targetAltitude !== currentAltitude ? 1 : BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP_TOL;
                if (distanceStep >= distanceToLegEnd - tolerance) {
                    if (altitudeStep !== 0) {
                        altitudeStep = MathUtils.lerp(distanceToLegEnd, 0, distanceStep, 0, altitudeStep, true, true);
                    }
                    distanceStep = distanceToLegEnd;
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const timeStep = distanceStep / gs;
                distanceToEnd -= distanceStep;
                distanceToLegEnd -= distanceStep;
                distanceToNextEvaluatePoint -= distanceStep;
                currentAltitude += altitudeStep;
                if (altitudeStep !== 0 && Math.abs(targetAltitude - currentAltitude) < 1) {
                    currentAltitude = targetAltitude;
                    if (!currentPlannedCruiseStep && !nextPlannedCruiseStep) {
                        distanceToNextEvaluatePoint = BoeingPathCalculator.CRUISE_STEP_START_MARGIN;
                    }
                    // This is a very rough approximation, but our margins are large enough (hundreds of NM) to cushion the expected
                    // error.
                    descentDistance = firstDescentConstraint
                        ? VNavUtils.distanceForAltitude(-3, Math.min(firstDescentConstraint.legs[0].altitude, currentAltitude) - currentAltitude)
                        : 0;
                }
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                if (currentPlannedCruiseStep) {
                    currentPlannedCruiseStepDeferredDistance += distanceStep;
                }
                if (advanceLegIndexTo !== undefined) {
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[currentLegIndex];
                    currentLegDistance = (_u = (_t = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _t === void 0 ? void 0 : _t.distanceWithTransitions) !== null && _u !== void 0 ? _u : 0;
                    distanceToLegEnd = currentLegDistance;
                }
            }
            else {
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                currentLegDistance = (_w = (_v = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _v === void 0 ? void 0 : _v.distanceWithTransitions) !== null && _w !== void 0 ? _w : 0;
                distanceToLegEnd = currentLegDistance;
            }
        }
        // Invalidate all planned cruise steps after the end.
        if (nextPlannedCruiseStepIndex >= 0) {
            for (let i = nextPlannedCruiseStepIndex; i < plannedCruiseSteps.length; i++) {
                const step = plannedCruiseSteps[i];
                step.isInvalid = true;
                step.deferredDistance = 0;
            }
        }
        cruiseSteps.length = currentCruiseStepIndex;
    }
    /**
     * Gets the estimated vertical speed achievable during a climb, in meters per second.
     * @param climbN1MethodName The name of the method in {@link BoeingEngineDataProvider} which provides the target
     * engine N1 during the climb.
     * @param altitude The altitude of the climb, in meters above MSL.
     * @param wingArea The airplane's wing area, in square meters.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @param mach The mach number during the climb.
     * @param weight The weight of the airplane, in pounds.
     * @param engineCount The number of operational engines.
     * @returns The estimated vertical speed achievable during a climb with the specified parameters, in meters per
     * second.
     */
    getClimbVerticalSpeed(climbN1MethodName, altitude, wingArea, pressure, temperature, mach, weight, engineCount) {
        const tas = AeroMath.machToTas(mach, AeroMath.soundSpeedAir(temperature));
        const cl = AeroMath.liftCoefficient(UnitType.POUND_FORCE.convertTo(weight, UnitType.NEWTON), wingArea, AeroMath.densityAir(pressure, temperature), tas);
        const temperatureK = temperature + 273.15;
        const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(altitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
        const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
        const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
        const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
        return this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, weight, cl, tas, 0);
    }
    /**
     * Evaluates the estimated cost, in pounds of fuel per nautical mile, of cruising at a given altitude.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param costIndex The cost index to use when converting time cost to fuel equivalents, in (dollars per hour) per
     * (cents per pound of fuel).
     * @param cruiseAltitude The cruise altitude to simulate, in meters above MSL.
     * @param selCruiseCas The selected cruise calibrated airspeed, in meters per second, or `null` if there is no such
     * speed.
     * @param selCruiseMach The selected cruise mach number, or `null` if there is no such speed.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param startLegIndex The global index of the flight plan leg containing the point at which to start the
     * simulation.
     * @param startDistanceToLegEnd The along-track distance, in meters, from the simulation start point to the end of
     * its containing leg.
     * @param startWeight The weight of the airplane at the start of the simulation, in pounds.
     * @param endLegIndex The global index of the last flight plan leg eligible for simulation, exclusive.
     * @param distanceToSimulate The total along-track distance to simulate, in meters.
     * @param engineCount The number of operational engines to simulate.
     * @returns The estimated cost, in pounds of fuel per nautical mile, of cruising at the specified altitude with the
     * specified parameters.
     */
    evaluateCruiseStepCost(lateralLegs, verticalPlan, verticalPathEntry, costIndex, cruiseAltitude, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, distanceToSimulate, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g;
        const verticalPath = verticalPathEntry.path;
        const cruiseAltitudeFeet = UnitType.METER.convertTo(cruiseAltitude, UnitType.FOOT);
        const wingArea = this.perfProvider.getWingArea();
        let distanceToEnd = distanceToSimulate;
        const useTransitionCas = transitionAltitude !== null && transitionCas !== null && cruiseAltitude < transitionAltitude;
        const useRestrictionCas = restrictionAltitude !== null && restrictionCas !== null && cruiseAltitude < restrictionAltitude;
        const isSelCruiseSpeed = selCruiseCas !== null || selCruiseMach !== null;
        let currentLegIndex = startLegIndex;
        let currentLeg = lateralLegs[startLegIndex];
        let currentLegDistance = (_b = (_a = currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentWeight = startWeight;
        let currentCruiseCas = selCruiseCas !== null && selCruiseCas !== void 0 ? selCruiseCas : Infinity;
        let currentCruiseMach = selCruiseMach !== null && selCruiseMach !== void 0 ? selCruiseMach : Infinity;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
        let legCourse = undefined;
        let legCourseIndex = undefined;
        let windVector = null;
        let headwind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        let totalFuelBurn = 0;
        let totalDuration = 0;
        while (distanceToEnd > 0 && currentLegIndex < endLegIndex) {
            // ---- Update speed constraint ----
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (currentLegDistance > 0) {
                // ---- Update average leg course ----
                if (legCourseIndex !== currentLegIndex) {
                    legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    legCourseIndex = currentLegIndex;
                }
                // ---- Compute ambient conditions ----
                // Check if we need to update winds and delta ISA offset.
                if (currentLegIndex !== lastWeatherLegIndex) {
                    const distanceAlongLeg = currentLegDistance - distanceToLegEnd;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache);
                    if (windVector !== null && legCourse !== undefined) {
                        headwind = -BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1]);
                    }
                    else {
                        headwind = 0;
                    }
                    deltaIsa = (_c = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg)) !== null && _c !== void 0 ? _c : 0;
                    lastWeatherLegIndex = currentLegIndex;
                }
                const pressure = AeroMath.isaPressure(cruiseAltitude);
                const temperature = AeroMath.isaTemperature(cruiseAltitude) + deltaIsa;
                const density = AeroMath.densityAir(pressure, temperature);
                const soundSpeed = AeroMath.soundSpeedAir(temperature);
                // ---- Compute the current simulation step's target speed ----
                if (!isSelCruiseSpeed) {
                    [currentCruiseCas, currentCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, cruiseAltitudeFeet, currentWeight, headwind, BoeingPathCalculator.econSpeedCache, pressure);
                    currentCruiseCas = UnitType.KNOT.convertTo(currentCruiseCas, UnitType.MPS);
                }
                const targetCas = BoeingPathCalculator.getTargetCas(currentCruiseCas, currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined);
                const targetMach = BoeingPathCalculator.getTargetMach(currentCruiseMach, currentSpeedConstraint);
                const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
                const mach = AeroMath.casToMach(casToTarget, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const wind = legCourse !== undefined && windVector
                    ? Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1], tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas)
                    : 0;
                const gs = tas + wind;
                const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                const engineGrossThrust = this.perfProvider.getLevelFlightRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, mach, 0, engineCount);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                let distanceStep = Math.min(BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP, distanceToEnd);
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd - BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP_TOL) {
                    distanceStep = distanceToLegEnd;
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const timeStep = distanceStep / gs;
                const fuelBurn = timeStep * engineFuelFlow * engineCount;
                distanceToEnd -= distanceStep;
                distanceToLegEnd -= distanceStep;
                totalFuelBurn += fuelBurn;
                totalDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - fuelBurn);
                if (advanceLegIndexTo !== undefined) {
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_e = (_d = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                }
            }
            else {
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                currentLegDistance = (_g = (_f = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _f === void 0 ? void 0 : _f.distanceWithTransitions) !== null && _g !== void 0 ? _g : 0;
                distanceToLegEnd = currentLegDistance;
            }
        }
        // Boeing cost formula: fuel(lb) + CI * 100 * time(hr).
        return (totalFuelBurn + costIndex * totalDuration / 36) / UnitType.METER.convertTo(distanceToSimulate - distanceToEnd, UnitType.NMILE);
    }
    /**
     * Calculates the top of descent and simulates the performance (off-idle) descent phase for a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const firstDescentConstraintLegIndex = firstDescentConstraint.index;
        const targetAltitude = firstDescentConstraint.legs[0].altitude;
        // If cruise altitude is below the target altitude, then there is no performance descent path to be calculated (we
        // will transition immediately from cruise to geometric descent).
        if (cruiseAltitude <= targetAltitude) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        // If we have already sequenced the first descent constraint, then we are in the geometric descent segment and
        // there is no performance descent path to be calculated.
        if (activeLegIndex > firstDescentConstraintLegIndex) {
            // Set both the TOD and the geometric descent intercept point to be slightly behind the airplane's current
            // position. This will allow the geometric descent path to be properly calculated.
            const distanceToLegEnd = activeDistanceToLegEnd + 10;
            verticalPath.todLegIndex = activeLegIndex;
            verticalPath.todVectorIndex = 0;
            verticalPath.todDistanceToLegEnd = distanceToLegEnd;
            verticalPath.perfDescentTodDistance = 0;
            verticalPath.perfDescentSimDistance = 0;
            verticalPath.geoDescentInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentInterceptDistanceToLegEnd = distanceToLegEnd;
            verticalPath.geoDescentInterceptWeight = activeWeight;
            verticalPath.geoDescentSimInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentSimInterceptVectorIndex = -1;
            verticalPath.geoDescentSimInterceptDistanceToLegEnd = distanceToLegEnd;
            return;
        }
        const geoInterceptLegIndex = firstDescentConstraintLegIndex + 1;
        const geoInterceptConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, geoInterceptLegIndex);
        const geoInterceptConstraintTargetAltitude = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.targetAltitude;
        const geoInterceptLeg = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.legs[geoInterceptLegIndex - geoInterceptConstraint.index];
        const doesGeoInterceptLegStartLevel = geoInterceptLeg === undefined
            || geoInterceptLeg.fpa === 0
            || firstDescentConstraint.targetAltitude + 1 < geoInterceptLeg.altitude + VNavUtils.altitudeForDistance(geoInterceptLeg.fpa, geoInterceptLeg.distance);
        // Now we will iteratively solve for the TOD. In each iteration, we will choose a TOD along the flight path,
        // then simulate the entire performance descent segment down to the first descent constraint. If the lateral
        // distance covered brings us to within tolerance to the constraint fix, we are done. Otherwise, we adjust
        // the TOD by a lateral distance equal to the difference between the simulated lateral distance and the required
        // lateral distance and run another iteration.
        // If the performance descent was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use a crude estimate based on constant FPA.
        let estimatedTodDistanceFromFirstConstraint;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromFirstConstraint = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromFirstConstraint = VNavUtils.distanceForAltitude(-3, targetAltitude - cruiseAltitude);
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDescentDistance = estimatedTodDistanceFromFirstConstraint;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the first descent constraint fix to find the lateral position of the TOD
            // -----------------------------
            let todLegIndex = -1;
            let todLeg = undefined;
            let legIndex = firstDescentConstraintLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDescentDistance;
            while (legIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[legIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLegIndex = legIndex;
                    todLeg = leg;
                    todDistanceToLegEnd = distanceToGo;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                legIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs with non-zero distance before the first descent constraint.
                this.resetVerticalPathComputedDescentData(verticalPathEntry);
                return;
            }
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, doesGeoInterceptLegStartLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDescentDistance, todLegIndex, todDistanceToLegEnd, firstDescentConstraintLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDescentDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDescentDistance, prevEstimate);
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = firstDescentConstraintLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = 0;
    }
    /**
     * Calculates the top of descent and simulates the level deceleration segment for a flight plan in which the cruise
     * altitude intercepts the geometric descent path after the first descent altitude constraint.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        // Find the constraint that defines the vertical path we will intercept. This must be a non-flat constraint with a
        // target altitude lower than the cruise altitude.
        let constraintToIntercept = undefined;
        for (let i = firstDescentConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                break;
            }
            if (constraint.targetAltitude <= cruiseAltitude && constraint.fpa > 0) {
                constraintToIntercept = constraint;
                break;
            }
        }
        // If there is no constraint to intercept, then we will remain in cruise until the end of the flight plan.
        if (!constraintToIntercept) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        // Find the point along the flight plan at which the cruise altitude intercepts the geometric descent path.
        let distanceToIntercept = VNavUtils.distanceForAltitude(constraintToIntercept.fpa, cruiseAltitude - constraintToIntercept.targetAltitude);
        let interceptLegIndex = constraintToIntercept.index;
        let interceptDistanceToLegEnd = 0;
        let interceptLeg = lateralLegs[interceptLegIndex];
        while (interceptLeg && distanceToIntercept > 0) {
            const legDistance = interceptLeg.calculated ? interceptLeg.calculated.distanceWithTransitions : 0;
            if (legDistance > distanceToIntercept) {
                interceptDistanceToLegEnd = distanceToIntercept;
                break;
            }
            else {
                distanceToIntercept -= legDistance;
                interceptLeg = lateralLegs[--interceptLegIndex];
            }
        }
        // If we have already sequenced the point at which the cruise altitude intercepts the geometric descent path, then
        // we are already in the geometric descent segment and there is no performance descent path to calculate.
        if (activeLegIndex > interceptLegIndex
            || (activeLegIndex === interceptLegIndex
                && activeDistanceToLegEnd < interceptDistanceToLegEnd)) {
            // Set both the TOD and the geometric descent intercept point to be slightly behind the airplane's current
            // position. This will allow the geometric descent path to be properly calculated.
            const distanceToLegEnd = activeDistanceToLegEnd + 10;
            verticalPath.todLegIndex = activeLegIndex;
            verticalPath.todVectorIndex = 0;
            verticalPath.todDistanceToLegEnd = distanceToLegEnd;
            verticalPath.perfDescentTodDistance = 0;
            verticalPath.perfDescentSimDistance = 0;
            verticalPath.geoDescentInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentInterceptDistanceToLegEnd = distanceToLegEnd;
            verticalPath.geoDescentInterceptWeight = activeWeight;
            verticalPath.geoDescentSimInterceptLegIndex = activeLegIndex;
            verticalPath.geoDescentSimInterceptVectorIndex = -1;
            verticalPath.geoDescentSimInterceptDistanceToLegEnd = distanceToLegEnd;
            return;
        }
        // Now we will iteratively solve for the TOD, which in this context is the beginning of level deceleration.
        // If the level deceleration was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use an arbitrary estimate of 10km.
        let estimatedTodDistanceFromIntercept;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromIntercept = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromIntercept = 10000;
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDecelerationDistance = estimatedTodDistanceFromIntercept;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the intercept point to find the lateral position of the TOD
            // -----------------------------
            let todLegIndex = -1;
            let todLeg = undefined;
            let legIndex = interceptLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDecelerationDistance + interceptDistanceToLegEnd;
            while (legIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[legIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLegIndex = legIndex;
                    todLeg = leg;
                    todDistanceToLegEnd = distanceToGo;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                legIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs with non-zero distance before the intercept point.
                this.resetVerticalPathComputedDescentData(verticalPathEntry);
                return;
            }
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, cruiseAltitude, constraintToIntercept.targetAltitude, false, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDecelerationDistance, todLegIndex, todDistanceToLegEnd, interceptLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDecelerationDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDecelerationDistance, prevEstimate);
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = interceptLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = interceptDistanceToLegEnd;
    }
    /**
     * Adjusts the vertical flight path vectors in the performance (off-idle) descent to account for changes in lateral
     * flight plan leg distances since the vectors were simulated.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPath The vertical flight path containing the vectors to adjust.
     */
    adjustPerformanceDescent(lateralLegs, verticalPath) {
        var _a, _b, _c;
        if (verticalPath.todLegIndex === undefined
            || verticalPath.todDistanceToLegEnd === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined) {
            return;
        }
        let distanceCovered = verticalPath.todDistanceToLegEnd;
        const endLegIndex = Math.min(verticalPath.legs.length, verticalPath.geoDescentSimInterceptLegIndex + 1);
        for (let i = verticalPath.todLegIndex + 1; i < endLegIndex; i++) {
            const leg = verticalPath.legs[i];
            if (leg.vectors.length === 0) {
                continue;
            }
            const isInterceptLeg = i === verticalPath.geoDescentSimInterceptLegIndex;
            const endDistanceToLegEnd = isInterceptLeg ? verticalPath.geoDescentSimInterceptDistanceToLegEnd : 0;
            const lerpEndDistanceToLegEnd = Math.max(0, endDistanceToLegEnd);
            const newLegDistance = (_c = (_b = (_a = lateralLegs[i]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            for (let j = 0; j < leg.vectors.length; j++) {
                const vector = leg.vectors[j];
                if (isInterceptLeg && vector.simStartDistanceToLegEnd <= endDistanceToLegEnd) {
                    break;
                }
                vector.startDistanceToLegEnd = MathUtils.lerp(vector.simStartDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
                vector.endDistanceToLegEnd = MathUtils.lerp(vector.simEndDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
            }
            distanceCovered += newLegDistance - endDistanceToLegEnd;
        }
        verticalPath.perfDescentTodDistance = distanceCovered;
    }
    /**
     * Simulates the VNAV climb phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The vertical flight path entry to which to write the results of the simulation.
     * @param climbThrustMode The thrust mode to use during the climb phase.
     * @param climbCas The climb calibrated airspeed to use, in meters per second.
     * @param climbMach The climb mach number to use.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param bocLegIndex The global index of the flight plan leg containing the start of the climb.
     * @param bocDistanceToLegEnd The lateral distance, in meters, from the start of the climb to the end of its
     * containing leg.
     * @param bocAltitude The altitude, in meters above MSL, of the start of the climb.
     * @param bocWeight The airplane weight, in pounds, at the start of the climb.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the climb, exclusive. If the
     * climb is simulated to end past the last eligible leg, then the simulation will proceed along the last eligible leg
     * as if it were infinitely extended until the top of climb is reached.
     * @param isMissedApproach Whether the simulated climb is part of the missed approach.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateClimb(lateralLegs, verticalPlan, verticalPathEntry, climbThrustMode, climbCas, climbMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, cruiseAltitude, bocLegIndex, bocDistanceToLegEnd, bocAltitude, bocWeight, endLegIndex, isMissedApproach, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var _k, _l;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        if (bocAltitude >= cruiseAltitude - 100 || bocLegIndex >= endLegIndex) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        const climbN1MethodName = this.getClimbN1MethodName(climbThrustMode);
        const wingArea = this.perfProvider.getWingArea();
        let currentVerticalPathLegIndex = bocLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        // Simulate climb steps. Each step covers the distance to the end of the next lateral leg, the next AT OR BELOW
        // climb altitude restriction to be sequenced, the next speed restriction or speed transition to be sequenced, or
        // 1000 feet of climb, whichever is shorter.
        let currentAltitude = bocAltitude;
        let currentLegIndex = bocLegIndex;
        let currentLeg = lateralLegs[bocLegIndex];
        let distanceToLegEnd = bocDistanceToLegEnd;
        let currentWeight = bocWeight;
        let lastVerticalPathLegIndex = currentVerticalPathLegIndex;
        let lastVerticalPathVectorIndex = currentVerticalPathVectorIndex - 1;
        let lastDistanceToLegEnd = bocDistanceToLegEnd;
        const getNextTargetConstraint = isMissedApproach ? VNavUtils.getNextMaprTargetConstraint : VNavUtils.getNextClimbTargetConstraint;
        let currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, bocLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = climbCas;
        const defaultTargetCasSource = isFinite(climbCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = climbMach;
        const defaultTargetMachSource = isFinite(climbMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let casToUse = Infinity;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude < cruiseAltitude) {
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedClimbWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                deltaIsa = (_a = this.windPlanner.getInterpolatedClimbIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (currentTargetAltitudeConstraint && currentLegIndex > currentTargetAltitudeConstraint.index) {
                // We passed the current target altitude constraint that we were tracking, so we need to get the new current
                // target altitude constraint.
                currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
            }
            // Do not apply flight plan leg altitude restriction if we are past the end of the last eligible leg to be
            // simulated. Otherwise we might get stuck below the cruise altitude forever.
            const targetAltitude = currentTargetAltitudeConstraint && (currentLegIndex < endLegIndex - 1 || distanceToLegEnd > 0)
                ? Math.min(cruiseAltitude, currentTargetAltitudeConstraint.maxAltitude)
                : cruiseAltitude;
            if (currentSpeedConstraint && currentLegIndex > currentSpeedConstraint.globalLegIndex) {
                // We passed the current speed constraint that we were tracking, so we need to get the new current speed
                // constraint.
                currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
                // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed constraint
                // increased our target speed.
                if (!isAccelerating) {
                    isAccelerating = true;
                    accelerationCas = casToUse;
                }
            }
            if (useTransitionCas) {
                if (currentAltitude >= transitionAltitude) {
                    useTransitionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed transition
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            if (useRestrictionCas) {
                if (currentAltitude >= restrictionAltitude) {
                    useRestrictionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed restriction
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
            let distanceStep;
            let timeStep;
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
                altitudeStep = Math.min(altitudeStep, restrictionAltitude - currentAltitude);
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
                altitudeStep = Math.min(altitudeStep, transitionAltitude - currentAltitude);
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = casToTarget);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || casToTarget <= accelerationCas + 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            casToUse = isAccelerating ? accelerationCas : casToTarget;
            // If we are on the last eligible leg to be simulated, we will run the simulation even if the leg does not have
            // a non-zero calculated distance in order to guarantee that the simulation eventually reaches cruise altitude.
            if (currentLegIndex === endLegIndex - 1 || (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0)) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let vs;
                let engineFuelFlow;
                if (altitudeStep <= 0) {
                    // The current altitude is at or above the current target climb altitude (if it were at or above the cruise
                    // altitude we would have exited the while loop already). In this case, we will hold the current altitude
                    // until we sequence the altitude constraint.
                    altitudeStep = 0;
                    vs = 0;
                    const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0);
                    if (isAccelerating) {
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                        const targetNetThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, targetCl, 0);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(targetNetThrustRequired, currentWeight, cl, tas, 0, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        timeStep = tasStep / acceleration;
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                        timeStep = distanceStep / gs;
                    }
                    const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                }
                else {
                    // The current altitude is below the current target climb altitude, so we will climb using the selected climb
                    // climb thrust rating.
                    const temperatureK = temperature + 273.15;
                    const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(currentAltitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                    const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                    const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                    const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                    if (isAccelerating) {
                        vs = BoeingPathCalculator.CLIMB_ACCEL_VS_MPS;
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, vs, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        const accelTimeStep = tasStep / acceleration;
                        const accelAltitudeStep = vs * accelTimeStep;
                        // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the current climb target altitude).
                        if (accelAltitudeStep > altitudeStep) {
                            // vs cannot be 0 here
                            timeStep = altitudeStep / vs;
                        }
                        else {
                            altitudeStep = accelAltitudeStep;
                            timeStep = accelTimeStep;
                        }
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), 1);
                        timeStep = altitudeStep / vs;
                        distanceStep = timeStep * gs;
                    }
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd && currentLegIndex < endLegIndex - 1) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined || (currentLegIndex === endLegIndex - 1 && distanceToLegEnd > 0 && distanceStep > distanceToLegEnd)) {
                    // We are either advancing legs or we are about to cross the end of the last eligible leg to be simulated.
                    // Either way we need to end the current step at the end of the current leg.
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * vs;
                    if (advanceLegIndexTo !== undefined) {
                        currentLegIndex = advanceLegIndexTo;
                        currentLeg = lateralLegs[currentLegIndex];
                        distanceToLegEnd = (_e = (_d = currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                    }
                    else {
                        distanceToLegEnd = 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentAltitude += altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.ClimbLevelAcceleration;
                    }
                    else {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.Climb : VerticalFlightPathVectorType.ClimbLevel;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from a level acceleration into a climb
                        // acceleration or vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_f = (_k = pathLeg.vectors)[vectorIndex]) !== null && _f !== void 0 ? _f : (_k[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                    lastVerticalPathVectorIndex = currentVerticalPathVectorIndex;
                    lastDistanceToLegEnd = stepEndDistanceToLegEnd;
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_g = (_l = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_l[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = isAccelerating ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.Climb;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                lastVerticalPathVectorIndex = 0;
                lastDistanceToLegEnd = 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
        verticalPath.tocLegIndex = lastVerticalPathLegIndex;
        verticalPath.tocVectorIndex = lastVerticalPathVectorIndex;
        verticalPath.tocDistanceToLegEnd = lastDistanceToLegEnd;
        verticalPath.tocWeight = currentWeight;
        verticalPathEntry.lastTocLegIndex = verticalPath.tocLegIndex;
        verticalPathEntry.lastTocDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
    }
    /**
     * Simulates the VNAV cruise phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param costIndex The cost index to use when converting time cost to fuel equivalents, in (dollars per hour) per
     * (cents per pound of fuel).
     * @param initialCruiseAltitude The initial cruise altitude, in meters above MSL.
     * @param climbThrustMode The climb thrust mode to use during step climbs.
     * @param selCruiseCas The selected cruise calibrated airspeed, in meters per second, or `null` if there is no such
     * speed.
     * @param selCruiseMach The selected cruise mach number, or `null` if there is no such speed.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeAltitude The airplane's current altitude, in meters above MSL.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the cruise, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCruise(lateralLegs, verticalPlan, verticalPathEntry, costIndex, initialCruiseAltitude, climbThrustMode, selCruiseCas, selCruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeAltitude, activeLegIndex, activeDistanceToLegEnd, activeWeight, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        var _p, _q, _r;
        const verticalPath = verticalPathEntry.path;
        endLegIndex = Math.min(endLegIndex, lateralLegs.length);
        let tocLegIndex;
        let tocDistanceToLegEnd;
        let tocWeight = activeWeight;
        let currentVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let tocCasToUse = undefined;
        // If a TOC is defined in the vertical flight path, then we need to make sure we start writing cruise vectors after
        // the TOC. Otherwise, the simulation starts in the cruise phase at the airplane's current along-track position, so
        // we will start writing vectors at index 0 for the active leg.
        if (verticalPath.tocLegIndex !== undefined
            && verticalPath.tocVectorIndex !== undefined
            && verticalPath.tocDistanceToLegEnd !== undefined
            && verticalPath.tocWeight !== undefined) {
            // Check if the TOC lies past the end of its containing leg. If it does, then we need to start our simulation at
            // the beginning of the next leg.
            if (verticalPath.tocDistanceToLegEnd < 0) {
                tocLegIndex = verticalPath.tocLegIndex + 1;
                tocDistanceToLegEnd = (_c = (_b = (_a = lateralLegs[tocLegIndex]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
            }
            else {
                tocLegIndex = verticalPath.tocLegIndex;
                tocDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
                tocWeight = verticalPath.tocWeight;
                const tocPathLeg = verticalPath.legs[tocLegIndex];
                const tocPathVector = tocPathLeg.vectors[verticalPath.tocVectorIndex];
                currentVerticalPathLegIndex = tocLegIndex;
                currentVerticalPathVectorIndex = verticalPath.tocVectorIndex + 1;
                tocCasToUse = UnitType.KNOT.convertTo(tocPathVector.endCas, UnitType.MPS);
                for (let i = 0; i < currentVerticalPathVectorIndex; i++) {
                    currentVerticalPathLegDuration += tocPathLeg.vectors[i].duration;
                }
            }
        }
        else {
            tocLegIndex = activeLegIndex;
            tocDistanceToLegEnd = activeDistanceToLegEnd;
            currentVerticalPathLegIndex = tocLegIndex;
        }
        if (tocLegIndex >= endLegIndex) {
            return;
        }
        const climbN1MethodName = this.getClimbN1MethodName(climbThrustMode);
        const wingArea = this.perfProvider.getWingArea();
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        const isSelCruiseSpeed = selCruiseCas !== null || selCruiseMach !== null;
        // Start the simulation at the initial cruise altitude if we have sequenced the first descent constraint, or we
        // have not yet passed the TOC, or we are within 100 meters of the initial cruise altitude. Otherwise, start the
        // simulation at the airplane's current altitude.
        let currentAltitude = ((verticalPlan.firstDescentConstraintLegIndex !== undefined && activeLegIndex > verticalPlan.firstDescentConstraintLegIndex)
            || !verticalPathEntry.isTocSequenced
            || Math.abs(initialCruiseAltitude - activeAltitude) < 100)
            ? initialCruiseAltitude
            : activeAltitude;
        let currentLegIndex = tocLegIndex;
        let currentLeg = lateralLegs[tocLegIndex];
        let currentLegDistance = (_e = (_d = currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
        let distanceToLegEnd = tocDistanceToLegEnd;
        let currentWeight = tocWeight;
        let currentCruiseCas = selCruiseCas !== null && selCruiseCas !== void 0 ? selCruiseCas : Infinity;
        let currentCruiseMach = selCruiseMach !== null && selCruiseMach !== void 0 ? selCruiseMach : Infinity;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let distanceToNextSpeedConstraint = nextSpeedConstraint
            ? BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd)
            : Infinity;
        let useNextSpeedConstraint = false;
        let prevUsedSpeedConstraint = currentSpeedConstraint;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        let currentCruiseStepIndex = BoeingVNavUtils.getCurrentCruiseStepIndex(verticalPath, tocLegIndex, tocDistanceToLegEnd);
        let currentCruiseStep = verticalPath.cruiseSteps[currentCruiseStepIndex];
        let nextCruiseStep = verticalPath.cruiseSteps[currentCruiseStepIndex + 1];
        let distanceToNextCruiseStep = nextCruiseStep
            ? BoeingPathCalculator.getDistanceToCruiseStep(lateralLegs, nextCruiseStep, currentLegIndex, distanceToLegEnd)
            : Infinity;
        let hasInitiatedStepDescent = false;
        let targetAltitude = (_f = currentCruiseStep === null || currentCruiseStep === void 0 ? void 0 : currentCruiseStep.toAltitude) !== null && _f !== void 0 ? _f : initialCruiseAltitude;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let legCourse = undefined;
        let legCourseIndex = undefined;
        let windVector = null;
        let headwind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        let lastWeatherAltitude = currentAltitude;
        while (currentLegIndex < endLegIndex) {
            const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
            const pressure = AeroMath.isaPressure(currentAltitude);
            // ---- Update speed constraint ----
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                distanceToNextSpeedConstraint = nextSpeedConstraint
                    ? BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd)
                    : Infinity;
                useNextSpeedConstraint = false;
            }
            // ---- Update cruise step ----
            if (nextCruiseStep && distanceToNextCruiseStep < 1) {
                currentCruiseStepIndex++;
                currentCruiseStep = nextCruiseStep;
                nextCruiseStep = verticalPath.cruiseSteps[currentCruiseStepIndex + 1];
                distanceToNextCruiseStep = nextCruiseStep
                    ? BoeingPathCalculator.getDistanceToCruiseStep(lateralLegs, nextCruiseStep, currentLegIndex, distanceToLegEnd)
                    : Infinity;
                hasInitiatedStepDescent || (hasInitiatedStepDescent = currentCruiseStep.toAltitude < currentAltitude);
                targetAltitude = currentCruiseStep.toAltitude;
            }
            if (currentLegDistance > 0) {
                // ---- Update average leg course ----
                if (legCourseIndex !== currentLegIndex) {
                    legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    legCourseIndex = currentLegIndex;
                }
                // ---- Compute ambient conditions ----
                // Check if we need to update winds and delta ISA offset.
                if (currentLegIndex !== lastWeatherLegIndex || Math.abs(currentAltitude - lastWeatherAltitude) > 30.48) {
                    const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache);
                    if (windVector !== null) {
                        if (legCourse !== undefined) {
                            headwind = -BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1]);
                        }
                        else {
                            headwind = 0;
                        }
                    }
                    else {
                        headwind = 0;
                    }
                    deltaIsa = (_g = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg)) !== null && _g !== void 0 ? _g : 0;
                    lastWeatherLegIndex = currentLegIndex;
                    lastWeatherAltitude = currentAltitude;
                }
            }
            // ---- Compute the current simulation step's target speed ----
            if (!isSelCruiseSpeed) {
                [currentCruiseCas, currentCruiseMach] = this.speedProvider.getEconCruiseSpeed(costIndex, currentAltitudeFeet, currentWeight, headwind, BoeingPathCalculator.econSpeedCache, pressure);
                currentCruiseCas = UnitType.KNOT.convertTo(currentCruiseCas, UnitType.MPS);
            }
            const prevUsedTransitionCas = useTransitionCas ? transitionCas : undefined;
            const prevUsedRestrictionCas = useRestrictionCas ? restrictionCas : undefined;
            // Initiating a step descent will remove transition and restriction speed limits if stepping below their
            // respective altitudes, so neither speed limit will ever be in effect after a step descent (unless the pilot
            // takes action to restore them, but for the purposes of the simulation we will assume this doesn't happen).
            useTransitionCas = canUseTransitionCas && !hasInitiatedStepDescent && currentAltitude < transitionAltitude;
            useRestrictionCas = canUseRestrictionCas && !hasInitiatedStepDescent && currentAltitude < restrictionAltitude;
            const speedConstraintToUse = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            const { targetCas, targetCasSource, targetMach, targetMachSource } = BoeingPathCalculator.getTargetSpeedData(currentCruiseCas, currentCruiseMach, speedConstraintToUse, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            tocCasToUse !== null && tocCasToUse !== void 0 ? tocCasToUse : (tocCasToUse = casToTarget);
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = tocCasToUse);
            if (!isAccelerating) {
                accelerationCas = casToTarget;
                const { targetCas: prevTargetCas, targetMach: prevTargetMach } = BoeingPathCalculator.getTargetSpeedData(currentCruiseCas, currentCruiseMach, prevUsedSpeedConstraint, prevUsedTransitionCas, prevUsedRestrictionCas, BoeingPathCalculator.targetSpeedDataCache);
                const prevCasToTarget = Math.min(prevTargetCas, AeroMath.machToCas(prevTargetMach, pressure));
                if (Math.abs(casToTarget - prevCasToTarget) > 0.1) {
                    isAccelerating = true;
                }
            }
            else if (!isFinite(accelerationCas) || Math.abs(casToTarget - accelerationCas) <= 0.1) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            prevUsedSpeedConstraint = speedConstraintToUse;
            const casToUse = isAccelerating ? accelerationCas : casToTarget;
            if (currentLegDistance > 0) {
                let maxDistanceStep = Math.min(distanceToLegEnd, distanceToNextCruiseStep);
                if (maxDistanceStep > BoeingPathCalculator.MAX_DISTANCE_STEP + BoeingPathCalculator.MAX_DISTANCE_STEP_TOL) {
                    maxDistanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                }
                let distanceStep;
                let altitudeStep;
                let timeStep;
                let tasStep;
                let deltaTas;
                // ---- Compute additional ambient conditions ----
                const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
                const density = AeroMath.densityAir(pressure, temperature);
                const soundSpeed = AeroMath.soundSpeedAir(temperature);
                // ---- Compute simulation step speeds ----
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windVector !== null && legCourse !== undefined) {
                    wind = Math.max(BoeingPathCalculator.getAlongCourseWindComponent(legCourse, windVector[0], windVector[1], tas), BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                }
                const gs = tas + wind;
                // ---- Handle flight plan speed constraint anticipation ----
                // Do not try to anticipate the next speed constraint until we are within 150 NM. This threshold is
                // chosen because it guarantees that we don't overshoot any anticipated distance less than or equal to
                // 50 NM (50 NM + 100 NM maximum step distance).
                if (!useNextSpeedConstraint && nextSpeedConstraint && distanceToNextSpeedConstraint <= BoeingPathCalculator.MAX_DISTANCE_STEP + 92600) {
                    let casToAnticipate = undefined;
                    if (nextSpeedConstraint.maxCas < casToUse) {
                        casToAnticipate = nextSpeedConstraint.maxCas;
                    }
                    else if (isFinite(nextSpeedConstraint.maxMach)) {
                        const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                        if (nextSpeedConstraintMachCas < casToUse) {
                            casToAnticipate = nextSpeedConstraintMachCas;
                        }
                    }
                    if (casToAnticipate !== undefined) {
                        const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                        const timeToDecel = (tasToAnticipate - tas) / BoeingPathCalculator.CRUISE_ANTICIPATION_ASSUMED_DECELERATION;
                        const distanceToDecel = gs * timeToDecel + BoeingPathCalculator.CRUISE_ANTICIPATION_ASSUMED_DECELERATION / 2 * timeToDecel * timeToDecel;
                        // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                        // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                        // distance step if necessary so that the next step begins at the point at which we are predicted to
                        // need to start decelerating to reach the target speed 500 meters before the speed constraint.
                        if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                            useNextSpeedConstraint = true;
                            isAccelerating = true;
                            accelerationCas = casToUse;
                            continue;
                        }
                        else {
                            maxDistanceStep = Math.min(maxDistanceStep, distanceToNextSpeedConstraint - distanceToDecel - 500);
                        }
                    }
                }
                // ---- Compute simulation step deltas ----
                const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let engineGrossThrust;
                if (targetAltitude === currentAltitude) {
                    // We are currently cruising at the target altitude.
                    altitudeStep = 0;
                    if (isAccelerating) {
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        deltaTas = targetTas - tas;
                        tasStep = deltaTas;
                        if (deltaTas > 0) {
                            // We are currently accelerating.
                            const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                            const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, targetCl, 0);
                            const [timeToAccel, distanceToAccel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, targetTas, 0, netThrustRequired / engineCount, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_LEVEL_ACCELERATION);
                            acceleration = deltaTas / timeToAccel;
                            distanceStep = distanceToAccel;
                            timeStep = timeToAccel;
                            engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
                        }
                        else {
                            // We are currently decelerating.
                            const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                            const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                            engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / thrustCorrection;
                            if (useNextSpeedConstraint) {
                                // We are currently decelerating to anticipate a flight plan speed constraint.
                                acceleration = BoeingPathCalculator.getRequiredAcceleration(distanceToNextSpeedConstraint, gs, gs + deltaTas);
                                distanceStep = distanceToNextSpeedConstraint;
                                timeStep = deltaTas / acceleration;
                            }
                            else {
                                // We are currently decelerating from climb speed to cruise speed.
                                const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(idleN1, mach, pressure, temperature);
                                acceleration = Math.min(this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0), -BoeingPathCalculator.MIN_LEVEL_DECELERATION);
                                timeStep = deltaTas / acceleration;
                                distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                            }
                        }
                    }
                    else {
                        engineGrossThrust = this.perfProvider.getLevelFlightRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, mach, 0, engineCount);
                        distanceStep = maxDistanceStep;
                        timeStep = distanceStep / gs;
                        tasStep = 0;
                        deltaTas = 0;
                    }
                }
                else {
                    // We are currently stepping to another target altitude.
                    let altitudeToAccel = 0;
                    let timeToAccel = 0;
                    let vs;
                    if (targetAltitude > currentAltitude) {
                        // We are currently stepping to a higher target altitude.
                        // Limit the altitude step to the maximum altitude step (1000 feet), the altitude remaining to the target
                        // altitude, or the altitude remaining to the transition/restriction altitudes.
                        altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
                        if (canUseTransitionCas && currentAltitude < transitionAltitude) {
                            altitudeStep = Math.min(altitudeStep, transitionAltitude - currentAltitude);
                        }
                        if (canUseRestrictionCas && currentAltitude < restrictionAltitude) {
                            altitudeStep = Math.min(altitudeStep, restrictionAltitude - currentAltitude);
                        }
                        const temperatureK = temperature + 273.15;
                        const n1 = this.engineDataProvider[climbN1MethodName](currentAltitudeFeet, temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                        const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                        engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                        const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                        if (isAccelerating) {
                            const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                            deltaTas = targetTas - tas;
                            if (deltaTas > 0) {
                                // We are currently accelerating.
                                vs = BoeingPathCalculator.CLIMB_ACCEL_VS_MPS;
                                [timeToAccel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, targetTas, vs, engineNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_CLIMB_ACCELERATION);
                                altitudeToAccel = vs * timeToAccel;
                                acceleration = deltaTas / timeToAccel;
                            }
                            else {
                                // We are currently decelerating.
                                vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), BoeingPathCalculator.MIN_CLIMB_VS_MPS);
                                if (useNextSpeedConstraint) {
                                    // We are currently decelerating to anticipate a flight plan speed constraint.
                                    acceleration = BoeingPathCalculator.getRequiredAcceleration(distanceToNextSpeedConstraint, gs, gs + deltaTas);
                                }
                                else {
                                    // We are currently decelerating from climb speed to cruise speed.
                                    acceleration = BoeingPathCalculator.ASSUMED_CLIMB_DECELERATION;
                                }
                                timeToAccel = deltaTas / acceleration;
                                altitudeToAccel = vs * timeToAccel;
                            }
                        }
                        else {
                            // We are currently holding a constant speed.
                            vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), BoeingPathCalculator.MIN_CLIMB_VS_MPS);
                            deltaTas = 0;
                        }
                    }
                    else {
                        // We are currently stepping to a lower target altitude.
                        // Limit the altitude step to the maximum altitude step (1000 feet) or the altitude remaining to the target
                        // altitude. We don't need to worry about the transition/restriction altitudes because they are automatically
                        // cleared when initiating a step descent.
                        altitudeStep = Math.max(-BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
                        vs = BoeingPathCalculator.CRUISE_DESCENT_VS_MPS;
                        if (isAccelerating) {
                            const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                            deltaTas = targetTas - tas;
                            if (deltaTas > 0) {
                                // We are currently accelerating.
                                const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                                const netThrustRequired = this.perfProvider.getRequiredThrust(currentWeight, targetCl, targetTas, vs, 0);
                                [timeToAccel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, targetTas, vs, netThrustRequired / engineCount, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_DESCENT_ACCELERATION);
                                altitudeToAccel = vs * timeToAccel;
                                acceleration = deltaTas / timeToAccel;
                                engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
                            }
                            else {
                                // We are currently decelerating.
                                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                                const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                                engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / thrustCorrection;
                                if (useNextSpeedConstraint) {
                                    // We are currently decelerating to anticipate a flight plan speed constraint.
                                    acceleration = BoeingPathCalculator.getRequiredAcceleration(distanceToNextSpeedConstraint, gs, gs + deltaTas);
                                }
                                else {
                                    // We are currently decelerating from climb speed to cruise speed.
                                    const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(idleN1, mach, pressure, temperature);
                                    acceleration = Math.min(this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0), -BoeingPathCalculator.MIN_DESCENT_DECELERATION);
                                }
                                timeToAccel = deltaTas / acceleration;
                                altitudeToAccel = vs * timeToAccel;
                            }
                        }
                        else {
                            // We are currently holding a constant speed.
                            deltaTas = 0;
                            engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                        }
                    }
                    if (isAccelerating) {
                        // If we are currently accelerating toward a target speed, then we need to check if we are predicted to
                        // reach the target speed before the end of the planned altitude step. If so, then we need to end the
                        // current step when we reach the target speed.
                        if (altitudeToAccel < altitudeStep - 1) {
                            altitudeStep = altitudeToAccel;
                            timeStep = timeToAccel;
                            tasStep = deltaTas;
                        }
                        else {
                            timeStep = MathUtils.lerp(altitudeStep, 0, altitudeToAccel, 0, timeToAccel, true, true);
                            tasStep = MathUtils.lerp(altitudeStep, 0, altitudeToAccel, 0, deltaTas, true, true);
                        }
                    }
                    else {
                        acceleration = 0;
                        timeStep = altitudeStep / vs;
                        tasStep = 0;
                    }
                    distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                }
                if (distanceStep > maxDistanceStep + 1) {
                    if (isAccelerating) {
                        const oldTimeStep = timeStep;
                        timeStep = BoeingPathCalculator.timeToDistance(maxDistanceStep, gs, acceleration);
                        altitudeStep = MathUtils.lerp(timeStep, 0, oldTimeStep, 0, altitudeStep, true, true);
                        tasStep = MathUtils.lerp(timeStep, 0, oldTimeStep, 0, tasStep, true, true);
                    }
                    else {
                        timeStep = maxDistanceStep / gs;
                        altitudeStep = MathUtils.lerp(maxDistanceStep, 0, distanceStep, 0, altitudeStep);
                    }
                }
                distanceStep = Math.min(distanceStep, maxDistanceStep);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg before the end of the distance step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceToLegEnd <= distanceStep + 1) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                if (advanceLegIndexTo !== undefined) {
                    distanceStep = distanceToLegEnd;
                    distanceToLegEnd = 0;
                }
                else {
                    distanceToLegEnd -= distanceStep;
                }
                currentAltitude += altitudeStep;
                if (Math.abs(currentAltitude - targetAltitude) < 1e-3) {
                    currentAltitude = targetAltitude;
                }
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                distanceToNextSpeedConstraint -= distanceStep;
                distanceToNextCruiseStep -= distanceStep;
                let endPressure;
                let casToTargetAtEnd;
                if (altitudeStep === 0) {
                    endPressure = pressure;
                    casToTargetAtEnd = casToTarget;
                }
                else {
                    endPressure = AeroMath.isaPressure(currentAltitude);
                    casToTargetAtEnd = Math.min(targetCas, AeroMath.machToCas(targetMach, endPressure));
                }
                if (isAccelerating) {
                    if (Math.abs(tasStep - deltaTas) < 1e-3) {
                        // The current simulation step ends at the acceleration target.
                        accelerationCas = casToTargetAtEnd;
                    }
                    else {
                        // The current simulation step ends before we are predicted to reach the acceleration target.
                        // For performance reasons we won't bother getting the temperature at the end of the vector.
                        const endCas = AeroMath.tasToCas(tas + tasStep, endPressure, temperature);
                        // Do not allow CAS to "overshoot" the target due to potential changes in static pressure across the
                        // vector causing changes in the target CAS.
                        const accelSign = deltaTas >= 0 ? 1 : -1;
                        if ((endCas - casToTargetAtEnd) * accelSign >= -1e-3) {
                            accelerationCas = casToTargetAtEnd;
                        }
                        else {
                            accelerationCas = endCas;
                        }
                    }
                }
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    const vector = (_h = (_p = pathLeg.vectors)[_q = currentVerticalPathVectorIndex++]) !== null && _h !== void 0 ? _h : (_p[_q] = BoeingPathCalculator.createVerticalPathVector());
                    vector.type = BoeingPathCalculator.getCruiseVectorType(altitudeStep, isAccelerating ? acceleration : 0);
                    vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    vector.simEndDistanceToLegEnd = distanceToLegEnd;
                    vector.endDistanceToLegEnd = distanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = targetCasSource;
                    vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                    vector.targetMachSource = targetMachSource;
                    vector.duration = timeStep;
                    vector.gs = gs;
                    vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, endPressure);
                    }
                    else {
                        if (altitudeStep === 0) {
                            vector.endCas = vector.startCas;
                            vector.endMach = vector.startMach;
                        }
                        else {
                            vector.endCas = UnitType.MPS.convertTo(casToTargetAtEnd, UnitType.KNOT);
                            vector.endMach = AeroMath.casToMach(casToTargetAtEnd, endPressure);
                        }
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    pathLeg.vectors.length = currentVerticalPathVectorIndex;
                    pathLeg.simDistance = currentLegDistance;
                    pathLeg.simDuration = currentVerticalPathLegDuration;
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[advanceLegIndexTo];
                    currentLegDistance = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                    distanceToLegEnd = currentLegDistance;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_l = (_r = pathLeg.vectors)[0]) !== null && _l !== void 0 ? _l : (_r[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = BoeingPathCalculator.getCruiseVectorType(targetAltitude - currentAltitude, isAccelerating ? acceleration : 0);
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                currentLegDistance = (_o = (_m = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _m === void 0 ? void 0 : _m.distanceWithTransitions) !== null && _o !== void 0 ? _o : 0;
                distanceToLegEnd = currentLegDistance;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
            }
        }
    }
    /**
     * Simulates the VNAV performance (off-idle) descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param targetAltitude The altitude to target, in meters above MSL, at the end of the performance descent phase.
     * @param geoInterceptConstraintTargetAltitude The target altitude of the descent altitude constraint containing the
     * point where the performance descent intercepts the geometric descent path, or `undefined` if there is no such
     * constraint.
     * @param isGeoInterceptPathLevel Whether the geometric descent path is level at the point where the performance
     * descent intercepts it.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param estimatedTodDistance The lateral distance, in meters, from the top of descent to the first descent altitude
     * constraint along the flight plan.
     * @param todLegIndex The global index of the flight plan leg containing the top of descent.
     * @param todDistanceToLegEnd The lateral distance, in meters, from the top of descent to the end of its containing
     * leg.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the descent, exclusive.
     * @param engineCount The number of operational engines to simulate.
     * @returns The total simulated distance, in meters, of the performance descent phase.
     */
    simulatePerformanceDescent(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, isGeoInterceptPathLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedTodDistance, todLegIndex, todDistanceToLegEnd, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        if (todLegIndex >= lateralLegs.length) {
            verticalPath.todLegIndex = todLegIndex;
            verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
            verticalPath.perfDescentTodDistance = estimatedTodDistance;
            verticalPath.perfDescentSimDistance = 0;
            return 0;
        }
        const wingArea = this.perfProvider.getWingArea();
        // Find the vertical path vector
        let currentVerticalPathLegIndex = todLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let todCasToUse;
        let todWeight = 0;
        let useEstimatedWeight = false;
        let estimatedWeightStop = 0;
        let estimatedWeightStopDistanceToLegEnd = 0;
        const todPathLeg = verticalPath.legs[todLegIndex];
        // Note that we are guaranteed todPathLeg has at least one calculated vector due to the way in which todLegIndex
        // is chosen.
        if (todDistanceToLegEnd > todPathLeg.vectors[0].startDistanceToLegEnd + 1) {
            // The TOD is before the start of the first vector of the TOD leg. This can only happen if there is no valid
            // calculated vector that covers the TOD. In this case, we need to estimate what the airplane weight would be at
            // TOD. We will employ a crude method of estimation that assumes the airplane maintains a constant speed and N1
            // from TOD to the point where the first vector starts. During the simulation from TOD to the start of the first
            // vector, we will use an estimated weight that is linearly interpolated between the estimated TOD weight and the
            // weight at the start of the first vector.
            const firstVector = todPathLeg.vectors[0];
            useEstimatedWeight = true;
            estimatedWeightStop = firstVector.startWeight;
            estimatedWeightStopDistanceToLegEnd = firstVector.startDistanceToLegEnd;
            const distanceFromTod = todDistanceToLegEnd - estimatedWeightStopDistanceToLegEnd;
            const pressure = AeroMath.isaPressure(cruiseAltitude);
            const temperature = AeroMath.isaTemperature(cruiseAltitude);
            const mach = Math.min(descentMach, AeroMath.casToMach(descentCas, pressure));
            const n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach)
                + (cruiseAltitude === targetAltitude ? 0 : this.performanceDescentIdleN1Offset);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const timeFromTod = distanceFromTod / (soundSpeed * mach);
            const engineFuelFlow = this.perfProvider.getEngineFuelFlow(this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach));
            todWeight = estimatedWeightStop + engineFuelFlow * engineCount * timeFromTod / 3600;
            todCasToUse = UnitType.KNOT.convertTo(firstVector.startCas, UnitType.MPS);
        }
        else {
            // The TOD is after the start of the first vector of the TOD leg. We can grab the airplane weight at TOD from
            // the appropriate calculated vector. We also need to find the index at which to start inserting descent vectors.
            for (let i = 0; i < todPathLeg.vectors.length; i++) {
                const vector = todPathLeg.vectors[i];
                if (vector.startDistanceToLegEnd <= todDistanceToLegEnd) {
                    // The current vector starts at or after the TOD -> start inserting descent vectors at this index.
                    currentVerticalPathVectorIndex = i;
                    todCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                    todWeight = vector.startWeight;
                    break;
                }
                if (vector.endDistanceToLegEnd < todDistanceToLegEnd) {
                    // The current vector ends after the TOD -> change the vector to end at the TOD and start inserting descent
                    // vectors at the next index.
                    vector.endAltitude = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                    vector.endWeight = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                    // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                    // vector will be. For non-acceleration vectors, the end speed stays the same.
                    if (vector.endCas !== vector.startCas) {
                        // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                        // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                        // stays constant.
                        vector.endMach = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                    }
                    // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                    // vectors, but the absolute magnitude of the error should still be acceptable.
                    vector.duration = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                    vector.simEndDistanceToLegEnd = todDistanceToLegEnd;
                    vector.endDistanceToLegEnd = todDistanceToLegEnd;
                    currentVerticalPathVectorIndex = i + 1;
                    currentVerticalPathLegDuration += vector.duration;
                    todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                    todWeight = vector.endWeight;
                    break;
                }
                currentVerticalPathVectorIndex = i + 1;
                currentVerticalPathLegDuration += vector.duration;
                todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                todWeight = vector.endWeight;
            }
        }
        // If a TOC is defined, then check if the TOD lies before the TOC. If it does, then use the TOC weight as the weight
        // at TOD instead of the estimated weight at the TOD.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            if (todLegIndex < verticalPath.tocLegIndex
                || (todLegIndex === verticalPath.tocLegIndex && todDistanceToLegEnd > verticalPath.tocDistanceToLegEnd)) {
                todWeight = verticalPath.tocWeight;
            }
        }
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction or speed transition, or 1000 feet of descent, whichever is shorter.
        let currentAltitude = cruiseAltitude;
        let currentLegIndex = todLegIndex;
        let currentLeg = lateralLegs[todLegIndex];
        let distanceToLegEnd = todDistanceToLegEnd;
        let advanceLegIndexTo = undefined;
        const todVectorIndex = currentVerticalPathVectorIndex;
        let lastVerticalPathLegIndex = currentVerticalPathLegIndex;
        let lastVerticalPathVectorIndex = currentVerticalPathVectorIndex - 1;
        let lastDistanceToLegEnd = todDistanceToLegEnd;
        let currentWeight = todWeight;
        let totalDistanceCovered = 0;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        // Only apply transition and restriction speed limits if they are defined and the either we are intercepting the
        // geometric descent below the threshold altitudes or the intercept is at the threshold altitude and the geometric
        // descent path at the point of intercept descends past the threshold altitude (i.e. we will not level off at the
        // intercept).
        const canUseTransitionCas = transitionAltitude !== null
            && transitionCas !== null
            && (targetAltitude < transitionAltitude - 0.3048
                || (targetAltitude < transitionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < transitionAltitude - 0.3048)));
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        const canUseRestrictionCas = restrictionAltitude !== null
            && restrictionCas !== null
            && (targetAltitude < restrictionAltitude - 0.3048
                || (targetAltitude < restrictionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < restrictionAltitude - 0.3048)));
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = descentCas;
        const defaultTargetMach = descentMach;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        let isInLevelDecelerationPhase = true;
        let isDecelerating = true;
        let decelerationCas = undefined;
        let decelerationAccel = 0;
        let decelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude > targetAltitude || isInLevelDecelerationPhase) {
            // If the current leg is the leg that we want to advance to, reset the advance leg index so that we don't skip
            // the current leg.
            if (advanceLegIndexTo === currentLegIndex) {
                advanceLegIndexTo = undefined;
            }
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                // If we are still at cruise altitude (i.e. level deceleration), then use cruise winds. Otherwise use descent
                // winds.
                if (currentAltitude === cruiseAltitude) {
                    const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache);
                    deltaIsa = (_a = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg)) !== null && _a !== void 0 ? _a : 0;
                }
                else {
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                    deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                }
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, currentAltitude - targetAltitude);
            let distanceStep;
            let timeStep;
            let mach;
            let tas;
            let gs;
            let cl;
            let n1;
            let vs;
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            useTransitionCas || (useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude);
            useRestrictionCas || (useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude);
            const { targetCas, targetCasSource, targetMach, targetMachSource } = BoeingPathCalculator.getTargetSpeedData(defaultTargetCas, defaultTargetMach, useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            todCasToUse !== null && todCasToUse !== void 0 ? todCasToUse : (todCasToUse = casToTarget);
            decelerationCas !== null && decelerationCas !== void 0 ? decelerationCas : (decelerationCas = todCasToUse);
            // Check if we need to continue to decelerate
            if (isDecelerating && (!isFinite(decelerationCas) || casToTarget >= decelerationCas - 0.1)) {
                isDecelerating = false;
                isInLevelDecelerationPhase = false;
                decelerationCas = casToTarget;
                // If we were only simulating the level deceleration phase, then end the simulation now that we are no longer
                // in it.
                if (currentAltitude <= targetAltitude) {
                    break;
                }
            }
            if (advanceLegIndexTo === undefined) {
                // We are not skipping the current leg.
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                let casToUse;
                if (isDecelerating) {
                    vs = isInLevelDecelerationPhase ? 0 : BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                    casToUse = decelerationCas;
                    mach = AeroMath.casToMach(decelerationCas, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    decelerationAccel = Math.min(-0.1, this.perfProvider.getAcceleration(this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) * engineCount, currentWeight, cl, tas, vs, 0));
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    const tasStep = Math.min(tas - targetTas, 3);
                    const accelTimeStep = tasStep / -decelerationAccel;
                    const accelAltitudeStep = -vs * accelTimeStep;
                    // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the first descent constraint).
                    if (accelAltitudeStep > altitudeStep) {
                        // vs cannot be 0 here
                        timeStep = altitudeStep / -vs;
                    }
                    else {
                        altitudeStep = accelAltitudeStep;
                        timeStep = accelTimeStep;
                    }
                    distanceStep = gs * timeStep + decelerationAccel / 2 * timeStep * timeStep;
                }
                else {
                    altitudeStep = Math.min(304.8, currentAltitude - targetAltitude);
                    casToUse = casToTarget;
                    mach = AeroMath.casToMach(casToUse, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    n1 = idleN1 + this.performanceDescentIdleN1Offset;
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 100 NM.
                            if (distanceToNextSpeedConstraint <= 185200) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // altitude step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters prior to the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isDecelerating = true;
                                    decelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature);
                                    vs = Math.min(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), -1);
                                    altitudeStep = Math.min(altitudeStep, (distanceToNextSpeedConstraint - distanceToDecel - 500) / gs * -vs);
                                }
                            }
                        }
                    }
                    // If we are not yet using the speed restriction limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the restriction altitude, check if we need to start anticipating the speed restriction.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseRestrictionCas
                        && !useRestrictionCas
                        && restrictionCas < casToUse
                        && (targetAltitude < restrictionAltitude - 1)
                        && currentAltitude - restrictionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(restrictionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToRestriction = currentAltitude - restrictionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the restriction altitude.
                        if (altitudeToDecel >= altitudeToRestriction - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToRestriction - altitudeToDecel - 100);
                        }
                    }
                    // If we are not yet using the speed transition limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the transition altitude, check if we need to start anticipating the speed transition.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseTransitionCas
                        && !useTransitionCas
                        && transitionCas < casToUse
                        && currentAltitude - transitionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(transitionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToTransition = currentAltitude - transitionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // transition, immediately start decelerating towards the transition speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the transition altitude.
                        if (altitudeToDecel >= altitudeToTransition - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToTransition - altitudeToDecel - 100);
                        }
                    }
                }
                const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                vs !== null && vs !== void 0 ? vs : (vs = Math.min(this.perfProvider.getVerticalSpeed((engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature)) * engineCount, currentWeight, cl, tas, 0), -1));
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = altitudeStep / -vs);
                distanceStep !== null && distanceStep !== void 0 ? distanceStep : (distanceStep = timeStep * gs);
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                if (distanceStep >= distanceToLegEnd) {
                    // Search forward in the lateral plan for a leg with a non-zero calculated distance until we are past the
                    // last eligible leg.
                    let searchLegIndex = currentLegIndex;
                    while (++searchLegIndex < endLegIndex) {
                        const searchLeg = lateralLegs[searchLegIndex];
                        if (searchLeg.calculated && searchLeg.calculated.distanceWithTransitions > 0) {
                            advanceLegIndexTo = searchLegIndex;
                            break;
                        }
                    }
                }
                const currentLegDistance = (_d = (_c = currentLeg.calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isDecelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, decelerationAccel);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * -vs;
                    currentLegIndex++;
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_f = (_e = currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isDecelerating) {
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                }
                totalDistanceCovered += stepDistance;
                currentVerticalPathLegDuration += timeStep;
                currentAltitude -= altitudeStep;
                // If we are using estimated weight, then check if we have passed the point where we should stop using
                // estimated weight.
                if (useEstimatedWeight && (currentLegIndex > todLegIndex || distanceToLegEnd <= estimatedWeightStopDistanceToLegEnd)) {
                    useEstimatedWeight = false;
                }
                if (useEstimatedWeight) {
                    currentWeight = MathUtils.lerp(distanceToLegEnd, todDistanceToLegEnd, estimatedWeightStopDistanceToLegEnd, todWeight, estimatedWeightStop);
                }
                else {
                    const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                    currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                }
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isInLevelDecelerationPhase) {
                        vectorType = VerticalFlightPathVectorType.LevelDeceleration;
                    }
                    else if (isDecelerating) {
                        vectorType = VerticalFlightPathVectorType.IdleDescentDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.IdleDescent;
                    }
                    if (isDecelerating) {
                        // If we are decelerating, we need to check if we went straight from a level deceleration into a descent
                        // deceleration. If so, we need to insert a new vector.
                        if (!decelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            decelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not decelerating, we need to check if the current vector is a deceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = decelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        decelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isDecelerating || !decelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        decelerationVectorStarted = isDecelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isDecelerating) {
                        vector.endCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(decelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                    lastVerticalPathVectorIndex = vectorIndex;
                    lastDistanceToLegEnd = stepEndDistanceToLegEnd;
                    if (!isDecelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex++;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    decelerationVectorStarted = false;
                }
            }
            else {
                // The current leg is being skipped, which can only happen if it has no calculated lateral path or the lateral
                // path has a distance of zero. Therefore we insert one zero-length vector into the vertical path for the leg
                // and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isDecelerating) {
                    vectorType = isInLevelDecelerationPhase ? VerticalFlightPathVectorType.LevelDeceleration : VerticalFlightPathVectorType.IdleDescentDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.IdleDescent;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isDecelerating) {
                    vector.startCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(decelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                lastVerticalPathVectorIndex = 0;
                lastDistanceToLegEnd = 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                decelerationVectorStarted = false;
            }
        }
        verticalPath.todLegIndex = todLegIndex;
        verticalPath.todVectorIndex = todVectorIndex;
        verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
        verticalPath.perfDescentTodDistance = estimatedTodDistance;
        verticalPath.perfDescentSimDistance = totalDistanceCovered;
        verticalPath.geoDescentSimInterceptLegIndex = lastVerticalPathLegIndex;
        verticalPath.geoDescentSimInterceptVectorIndex = lastVerticalPathVectorIndex;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = lastDistanceToLegEnd;
        verticalPath.geoDescentInterceptWeight = currentWeight;
        return totalDistanceCovered;
    }
    /**
     * Simulates the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        var _a, _b, _c;
        const verticalPath = verticalPathEntry.path;
        if (verticalPlan.firstDescentConstraintLegIndex === undefined
            || verticalPlan.lastDescentConstraintLegIndex === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptVectorIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptLegIndex === undefined
            || verticalPath.geoDescentInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptWeight === undefined) {
            return;
        }
        const firstDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const lastDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        if (!firstDescentConstraint || !lastDescentConstraint) {
            return;
        }
        // Start simulation at the active leg, or the start of the geometric descent, whichever one comes later.
        const startAtActive = activeLegIndex > verticalPath.geoDescentSimInterceptLegIndex
            || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex && activeDistanceToLegEnd < verticalPath.geoDescentSimInterceptDistanceToLegEnd);
        let startLegIndex = startAtActive ? activeLegIndex : verticalPath.geoDescentSimInterceptLegIndex;
        // Simulate until the MAP or the end of the flight plan, whichever one comes first.
        const endLegIndex = Math.min(lateralLegs.length, (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : Infinity);
        if (startLegIndex >= endLegIndex) {
            return;
        }
        let startDistanceToLegEnd;
        let startWeight;
        let startVerticalPathLegIndex = startLegIndex;
        let startVerticalPathVectorIndex = 0;
        let startVerticalPathLegDuration = 0;
        if (startAtActive) {
            startDistanceToLegEnd = activeDistanceToLegEnd;
            startWeight = activeWeight;
        }
        else {
            startDistanceToLegEnd = verticalPath.geoDescentSimInterceptDistanceToLegEnd;
            startWeight = verticalPath.geoDescentInterceptWeight;
            startVerticalPathVectorIndex = verticalPath.geoDescentSimInterceptVectorIndex + 1;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            for (let i = 0; i < startVerticalPathVectorIndex; i++) {
                startVerticalPathLegDuration += pathLeg.vectors[i].duration;
            }
        }
        let startLeg = lateralLegs[startLegIndex];
        // If the current leg is not calculated, we are already at or past the end of the leg, or we are initially
        // intercepting the geometric descent at the first descent constraint, advance to the next leg.
        if (!startLeg.calculated
            || startDistanceToLegEnd <= 0
            || (startLegIndex === verticalPath.geoDescentInterceptLegIndex
                && verticalPath.geoDescentInterceptLegIndex === verticalPlan.constraints[firstDescentConstraintIndex].index
                && verticalPath.geoDescentInterceptDistanceToLegEnd === 0)) {
            startLegIndex++;
            startLeg = lateralLegs[startLegIndex];
            startDistanceToLegEnd = (_c = (_b = startLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            pathLeg.vectors.length = startVerticalPathVectorIndex;
            pathLeg.simDuration = startVerticalPathLegDuration;
            startVerticalPathLegIndex = startLegIndex;
            startVerticalPathVectorIndex = 0;
            startVerticalPathLegDuration = 0;
        }
        if (startAtActive) {
            // If we are starting at the active leg, then we need to clear all vectors prior to the starting leg
            for (let i = 0; i < startLegIndex; i++) {
                const leg = verticalPath.legs[i];
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
        }
        this.simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount);
        this.simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount);
    }
    /**
     * Performs a coarse simulation of the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param lastDescentConstraintIndex The index of the last descent altitude constraint in the flight plan.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param endLegIndex The global index of the flight plan leg at which to end the simulation, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount) {
        // Simulate coarse descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, or the next change in target airspeed, whichever is shorter.
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var _m, _o, _p, _q;
        const verticalPath = verticalPathEntry.path;
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legIndexOffset = startLegIndex;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentLeg = lateralLegs[currentLegIndex];
        let currentCoarsePathLegIndex = 0;
        let currentCoarsePathVectorIndex = 0;
        let currentWeight = startWeight;
        let currentAltitudeConstraintIndex = -1;
        let priorAltitudeConstraintIndex = -1;
        let currentAltitudeConstraint = undefined;
        let priorAltitudeConstraint = undefined;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        let useTransitionCas = false;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useRestrictionCas = false;
        const defaultTargetCas = descentCas;
        const defaultTargetMach = descentMach;
        let legCourse = undefined;
        let lastLegCourseIndex = undefined;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentLegIndex < endLegIndex) {
            // Update the current and prior altitude constraints for the current leg.
            if (currentLegIndex <= lastDescentConstraint.index) {
                if (!currentAltitudeConstraint || currentLegIndex > currentAltitudeConstraint.index) {
                    currentAltitudeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, currentLegIndex);
                    priorAltitudeConstraintIndex = currentAltitudeConstraintIndex + 1;
                }
            }
            else {
                currentAltitudeConstraintIndex = -1;
                priorAltitudeConstraintIndex = -1;
            }
            currentAltitudeConstraint = verticalPlan.constraints[currentAltitudeConstraintIndex];
            priorAltitudeConstraint = verticalPlan.constraints[priorAltitudeConstraintIndex];
            let distanceStep = distanceToLegEnd;
            let startAltitude;
            let endAltitude;
            let fpa; // Negative = descending path.
            // Calculate the current vector's start and end altitude and FPA.
            if (currentAltitudeConstraint && priorAltitudeConstraint) {
                // We are not past the last descent constraint.
                const verticalLeg = currentAltitudeConstraint.legs[currentAltitudeConstraint.index - currentLegIndex];
                const desiredAltitude = VNavUtils.altitudeForDistance(verticalLeg.fpa, distanceToLegEnd) + verticalLeg.altitude;
                if (desiredAltitude > priorAltitudeConstraint.targetAltitude + 1) {
                    // The desired altitude on the current leg's vertical path exceeds the prior constraint's target altitude
                    // (with tolerance to guard against floating point error and generating very short vectors when the vertical
                    // path doesn't quite line up with the lateral leg distance). Therefore we will hold the prior constraint's
                    // target altitude until we intercept the vertical path.
                    startAltitude = priorAltitudeConstraint.targetAltitude;
                    endAltitude = startAltitude;
                    fpa = 0;
                    if (verticalLeg.fpa > 0 && verticalLeg.altitude < priorAltitudeConstraint.targetAltitude) {
                        distanceStep = MathUtils.lerp(startAltitude, verticalLeg.altitude, desiredAltitude, distanceToLegEnd, 0);
                    }
                }
                else {
                    endAltitude = verticalLeg.altitude;
                    startAltitude = desiredAltitude;
                    fpa = -verticalLeg.fpa;
                }
            }
            else {
                // We are past the last descent constraint. Therefore we will hold the target altitude of the last constraint.
                startAltitude = lastDescentConstraint.targetAltitude;
                endAltitude = startAltitude;
                fpa = 0;
            }
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (!useTransitionCas && canUseTransitionCas) {
                if (startAltitude < transitionAltitude - 0.3048 || (startAltitude < transitionAltitude + 0.3048 && endAltitude < transitionAltitude - 0.3048)) {
                    useTransitionCas = true;
                }
            }
            if (!useRestrictionCas && canUseRestrictionCas) {
                if (startAltitude < restrictionAltitude - 0.3048 || (startAltitude < restrictionAltitude + 0.3048 && endAltitude < restrictionAltitude - 0.3048)) {
                    useRestrictionCas = true;
                }
            }
            const { targetCas, targetCasSource, targetMach, targetMachSource } = BoeingPathCalculator.getTargetSpeedData(defaultTargetCas, defaultTargetMach, currentSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
            // If the vector didn't start below the transition altitude but will end below it, then we will end the vector
            // at the transition altitude.
            if (!useTransitionCas && canUseTransitionCas && endAltitude < transitionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(transitionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = transitionAltitude;
            }
            // If the vector didn't start below the restriction altitude but will end below it, then we will end the vector
            // at the restriction altitude.
            if (!useRestrictionCas && canUseRestrictionCas && endAltitude < restrictionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(restrictionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = restrictionAltitude;
            }
            // Check if we need to update winds and delta ISA offset.
            if (startAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(startAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = startAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(startAltitude);
            const temperature = AeroMath.isaTemperature(startAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                if (currentLegIndex !== lastLegCourseIndex) {
                    legCourse = legCourse = BoeingPathCalculator.getAverageLegCourse(currentLeg);
                    lastLegCourseIndex = currentLegIndex;
                }
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windVector && windVector[1] > 0 && legCourse !== undefined) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(legCourse, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                const mach = AeroMath.casToMach(casToTarget, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const vs = gs * Math.tan(fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                if (distanceStep >= distanceToLegEnd - 1e-3) {
                    distanceStep = distanceToLegEnd;
                }
                const timeStep = distanceStep / gs;
                const engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = currentLeg.calculated.distanceWithTransitions;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = startAltitude;
                const stepStartWeight = currentWeight;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    currentLegIndex = advanceLegIndexTo;
                    if (currentLegIndex < endLegIndex) {
                        currentLeg = lateralLegs[advanceLegIndexTo];
                        distanceToLegEnd = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                }
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentCoarsePathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = (_d = (_m = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _d !== void 0 ? _d : (_m[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                    const vector = (_e = (_o = pathLeg.vectors)[currentCoarsePathVectorIndex]) !== null && _e !== void 0 ? _e : (_o[currentCoarsePathVectorIndex] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    vector.targetCas = targetCas;
                    vector.targetCasSource = targetCasSource;
                    vector.targetMach = targetMach;
                    vector.targetMachSource = targetMachSource;
                    vector.fpa = fpa;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentCoarsePathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const pathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    pathLeg.vectors.length = currentCoarsePathVectorIndex;
                    pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                    pathLeg.distance = currentLegDistance;
                    pathLeg.course = legCourse;
                    currentCoarsePathLegIndex = advanceLegIndexTo - startLegIndex;
                    currentCoarsePathVectorIndex = 0;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = (_f = (_p = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _f !== void 0 ? _f : (_p[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                const vector = (_g = (_q = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_q[0] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = startAltitude;
                vector.endAltitude = endAltitude;
                vector.targetCas = targetCas;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = targetMach;
                vector.targetMachSource = targetMachSource;
                vector.fpa = 0;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                pathLeg.vectors.length = 1;
                pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                pathLeg.distance = 0;
                pathLeg.course = undefined;
                currentLegIndex++;
                if (currentLegIndex < endLegIndex) {
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                }
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
            }
        }
        // Delete all coarse path legs after the last simulated leg.
        coarsePath.legs.length = currentCoarsePathLegIndex;
        if (coarsePath.legs.length === 0) {
            return;
        }
        // Compute estimated deceleration times and distances.
        // Get the speed constraint in effect after sequencing the last leg.
        const endSpeedConstraint = nextSpeedConstraint && endLegIndex > nextSpeedConstraint.globalLegIndex ? nextSpeedConstraint : undefined;
        const { targetCas: endTargetCas, targetCasSource: endTargetCasSource, targetMach: endTargetMach, targetMachSource: endTargetMachSource } = BoeingPathCalculator.getTargetSpeedData(defaultTargetCas, defaultTargetMach, endSpeedConstraint, useTransitionCas ? transitionCas : undefined, useRestrictionCas ? restrictionCas : undefined, BoeingPathCalculator.targetSpeedDataCache);
        let distanceToEnd = 0;
        let nextVector;
        let nextCasToTarget;
        let anticipatedTargetCas = Infinity;
        let anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
        let anticipatedTargetMach = Infinity;
        let anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
        for (let i = coarsePath.legs.length - 1; i >= 0; i--) {
            const leg = coarsePath.legs[i];
            for (let j = leg.vectors.length - 1; j >= 0; j--) {
                const vector = leg.vectors[j];
                // Check if we need to update winds and delta ISA offset.
                if (lastWeatherAltitude === undefined || Math.abs(vector.endAltitude - lastWeatherAltitude) > 1) {
                    const currentAltitudeFeet = UnitType.METER.convertTo(vector.endAltitude, UnitType.FOOT);
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                    deltaIsa = (_k = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _k !== void 0 ? _k : 0;
                    lastWeatherAltitude = vector.endAltitude;
                }
                const pressure = AeroMath.isaPressure(vector.endAltitude);
                const casToTarget = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, pressure));
                if (nextCasToTarget === undefined) {
                    // If nextCasToTarget is undefined, then we are not extending deceleration from the succeeding vector (the
                    // previous one to be iterated) into the current vector. Therefore, we will set the anticipated speed values to
                    // be equal to the target speed at the beginning of the succeeding vector.
                    if (nextVector) {
                        nextCasToTarget = Math.min(nextVector.targetCas, AeroMath.machToCas(nextVector.targetMach, pressure));
                        anticipatedTargetCas = nextVector.targetCas;
                        anticipatedTargetCasSource = nextVector.targetCasSource;
                        anticipatedTargetMach = nextVector.targetMach;
                        anticipatedTargetMachSource = nextVector.targetMachSource;
                    }
                    else {
                        nextCasToTarget = Math.min(endTargetCas, AeroMath.machToCas(endTargetMach, pressure));
                        anticipatedTargetCas = endTargetCas;
                        anticipatedTargetCasSource = endTargetCasSource;
                        anticipatedTargetMach = endTargetMach;
                        anticipatedTargetMachSource = endTargetMachSource;
                    }
                }
                if (isFinite(casToTarget) && isFinite(nextCasToTarget) && nextCasToTarget < casToTarget - 0.5) {
                    // We need to decelerate.
                    const initialMach = AeroMath.casToMach(casToTarget, pressure);
                    const finalMach = AeroMath.casToMach(nextCasToTarget, pressure);
                    const temperature = AeroMath.isaTemperature(vector.endAltitude) + deltaIsa;
                    const density = AeroMath.densityAir(pressure, temperature);
                    const soundSpeed = AeroMath.soundSpeedAir(temperature);
                    const initialTas = AeroMath.machToTas(initialMach, soundSpeed);
                    const finalTas = AeroMath.machToTas(finalMach, soundSpeed);
                    // Find the wind component along the leg's course.
                    let wind = 0;
                    if (leg.course !== undefined && windVector && windVector[0] > 0) {
                        wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(leg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                    }
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(initialTas, finalTas));
                    const initialGs = initialTas + wind;
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, initialMach);
                    const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, initialMach, pressure, temperature);
                    const vs = VNavUtils.altitudeForDistance(vector.fpa, initialGs);
                    const [timeToDecel, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineIdleNetThrust, engineCount, wingArea, 0, vector.endWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_DESCENT_DECELERATION);
                    vector.estimatedDecelTime = timeToDecel;
                    vector.estimatedDecelDistance = distanceToDecel + wind * timeToDecel;
                    vector.estimatedDecelStartTas = initialTas;
                    vector.estimatedDecelEndTas = finalTas;
                    vector.estimatedDecelWind = wind;
                    vector.anticipatedTargetCas = anticipatedTargetCas;
                    vector.anticipatedTargetCasSource = anticipatedTargetCasSource;
                    vector.anticipatedTargetMach = anticipatedTargetMach;
                    vector.anticipatedTargetMachSource = anticipatedTargetMachSource;
                    const vectorDistance = vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
                    if (vector.estimatedDecelDistance > vectorDistance) {
                        // The distance required to decelerate is longer than the vector. Therefore, we need to determine the
                        // speed at the start of the vector such that a deceleration starting at that speed will reach the
                        // anticipated target speed at the end of the vector.
                        const acceleration = (finalTas - initialTas) / timeToDecel;
                        vector.estimatedDecelTime = BoeingPathCalculator.timeToDistance(vectorDistance, initialTas + wind, acceleration);
                        vector.estimatedDecelDistance = vectorDistance;
                        // Check if we need to get updated weather data for the altitude at the start of the vector.
                        if (lastWeatherAltitude === undefined || Math.abs(vector.startAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(vector.startAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                            deltaIsa = (_l = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _l !== void 0 ? _l : 0;
                            lastWeatherAltitude = vector.startAltitude;
                        }
                        const vectorStartPressure = AeroMath.isaPressure(vector.startAltitude);
                        const vectorStartSoundSpeed = AeroMath.soundSpeedIsa(vector.startAltitude, deltaIsa);
                        let vectorStartTas = finalTas - acceleration * vector.estimatedDecelTime;
                        let vectorStartCas = AeroMath.machToCas(AeroMath.tasToMach(vectorStartTas, vectorStartSoundSpeed), vectorStartPressure);
                        // If the altitude is different between the start and end of the vector, then we need to make sure that the
                        // different airspeed conversions don't result in the estimated CAS at the start of the vector being less
                        // than the anticipated CAS at the end of the vector.
                        if (vectorStartCas < nextCasToTarget) {
                            vectorStartCas = nextCasToTarget;
                            vectorStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartCas, vectorStartPressure), vectorStartSoundSpeed);
                        }
                        // Check if the estimated CAS at the start of the vector is less than the (non-anticipated) target CAS at
                        // the start of the vector. If it is, then we need to extend the deceleration into the preceding vector
                        // (the next one to be iterated). If it is not, then we will have the deceleration start at the beginning
                        // of the vector at the non-anticipated target speed.
                        const vectorStartTargetCas = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, vectorStartPressure));
                        if (vectorStartCas < vectorStartTargetCas) {
                            vector.estimatedDecelStartTas = vectorStartTas;
                            // Set nextCasToTarget so that the preceding vector (the next one to be iterated) will anticipate the
                            // speed at the start of this vector required to meet this vector's anticipated speed target instead of
                            // this vector's target speed.
                            nextCasToTarget = vectorStartCas;
                        }
                        else {
                            vector.estimatedDecelStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartTargetCas, vectorStartPressure), vectorStartSoundSpeed);
                            nextCasToTarget = undefined;
                        }
                    }
                    else {
                        nextCasToTarget = undefined;
                    }
                }
                else {
                    vector.estimatedDecelTime = 0;
                    vector.estimatedDecelDistance = 0;
                    vector.estimatedDecelStartTas = 0;
                    vector.estimatedDecelEndTas = 0;
                    vector.estimatedDecelWind = 0;
                    vector.anticipatedTargetCas = Infinity;
                    vector.anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
                    vector.anticipatedTargetMach = Infinity;
                    vector.anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
                    nextCasToTarget = undefined;
                }
                nextVector = vector;
            }
            leg.endDistanceToEnd = distanceToEnd;
            distanceToEnd += leg.distance;
        }
    }
    /**
     * Performs a detailed simulation of the VNAV geometric descent phase of a flight plan.
     * @param verticalPathEntry The entry for the vertical flight path.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startVerticalPathLegIndex The index of the vertical path leg at which to start the simulation.
     * @param startVerticalPathVectorIndex The within-leg index of the vertical path vector at which to start the
     * simulation.
     * @param startVerticalPathLegDuration The total duration, in seconds, of all vertical path vectors in the leg
     * containing the start of the simulation that are situated prior to the start point.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount) {
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, the next change in target airspeed, or 1000 feet of descent, whichever is shorter.
        var _a, _b, _c, _d, _e;
        var _f, _g;
        const verticalPath = verticalPathEntry.path;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentVerticalPathLegIndex = startVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = startVerticalPathVectorIndex;
        let currentVerticalPathLegDuration = startVerticalPathLegDuration;
        let currentWeight = startWeight;
        let currentCoarsePathLegIndex = startLegIndex - coarsePath.legIndexOffset;
        let currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
        let currentCoarsePathVectorIndex = 0;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentCoarsePathLegIndex < coarsePath.legs.length) {
            // Find the coarse path vector containing the current position in the simulation.
            let coarsePathVector = currentCoarsePathLeg.vectors[currentCoarsePathVectorIndex];
            while (currentCoarsePathVectorIndex < currentCoarsePathLeg.vectors.length - 1 && coarsePathVector.endDistanceToLegEnd > distanceToLegEnd) {
                coarsePathVector = currentCoarsePathLeg.vectors[++currentCoarsePathVectorIndex];
            }
            // If the current coarse path vector has zero length, then currentAltitude will be set to the start altitude
            // because lerp() defaults to y0 when x0 and x1 are equal.
            const currentAltitude = MathUtils.lerp(distanceToLegEnd, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude, true, true);
            let altitudeStep;
            let distanceStep;
            // Check if we need to update winds and delta ISA offset.
            if (lastWeatherAltitude === undefined || Math.abs(currentAltitude - lastWeatherAltitude) > 1) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, pressure));
            if (currentCoarsePathLeg.distance > 0) {
                // Find the wind component along the leg's course.
                let wind = 0;
                if (currentCoarsePathLeg.course !== undefined && windVector && windVector[0] > 0) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS)
                        * Math.cos(MathUtils.diffAngleDeg(currentCoarsePathLeg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                let maxDistanceStep;
                let isDecelerating;
                let acceleration;
                if (coarsePathVector.estimatedDecelTime > 0) {
                    // The current coarse path vector ends with a deceleration to an anticipated target speed.
                    const decelStartDistanceToLegEnd = coarsePathVector.estimatedDecelDistance + coarsePathVector.endDistanceToLegEnd;
                    if (decelStartDistanceToLegEnd > distanceToLegEnd - 1e-3) {
                        // We are currently decelerating.
                        maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                        isDecelerating = true;
                        acceleration = (coarsePathVector.estimatedDecelEndTas - coarsePathVector.estimatedDecelStartTas) / coarsePathVector.estimatedDecelTime;
                    }
                    else {
                        // We have not yet reached the point where deceleration starts. We need to ensure that the current vector
                        // does not extend beyond the deceleration start point.
                        maxDistanceStep = distanceToLegEnd - decelStartDistanceToLegEnd;
                        isDecelerating = false;
                        acceleration = 0;
                    }
                }
                else {
                    // The current coarse path vector does not end with a deceleration.
                    maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    isDecelerating = false;
                    acceleration = 0;
                }
                if (coarsePathVector.fpa < 0) {
                    const maxAltitudeStep = currentAltitude - MathUtils.lerp(distanceToLegEnd - maxDistanceStep, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude);
                    if (maxAltitudeStep > BoeingPathCalculator.MAX_ALTITUDE_STEP + BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_ALTITUDE_STEP / maxAltitudeStep * maxDistanceStep;
                        altitudeStep = BoeingPathCalculator.MAX_ALTITUDE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                        altitudeStep = maxAltitudeStep;
                    }
                }
                else {
                    if (maxDistanceStep > BoeingPathCalculator.MAX_DISTANCE_STEP + BoeingPathCalculator.MAX_DISTANCE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                    }
                    altitudeStep = 0;
                }
                let endDistanceToLegEnd;
                let endAltitude;
                let shouldAdvanceVector;
                // Check if we need to advance to the next coarse path vector after the current step, with tolerance for
                // floating point errors.
                if (distanceToLegEnd - distanceStep < coarsePathVector.endDistanceToLegEnd + 1e-3) {
                    distanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    endDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd;
                    endAltitude = coarsePathVector.endAltitude;
                    shouldAdvanceVector = true;
                }
                else {
                    endDistanceToLegEnd = distanceToLegEnd - distanceStep;
                    endAltitude = currentAltitude - altitudeStep;
                    shouldAdvanceVector = false;
                }
                let startCas;
                let startMach;
                let endCas;
                let endMach;
                let mach;
                let tas;
                let gs;
                let timeStep;
                if (isDecelerating) {
                    const decelStartDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd + coarsePathVector.estimatedDecelDistance;
                    const startTimeToDecelEnd = distanceToLegEnd >= decelStartDistanceToLegEnd - 1
                        ? coarsePathVector.estimatedDecelTime
                        : BoeingPathCalculator.timeToDistance(distanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const endTimeToDecelEnd = endDistanceToLegEnd <= coarsePathVector.endDistanceToLegEnd + 1
                        ? 0
                        : BoeingPathCalculator.timeToDistance(endDistanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const startTas = coarsePathVector.estimatedDecelEndTas - acceleration * startTimeToDecelEnd;
                    const endTas = coarsePathVector.estimatedDecelEndTas - acceleration * endTimeToDecelEnd;
                    tas = startTas;
                    mach = AeroMath.tasToMach(tas, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(startTas, endTas));
                    gs = tas + wind;
                    timeStep = BoeingPathCalculator.timeToDistance(distanceStep, gs, acceleration);
                    if (!isFinite(timeStep)) {
                        timeStep = distanceStep / ((startTas + endTas) / 2 + wind);
                    }
                    if (altitudeStep > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                            deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                            lastWeatherAltitude = endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(endAltitude, deltaIsa);
                        endMach = AeroMath.tasToMach(endTas, endSoundSpeed);
                        endCas = AeroMath.machToCas(endMach, endPressure);
                    }
                    else {
                        endMach = AeroMath.tasToMach(endTas, soundSpeed);
                        endCas = AeroMath.machToCas(endMach, pressure);
                    }
                    startMach = AeroMath.tasToMach(startTas, soundSpeed);
                    startCas = AeroMath.machToCas(startMach, pressure);
                    if (startCas < endCas) {
                        startCas = endCas;
                        startMach = AeroMath.casToMach(startCas, pressure);
                    }
                }
                else {
                    mach = AeroMath.casToMach(casToTarget, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                    gs = tas + wind;
                    timeStep = distanceStep / gs;
                    startCas = casToTarget;
                    startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (altitudeStep > 1) {
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endCasToTarget = coarsePathVector.targetCas;
                        const endMachCasToTarget = AeroMath.machToCas(coarsePathVector.targetMach, endPressure);
                        if (endMachCasToTarget <= endCasToTarget) {
                            endCas = endMachCasToTarget;
                            endMach = coarsePathVector.targetMach;
                        }
                        else {
                            endCas = endCasToTarget;
                            endMach = AeroMath.casToMach(casToTarget, endPressure);
                        }
                    }
                    else {
                        endCas = startCas;
                        endMach = startMach;
                    }
                }
                const vs = gs * Math.tan(coarsePathVector.fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let engineGrossThrust;
                if (isDecelerating) {
                    // Assume engines are at idle if we are decelerating.
                    engineGrossThrust = this.perfProvider.getEngineIdleGrossThrust(pressure, temperature, mach);
                }
                else {
                    engineGrossThrust = this.perfProvider.getRequiredEngineGrossThrust(currentWeight, cl, pressure, temperature, tas, vs, 0, engineCount, mach);
                }
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg at the end of the step. If so, advance to the next leg.
                let advanceLegIndexTo = undefined;
                if (shouldAdvanceVector && currentCoarsePathVectorIndex + 1 >= currentCoarsePathLeg.vectors.length) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                distanceToLegEnd = endDistanceToLegEnd;
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    const vector = (_c = (_f = pathLeg.vectors)[currentVerticalPathVectorIndex]) !== null && _c !== void 0 ? _c : (_f[currentVerticalPathVectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                    vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    if (isDecelerating) {
                        vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                        vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    }
                    else {
                        vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.targetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                        vector.targetMachSource = coarsePathVector.targetMachSource;
                    }
                    vector.startCas = UnitType.MPS.convertTo(startCas, UnitType.KNOT);
                    vector.startMach = startMach;
                    vector.endCas = UnitType.MPS.convertTo(endCas, UnitType.KNOT);
                    vector.endMach = endMach;
                    vector.duration = timeStep;
                    vector.simEndDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentVerticalPathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentCoarsePathLeg.distance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentLegIndex = advanceLegIndexTo;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    currentCoarsePathLegIndex = advanceLegIndexTo - coarsePath.legIndexOffset;
                    currentCoarsePathVectorIndex = 0;
                    if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                        currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                        distanceToLegEnd = currentCoarsePathLeg.distance;
                    }
                }
                else if (shouldAdvanceVector) {
                    currentCoarsePathVectorIndex++;
                }
            }
            else {
                // The current leg has a distance of zero. Therefore we insert one zero-length vector into the vertical path
                // for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_d = (_g = pathLeg.vectors)[0]) !== null && _d !== void 0 ? _d : (_g[0] = BoeingPathCalculator.createVerticalPathVector());
                const isDecelerating = coarsePathVector.anticipatedTargetCasSource !== VerticalFlightPathVectorSpeedSource.None
                    || coarsePathVector.anticipatedTargetMachSource !== VerticalFlightPathVectorSpeedSource.None;
                vector.gs = AeroMath.casToTas(casToTarget, pressure, temperature);
                vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = coarsePathVector.startAltitude;
                vector.endAltitude = coarsePathVector.endAltitude;
                if (isDecelerating) {
                    vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                    vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    vector.startMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelStartTas, soundSpeed);
                    vector.startCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.startMach, pressure), UnitType.KNOT);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(coarsePathVector.endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(coarsePathVector.endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache);
                            deltaIsa = (_e = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _e !== void 0 ? _e : 0;
                            lastWeatherAltitude = coarsePathVector.endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(coarsePathVector.endAltitude, deltaIsa);
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, endSoundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, endPressure), UnitType.KNOT);
                    }
                    else {
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, soundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, pressure), UnitType.KNOT);
                    }
                }
                else {
                    vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.targetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                    vector.targetMachSource = coarsePathVector.targetMachSource;
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endCasToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, endPressure));
                        vector.endMach = UnitType.MPS.convertTo(endCasToTarget, UnitType.KNOT);
                        vector.endCas = AeroMath.casToMach(endCasToTarget, endPressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    vector.endCas = vector.startCas;
                    vector.endMach = vector.startMach;
                }
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
                if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                    currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    distanceToLegEnd = currentCoarsePathLeg.distance;
                }
            }
        }
    }
    /**
     * Creates a new speed constraint list item.
     * @returns A new speed constraint list item.
     */
    static createSpeedConstraintListItem() {
        return {
            globalLegIndex: 0,
            flightPhase: VerticalFlightPhase.Climb,
            speedConstraint: {
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS
            },
            isMissedApproach: false,
            minCas: -Infinity,
            maxCas: Infinity,
            minMach: -Infinity,
            maxMach: Infinity
        };
    }
    /**
     * Creates a new planned cruise step object.
     * @returns A new planned cruise step object.
     */
    static createPlannedCruiseStep() {
        return {
            globalLegIndex: 0,
            toAltitude: 0,
            deferredDistance: 0,
            isInvalid: false
        };
    }
    /**
     * Creates a new vertical flight path.
     * @param planIndex The index of the path's associated flight plan. Defaults to `0`.
     * @returns A new vertical flight path.
     */
    static createVerticalPath(planIndex = 0) {
        return {
            planIndex,
            legs: [],
            cruiseSteps: [],
            isPending: false,
            tocLegIndex: undefined,
            tocVectorIndex: undefined,
            tocDistanceToLegEnd: undefined,
            tocWeight: undefined,
            predictedCruiseDistance: undefined,
            predictedCruiseDuration: undefined,
            todLegIndex: undefined,
            todVectorIndex: undefined,
            todDistanceToLegEnd: undefined,
            perfDescentTodDistance: undefined,
            perfDescentSimDistance: undefined,
            geoDescentInterceptLegIndex: undefined,
            geoDescentInterceptDistanceToLegEnd: undefined,
            geoDescentSimInterceptLegIndex: undefined,
            geoDescentSimInterceptVectorIndex: undefined,
            geoDescentSimInterceptDistanceToLegEnd: undefined,
            geoDescentInterceptWeight: undefined
        };
    }
    /**
     * Creates a new vertical flight path leg.
     * @returns A new vertical flight path leg.
     */
    static createVerticalPathLeg() {
        return {
            vectors: [],
            simDistance: 0,
            simDuration: 0
        };
    }
    /**
     * Creates a new vertical flight path vector.
     * @returns A new vertical flight path vector.
     */
    static createVerticalPathVector() {
        return {
            type: VerticalFlightPathVectorType.Climb,
            simStartDistanceToLegEnd: 0,
            simEndDistanceToLegEnd: 0,
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: NaN,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: NaN,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            startCas: 0,
            startMach: 0,
            endCas: 0,
            endMach: 0,
            gs: 0,
            startWeight: 0,
            endWeight: 0,
            duration: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path vector.
     * @returns A new geometric descent coarse vertical flight path vector.
     */
    static createCruiseStep() {
        return {
            globalLegIndex: -1,
            distanceToLegEnd: 0,
            fromAltitude: 0,
            toAltitude: 0,
            plannedStepIndex: -1
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path.
     * @returns A new geometric descent coarse vertical flight path.
     */
    static createGeometricDescentCoarsePath() {
        return {
            legs: [],
            legIndexOffset: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path leg.
     * @returns A new geometric descent coarse vertical flight path leg.
     */
    static createGeometricDescentCoarseLeg() {
        return {
            vectors: [],
            altitudeConstraintIndex: -1,
            distance: 0,
            endDistanceToEnd: 0,
            course: undefined
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path vector.
     * @returns A new geometric descent coarse vertical flight path vector.
     */
    static createGeometricDescentCoarseVector() {
        return {
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: Infinity,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: Infinity,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            fpa: 0,
            anticipatedTargetCas: Infinity,
            anticipatedTargetCasSource: VerticalFlightPathVectorSpeedSource.None,
            anticipatedTargetMach: Infinity,
            anticipatedTargetMachSource: VerticalFlightPathVectorSpeedSource.None,
            estimatedDecelTime: 0,
            estimatedDecelDistance: 0,
            estimatedDecelStartTas: 0,
            estimatedDecelEndTas: 0,
            estimatedDecelWind: 0,
            startWeight: 0,
            endWeight: 0
        };
    }
    /**
     * Copies a vertical flight path.
     * @param source The path to copy from.
     * @param target The path to copy to. If not defined, a new vertical flight path will be created.
     * @returns The vertical flight path that was copied to.
     */
    static copyVerticalPath(source, target) {
        if (!target) {
            target = BoeingPathCalculator.createVerticalPath(source.planIndex);
        }
        target.legs.length = source.legs.length;
        for (let i = 0; i < source.legs.length; i++) {
            target.legs[i] = BoeingPathCalculator.copyVerticalPathLeg(source.legs[i], target.legs[i]);
        }
        target.tocLegIndex = source.tocLegIndex;
        target.tocVectorIndex = source.tocVectorIndex;
        target.tocDistanceToLegEnd = source.tocDistanceToLegEnd;
        target.tocWeight = source.tocWeight;
        target.predictedCruiseDistance = source.predictedCruiseDistance;
        target.predictedCruiseDuration = source.predictedCruiseDuration;
        target.todLegIndex = source.todLegIndex;
        target.todVectorIndex = source.todVectorIndex;
        target.todDistanceToLegEnd = source.todDistanceToLegEnd;
        target.perfDescentTodDistance = source.perfDescentTodDistance;
        target.perfDescentSimDistance = source.perfDescentSimDistance;
        target.geoDescentInterceptLegIndex = source.geoDescentInterceptLegIndex;
        target.geoDescentInterceptDistanceToLegEnd = source.geoDescentInterceptDistanceToLegEnd;
        target.geoDescentSimInterceptLegIndex = source.geoDescentSimInterceptLegIndex;
        target.geoDescentSimInterceptVectorIndex = source.geoDescentSimInterceptVectorIndex;
        target.geoDescentSimInterceptDistanceToLegEnd = source.geoDescentSimInterceptDistanceToLegEnd;
        target.geoDescentInterceptWeight = source.geoDescentInterceptWeight;
        return target;
    }
    /**
     * Copies a vertical flight path leg.
     * @param source The leg to copy from.
     * @param target The leg to copy to. If not defined, a new vertical flight path leg will be created.
     * @returns The vertical flight path leg that was copied to.
     */
    static copyVerticalPathLeg(source, target) {
        var _a;
        if (!target) {
            target = BoeingPathCalculator.createVerticalPathLeg();
        }
        target.vectors.length = source.vectors.length;
        for (let i = 0; i < source.vectors.length; i++) {
            target.vectors[i] = Object.assign((_a = target.vectors[i]) !== null && _a !== void 0 ? _a : {}, source.vectors[i]);
        }
        target.simDistance = source.simDistance;
        target.simDuration = source.simDuration;
        return target;
    }
    /**
     * Gets the time required to travel a given distance with constant acceleration.
     * @param distance The distance to travel.
     * @param v0 The initial velocity. The value should be expressed in units of `distance` per unit time.
     * @param acceleration The acceleration. The value should be expressed in units of `distance` per unit time squared.
     * @returns The time required to travel the specified distance given the specified constant acceleration from the
     * initial velocity. The value is expressed in the unit of time chosen for `v0` and `acceleration`.
     */
    static timeToDistance(distance, v0, acceleration) {
        if (acceleration === 0) {
            return distance / v0;
        }
        const a = acceleration / 2;
        const b = v0;
        const c = -distance;
        return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    /**
     * Gets the acceleration required to change velocity from an initial to a final value over a given distance.
     * @param distance The distance over which to accelerate.
     * @param v0 The initial velocity, expressed in units of {@linkcode distance} over time.
     * @param v1 The final velocity, expressed in units of {@linkcode distance} over time.
     * @returns The acceleration required to change from the specified initial to final velocities over the specified
     * distance. The acceleration is expressed in units of {@linkcode distance} over time squared.
     */
    static getRequiredAcceleration(distance, v0, v1) {
        return (v1 * v1 - v0 * v0) / (2 * distance);
    }
    /**
     * Gets the lateral distance, in meters, from a given query point along a flight plan to a speed constraint in the
     * same flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param speedConstraint The speed constraint to get the distance to.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of its containing leg.
     * @returns The lateral distance, in meters, from the specified query point to the specified speed constraint.
     * @throws RangeError if `globalLegIndex` is out of bounds.
     */
    static getDistanceToSpeedConstraint(lateralLegs, speedConstraint, globalLegIndex, distanceToLegEnd) {
        var _a, _b, _c, _d, _e, _f;
        if (globalLegIndex < 0 || globalLegIndex >= lateralLegs.length) {
            throw new RangeError();
        }
        if (globalLegIndex <= speedConstraint.globalLegIndex) {
            let distance = distanceToLegEnd;
            const end = Math.min(speedConstraint.globalLegIndex + 1, lateralLegs.length);
            for (let i = globalLegIndex + 1; i < end; i++) {
                distance += (_b = (_a = lateralLegs[i].calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
            }
            return distance;
        }
        else {
            let distance = distanceToLegEnd - ((_d = (_c = lateralLegs[globalLegIndex].calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0);
            const end = Math.max(speedConstraint.globalLegIndex, 0);
            for (let i = globalLegIndex - 1; i > end; i--) {
                distance -= (_f = (_e = lateralLegs[i].calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            }
            return distance;
        }
    }
    /**
     * Gets the lateral distance, in meters, from a given query point along a flight plan to a cruise step in the same
     * flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param cruiseStep The cruise step to get the distance to.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of its containing leg.
     * @returns The lateral distance, in meters, from the specified query point to the specified cruise step.
     * @throws RangeError if `globalLegIndex` is out of bounds.
     */
    static getDistanceToCruiseStep(lateralLegs, cruiseStep, globalLegIndex, distanceToLegEnd) {
        var _a, _b, _c, _d, _e, _f;
        if (globalLegIndex < 0 || globalLegIndex >= lateralLegs.length) {
            throw new RangeError();
        }
        if (globalLegIndex <= cruiseStep.globalLegIndex) {
            let distance = distanceToLegEnd;
            const end = Math.min(cruiseStep.globalLegIndex + 1, lateralLegs.length);
            for (let i = globalLegIndex + 1; i < end; i++) {
                distance += (_b = (_a = lateralLegs[i].calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
            }
            return distance - cruiseStep.distanceToLegEnd;
        }
        else {
            let distance = distanceToLegEnd - ((_d = (_c = lateralLegs[globalLegIndex].calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0);
            const end = Math.max(cruiseStep.globalLegIndex, 0);
            for (let i = globalLegIndex - 1; i > end; i--) {
                distance -= (_f = (_e = lateralLegs[i].calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            }
            return distance - cruiseStep.distanceToLegEnd;
        }
    }
    /**
     * Gets the calibrated airspeed (CAS) to target, in meters per second.
     * @param defaultCas The default CAS to target, in meters per second.
     * @param speedConstraint The speed constraint in effect.
     * @param transitionCas The transition speed in effect, in meters per second.
     * @param restrictionCas The restriction speed in effect, in meters per second.
     * @returns The calibrated airspeed (CAS) to target, in meters per second, given the specified default CAS target,
     * speed constraint, and transition and restriction speeds.
     */
    static getTargetCas(defaultCas, speedConstraint, transitionCas, restrictionCas) {
        let targetCas = defaultCas;
        if (speedConstraint) {
            if (speedConstraint.minCas > targetCas) {
                targetCas = speedConstraint.minCas;
            }
            if (speedConstraint.maxCas < targetCas) {
                targetCas = speedConstraint.maxCas;
            }
        }
        if (restrictionCas !== undefined && restrictionCas < targetCas) {
            targetCas = restrictionCas;
        }
        if (transitionCas !== undefined && transitionCas < targetCas) {
            targetCas = transitionCas;
        }
        return targetCas;
    }
    /**
     * Gets the mach number to target.
     * @param defaultMach The default mach number to target.
     * @param speedConstraint The speed constraint in effect.
     * @returns The mach number to target, given the specified default mach target and speed constraint.
     */
    static getTargetMach(defaultMach, speedConstraint) {
        let targetMach = defaultMach;
        if (speedConstraint) {
            if (speedConstraint.minMach > targetMach) {
                targetMach = speedConstraint.minMach;
            }
            if (speedConstraint.maxMach < targetMach) {
                targetMach = speedConstraint.maxMach;
            }
        }
        return targetMach;
    }
    /**
     * Gets target speed data.
     * @param scheduleCas The scheduled calibrated airspeed, in meters per second, or `Infinity` if there is no scheduled
     * calibrated airspeed.
     * @param scheduleMach The scheduled mach number, or `Infinity` if there is no scheduled mach number.
     * @param speedConstraint The speed constraint in effect.
     * @param transitionCas The transition speed in effect, in meters per second.
     * @param restrictionCas The restriction speed in effect, in meters per second.
     * @param out The object to which to write the results.
     * @returns The target speed data given the specified scheduled speeds, speed constraint, and transition/restriction
     * speed limits.
     */
    static getTargetSpeedData(scheduleCas, scheduleMach, speedConstraint, transitionCas, restrictionCas, out) {
        out.targetCas = scheduleCas;
        out.targetCasSource = isFinite(scheduleCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        out.targetMach = scheduleMach;
        out.targetMachSource = isFinite(scheduleMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        if (speedConstraint) {
            if (speedConstraint.minCas > out.targetCas) {
                out.targetCas = speedConstraint.minCas;
                out.targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (speedConstraint.maxCas < out.targetCas) {
                out.targetCas = speedConstraint.maxCas;
                out.targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (speedConstraint.minMach > out.targetMach) {
                out.targetMach = speedConstraint.minCas;
                out.targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (speedConstraint.maxMach < out.targetMach) {
                out.targetMach = speedConstraint.maxMach;
                out.targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
        }
        if (restrictionCas !== undefined && restrictionCas < out.targetCas) {
            out.targetCas = restrictionCas;
            out.targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
        }
        if (transitionCas !== undefined && transitionCas < out.targetCas) {
            out.targetCas = transitionCas;
            out.targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
        }
        return out;
    }
    /**
     * Gets the average true course, in degrees, along a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The average true course, in degrees, along the specified flight plan leg, or `undefined` if the
     * leg's lateral path has not been calculated or its lateral distance is zero.
     */
    static getAverageLegCourse(leg) {
        if (leg.calculated
            && leg.calculated.startLat !== undefined
            && leg.calculated.startLon !== undefined
            && leg.calculated.endLat !== undefined
            && leg.calculated.endLon !== undefined) {
            const legCourse = GeoPoint.finalBearing(leg.calculated.startLat, leg.calculated.startLon, leg.calculated.endLat, leg.calculated.endLon);
            if (!isFinite(legCourse)) {
                return undefined;
            }
            else {
                return legCourse;
            }
        }
        else {
            return undefined;
        }
    }
    /**
     * Gets the effective wind component, in meters per second, along a course. The effective wind component is defined
     * such that for an airplane whose ground track is equal to the course, the airplane's ground speed is equal to the
     * airplane's true airspeed plus the effective wind component.
     * @param course The true course along which to get the wind component, in degrees.
     * @param windDirection The true wind direction, in degrees.
     * @param windSpeed The wind speed, in knots.
     * @param tas The airplane's true airspeed, in meters per second. If not defined, then the tailwind component along
     * the specified course will be returned (i.e. the scalar projection of the wind vector onto the course vector)
     * instead of the effective wind component.
     * @returns The effective wind component, in meters per second, along the specified course.
     */
    static getAlongCourseWindComponent(course, windDirection, windSpeed, tas) {
        if (windSpeed > 0) {
            const windMps = UnitType.KNOT.convertTo(windSpeed, UnitType.MPS);
            // Tailwind component along the course.
            const tailwind = windMps * Math.cos(MathUtils.diffAngleDeg(course, windDirection + 180, false) * Avionics.Utils.DEG2RAD);
            if (tas === undefined) {
                return tailwind;
            }
            else {
                // The airplane must adjust its heading (and therefore the direction of its TAS vector) to compensate for
                // crosswind in order to stay on course. In doing so, the along-course component of the TAS vector decreases.
                const cross = Math.sqrt(Math.max(windMps * windMps - tailwind * tailwind, 0));
                const alongCourseTas = Math.sqrt(Math.max(tas * tas - cross * cross, 0));
                return alongCourseTas + tailwind - tas;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * Gets an appropriate cruise vertical flight path vector type.
     * @param altitudeStep The altitude step for the vector, in meters.
     * @param acceleration The acceleration for the vector, in meters per second squared.
     * @returns An appropriate cruise vertical flight path vector type for a vector with the specified altitude step
     * and acceleration.
     */
    static getCruiseVectorType(altitudeStep, acceleration) {
        if (altitudeStep === 0) {
            if (acceleration === 0) {
                return VerticalFlightPathVectorType.Cruise;
            }
            else if (acceleration < 0) {
                return VerticalFlightPathVectorType.CruiseDeceleration;
            }
            else {
                return VerticalFlightPathVectorType.CruiseAcceleration;
            }
        }
        else if (altitudeStep > 0) {
            if (acceleration === 0) {
                return VerticalFlightPathVectorType.CruiseStepClimb;
            }
            else if (acceleration < 0) {
                return VerticalFlightPathVectorType.CruiseStepClimbDeceleration;
            }
            else {
                return VerticalFlightPathVectorType.CruiseStepClimbAcceleration;
            }
        }
        else {
            if (acceleration === 0) {
                return VerticalFlightPathVectorType.CruiseStepDescent;
            }
            else if (acceleration < 0) {
                return VerticalFlightPathVectorType.CruiseStepDescentDeceleration;
            }
            else {
                return VerticalFlightPathVectorType.CruiseStepDescentAcceleration;
            }
        }
    }
    /**
     * Gets the geo circle representation of the course at and the position vector of a point along a flight plan leg's
     * lateral flight path.
     * @param legCalc The lateral flight path calculations for a flight plan leg.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of the flight plan leg.
     * @param courseOut The geo circle to which write the flight path course at the query point.
     * @param positionOut The 3D vector to which to write the position vector of the query point.
     * @returns Whether a course and position vector were successfully found for the query point.
     */
    static getCourseAndPositionAlongLeg(legCalc, distanceToLegEnd, courseOut, positionOut) {
        // Iterate over all vectors (including transitions) in the leg in forward order until we reach the query point.
        let distanceToGo = legCalc.distanceWithTransitions - distanceToLegEnd;
        let vectors = legCalc.ingress;
        let vectorIndex = 0;
        let vector = vectors[vectorIndex];
        let lastVector = undefined;
        // ingress vectors
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // ingress to egress vectors
        vectors = legCalc.ingressToEgress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // egress vectors
        vectors = legCalc.egress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // If we have exhausted all vectors on the leg without reaching the query point, advance past the end of the last
        // vector (if it exists).
        if (lastVector) {
            FlightPathUtils.setGeoCircleFromVector(lastVector, courseOut);
            courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(lastVector.endLat, lastVector.endLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
            return true;
        }
        return false;
    }
}
BoeingPathCalculator.MAX_DISTANCE_STEP = 185200; // meters (100 nautical miles)
BoeingPathCalculator.MAX_DISTANCE_STEP_TOL = 18520; // meters (10 nautical miles)
BoeingPathCalculator.MAX_ALTITUDE_STEP = 304.8; // meters (1000 feet)
BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL = 30.48; // meters (100 feet)
BoeingPathCalculator.CLIMB_ACCEL_VS_MPS = UnitType.FPM.convertTo(500, UnitType.MPS);
BoeingPathCalculator.DESCENT_DECEL_VS_MPS = UnitType.FPM.convertTo(-500, UnitType.MPS);
BoeingPathCalculator.MIN_GROUND_SPEED = 25.722; // meters per second (50 knots)
BoeingPathCalculator.MIN_CLIMB_VS_MPS = UnitType.FPM.convertTo(200, UnitType.MPS);
BoeingPathCalculator.MIN_CLIMB_ACCELERATION = UnitType.KNOT_PER_SEC.convertTo(0.1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_LEVEL_ACCELERATION = UnitType.KNOT_PER_SEC.convertTo(0.1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_LEVEL_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(0.5, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_DESCENT_ACCELERATION = UnitType.KNOT_PER_SEC.convertTo(0.1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.MIN_DESCENT_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(0.5, UnitType.MPS_PER_SEC);
BoeingPathCalculator.ASSUMED_CLIMB_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(-1, UnitType.MPS_PER_SEC);
BoeingPathCalculator.CRUISE_STEP_START_MARGIN = 926000; // meters (500 nautical miles)
BoeingPathCalculator.CRUISE_STEP_TOD_MARGIN = 370400; // meters (200 nautical miles)
BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP = 185200; // meters (100 nautical miles)
BoeingPathCalculator.CRUISE_STEP_EVALUATE_STEP_TOL = 18520; // meters (10 nautical miles)
BoeingPathCalculator.CRUISE_STEP_EVALUATE_LOOKAHEAD = 926000; // meters (500 nautical miles)
BoeingPathCalculator.CRUISE_STEP_CLIMB_RESIDUAL_VS_MPS = UnitType.FPM.convertTo(200, UnitType.MPS);
BoeingPathCalculator.CRUISE_DESCENT_VS_MPS = UnitType.FPM.convertTo(-1250, UnitType.MPS);
BoeingPathCalculator.CRUISE_ANTICIPATION_ASSUMED_DECELERATION = UnitType.KNOT_PER_SEC.convertTo(-2, UnitType.MPS_PER_SEC);
BoeingPathCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingPathCalculator.vec3Cache = [Vec3Math.create()];
BoeingPathCalculator.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
BoeingPathCalculator.windCache = new Float64Array(2);
BoeingPathCalculator.econSpeedCache = new Float64Array(2);
BoeingPathCalculator.targetSpeedDataCache = {
    targetCas: Infinity,
    targetCasSource: VerticalFlightPathVectorSpeedSource.None,
    targetMach: Infinity,
    targetMachSource: VerticalFlightPathVectorSpeedSource.None
};
BoeingPathCalculator.getCourseAndPositionAlongLegCache = {
    geoPoint: [new GeoPoint(0, 0)]
};

var BoeingVNavVars;
(function (BoeingVNavVars) {
    BoeingVNavVars["VNAVDesiredState"] = "L:WTAP_Boeing_VNav_Desired_State";
    BoeingVNavVars["RNP"] = "L:WTAP_Boeing_VNav_RNP";
    BoeingVNavVars["PerformanceTODDistance"] = "L:WTAP_VNav_Distance_To_Performance_TOD";
    BoeingVNavVars["PerformanceTODLegIndex"] = "L:WTAP_VNav_Performance_TOD_Leg_Index";
    BoeingVNavVars["PerformanceTODDistanceInLeg"] = "L:WTAP_VNav_Performance_TOD_Distance_In_Leg";
})(BoeingVNavVars || (BoeingVNavVars = {}));
/** A publisher for Boeing VNAV sim var events. */
class BoeingVNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(BoeingVNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
BoeingVNavSimVarPublisher.simvars = new Map([
    ['boeingvnav_desired_state', { name: BoeingVNavVars.VNAVDesiredState, type: SimVarValueType.Enum }],
    ['boeingvnav_rnp', { name: BoeingVNavVars.RNP, type: SimVarValueType.Number }],
    ['boeingvnav_performance_tod_distance', { name: BoeingVNavVars.PerformanceTODDistance, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_leg_distance', { name: BoeingVNavVars.PerformanceTODDistanceInLeg, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_global_leg_index', { name: BoeingVNavVars.PerformanceTODLegIndex, type: SimVarValueType.Number }],
]);

/**
 * Valid CDI scale labels for the LVar scale enum.
 */
var CDIScaleLabel;
(function (CDIScaleLabel) {
    CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
    CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
    CDIScaleLabel[CDIScaleLabel["TerminalDeparture"] = 2] = "TerminalDeparture";
    CDIScaleLabel[CDIScaleLabel["TerminalArrival"] = 3] = "TerminalArrival";
    CDIScaleLabel[CDIScaleLabel["Enroute"] = 4] = "Enroute";
    CDIScaleLabel[CDIScaleLabel["Oceanic"] = 5] = "Oceanic";
    CDIScaleLabel[CDIScaleLabel["Approach"] = 6] = "Approach";
    CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 7] = "MissedApproach";
})(CDIScaleLabel || (CDIScaleLabel = {}));
/**
 * Sim var names for Boeing LNAV-related data.
 */
var BoeingLNavDataVars;
(function (BoeingLNavDataVars) {
    /** The global leg index of the flight plan leg that is nominally being tracked by LNAV. */
    BoeingLNavDataVars["NominalLegIndex"] = "L:WTBoeing_LNavData_Nominal_Leg_Index";
    /** The current CDI scale label. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    BoeingLNavDataVars["CDIScaleLabel"] = "L:WTBoeing_LNavData_CDI_Scale_Label";
    /** The current lateral RNP in nautical miles */
    BoeingLNavDataVars["RNP"] = "L:WTBoeing_LNavData_RNP";
    /** The nominal distance remaining to the end of the currently tracked flight plan leg. */
    BoeingLNavDataVars["TrackedLegEndDistance"] = "L:WTBoeing_LNavData_Tracked_Leg_End_Distance";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Distance_Direct";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationRunwayDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Runway_Distance_Direct";
    /** The flight plan distance to the final approach fix, in nautical miles. */
    BoeingLNavDataVars["FafDistance"] = "L:WTBoeing_LNavData_Faf_Distance";
    /** The direct distance to the missed approach point fix, in nautical miles, or -1 if invalid. */
    BoeingLNavDataVars["MapDistanceDirect"] = "L:WTBoeing_LNavData_Map_Distance";
    /** The total direct distance in nautical miles, or 0 when invalid. */
    BoeingLNavDataVars["TotalDistanceDirect"] = "L:WTBoeing_LNavData_Total_Distance_Direct";
})(BoeingLNavDataVars || (BoeingLNavDataVars = {}));
/**
 * A publisher for Boeing LNAV-related data sim var events.
 */
class BoeingLNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(BoeingLNavDataSimVarPublisher.simvars, bus);
    }
}
BoeingLNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale_label', { name: BoeingLNavDataVars.CDIScaleLabel, type: SimVarValueType.Number }],
    ['lnavdata_rnp', { name: BoeingLNavDataVars.RNP, type: SimVarValueType.Number }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }],
    ['lnavdata_total_distance_direct', { name: BoeingLNavDataVars.TotalDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_nominal_leg_index', { name: BoeingLNavDataVars.NominalLegIndex, type: SimVarValueType.Number }],
    ['lnavdata_tracked_leg_end_distance', { name: BoeingLNavDataVars.TrackedLegEndDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance_direct', { name: BoeingLNavDataVars.DestinationDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_destination_runway_distance_direct', { name: BoeingLNavDataVars.DestinationRunwayDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_faf', { name: BoeingLNavDataVars.FafDistance, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_map_direct', { name: BoeingLNavDataVars.MapDistanceDirect, type: SimVarValueType.NM }],
]);

/** base publisher for simvars */
class BoeingAPSimVarPublisher extends SimVarPublisher {
    /**
     * Create a BoeingAPSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(BoeingAPSimVarPublisher.simvars, bus, pacer);
    }
}
BoeingAPSimVarPublisher.simvars = new Map([
    ['ap_boeing_disconnected', { name: 'L:WT_Boeing_Autopilot_Disconnected', type: SimVarValueType.Bool }],
    ['ap_boeing_selected_ias', { name: 'AUTOPILOT AIRSPEED HOLD VAR:1', type: SimVarValueType.Knots }],
    ['ap_boeing_selected_mach', { name: 'AUTOPILOT MACH HOLD VAR:1', type: SimVarValueType.Number }],
    ['ap_boeing_mcp_speed_is_mach', { name: 'L:XMLVAR_AirSpeedIsInMach', type: SimVarValueType.Bool }],
    ['ap_boeing_track_mode_active', { name: 'L:XMLVAR_TRK_MODE_ACTIVE', type: SimVarValueType.Bool }],
    ['ap_boeing_approach_mode_armed', { name: 'L:AP_APR_ARMED', type: SimVarValueType.Bool }],
    ['ap_boeing_autothrottle_armed', { name: 'L:XMLVAR_AUTO_THROTTLE_ARM_0_STATE', type: SimVarValueType.Bool }],
]);

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
var BoeingFlightPlans;
(function (BoeingFlightPlans) {
    BoeingFlightPlans[BoeingFlightPlans["ACT_RTE_PLAN_INDEX"] = 0] = "ACT_RTE_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_1_INACTIVE_PLAN_INDEX"] = 1] = "RTE_1_INACTIVE_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_1_MOD_PLAN_INDEX"] = 2] = "RTE_1_MOD_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_2_INACTIVE_PLAN_INDEX"] = 3] = "RTE_2_INACTIVE_PLAN_INDEX";
    BoeingFlightPlans[BoeingFlightPlans["RTE_2_MOD_PLAN_INDEX"] = 4] = "RTE_2_MOD_PLAN_INDEX";
})(BoeingFlightPlans || (BoeingFlightPlans = {}));
var BoeingUserDataKeys;
(function (BoeingUserDataKeys) {
    BoeingUserDataKeys["USER_DATA_KEY_ALTN"] = "wtboeing.altn";
    BoeingUserDataKeys["USER_DATA_KEY_FIX_INFO"] = "wtboeing.fix-info";
    BoeingUserDataKeys["USER_DATA_KEY_NEW_INACTIVE_PLAN"] = "wtboeing.new-inactive-plan";
    BoeingUserDataKeys["USER_DATA_KEY_NEW_UPLINKED_PLAN"] = "wtboeing.new-uplinked-plan";
    BoeingUserDataKeys["USER_DATA_KEY_UPLINKED_PLAN_ID"] = "wtboeing.uplinked-plan-id";
    BoeingUserDataKeys["USER_DATA_KEY_ROUTE"] = "wtboeing.route";
    BoeingUserDataKeys["USER_DATA_KEY_VISUAL_APPROACH"] = "wtboeing.visual-approach";
    BoeingUserDataKeys["USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA"] = "wtboeing.visual-approach-vfr-vpa";
    BoeingUserDataKeys["USER_DATA_KEY_HUD_TAKEOFF"] = "wtboeing.hud-takeoff";
    BoeingUserDataKeys["USER_DATA_KEY_VNAV_DES_PENDING"] = "wtboeing.vnav-des-pending";
    BoeingUserDataKeys["USER_DATA_KEY_VNAV_CRUISE_CLIMB_PENDING"] = "wtboeing.vnav-cruise-climb-pending";
    BoeingUserDataKeys["USER_DATA_KEY_DIRECT_TO_PENDING"] = "wtboeing.direct-to-pending";
})(BoeingUserDataKeys || (BoeingUserDataKeys = {}));

/**
 * A utility class for working with Boeing flight path calculations.
 */
class BoeingFlightPathUtils {
}
/** The flight path calculator plans turns at these bank angles */
BoeingFlightPathUtils.flightPathBankAngleTable = [
    [15, 0],
    [25, 100],
    [25, 375],
    [19, 450],
];

const definitions = {
    'manualZfw': {
        defaultValue: null,
    },
    'manualGw': {
        defaultValue: null,
    },
    'takeoffGw': {
        defaultValue: null,
    },
    'cruiseCg': {
        defaultValue: null,
    },
    'manualLateralRnp': {
        defaultValue: null,
    },
    'manualVerticalRnp': {
        defaultValue: null,
    },
    'takeoffFlaps': {
        defaultValue: null,
    },
    'takeoffCg': {
        defaultValue: null,
    },
    'takeoffAssumedTemp': {
        defaultValue: null,
    },
    'takeoffThrustMode': {
        defaultValue: TakeoffThrustMode.TO,
    },
    'takeoffThrustReductionPoint': {
        defaultValue: 1500,
    },
    'takeoffAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffEoAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffTemp': {
        defaultValue: null,
    },
    'takeoffWind': {
        defaultValue: null,
    },
    'takeoffRunwayWind': {
        defaultValue: null,
    },
    'takeoffRunwaySlope': {
        defaultValue: 0,
    },
    'takeoffRunwayCondition': {
        defaultValue: RunwayCondition.DRY,
    },
    'climbThrustMode': {
        defaultValue: ClimbThrustMode.CLB,
    },
    'climbSegmentExists': {
        defaultValue: false,
    },
    'cruiseRequiredTpr': {
        defaultValue: 0, // TODO Replace with actual value
    },
    'takeoffAirportIcao': {
        defaultValue: null,
    },
    'originRunway': {
        defaultValue: null,
    },
    'takeoffRunway': {
        defaultValue: null,
    },
    'takeoffRunwayPositionShift': {
        defaultValue: null,
    },
    'approachAirportIcao': {
        defaultValue: null,
    },
    'approachRunway': {
        defaultValue: null,
    },
    'approachLandingRef': {
        defaultValue: 1,
    },
    'glideSlope': {
        defaultValue: GlideslopeStatus.ON,
        differentiateInModPlan: true,
    },
    'approachWindCorrection': {
        defaultValue: 5,
    },
    'approachFlapSpeed': {
        defaultValue: null,
    },
    'cruiseAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedLimitCas': {
        defaultValue: 250,
    },
    'climbSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'climbSpeedRestrCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedRestrAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'descentSpeedLimitCas': {
        defaultValue: 240,
    },
    'descentSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'descentSpeedRestrCas': {
        defaultValue: null,
    },
    'descentSpeedRestrAltitude': {
        defaultValue: null,
    },
    'transitionAltitude': {
        defaultValue: 18000,
    },
    'transitionLevel': {
        defaultValue: 18000,
    },
    'stepSize': {
        defaultValue: 'ICAO',
    },
    'reserveFuel': {
        defaultValue: null,
    },
    'costIndex': {
        defaultValue: null,
    },
    'currentThrustMode': {
        defaultValue: null,
    },
    'speedMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbEconCas': {
        defaultValue: 310,
    },
    'speedClimbEconMach': {
        defaultValue: .85,
    },
    'speedClimbSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedClimbSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedCruiseEconCas': {
        defaultValue: 310,
    },
    'speedCruiseEconMach': {
        defaultValue: .850,
    },
    'speedCruiseEconUnit': {
        defaultValue: 'cas',
    },
    'speedCruiseSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedDescentEconCas': {
        defaultValue: 290,
    },
    'speedDescentEconMach': {
        defaultValue: .850,
    },
    'speedDescentSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'thermalAntiIceAltitude': {
        defaultValue: null,
    },
    'alternateCruiseAltitude': {
        defaultValue: 37000,
    },
    'alternateSpeedValue': {
        defaultValue: 250,
    },
    'alternateSpeedIsMach': {
        defaultValue: false,
    },
};

/**
 * Proxied `MutableSubscribable` that mirrors a property desired to be accessed by {@link PerformancePlanProxy}
 */
class ProxiedPerformancePlanProperty extends AbstractSubscribable {
    /**
     * Ctor
     *
     * @param key property key
     * @param proxy the proxy this property belongs to
     * @param editInPlace whether the property can be edited without a new flight plan being created
     */
    constructor(key, proxy, editInPlace = false) {
        super();
        this.key = key;
        this.proxy = proxy;
        this.editInPlace = editInPlace;
        this.targetPlan = null;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subject = Subject.create(null);
        this.backSubjectSubscription = undefined;
    }
    /**
     * Switches the target plan
     *
     * @param plan the new target plan
     */
    switchToPlan(plan) {
        var _a;
        this.targetPlan = plan;
        (_a = this.backSubjectSubscription) === null || _a === void 0 ? void 0 : _a.destroy();
        this.backSubjectSubscription = this.backingSubject().sub((it) => {
            this.subject.set(it);
        }, true);
    }
    /**
     * Returns the backing subject in the target plan for the property
     *
     * @returns the subject
     *
     * @throws if no target plan exists
     */
    backingSubject() {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        return this.targetPlan[this.key];
    }
    /**
     * Resets the property to its default value according to the default values performance plan
     */
    resetToDefault() {
        const defaultValue = this.proxy.defaultValuesPlan[this.key];
        this.proxy.onBeforeEdit(this, defaultValue);
        this.backingSubject().set(defaultValue.get());
        this.proxy.onAfterEdit(this, defaultValue);
    }
    /** @inheritDoc */
    get() {
        if (!this.targetPlan) {
            return null;
        }
        return this.backingSubject().get();
    }
    /** @inheritDoc */
    set(value) {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        this.proxy.onBeforeEdit(this, value);
        this.backingSubject().set(value);
        this.proxy.onAfterEdit(this, value);
    }
    /** @inheritDoc */
    sub(handler, initialNotify, paused) {
        return this.subject.sub(handler, initialNotify, paused);
    }
    /** @inheritDoc */
    unsub(handler) {
        return this.subject.unsub(handler);
    }
}

/**
 * Utils for performance plans
 */
class PerformancePlanUtils {
    /**
     * Serializes a plan
     *
     * @param plan the plan to serialize
     *
     * @returns the serialized JSON string
     */
    static serialize(plan) {
        const tmpObj = {};
        Object.keys(plan).forEach((key) => {
            tmpObj[key] = plan[key].get();
        });
        return JSON.stringify(tmpObj);
    }
    /**
     * Deserializes a serialized performance plan into a plan
     *
     * @param data the serialized data string
     * @param plan the plan to deserialize into
     */
    static deserializeInto(data, plan) {
        const customData = JSON.parse(data);
        Object.keys(customData).forEach((key) => {
            const value = customData[key];
            if (value !== undefined) {
                plan[key].set(value);
            }
        });
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @returns a performance plan with default values filled
     */
    static createPlanFromDefinitions() {
        const plan = {};
        for (const [key, definition] of Object.entries(definitions)) {
            plan[key] = Subject.create(definition.defaultValue);
        }
        return plan;
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @param partialProxy an object containing the callbacks to attach to the proxy
     *
     * @returns a performance plan with default values filled
     */
    static createProxyFromDefinitions(partialProxy) {
        const proxy = {
            defaultValuesPlan: partialProxy.defaultValuesPlan,
            /** @inheritDoc */
            switchToPlan(plan, initial) {
                for (const [key, definition] of Object.entries(definitions)) {
                    if (initial || definition.differentiateInModPlan) {
                        this[key].switchToPlan(plan);
                    }
                }
            },
            /** @inheritDoc */
            onBeforeEdit(property, newValue) {
                partialProxy.onBeforeEdit(property, newValue);
            },
            /** @inheritDoc */
            onAfterEdit(property, newValue) {
                partialProxy.onAfterEdit(property, newValue);
            },
        };
        for (const [key, definition] of Object.entries(definitions)) {
            const property = new ProxiedPerformancePlanProperty(key, proxy, !definition.differentiateInModPlan);
            proxy[key] = property;
        }
        return proxy;
    }
}

/**
 * Correlates flight plan indices with performance plan objects
 */
class PerformancePlanRepository {
    /**
     * Ctor
     * @param flightPlanner a flight planner instance
     * @param bus the event bus
     */
    constructor(flightPlanner, bus) {
        this.flightPlanner = flightPlanner;
        this.bus = bus;
        this.repoId = Math.floor(Math.random() * 10000000);
        this._plans = [];
        this.plans = this._plans;
        this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[BoeingFlightPlans.ACT_RTE_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        const sub = this.bus.getSubscriber();
        sub.on('fplOriginDestChanged').handle((data) => {
            if (data.type === OriginDestChangeType.OriginAdded || data.type === OriginDestChangeType.OriginRemoved) {
                this.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, data.planIndex);
            }
        });
        sub.on('performancePlanChanged').handle((data) => {
            if (data.repoId !== this.repoId) {
                PerformancePlanUtils.deserializeInto(data.serializedPlan, this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX]);
                if (this.has(data.planIndex)) {
                    this.copy(PerformancePlanRepository.SYNC_PLAN_INDEX, data.planIndex, true);
                }
            }
        });
    }
    /**
     * Whether the repository has a performance plan already stored for a given index
     *
     * @param index the index
     *
     * @returns boolean
     */
    has(index) {
        return this._plans[index] !== undefined;
    }
    /**
     * Returns a performance plan for a given flight plan index, or creates it
     *
     * @param index flight plan index
     *
     * @throws if an invalid flight plan index is specified
     *
     * @returns the performance plan
     */
    forFlightPlanIndex(index) {
        const existing = this._plans[index];
        if (!existing) {
            return this.create(index);
        }
        return existing;
    }
    /**
     * Gets the active plan. This is the plan that always exists even if there is no valid flight plan yet.
     * @returns the active plan
     */
    getActivePlan() {
        return this._plans[BoeingFlightPlans.ACT_RTE_PLAN_INDEX];
    }
    /**
     * Returns the performance plan containing default values
     *
     * @returns the plan
     */
    defaultValuesPlan() {
        return this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX];
    }
    /**
     * Returns whether this plan repository has nay valid plans
     *
     * @returns boolean
     */
    hasAnyPlan() {
        return this._plans.some((it, index) => !!it && this.flightPlanner.hasFlightPlan(index));
    }
    /**
     * Creates a performance plan at the given index if it doesn't exist, or returns the existing one
     *
     * @param atIndex the index
     *
     * @returns the created plan
     */
    create(atIndex) {
        if (!this.has(atIndex)) {
            const newPerformancePlan = PerformancePlanUtils.createPlanFromDefinitions();
            this._plans[atIndex] = newPerformancePlan;
            return newPerformancePlan;
        }
        else {
            return this._plans[atIndex];
        }
    }
    /**
     * Copies a performance plan onto another
     *
     * @param from from index
     * @param to to index
     * @param skipChecks whether to skip flight planner checks
     */
    copy(from, to, skipChecks = false) {
        const fromPlan = this._plans[from];
        const toPlan = skipChecks ? this._plans[to] : this.forFlightPlanIndex(to);
        // Copy data
        for (const key in toPlan) {
            const fromValue = fromPlan[key];
            const toValue = toPlan[key];
            if (fromValue instanceof Subject && toValue instanceof Subject) {
// do a shallow comparison of properties if fromValue is a complex type
                if (typeof fromValue.get() === 'object' && this.isSameObject(fromValue.get(), toValue.get())) {
                    continue;
                }
                toValue.set(fromValue.get());
            }
        }
    }
/**
     * Checks whether two objects are the same by performing a (very) shallow comparison.
     * @param obj1 The first object
     * @param obj2 The second object
     * @returns true if the objects are the same
     */
    isSameObject(obj1, obj2) {
        // Check if the values are null or undefined
        if (obj1 == null || obj2 == null) {
            return obj1 === obj2;
        }
        for (const prop in obj1) {
            if (typeof obj1[prop] === 'object') {
                continue;
            }
            if (obj1[prop] !== obj2[prop]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Triggers a synchronisation of the active plan performance plan over the EventBus.
     * @param planIndex the plan index
     */
    triggerSync(planIndex) {
        const packet = {
            repoId: this.repoId,
            planIndex,
            serializedPlan: PerformancePlanUtils.serialize(this._plans[planIndex]),
        };
        this.bus.getPublisher().pub('performancePlanChanged', packet, true, true);
    }
}
PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX = Number.MAX_SAFE_INTEGER;
PerformancePlanRepository.SYNC_PLAN_INDEX = PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX - 1;

/**
 * An abstract implementation of {@link BoeingSpeedProvider} which handles the computation of economy (ECON) speeds.
 */
class AbstractBoeingSpeedProvider {
    /**
     * Creates a new instance of AbstractBoeingSpeedProvider.
     * @param engineDataProvider A provider of airplane engine data.
     */
    constructor(engineDataProvider) {
        this.engineDataProvider = engineDataProvider;
    }
    /** @inheritdoc */
    getEconCruiseSpeed(costIndex, altitude, weight, headwind, out, pressure) {
        pressure !== null && pressure !== void 0 ? pressure : (pressure = AeroMath.isaPressure(UnitType.FOOT.convertTo(altitude, UnitType.METER)));
        // TODO: Get rid of hardcoded constants based on 787 numbers.
        // First we need to determine the limits of any FMC commanded speed:
        // During cruise the maximum ECON speed is MMO/VMO - 5 knots.
        const vmoCas = Math.round(this.getVmo(altitude));
        const vmoReducedBy5 = vmoCas - 5;
        const mmo = this.getMmo();
        const mmoCas = UnitType.KNOT.convertFrom(AeroMath.machToCas(mmo, pressure), UnitType.MPS);
        const mmoReducedBy5 = AeroMath.casToMach(UnitType.MPS.convertFrom(mmoCas - 5, UnitType.KNOT), pressure);
        // 1. ECON mach calculation:
        // We use LRC mach as baseline, as it already incorporates alt and weight.
        const lrcMach = this.engineDataProvider.getLongRangeCruiseMach(weight, altitude);
        // LRC speed is assumed to match ECON speed at Ci = ~180 and at Ci = 0 we assume a speed drop of -1%.
        // So, to calculate the ci based ECON mach, we scale LRC speed accordingly.
        const ci0EconMach = lrcMach * 0.99;
        const ciAdjustedEconMach = ci0EconMach + lrcMach * costIndex / 18000.0;
        // Next, the headwind is used to calculate a wind related ECON mach offset.
        // From the ECON-mach tables of comparable long range widebodies, we find that the impact on ECON mach (for a change between
        // 100 kts headwind vs 100 kts tailwind) at mtow is 4 times less than at empty weight. At the same time, changing alt from
        // FL270 to FL Max results also in a 4 times smaller impact.
        const headwindInducedOffset = (headwind / 10000) // Gives a +/- 0.01 offset when headwind changes +/- 100 kts
            * MathUtils.lerp(altitude, 27000, 43000, 2, 0.5) // multiplied with 2 @FL270 ... 0.5 @FL430
            * (-0.000009679 * weight + 5.891) // and multiplied with 3 @OEW ... 0.3 @MTOW
        ;
        // We can wrap up the calculation by adding the wind induced offset (headwind -> increase ECON mach,
        // tailwind -> decrease ECON mach) and clip the maximum at Mmo and the minimum at ci0CruiseMach (see Boeing PDF on cost index):
        const windAndCiAdjustedEconMach = MathUtils.clamp(ciAdjustedEconMach + headwindInducedOffset, ci0EconMach, mmo);
        // 2. ECON cas calculation
        // Based on the Boeing PDF AERO_FuelConsSeries, ECON cruise cas limits are defined as follows:
        // - min ci -> 290, max ci -> vmo reduced by 5,
        // For any intermediate ci values, we scale between the limits, while considering, that most of the cas range
        // is covered by a small portion of the full ci range. Evidence from videos suggest, that climb ECON cas
        // often lingers around the 300 mark. So define the lerp table as follows:
        // - ci0 -> 290, ci300 -> 340 and ci9999 -> vmo - 5
        const econCas = Math.round((costIndex <= 300
            ? MathUtils.lerp(costIndex, 0, 300, 290, 340, true, true)
            : MathUtils.lerp(costIndex, 300, 9999, 340, Math.max(vmoReducedBy5, 340), true, true)) + headwindInducedOffset / 10);
        out[0] = Math.min(econCas, vmoReducedBy5);
        out[1] = Math.min(windAndCiAdjustedEconMach, mmoReducedBy5);
        return out;
    }
    /** @inheritdoc */
    getEconDescentSpeed(costIndex, altitude, weight, out, pressure) {
        pressure !== null && pressure !== void 0 ? pressure : (pressure = AeroMath.isaPressure(UnitType.FOOT.convertTo(altitude, UnitType.METER)));
        // First we need to determine the limits of any FMC commanded speed:
        // During descent the maximum ECON speed is MMO/VMO - 16 knots.
        const vmoCas = Math.round(this.getVmo(altitude));
        const vmoReducedBy16 = vmoCas - 16;
        const mmo = this.getMmo();
        const mmoCas = UnitType.KNOT.convertFrom(AeroMath.machToCas(mmo, pressure), UnitType.MPS);
        const mmoReducedBy16 = AeroMath.casToMach(UnitType.MPS.convertFrom(mmoCas - 16, UnitType.KNOT), pressure);
        // 1. ECON mach calculation:
        // We use LRC mach as baseline, as it already incorporates alt and weight.
        const lrcMach = this.engineDataProvider.getLongRangeCruiseMach(weight, altitude);
        // LRC speed is assumed to match ECON speed at Ci = ~180 and at Ci = 0 we assume a speed drop of -1%.
        // So, to calculate the ci based ECON mach, we scale LRC speed accordingly.
        const ci0EconMach = lrcMach * 0.99;
        const ciAdjustedEconMach = ci0EconMach + lrcMach * costIndex / 18000.0;
        // 2. ECON cas calculation
        // Based on the Boeing PDF AERO_FuelConsSeries, ECON descent cas limits are defined as follows:
        // - min ci -> 250 (max L/D), max ci -> vmo reduced by 16,
        // For any intermediate ci values, we scale between the limits, while considering, that most of the cas range
        // is covered by a small portion of the full ci range. Evidence from videos suggest, that climb ECON cas
        // often lingers around the 300 mark. So define the lerp table as follows:
        // - ci0 -> 250, ci100 -> 320 and ci9999 -> 344 (vmo - 16)
        const econCas = Math.round(costIndex <= 100
            ? MathUtils.lerp(costIndex, 0, 100, 250, 320, true, true)
            : MathUtils.lerp(costIndex, 100, 9999, 320, Math.max(vmoReducedBy16, 320), true, true));
        out[0] = Math.min(econCas, vmoReducedBy16);
        out[1] = Math.min(ciAdjustedEconMach, mmoReducedBy16);
        return out;
    }
}

/* eslint-disable jsdoc/require-jsdoc */
/**
 * TODO: This needs to have the aircraft specific performance values split out from the static constants and methods.
 * Boeing Performance Math Utility Class.
 */
class BoeingAeroMath {
    // TODO: Clean up these various delta/pressure ratio methods....
    /**
     * Calculates the current dynamic pressure ratio.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg.
     * @param mach The current aircraft mach number.
     * @returns the current dynamic pressure ratio.
     */
    static calcDynamicPressureRatio(ambientPressure, mach) {
        return 1481.4 * Math.pow(mach, 2) * BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure);
    }
    /**
     * Calculate atmospheric pressure ratio from pressure altitude
     * @todo belongs somewhere else
     * @param zp Pressure altitude in feet
     * @param tropopause Tropopause altitude in feet
     * @returns Atmospheric pressure ratio (delta)
     */
    static deltaFromPressureAlt(zp, tropopause = 36089.24) {
        return zp < tropopause ? ((288.15 - 0.0019812 * zp) / 288.15) ** 5.25588 : 0.22336 * Math.E ** ((36089.24 - zp) / 20805.7);
    }
    /**
     * Calculate the Delta Pressure Ratio for a given altitude above sea level.
     * @param altitude The altitude, in Ft.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAltitude(altitude) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
        return isa[1] * 100 / BoeingAeroMath.slIsaPres;
    }
    /**
     * Calculate the Delta Pressure Ratio for a given ambient pressure.
     * @param ambientPressure The ambient pressure, in inHg.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAmbientPressure(ambientPressure) {
        return ambientPressure / 29.92;
    }
    /**
     * Calculate the Delta Total Pressure Ratio for a given Delta Pressure Ratio and Mach.
     * @param deltaPressureRatio The Delta Pressure Ratio.
     * @param mach The Mach.
     * @returns The Delta Total Pressure Ratio.
     */
    static calcDeltaTotalPressureRatio(deltaPressureRatio, mach) {
        return deltaPressureRatio * Math.pow(1 + 0.2 * (Math.pow(mach, 2)), 3.5);
    }
    /**
     * Calculates a thrust correction factor. Multiplying the correction factor by uncorrected thrust yields corrected
     * thrust.
     * @param mach The mach number.
     * @param ambientPressure The ambient pressure in inHg.
     * @returns The thrust correction factor for the specified parameters.
     */
    static calculateThrustCorrectionFactor(mach, ambientPressure) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        return 1 / (deltaPressureRatio * totalInletPressureMachRise);
    }
    /**
     * Gets the ISA Standard Temp and Press from Altitude.
     * @param altitude The altitude in feet.
     * @param isaPresDeviation Optional Pressure Deviation, in inHg.
     * @param isaTempDeviation Optional Temperature Deviation, in C.
     * @returns an array of [temp K, pressure HPA]
     */
    static calcIsaFromAltitude(altitude, isaPresDeviation, isaTempDeviation) {
        if (isaPresDeviation !== undefined) {
            altitude = BoeingAeroMath.calcPressureAltitude(altitude, 29.92 + isaPresDeviation);
        }
        let temp = 0.0;
        let pressure = 0.0;
        if (altitude <= 36089) {
            // 36089 is the altitude of the top of the troposphere
            temp = BoeingAeroMath.slIsaTemp + (-BoeingAeroMath.lapseFt * altitude);
            pressure = BoeingAeroMath.slIsaPres * Math.pow((BoeingAeroMath.slIsaTemp / temp), (0.034163203 / -0.0065));
        }
        else if (altitude <= 65616) {
            // 65616 is the altitude of the tropopause
            // 22335.6 is the pressure at the base of the tropopause in PA
            // const tropoPres = 22335.6;
            // tropoTemp = 216.65;
            temp = 216.65;
            pressure = 0.223356 * 101325 * Math.exp(-0.000157688 * (altitude - 36089));
        }
        else {
            temp = NaN;
            pressure = NaN;
        }
        return [temp + (isaTempDeviation !== null && isaTempDeviation !== void 0 ? isaTempDeviation : 0), pressure / 100];
    }
    /**
     * Calculate the speed of sound from temperature.
     * @param ambientTemperature The ambient temperature, in C.
     * @returns The speed of sound in ft/s.
     */
    static calcSpeedOfSoundFromTemp(ambientTemperature) {
        return Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE));
    }
    /**
     * Calculate the pressure altitude from Indicated Altitude and Sea Level Pressure.
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Pressure Altitude.
     */
    static calcPressureAltitude(indicatedAltitude, baroSettingInHg) {
        return indicatedAltitude + (1000 * (29.92 - baroSettingInHg));
    }
    /**
     * Calculate the static pre
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Static Pressure in inHg.
     */
    static calcStaticPressure(indicatedAltitude, baroSettingInHg) {
        return UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(BoeingAeroMath.calcPressureAltitude(indicatedAltitude, baroSettingInHg))[1], UnitType.IN_HG);
    }
    /**
     * Calculate the Impact Pressure from CAS.
     * @param cas Calibrated Airspeed in knots.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromCas(cas) {
        return BoeingAeroMath.airDensity * Math.pow(UnitType.KNOT.convertTo(cas, UnitType.MPS), 2) / 2;
    }
    /**
     * Calculate the Impact Pressure.
     * @param mach Mach Number.
     * @param ambientPressure The Ambient Pressure, in inHg.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromMach(mach, ambientPressure) {
        return 100 * (UnitType.IN_HG.convertTo(ambientPressure, UnitType.HPA) * (Math.pow(1 + Math.pow(0.2 * mach, 2), 2 / 7) - 1));
    }
    /**
     * Calculate the Mach number from airspeed, altitude and pressure.
     * @param cas Calibrated Airspeed in knots.
     * @param indicatedAltitude Indicated Altitude in Feet.
     * @param baroSettingInHg The local altimeter setting in inHg.
     * @returns The current Mach Number.
     */
    static calcMachFromCasAltitudePressure(cas, indicatedAltitude, baroSettingInHg) {
        const impactPressure = BoeingAeroMath.calcImpactPressureFromCas(cas);
        const staticPressure = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        return Math.sqrt(5 * (Math.pow((impactPressure / staticPressure) + 1, 2 / 7) - 1));
    }
    /**
     * Calculate static air temperature (SAT, also OAT), from total air temperature (TAT) and Mach.
     * @param tat Total Air Temp in degrees C.
     * @param mach Mach number.
     * @returns The Static Air Temperature in degrees C.
     */
    static calcSatFromTatAndMach(tat, mach) {
        // Gamma minus 1 / 2 = 0.2
        return UnitType.KELVIN.convertTo(UnitType.CELSIUS.convertTo(tat, UnitType.KELVIN) / (1 + (Math.pow(mach, 2) * 0.2)), UnitType.CELSIUS);
    }
    /**
     * Calculate the True Airspeed from Altitude, Temperature and Calibrated Airspeed.
     * @param altitude Altitude in Feet.
     * @param tat Total Air Temp in degrees C.
     * @param cas Calibrated Airspeed in KT.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns True Airspeed in KT.
     */
    static calcTasFromCas(altitude, tat, cas, baroSettingInHg) {
        const pressureAltitude = BoeingAeroMath.calcPressureAltitude(altitude, baroSettingInHg);
        const isa = BoeingAeroMath.calcIsaFromAltitude(pressureAltitude);
        const isaPres = isa[1];
        const mach = BoeingAeroMath.calcMachFromCasAltitudePressure(cas, altitude, baroSettingInHg);
        const temp = UnitType.CELSIUS.convertTo(BoeingAeroMath.calcSatFromTatAndMach(tat, mach), UnitType.KELVIN);
        const alpha = Math.sqrt(BoeingAeroMath.gammaGasVolume * temp);
        const tas = Math.sqrt(5) * alpha * Math.sqrt(Math.pow(((BoeingAeroMath.slIsaPres / isaPres) *
            (Math.pow((cas * cas / BoeingAeroMath.sqrtGammaGasSlNmSqd5) + 1, BoeingAeroMath.gammaOverGammaMinus1) - 1) + 1), BoeingAeroMath.gammaMinus1OverGamma) - 1);
        return UnitType.FPS.convertTo(tas, UnitType.KNOT);
    }
    /**
     * Calculate EAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientPressure Ambient Pressure, in inHg.
     * @returns The Equivalent Airspeed (EAS).
     */
    static calcEasFromMachAndAmbientPressure(mach, ambientPressure) {
        return UnitType.FPS.convertTo(BoeingAeroMath.sound * mach *
            Math.sqrt(BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure)), UnitType.KNOT);
    }
    /**
     * Calculate CAS from EAS.
     * @param eas Equivalent Airspeed in knots
     * @param pressureAlt The current pressure altitude, in Feet.
     * @returns Calibrated airspeed in knots
     */
    static easToCas(eas, pressureAlt) {
        const delta = BoeingAeroMath.deltaFromPressureAlt(pressureAlt);
        return 1479.1 * Math.sqrt((1 + delta * ((1 + 1 / delta * (eas / 1479.1) ** 2) ** 3.5 - 1)) ** (1 / 3.5) - 1);
    }
    /**
     * Calculate CAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientTemp Ambient Temperature, in C.
     * @returns The True Airspeed (TAS).
     */
    static calcTasFromMachAndTemp(mach, ambientTemp) {
        return mach * BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemp);
    }
    /**
     * Calculate density altitude from indicated altitude, barometer setting and static air temperature.
     * @param indicatedAltitude indicated altitude in feet (ft)
     * @param baroSettingInHg barometer setting in inches of mercury (inHg)
     * @param sat static air temperature in degrees celsius (°C)
     * @returns density altitude in feet (ft)
     */
    static calcDensityAltitude(indicatedAltitude, baroSettingInHg, sat) {
        const stationPressurePa = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        const stationPressureinHg = UnitType.HPA.convertTo(stationPressurePa / 100, UnitType.IN_HG);
        const tempR = 459.67 + UnitType.CELSIUS.convertTo(sat, UnitType.FAHRENHEIT);
        // NWS Calculation for ASOS/AWOS
        return 145422.16 * (1 - Math.pow(17.326 * stationPressureinHg / tempR, 0.235));
    }
    /**
     * Calculate observed wind from true airspeed, ground speed, magnetic heading and magnetic track.
     * @param tas The true airspeed in KT.
     * @param gs The ground speed in KT.
     * @param heading The current magnetic heading in degrees.
     * @param track The current magnetic ground track in degrees.
     * @returns Array of [wind direction degrees mag, wind speed kt].
     */
    static calcWind(tas, gs, heading, track) {
        const headingRad = UnitType.DEGREE.convertTo(heading, UnitType.RADIAN);
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windComponentNorth = gs * Math.cos(trackRad) - tas * Math.cos(headingRad);
        const windComponentEast = gs * Math.sin(trackRad) - tas * Math.sin(headingRad);
        const windDirection = NavMath.normalizeHeading(90 - Math.round(UnitType.RADIAN.convertTo(Math.atan2(-windComponentNorth, -windComponentEast), UnitType.DEGREE)));
        const windSpeed = Math.sqrt(Math.pow(windComponentNorth, 2) + Math.pow(windComponentEast, 2));
        return [windDirection, windSpeed];
    }
    /**
     * Calculate headwind and crosswind components from the current ground track, wind speed and wind direction.
     * @param track Current magnetic ground track.
     * @param windSpeed Current wind speed in kt.
     * @param windDirection Current wind direction in degrees magnetic.
     * @returns Array of [headwind component in kt (+ is headwind, - is tailwind),
     * crosswind component in kt (+ is Left crosswind, - is Right crosswind)].
     */
    static calcRelativeWindComponents(track, windSpeed, windDirection) {
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windDirectionRad = UnitType.DEGREE.convertTo(windDirection, UnitType.RADIAN);
        return [
            Math.round(windSpeed * (Math.cos(trackRad - windDirectionRad))),
            Math.round(windSpeed * (Math.sin(trackRad - windDirectionRad)))
        ];
    }
}
/** ISA temp at Sea Level in Kelvin  */
BoeingAeroMath.slIsaTemp = 288.15;
/** ISA pressure at Sea Level in Pascals  */
BoeingAeroMath.slIsaPres = 101325;
/** Specific heat ratio for air  */
BoeingAeroMath.gamma = 1.4;
/** Constant: gamma over gamma minus 1 */
BoeingAeroMath.gammaOverGammaMinus1 = BoeingAeroMath.gamma / (BoeingAeroMath.gamma - 1);
/** Constant: gamma minus 1 over gamma */
BoeingAeroMath.gammaMinus1OverGamma = (BoeingAeroMath.gamma - 1) / BoeingAeroMath.gamma;
/** Specific gas constant in Kelvin (from the world)  */
BoeingAeroMath.gasKelvin = 287.05;
/** Specific gas constant in Rankine (from sim code) */
BoeingAeroMath.gasRankine = 1716;
/** Specific heat ratio for air times gas constant.  */
BoeingAeroMath.gammaGas = BoeingAeroMath.gamma * BoeingAeroMath.gasKelvin;
/** Specific heat ratio for air times gas constant divided per cubic ft.  */
BoeingAeroMath.gammaGasVolume = BoeingAeroMath.gammaGas / Math.pow(UnitType.FOOT.convertTo(1, UnitType.METER), 2);
/** Constant: gammaGas * slIsaTemp */
BoeingAeroMath.gammaGasSl = BoeingAeroMath.gammaGas * BoeingAeroMath.slIsaTemp;
/** Constant: sqrt gammaGasSl * nm */
BoeingAeroMath.sqrtGammaGasSlNm = Math.sqrt(BoeingAeroMath.gammaGasSl) * UnitType.METER.convertTo(3600.0, UnitType.NMILE);
/** Constant: 5 * sqrtGammaGasSlNm squared  */
BoeingAeroMath.sqrtGammaGasSlNmSqd5 = 5.0 * BoeingAeroMath.sqrtGammaGasSlNm * BoeingAeroMath.sqrtGammaGasSlNm;
/** Atmospheric Lapse Rate Constant (Kelvin per foot)  */
BoeingAeroMath.lapseFt = 0.0019812;
/** Fluid density of Air in kg/m^3.  */
BoeingAeroMath.airDensity = 1.225;
/** Gravity at SL ft/s^2.  */
BoeingAeroMath.gravity = 32.17405;
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;
/** Speed of Sound at SL ft/s.  */
BoeingAeroMath.sound = Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE);

/* eslint-disable max-len */
/**
 * An interface for accessing aircraft specific performance data.
 */
class BoeingPerformanceDataProvider {
    constructor() {
        /** Aircraft Specific values from flight_model.cfg and engines.cfg files.  */
        this.aircraftFlightModel = this.getAircraftFlightModel();
        this.aspectRatio = Math.pow(this.aircraftFlightModel.wing_span, 2) / this.aircraftFlightModel.wing_area;
    }
    /**
     * Calculate the Optimum (best range) Altitude for a specific Mach.
     * @param mach The Mach number.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude, in FT.
     */
    calcOptimumAltitudeFromCruiseMach(mach, weight) {
        const rangeTable = [];
        let altitude = 25000;
        while (altitude <= 43100) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            altitude += 1000;
        }
        const maxRange = Math.max(...rangeTable);
        const optAltitude = 25000 + 1000 * rangeTable.findIndex(v => v === maxRange);
        return optAltitude;
    }
    /**
     * Calculate the Optimum (best range) Mach for a specific Altitude.
     * @param altitude The Altitude, in FT.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Mach.
     */
    calcOptimumCruiseMachFromAltitude(altitude, weight) {
        const rangeTable = [];
        let mach = .7;
        while (mach <= 0.9) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            mach += 0.01;
        }
        const maxRange = Math.max(...rangeTable);
        const optMach = .7 + (0.01 * rangeTable.findIndex(v => v === maxRange));
        return optMach;
    }
    /**
     * Calculate the Optimum (best range) Mach and Altitude for a specific aircraft weight.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude and Mach as [Alt in FT, Mach].
     */
    calcOptimumCruiseMachAndAltitude(weight) {
        const rangeTable = [];
        let mach = 70;
        let altitude = 25000;
        while (Math.round(altitude) <= 41000) {
            while (Math.round(mach) <= 90) {
                const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
                const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
                const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
                const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach / 100, ambientTemperature);
                const cl = this.calculateCL(weight, ambientPressure, mach / 100);
                const netThrust = this.calculateThrustRequired(weight, cl, 0);
                const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach / 100, altitude, ambientTemperature, ambientPressure);
                const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
                const rangePerThousandPounds = (1000 / fuelFlow) * tas;
                rangeTable.push(rangePerThousandPounds);
                mach += 1;
            }
            altitude += 1000;
            mach = 70;
        }
        //21 values per altitude
        const maxRange = Math.max(...rangeTable);
        const index = rangeTable.findIndex(v => v === maxRange);
        const altIndex = Math.floor(index / 21);
        const machIndex = index - (altIndex * 21);
        const optMach = .7 + (0.01 * machIndex);
        const optAlt = 25000 + (altIndex * 1000);
        return [optAlt, optMach];
    }
    /**
     * Calculates the current Lift Coefficient.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg
     * @param mach The current aircraft mach number.
     * @returns the current lift coefficient.
     */
    calculateCL(aircraftWeight, ambientPressure, mach) {
        return aircraftWeight / (BoeingAeroMath.calcDynamicPressureRatio(ambientPressure, mach) * this.aircraftFlightModel.wing_area);
    }
    /**
     * Gets the number of possible aircraft configurations, clean and flaps.
     * @returns The number of aircraft configurations.
     */
    getNumberOfConfigurations() {
        return this.aircraftFlightModel.cl_cd.length;
    }
    /**
     * Calculates the current drag coefficient.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The Drag Coefficient
     */
    calculateCD(cl, flapsIndex) {
        const correctedCl = cl - this.aircraftFlightModel.cl_cd[flapsIndex][0];
        const parasiticDrag = this.aircraftFlightModel.cl_cd[flapsIndex][1];
        const inducedDrag = (Math.pow(correctedCl, 2) * this.aircraftFlightModel.induced_drag_scalar) /
            (Math.PI * this.aircraftFlightModel.oswald_efficiency_factor * this.aspectRatio);
        return parasiticDrag + inducedDrag;
    }
    /**
     * Calculates the efficiency factor.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the efficiency factor.
     */
    calculateEfficiency(cl, flapsIndex) {
        return cl / this.calculateCD(cl, flapsIndex);
    }
    /**
     * Calculates the best L/D speed by finding a mach value at the altitude that produces the highest L/D ratio.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param altitude Altitude to find the best econ speed for.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best Econ Speed in Mach.
     */
    calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex) {
        const ambientPressure = UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(altitude)[1], UnitType.IN_HG);
        let machTarget = 0.5;
        let clTarget = 0;
        let ldTarget = 0;
        let iterations = 0;
        while (iterations < 300) {
            clTarget = this.calculateCL(aircraftWeight, ambientPressure, machTarget);
            const newldTarget = this.calculateEfficiency(clTarget, flapsIndex);
            if (newldTarget > ldTarget) {
                ldTarget = newldTarget;
                machTarget += .01;
            }
            else {
                return machTarget -= .01;
            }
            iterations++;
        }
        return machTarget;
    }
    /**
     * Gets the best econ speed based on CAFE/Carson Speed multiplier against best L/D speed.
     * @param aircraftWeight The aircraft weight.
     * @param altitude The altitide to find the best speed at.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best econ speed.
     */
    calculateBestEconSpeed(aircraftWeight, altitude, flapsIndex) {
        return 1.32 * this.calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex);
    }
    /**
     * Calculates the total required net thrust to maintain the current speed and altitude.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The total required net thrust.
     */
    calculateThrustRequired(aircraftWeight, cl, flapsIndex) {
        return aircraftWeight / this.calculateEfficiency(cl, flapsIndex);
    }
    /**
     * Calculates an FPA for a total net thrust at a constant speed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The predicted FPA in Degrees.
     */
    calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex) {
        return Avionics.Utils.RAD2DEG * Math.asin((totalNetThrust / aircraftWeight) - (1 / this.calculateEfficiency(cl, flapsIndex)));
    }
    /**
     * Calculates a vertical speed for a total net thrust for a constant true airspeed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the predicted VS in FPM
     */
    calculateConstantSpeedVerticalSpeedFromThrust(totalNetThrust, tas, aircraftWeight, cl, flapsIndex) {
        return VNavUtils.getVerticalSpeedFromFpa(this.calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex), tas);
    }
    /**
     * Calculates a total net thrust at a constant speed for a given FPA
     * @param fpa Flight Path Angle in degrees (+ve = up)
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @param accelFactor Acceleration factor (see {@link calculateAccelerationFactor}).
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForFpa(fpa, aircraftWeight, cl, flapsIndex, accelFactor) {
        return aircraftWeight * (accelFactor * Math.sin(fpa * Avionics.Utils.DEG2RAD) + 1 / this.calculateEfficiency(cl, flapsIndex));
    }
    /**
     * Calculates a total net thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/min
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @param accelFactor Acceleration factor (see {@link calculateAccelerationFactor}).
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex, accelFactor) {
        return this.calculateConstantSpeedThrustForFpa(VNavUtils.getFpaFromVerticalSpeed(vs, tas), aircraftWeight, cl, flapsIndex, accelFactor);
    }
    /**
     * Calculates a gross thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/min
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param enginesAvailable The number of engines currently running to provide the thrust
     * @param altitude Pressure altitude in feet
     * @param isaDeviation ISA temperature deviation in °C
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @param speedTargetIsMach True if the speed target is a constant mach, otherwise constant CAS is assumed.
     * @returns Total Net Thrust in LBS.
     */
    calculateCorrectedN1ForVerticalSpeed(vs, tas, aircraftWeight, enginesAvailable, altitude, isaDeviation, flapsIndex, speedTargetIsMach = false) {
        const [isaTempK] = BoeingAeroMath.calcIsaFromAltitude(altitude);
        const [ambientTempK, ambientPressHpa] = BoeingAeroMath.calcIsaFromAltitude(altitude, undefined, isaDeviation);
        const ambientTemperature = UnitType.KELVIN.convertTo(ambientTempK, UnitType.CELSIUS);
        const ambientPressure = UnitType.HPA.convertTo(ambientPressHpa, UnitType.IN_HG);
        const mach = AeroMath.tasToMach(UnitType.KNOT.convertTo(tas, UnitType.MPS), AeroMath.soundSpeedAir(ambientTemperature));
        const cl = this.calculateCL(aircraftWeight, ambientPressure, mach);
        const accelFactor = this.calculateAccelerationFactor(altitude, mach, speedTargetIsMach, ambientTempK, isaTempK);
        const netThrust = this.calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex, accelFactor);
        const netThrustPerEngine = netThrust / Math.max(1, enginesAvailable);
        const [, cn1] = this.findGrossThrustAndCn1FromNetThrust(BoeingPerformanceDataProvider.vec2Cache, netThrustPerEngine, mach, altitude, ambientTemperature, ambientPressure);
        return cn1;
    }
    /**
     * Calculates the acceleration factor (1 + V/g . dV/dh) for climb/descent performance.
     * @param altitude Pressure altitude in feet.
     * @param mach Mach number.
     * @param constantMach True for constant CAS, false for constant mach.
     * @param ambientTemp Ambient temperature in K.
     * @param isaTemp Ambient temperature in K.
     * @param tropopause The tropopause altitude in feet, defaults to ISA (36089 feet).
     * @returns The acceleration factor for climb/descent performance.
     */
    calculateAccelerationFactor(altitude, mach, constantMach, ambientTemp, isaTemp, tropopause = 36089) {
        if (!constantMach) {
            const m2 = mach * mach;
            const phi = (Math.pow((1 + 0.2 * m2), 3.5) - 1) / (0.7 * m2 * Math.pow(1 + 0.2 * m2, 3.5));
            const tempRatio = isaTemp / ambientTemp; // Tisa / T
            if (altitude > tropopause) {
                // constant cas above the tropopause
                return 1 + 0.7 * m2 * phi;
            }
            // constant cas below the tropopause
            return 1 + 0.7 * m2 * (phi - 0.190263 * (tempRatio));
        }
        else if (altitude > tropopause) {
            // constant mach above the tropopause
            return 1;
        }
        else {
            // constant mach below the tropopause
            return 1 - 0.13318 * mach * mach * isaTemp / ambientTemp;
        }
    }
    /**
     * Calculates fuel flow from a corrected thrust and corrected ram drag.
     * @param thrust Corrected Net thrust (if ram drag is given) or corrected gross thrust, in LBS.
     * @param ramDrag An optional corrected ram drag, in LBS.
     * @returns The calculated fuel flow, in LBS/HR.
     */
    calculateFuelFlowFromThrust(thrust, ramDrag) {
        if (ramDrag !== undefined) {
            return (thrust + ramDrag) * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
        }
        return thrust * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param n1 The corrected N1 percent.
     * @param mach The mach number.
     * @returns The corrected gross thrust, in pounds, at the specified corrected N1 and mach.
     */
    calculateThrustFromCorrectedN1(n1, mach) {
        return this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, n1) * this.aircraftFlightModel.static_thrust;
    }
    /**
     * Calculates idle corrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @returns The idle corrected N1 (%) at the specified mach number.
     */
    calculateIdleCorrectedN1(ambientTemperature, mach) {
        // TODO Should this use ambient or TAT? We call it with TAT right now
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        return (mach * this.aircraftFlightModel.mach_influence_on_n1) + (this.aircraftFlightModel.low_idle_n1 / Math.sqrt(thetaTotalTempRatio));
    }
    /**
     * Calculates uncorrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @param correctedN1 The corrected n1.
     * @returns The uncorrected N1 (%) at the specified mach number.
     */
    uncorrectN1(ambientTemperature, mach, correctedN1) {
        const totalInletTempMachRise = 1.0 + 0.2 * mach * mach;
        const StandardSeaLevelTemperature = BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        const ambientRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const theta_temperature_ratio = ambientRankine / StandardSeaLevelTemperature;
        const thetaTotalTempRatio = theta_temperature_ratio * totalInletTempMachRise;
        return correctedN1 * Math.sqrt(thetaTotalTempRatio);
    }
    /**
     * Calculates idle corrected gross thrust, in LBS, for one engine.
     * @param ambientTemperature The Ambient Temperature at the aircraft location in C.
     * @param mach The current aircraft mach number.
     * @returns The idle corrected gross thrust, in LBS, for one engine.
     */
    calculateIdleThrust(ambientTemperature, mach) {
        return this.calculateThrustFromCorrectedN1(this.calculateIdleCorrectedN1(ambientTemperature, mach), mach);
    }
    /**
     * Calculates the uncorrected ram drag provided by an engine, in pounds.
     * @param mach The airplane's mach number.
     * @param n1 The engine's corrected N1, as a percent.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius.
     * @param ambientPressure The ambient pressure, in inches of mercury.
     * @param inletTemp The engine inlet temperature, in Rankine.
     * @returns The uncorrected ram drag provided by an engine, in pounds, with the specified parameters.
     */
    calculateRamDrag(mach, n1, ambientTemperature, ambientPressure, inletTemp) {
        const airflowTableResult = this.aircraftFlightModel.corrected_airflow_table.get(n1, mach);
        const correctedAirflow = airflowTableResult * this.aircraftFlightModel.inlet_area;
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        const deltaTotalPressureRatio = deltaPressureRatio * totalInletPressureMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE; //Divide by sim normal SL temp constant to get thetaTTR
        const airflow = correctedAirflow * deltaTotalPressureRatio / Math.sqrt(thetaTotalTempRatio);
        const speedOfSound = BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemperature);
        return speedOfSound * mach * airflow / BoeingAeroMath.gravity; // Ram Drag in pounds
    }
    /**
     * Finds the uncorrected gross thrust, in pounds, provided by an engine when it is providing a given uncorrected net
     * thrust.
     * @param netThrust The uncorrected net thrust, in pounds, for which to find the gross thrust.
     * @param mach The airplane's mach number.
     * @param altitude The airplane's pressure altitude, in feet.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius. Defaults to ISA temperature for
     * the specified pressure altitude.
     * @param ambientPressure The ambient pressure, in inches of mercury. Defaults to ISA pressure for the specified
     * pressure altitude.
     * @param idleN1 The engine's idle corrected N1, as a percent. If not defined, it will be calculated from the specified mach
     * number and temperature.
     * @returns The uncorrected gross thrust, in pounds, provided by the engine with the specified parameters when it is
     * providing the specified uncorrected net thrust.
     */
    findGrossThrustFromNetThrust(netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1) {
        this.findGrossThrustAndCn1FromNetThrust(BoeingPerformanceDataProvider.vec2Cache, netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1);
        return BoeingPerformanceDataProvider.vec2Cache[0];
    }
    /**
     * Finds the uncorrected gross thrust, in pounds, provided by an engine when it is providing a given uncorrected net
     * thrust.
     * @param out A Vec2 to write the results.
     * @param netThrust The uncorrected net thrust, in pounds, for which to find the gross thrust.
     * @param mach The airplane's mach number.
     * @param altitude The airplane's pressure altitude, in feet.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius. Defaults to ISA temperature for
     * the specified pressure altitude.
     * @param ambientPressure The ambient pressure, in inches of mercury. Defaults to ISA pressure for the specified
     * pressure altitude.
     * @param idleN1 The engine's idle corrected N1, as a percent. If not defined, it will be calculated from the specified mach
     * number and temperature.
     * @returns The uncorrected gross thrust, in pounds, provided by the engine with the specified parameters when it is
     * providing the specified uncorrected net thrust, and the corrected N1 value.
     */
    findGrossThrustAndCn1FromNetThrust(out, netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1) {
        if (!ambientTemperature || !ambientPressure) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            if (!ambientTemperature) {
                ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            }
            if (!ambientPressure) {
                ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            }
        }
        idleN1 !== null && idleN1 !== void 0 ? idleN1 : (idleN1 = this.calculateIdleCorrectedN1(ambientTemperature, mach));
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const thrustCorrectionFactor = BoeingAeroMath.calculateThrustCorrectionFactor(mach, ambientPressure);
        const correctedNetThrust = netThrust * thrustCorrectionFactor;
        let lowCorrectedN1 = idleN1;
        let highCorrectedN1 = 110;
        let numIterations = 0;
        let estimatedCorrectedGrossThrust = 0;
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const lowCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, lowCorrectedN1) * this.aircraftFlightModel.static_thrust;
        let lowCorrectedNetThrust = lowCorrectedGrossThrust - this.calculateRamDrag(mach, lowCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        if (correctedNetThrust <= lowCorrectedNetThrust) {
            out[0] = lowCorrectedGrossThrust / thrustCorrectionFactor;
            out[1] = lowCorrectedN1;
            return out;
        }
        const highCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, highCorrectedN1) * this.aircraftFlightModel.static_thrust;
        let highCorrectedNetThrust = highCorrectedGrossThrust - this.calculateRamDrag(mach, highCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        const epsilon = this.aircraftFlightModel.static_thrust * 0.001;
        let estimatedCorrectedN1 = 0;
        while (numIterations < 100) {
            estimatedCorrectedN1 = MathUtils.lerp(correctedNetThrust, lowCorrectedNetThrust, highCorrectedNetThrust, lowCorrectedN1, highCorrectedN1);
            estimatedCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, estimatedCorrectedN1)
                * this.aircraftFlightModel.static_thrust;
            /** corrected net thrust estimate */
            const estimatedNetThrust = estimatedCorrectedGrossThrust
                - (this.calculateRamDrag(mach, estimatedCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor);
            if (Math.abs(estimatedNetThrust - correctedNetThrust) < epsilon) {
                out[0] = estimatedCorrectedGrossThrust / thrustCorrectionFactor;
                out[1] = estimatedCorrectedN1;
                return out;
            }
            const errorSign = Math.sign(estimatedNetThrust - correctedNetThrust);
            if (errorSign < 0) {
                lowCorrectedN1 = estimatedCorrectedN1;
                lowCorrectedNetThrust = estimatedNetThrust;
            }
            else {
                highCorrectedN1 = estimatedCorrectedN1;
                highCorrectedNetThrust = estimatedNetThrust;
            }
            numIterations++;
        }
        out[0] = estimatedCorrectedGrossThrust / thrustCorrectionFactor;
        out[1] = estimatedCorrectedN1;
        return out;
    }
}
BoeingPerformanceDataProvider.vec2Cache = Vec2Math.create();
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;

/**
 * An default implementation of {@link BoeingPathPerformanceProvider} which derives performance data from a
 * {@link BoeingPerformanceDataProvider}.
 */
class DefaultBoeingPathPerformanceProvider {
    /**
     * Creates an instance of DefaultBoeingPathPerformanceProvider.
     * @param performanceData The aircraft's performance data provider.
     */
    constructor(performanceData) {
        this.performanceData = performanceData;
    }
    /** @inheritdoc */
    getWingArea() {
        return this.performanceData.aircraftFlightModel.wing_area * 0.09290304;
    }
    /** @inheritdoc */
    getThrustCorrectionFactor(pressure, mach) {
        return BoeingAeroMath.calculateThrustCorrectionFactor(mach, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineIdleCorrectedN1(temperature, mach) {
        return this.performanceData.calculateIdleCorrectedN1(temperature, mach);
    }
    /** @inheritdoc */
    getEngineIdleGrossThrust(pressure, temperature, mach) {
        return this.getEngineCorrectedGrossThrust(this.getEngineIdleCorrectedN1(temperature, mach), mach) / this.getThrustCorrectionFactor(pressure, mach);
    }
    /** @inheritdoc */
    getEngineCorrectedGrossThrust(n1, mach) {
        return this.performanceData.calculateThrustFromCorrectedN1(n1, mach);
    }
    /** @inheritdoc */
    getEngineRamDrag(n1, mach, pressure, temperature) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(temperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        return this.performanceData.calculateRamDrag(mach, n1, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG), inletTemp);
    }
    /** @inheritdoc */
    getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) {
        return this.getEngineCorrectedGrossThrust(n1, mach) / this.getThrustCorrectionFactor(pressure, mach) - this.getEngineRamDrag(n1, mach, pressure, temperature);
    }
    /** @inheritdoc */
    estimateGrossThrustFromNetThrust(netThrust, mach, pressure, temperature) {
        return this.performanceData.findGrossThrustFromNetThrust(netThrust, mach, 0, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineFuelFlow(grossThrust) {
        return this.performanceData.calculateFuelFlowFromThrust(grossThrust);
    }
    /** @inheritdoc */
    getRequiredThrust(weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return weight * (sin + this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos));
    }
    /** @inheritdoc */
    getLevelFlightRequiredThrust(weight, cl, flapsIndex) {
        return this.performanceData.calculateThrustRequired(weight, cl, flapsIndex);
    }
    /** @inheritdoc */
    getRequiredEngineGrossThrust(weight, cl, pressure, temperature, tas, vs, flapsIndex, engineCount, mach) {
        mach !== null && mach !== void 0 ? mach : (mach = AeroMath.tasToMach(tas, AeroMath.soundSpeedAir(temperature)));
        const netThrustRequired = this.getRequiredThrust(weight, cl, tas, vs, flapsIndex);
        return this.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
    }
    /** @inheritdoc */
    getLevelFlightRequiredEngineGrossThrust(weight, cl, pressure, temperature, mach, flapsIndex, engineCount) {
        const netThrustRequired = this.performanceData.calculateThrustRequired(weight, cl, flapsIndex);
        return this.getRequiredEngineGrossThrustFromNetThrust(netThrustRequired / engineCount, pressure, temperature, mach);
    }
    /** @inheritdoc */
    getRequiredEngineGrossThrustFromNetThrust(netThrust, pressure, temperature, mach) {
        const idleN1 = this.getEngineIdleCorrectedN1(temperature, mach);
        const idleNetThrust = this.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
        return netThrust <= idleNetThrust
            ? this.getEngineCorrectedGrossThrust(idleN1, mach) / this.getThrustCorrectionFactor(pressure, mach)
            : this.estimateGrossThrustFromNetThrust(netThrust, mach, pressure, temperature);
    }
    /** @inheritdoc */
    getVerticalSpeed(netThrust, weight, cl, tas, flapsIndex) {
        return UnitType.FPM.convertTo(this.performanceData.calculateConstantSpeedVerticalSpeedFromThrust(netThrust, UnitType.MPS.convertTo(tas, UnitType.KNOT), weight, cl, flapsIndex), UnitType.MPS);
    }
    /** @inheritdoc */
    getAcceleration(netThrust, weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return UnitType.G_ACCEL.convertTo(netThrust / weight - sin - this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos), UnitType.MPS_PER_SEC);
    }
    /** @inheritdoc */
    estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineNetThrust, engineCount, wingArea, flapsIndex, weight, pressure, temperature, out, density, soundSpeed, minAccel = 0.1) {
        let totalTime = 0;
        let totalDistance = 0;
        if (density === undefined) {
            density = AeroMath.densityAir(pressure, temperature);
        }
        // For performance reasons, only calculate engine fuel flow at the starting speed.
        const initialMach = AeroMath.tasToMach(initialTas, soundSpeed !== null && soundSpeed !== void 0 ? soundSpeed : AeroMath.soundSpeedAir(temperature));
        const grossThrustPerEngineRequired = this.getRequiredEngineGrossThrustFromNetThrust(engineNetThrust, pressure, temperature, initialMach);
        const engineFuelFlow = this.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
        let currentTas = initialTas;
        while (Math.abs(finalTas - currentTas) > 0.1) {
            const weightNewtons = weight * 4.44822;
            let acceleration = this.getAcceleration(engineNetThrust * engineCount, weight, AeroMath.liftCoefficient(weightNewtons, wingArea, density, currentTas), currentTas, vs, flapsIndex);
            if (finalTas - currentTas > 0) {
                acceleration = Math.max(minAccel, acceleration);
            }
            else {
                acceleration = Math.min(-minAccel, acceleration);
            }
            const tasStep = MathUtils.clamp(finalTas - currentTas, -3, 3);
            const timeStep = tasStep / acceleration;
            totalTime += timeStep;
            totalDistance += currentTas * timeStep + acceleration * timeStep * timeStep / 2;
            currentTas += acceleration * timeStep;
            weight = Math.max(0, weight - engineFuelFlow * timeStep);
        }
        return Vec2Math.set(totalTime, totalDistance, out);
    }
}

/**
 * Boeing unit utility class.
 */
class BoeingUnitUtils {
    /**
     * Gets the weight unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The weight unit.
     */
    static getWeightUnits(isMetric) {
        return isMetric ? UnitType.KILOGRAM : UnitType.POUND;
    }
    /**
     * Gets the length unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The length unit.
     */
    static getLengthUnits(isMetric) {
        return isMetric ? UnitType.METER : UnitType.FOOT;
    }
    /**
     * Gets the pressure unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The pressure unit.
     */
    static getPressureUnits(isMetric) {
        return isMetric ? UnitType.HPA : UnitType.IN_HG;
    }
    /**
     * Gets the flow unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The flow unit.
     */
    static getFlowUnits(isMetric) {
        return isMetric ? UnitType.KGH : UnitType.PPH;
    }
    /**
     * Gets the string (used for display) for a given unit in the WT21.
     * @param unit The unit to get the string for.
     * @returns The unit string for display.
     */
    static getUnitString(unit) {
        var _a;
        return (_a = BoeingUnitUtils.UNIT_STRINGS.get(unit)) !== null && _a !== void 0 ? _a : '';
    }
    /**
     * Returns a boolean indicating if the sim is in metric mode.
     * @returns true if sim is in metric mode, false otherwise.
     */
    static getIsMetric() {
        return SimVar.GetGameVarValue('GAME UNIT IS METRIC', 'number') === 1;
    }
}
BoeingUnitUtils.UNIT_STRINGS = new Map([
    [UnitType.KILOGRAM, 'KG'],
    [UnitType.POUND, 'LB'],
    [UnitType.METER, 'M'],
    [UnitType.FOOT, 'FT'],
    [UnitType.IN_HG, 'IN'],
    [UnitType.HPA, 'HPA'],
    [UnitType.PPH, 'PPH'],
    [UnitType.KGH, 'KGH'],
]);

const MIN_PREDICTIONS_IAS = 160;
const NULL_WIND_ENTRY = { speed: 0, direction: 0, trueDegrees: false };
/**
 * An implementation of {@link FlightPlanPredictionsProvider} that uses {@link BoeingPathCalculator}
 */
class BoeingFlightPlanPredictionsProvider {
    /**
     * Ctor
     * @param bus the bus
     * @param fmsPosIndex the index of the fms position to use
     * @param planIndex the index of the plan to predict data for
     * @param updatePeriod the update period, in milliseconds, at which to update plan predictions
     * @param flightPlanner the flight planner
     * @param windPlanner the wind planner
     * @param verticalPathCalculator the path calculator
     * @param performancePlanRepository the perf plan repo
     * @param perfProvider the perf provider
     * @param facLoader the fac loader
     */
    constructor(bus, fmsPosIndex, planIndex, updatePeriod, flightPlanner, windPlanner, verticalPathCalculator, performancePlanRepository, perfProvider, facLoader) {
        this.bus = bus;
        this.fmsPosIndex = fmsPosIndex;
        this.planIndex = planIndex;
        this.updatePeriod = updatePeriod;
        this.flightPlanner = flightPlanner;
        this.windPlanner = windPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.perfProvider = perfProvider;
        this.facLoader = facLoader;
        this.onPredictionsUpdated = new SubEvent();
        this.updateDebouncer = new DebounceTimer();
        this.realTimeValue = ConsumerValue.create(null, -1);
        this.simTimeValue = ConsumerValue.create(null, -1);
        this.activeLegDistanceAlongValue = ConsumerValue.create(null, -1);
        this.activeLegDtgValue = ConsumerValue.create(null, -1);
        this.pposValue = ConsumerValue.create(null, new LatLongAlt(0, 0));
        this.casValue = ConsumerValue.create(null, 0);
        this.indicatedAltValue = ConsumerValue.create(null, 0);
        /** Indicated airspeed in knots. */
        this.indicatedSpeedValue = ConsumerValue.create(null, 0);
        this.oatValue = ConsumerValue.create(null, 0);
        this.isaValue = ConsumerValue.create(null, 0);
        this.ambientWindMagnitudeValue = ConsumerValue.create(null, 0);
        this.ambientWindDirectionValue = ConsumerValue.create(null, 0);
        this.fobValue = ConsumerValue.create(null, -1);
        this.fuelWeightValue = ConsumerValue.create(null, -1);
        this.fuelFlowValue = ConsumerValue.create(null, -1);
        this.planPredictions = new Map();
        this.trackedFacilityEntries = new Map();
        this.trackedFacilityEntryPredictions = new Map();
        this.trackFacilityLastUpdates = new Map();
        this.resolvedFacilities = new Map();
        this.destinationPredictions = {
            ident: '',
            position: new GeoPoint(0, 0),
            valid: true,
            distance: NaN,
            estimatedTimeOfArrival: NaN,
            fob: NaN,
            altitude: NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
        this.pposPrediction = {
            ident: '',
            position: new GeoPoint(0, 0),
            valid: false,
            distance: NaN,
            estimatedTimeOfArrival: NaN,
            fob: NaN,
            altitude: NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: 0,
        };
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.cachedSyncPacket = { planPredictions: {}, destinationPredictions: {}, trackedFacilityPredictions: {} };
        this.cachedSyncPositions = [];
        this.cachedSyncFacilityPositions = {};
        this.syncSub = this.bus.getSubscriber();
        this.syncPub = this.bus.getPublisher();
        this.initialized = false;
        this.useLocalCalculations = true;
    }
    /**
     * Fixes a Predictions object that was deserialized from JSON.
     * @param predictions The deserialized predictions object.
     * @returns The fixed predictions object.
     */
    static fixDeserializedPredictions(predictions) {
        var _a, _b, _c, _d, _e, _f;
        // We return a new object here to ensure that we don't forget to handle new fields.
        return {
            ident: predictions.ident,
            position: new GeoPoint((_a = predictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = predictions.position.lon) !== null && _b !== void 0 ? _b : NaN),
            valid: predictions.valid,
            distance: (_c = predictions.distance) !== null && _c !== void 0 ? _c : NaN,
            estimatedTimeOfArrival: (_d = predictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN,
            fob: (_e = predictions.fob) !== null && _e !== void 0 ? _e : NaN,
            altitude: (_f = predictions.altitude) !== null && _f !== void 0 ? _f : NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
    }
    /**
     * Initializes the predictor
     *
     * @param useLocalCalculations whether to use local calculations or receive calculations from another calculator
     */
    init(useLocalCalculations) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.useLocalCalculations = useLocalCalculations;
        const sub = this.bus.getSubscriber();
        if (useLocalCalculations) {
            this.setupLocalSyncEvents();
        }
        else {
            this.setupRemoteSyncEvents();
        }
        this.pposValue.setConsumer(sub.on(`fms_pos_gps-position_${this.fmsPosIndex}`));
        this.indicatedAltValue.setConsumer(sub.on('indicated_alt'));
        this.indicatedSpeedValue.setConsumer(sub.on('ias'));
        this.simTimeValue.setConsumer(sub.on('simTime'));
        if (useLocalCalculations) {
            this.realTimeValue.setConsumer(sub.on('realTime'));
            this.activeLegDistanceAlongValue.setConsumer(sub.on('lnav_leg_distance_along'));
            this.activeLegDtgValue.setConsumer(sub.on('lnav_leg_distance_remaining'));
            this.casValue.setConsumer(sub.on('ias'));
            this.oatValue.setConsumer(sub.on('ambient_temp_c'));
            this.isaValue.setConsumer(sub.on('isa_temp_c'));
            this.ambientWindMagnitudeValue.setConsumer(sub.on('ambient_wind_velocity'));
            this.ambientWindDirectionValue.setConsumer(sub.on('ambient_wind_direction'));
            this.fobValue.setConsumer(sub.on('fuel_total_weight'));
            this.fuelWeightValue.setConsumer(sub.on('fuel_weight_per_gallon'));
            this.fuelFlowValue.setConsumer(sub.on('fuel_flow_total'));
            sub.on('fplLegChange').handle(({ legIndex, type }) => {
                const legPredictions = this.planPredictions.get(legIndex);
                switch (type) {
                    case LegEventType.Removed:
                        legPredictions && (legPredictions.valid = false);
                }
            });
        }
        sub.on('realTime').whenChangedBy(this.updatePeriod).handle(this.requestPredictionsUpdate.bind(this));
    }
    /** Set a request to recalculate the predictions */
    requestPredictionsUpdate() {
        // we use a debounce timer to ensure we aren't re-calculating too frequently
        if (!this.updateDebouncer.isPending()) {
            this.updateDebouncer.schedule(() => {
                this.updatePposPrediction();
                if (this.useLocalCalculations) {
                    this.updatePredictions();
                }
            }, 500);
        }
    }
    /**
     * Sets up sync events for receiving remote calculations
     */
    setupRemoteSyncEvents() {
        this.syncSub.on('boeing_predictions_sync').handle((predictions) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
            for (const [index, legPredictions] of Object.entries(predictions.planPredictions)) {
                const existing = this.planPredictions.get(parseInt(index));
                if (existing) {
                    existing.ident = legPredictions.ident;
                    existing.position.set((_a = legPredictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = legPredictions.position.lon) !== null && _b !== void 0 ? _b : NaN);
                    existing.valid = legPredictions.valid;
                    existing.distance = (_c = legPredictions.distance) !== null && _c !== void 0 ? _c : NaN;
                    existing.estimatedTimeOfArrival = (_d = legPredictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN;
                    existing.fob = (_e = legPredictions.fob) !== null && _e !== void 0 ? _e : NaN;
                    existing.altitude = (_f = legPredictions.altitude) !== null && _f !== void 0 ? _f : NaN;
                    existing.speed = (_g = legPredictions.speed) !== null && _g !== void 0 ? _g : NaN;
                    existing.isSpeedMach = (_h = legPredictions.isSpeedMach) !== null && _h !== void 0 ? _h : false;
                    existing.duration = (_j = legPredictions.duration) !== null && _j !== void 0 ? _j : NaN;
                }
                else {
                    this.planPredictions.set(parseInt(index), BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(legPredictions));
                }
            }
            this.destinationPredictions.ident = predictions.destinationPredictions.ident;
            this.destinationPredictions.position.set((_k = predictions.destinationPredictions.position.lat) !== null && _k !== void 0 ? _k : NaN, (_l = predictions.destinationPredictions.position.lon) !== null && _l !== void 0 ? _l : NaN);
            this.destinationPredictions.valid = predictions.destinationPredictions.valid;
            this.destinationPredictions.distance = (_m = predictions.destinationPredictions.distance) !== null && _m !== void 0 ? _m : NaN;
            this.destinationPredictions.estimatedTimeOfArrival = (_o = predictions.destinationPredictions.estimatedTimeOfArrival) !== null && _o !== void 0 ? _o : NaN;
            this.destinationPredictions.fob = (_p = predictions.destinationPredictions.fob) !== null && _p !== void 0 ? _p : NaN;
            for (const [id, facilityPredictions] of Object.entries(predictions.trackedFacilityPredictions)) {
                const existing = this.trackedFacilityEntryPredictions.get(id);
                if (existing && facilityPredictions) {
                    existing.ident = facilityPredictions.ident;
                    existing.position.set((_q = facilityPredictions.position.lat) !== null && _q !== void 0 ? _q : NaN, (_r = facilityPredictions.position.lon) !== null && _r !== void 0 ? _r : NaN);
                    existing.valid = facilityPredictions.valid;
                    existing.distance = (_s = facilityPredictions.distance) !== null && _s !== void 0 ? _s : NaN;
                    existing.estimatedTimeOfArrival = (_t = facilityPredictions.estimatedTimeOfArrival) !== null && _t !== void 0 ? _t : NaN;
                    existing.fob = (_u = facilityPredictions.fob) !== null && _u !== void 0 ? _u : NaN;
                    existing.altitude = (_v = facilityPredictions.altitude) !== null && _v !== void 0 ? _v : NaN;
                    existing.speed = (_w = facilityPredictions.speed) !== null && _w !== void 0 ? _w : NaN;
                    existing.isSpeedMach = (_x = facilityPredictions.isSpeedMach) !== null && _x !== void 0 ? _x : false;
                    existing.duration = (_y = facilityPredictions.duration) !== null && _y !== void 0 ? _y : NaN;
                }
                else if (facilityPredictions) {
                    this.trackedFacilityEntryPredictions.set(id, BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(facilityPredictions));
                }
                else {
                    this.trackedFacilityEntryPredictions.set(id, undefined);
                }
            }
            this.onPredictionsUpdated.notify(this);
        });
    }
    /**
     * Sets up sync events for starting/stopping facility tracking from other predictors
     */
    setupLocalSyncEvents() {
        this.syncSub.on('boeing_predictions_start_tracking_facility').handle(({ id, entry }) => {
            this.startTrackingFacility(id, entry);
        });
        this.syncSub.on('boeing_predictions_stop_tracking_facility').handle((id) => {
            this.stopTrackingFacility(id);
        });
    }
    /**
     * Updates predictions for the flight plan, then notifies subscribers.
     */
    updatePredictions() {
        this.updatePredictionsInternal();
        this.onPredictionsUpdated.notify(this);
        this.syncPredictions();
    }
    /**
     * Update the current ppos 'prediction' with live values.
     */
    updatePposPrediction() {
        this.pposPrediction.position.set(this.pposValue.get().lat, this.pposValue.get().long);
        this.pposPrediction.valid = true;
        this.pposPrediction.distance = 0;
        this.pposPrediction.estimatedTimeOfArrival = this.simTimeValue.get() / 1000;
        this.pposPrediction.fob = this.fobValue.get();
        this.pposPrediction.altitude = UnitType.METER.convertFrom(this.indicatedAltValue.get(), UnitType.FOOT);
        this.pposPrediction.speed = this.indicatedSpeedValue.get();
    }
    /**
     * Updates predictions for the flight plan
     */
    updatePredictionsInternal() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return;
        }
        const cruiseAlt = this.performancePlanRepository.getActivePlan().cruiseAltitude.get();
        const zeroFuelWeight = this.performancePlanRepository.getActivePlan().manualZfw.get();
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        const verticalPath = this.verticalPathCalculator.getVerticalFlightPath(this.planIndex);
        const unixTimestamp = this.simTimeValue.get() / 1000;
        const canComputeAdvancedPredictions = cruiseAlt !== null && zeroFuelWeight !== null;
        const pposValue = this.pposValue.get();
        this.geoPointCache[2].set(pposValue.lat, pposValue.long);
        const _lastPosition = this.geoPointCache[2];
        const altitude = this.indicatedAltValue.get();
        const cas = this.casValue.get();
        const deltaIsa = this.oatValue.get() - this.isaValue.get();
        let _lastGroundSpeedMps = AeroMath.casToTasIsa(cas, altitude, deltaIsa);
        let accumulatedDistance = 0;
        let accumulatedTime = 0;
        for (let i = 0; i < plan.length; i++) {
            let legPredictions = this.planPredictions.get(i);
            const lateralLeg = plan.getLeg(i);
            const previousLateralLeg = plan.tryGetLeg(i - 1);
            const matchingVerticalLeg = verticalPath.legs[i];
            if (i < plan.activeLateralLeg || !matchingVerticalLeg) {
                if (legPredictions) {
                    legPredictions.valid = false;
                }
                this.invalidateTrackedFacilitiesForPosition(i);
                continue;
            }
            const legIsFollowingDiscontinuity = previousLateralLeg
                && ((BoeingFmsUtils.isDiscontinuityLeg(previousLateralLeg.leg.type) && !BitFlags.isAll(previousLateralLeg.flags, LegDefinitionFlags.DirectTo))
                    || BoeingFmsUtils.isVectorsLeg(previousLateralLeg === null || previousLateralLeg === void 0 ? void 0 : previousLateralLeg.leg.type));
            if (legPredictions === undefined) {
                legPredictions = {
                    ident: (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '',
                    position: new GeoPoint(0, 0),
                    valid: true,
                    distance: NaN,
                    estimatedTimeOfArrival: NaN,
                    fob: NaN,
                    altitude: NaN,
                    speed: NaN,
                    isSpeedMach: false,
                    duration: NaN,
                };
                this.planPredictions.set(i, legPredictions);
            }
            legPredictions.ident = (_b = lateralLeg.name) !== null && _b !== void 0 ? _b : '';
            let legDistance = NaN;
            let predictFromPpos = false;
            if (i === plan.activeLateralLeg) {
                // Active leg
                if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type) && matchingVerticalLeg.vectors.length > 0) {
                    // Active vectors leg
                    this.offsetPposAlongVectorsLeg(lateralLeg, 0.1, this.geoPointCache[1]);
                    this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1], legPredictions);
                    accumulatedDistance = legPredictions.distance;
                    // We skip the rest, and do not care about tracked facilities because who would put one on a VECTORS?
                    continue;
                }
                else {
                    accumulatedDistance += UnitType.METER.convertFrom(this.activeLegDtgValue.get(), UnitType.NMILE);
                    if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                        // Active non-vectors leg with a valid VNAV profile
                        accumulatedTime += (_c = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _c !== void 0 ? _c : matchingVerticalLeg.simDuration;
                    }
                    else {
                        // Active non-vectors leg without a valid VNAV profile
                        predictFromPpos = true;
                    }
                }
            }
            else if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type)) {
                // Upcoming vectors legs
                const previousPredictions = this.planPredictions.get(i - 1);
                if (previousPredictions) {
                    legPredictions.valid = previousPredictions.valid;
                    legPredictions.position.set(previousPredictions.position);
                    legPredictions.distance = previousPredictions.distance;
                    legPredictions.estimatedTimeOfArrival = previousPredictions.estimatedTimeOfArrival;
                    legPredictions.fob = previousPredictions.fob;
                    legPredictions.altitude = previousPredictions.altitude;
                    legPredictions.speed = previousPredictions.speed;
                    legPredictions.isSpeedMach = previousPredictions.isSpeedMach;
                    legPredictions.duration = previousPredictions.duration;
                }
                else {
                    legPredictions.valid = false;
                }
                accumulatedDistance += (_d = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _d !== void 0 ? _d : matchingVerticalLeg.simDistance;
                accumulatedTime += (_e = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _e !== void 0 ? _e : matchingVerticalLeg.simDuration;
                continue;
            }
            else if (legIsFollowingDiscontinuity) {
                if (((_f = lateralLeg.calculated) === null || _f === void 0 ? void 0 : _f.endLat) && lateralLeg.calculated.endLon) {
                    // Upcoming leg after discontinuity with valid termination point
                    const distance = GeoPoint.distance(_lastPosition.lat, _lastPosition.lon, lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                    const distanceMeters = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    accumulatedDistance += distanceMeters;
                    accumulatedTime += distanceMeters / _lastGroundSpeedMps;
                }
                else {
                    // Upcoming leg after discontinuity without a valid termination point
                    legPredictions.valid = false;
                    continue;
                }
            }
            else if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                // Upcoming non-vectors leg with a valid VNAV profile
                accumulatedDistance += (_g = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _g !== void 0 ? _g : matchingVerticalLeg.simDistance;
                accumulatedTime += (_h = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _h !== void 0 ? _h : matchingVerticalLeg.simDuration;
            }
            else if (lateralLeg.calculated) {
                // Upcoming non-vectors leg without a valid VNAV profile
                accumulatedDistance += lateralLeg.calculated.distanceWithTransitions;
                accumulatedTime += lateralLeg.calculated.distanceWithTransitions / _lastGroundSpeedMps;
            }
            legDistance = accumulatedDistance;
            if (canComputeAdvancedPredictions && predictFromPpos && ((_j = lateralLeg.calculated) === null || _j === void 0 ? void 0 : _j.endLat) && lateralLeg.calculated.endLon) {
                this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1].set((_k = lateralLeg.calculated) === null || _k === void 0 ? void 0 : _k.endLat, (_l = lateralLeg.calculated) === null || _l === void 0 ? void 0 : _l.endLon), legPredictions);
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (canComputeAdvancedPredictions && matchingVerticalLeg && matchingVerticalLeg.vectors.length !== 0) {
                const lastVector = this.getVerticalVectorForPredictions(matchingVerticalLeg);
                legPredictions.valid = true;
                legPredictions.position.set((_o = (_m = lateralLeg.calculated) === null || _m === void 0 ? void 0 : _m.endLat) !== null && _o !== void 0 ? _o : NaN, (_q = (_p = lateralLeg.calculated) === null || _p === void 0 ? void 0 : _p.endLon) !== null && _q !== void 0 ? _q : NaN);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = unixTimestamp + accumulatedTime;
                legPredictions.fob = lastVector.endWeight - zeroFuelWeight;
                legPredictions.altitude = lastVector.endAltitude;
                const predictedCas = lastVector.endCas;
                const predictedMach = lastVector.endMach;
                const targetCas = lastVector.targetCas;
                const targetMach = lastVector.targetMach;
                // TODO get pressure from vector
                const pressure = AeroMath.isaPressure(lastVector.endAltitude);
                const machCasEquivalent = AeroMath.machToCas(targetMach, pressure);
                const targetMachCasEquivalentKnots = UnitType.KNOT.convertFrom(machCasEquivalent, UnitType.MPS);
                if (targetMachCasEquivalentKnots < targetCas) {
                    legPredictions.speed = predictedMach;
                    legPredictions.isSpeedMach = true;
                }
                else {
                    legPredictions.speed = predictedCas;
                    legPredictions.isSpeedMach = false;
                }
                legPredictions.duration = matchingVerticalLeg.vectors.reduce((acc, vec) => acc + vec.duration, 0);
                const gs = this.getPredictedGroundSpeedAtEndOfLeg(matchingVerticalLeg);
                if (gs !== undefined && gs !== 0) {
                    _lastGroundSpeedMps = gs;
                }
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (lateralLeg.calculated && lateralLeg.calculated.endLat !== undefined && lateralLeg.calculated.endLon !== undefined) {
                legPredictions.valid = true;
                legPredictions.position.set(lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = NaN;
                legPredictions.fob = NaN;
                legPredictions.altitude = NaN;
                legPredictions.speed = NaN;
                legPredictions.isSpeedMach = false;
                legPredictions.duration = NaN;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            else {
                legPredictions.valid = false;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            if (legPredictions.valid) {
                Number.isFinite(legPredictions.position.lat) && _lastPosition.set(legPredictions.position);
            }
        }
        // Update tracked facilities with no leg index
        if (canComputeAdvancedPredictions) {
            for (const [id, entry] of this.getTrackedFacilityEntriesForPosition('direct')) {
                this.updateTrackedFacilityPredictionsFromPpos(id, entry);
            }
        }
        else {
            this.invalidateAllTrackedFacilities();
        }
        this.updateDestinationPredictions(canComputeAdvancedPredictions);
    }
    /**
     * Sync locally calculated predictions data to remote instruments
     */
    syncPredictions() {
        for (const [index, legPredictions] of this.planPredictions.entries()) {
            if (!this.cachedSyncPacket.planPredictions[index]) {
                this.cachedSyncPacket.planPredictions[index] = {};
            }
            Object.assign(this.cachedSyncPacket.planPredictions[index], legPredictions);
            if (!this.cachedSyncPositions[index]) {
                this.cachedSyncPositions[index] = { lat: 0, lon: 0 };
            }
            this.cachedSyncPositions[index].lat = legPredictions.position.lat;
            this.cachedSyncPositions[index].lon = legPredictions.position.lon;
            this.cachedSyncPacket.planPredictions[index].position = this.cachedSyncPositions[index];
        }
        Object.assign(this.cachedSyncPacket.destinationPredictions, this.destinationPredictions);
        if (!this.cachedSyncPositions[Number.MAX_SAFE_INTEGER]) {
            this.cachedSyncPositions[Number.MAX_SAFE_INTEGER] = { lat: 0, lon: 0 };
        }
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lat = this.destinationPredictions.position.lat;
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lon = this.destinationPredictions.position.lon;
        this.cachedSyncPacket.destinationPredictions.position = this.cachedSyncPositions[Number.MAX_SAFE_INTEGER];
        for (const [id] of this.trackedFacilityEntries) {
            const predictions = this.trackedFacilityEntryPredictions.get(id);
            if (predictions) {
                if (!this.cachedSyncPacket.trackedFacilityPredictions[id]) {
                    this.cachedSyncPacket.trackedFacilityPredictions[id] = {};
                }
                Object.assign(this.cachedSyncPacket.trackedFacilityPredictions[id], predictions);
                if (!this.cachedSyncFacilityPositions[id]) {
                    this.cachedSyncFacilityPositions[id] = { lat: 0, lon: 0 };
                }
                this.cachedSyncFacilityPositions[id].lat = predictions.position.lat;
                this.cachedSyncFacilityPositions[id].lon = predictions.position.lon;
                this.cachedSyncPacket.trackedFacilityPredictions[id].position = this.cachedSyncFacilityPositions[id];
            }
            else {
                this.cachedSyncPacket.trackedFacilityPredictions[id] = null;
            }
        }
        this.syncPub.pub('boeing_predictions_sync', this.cachedSyncPacket, true);
    }
    /**
     * Updates a tracked facility entry's predictions based on the predictions of a given leg index
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     * @param legIndex the leg index
     */
    updateTrackedFacilityPredictionsAfterLeg(id, entry, legIndex) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        const legPredictions = this.planPredictions.get(legIndex);
        if (!legPredictions || !legPredictions.valid) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        this.trackFacilityLastUpdates.set(entry, this.realTimeValue.get());
        const distance = legPredictions.position.distance(facilityPredictions.position);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(legPredictions.position, facilityPredictions.position, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions, legPredictions.estimatedTimeOfArrival, legPredictions.fob);
    }
    /**
     * Updates a tracked facility entry's predictions based on PPOS
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     */
    updateTrackedFacilityPredictionsFromPpos(id, entry) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        const ppos = this.pposValue.get();
        const distance = GeoPoint.distance(facility.lat, facility.lon, ppos.lat, ppos.long);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions);
    }
    /**
     * Linearly predicts over a distance with fixed parameters
     *
     * @param startLla the position to predict at
     * @param endLla the position to predict at
     * @param distance the distance, in metres, over which to predict
     * @param speed the speed, in knots CAS or mach number, to predict at
     * @param speedIsMach whether {@link speed} is a mach number
     * @param altitude the altitude, in metres, to predict at
     * @param oatTemperature the outside air temperature, in Celsius, to predict at
     * @param oatAltitude the altitude of measure of {@link oatTemperature}
     * @param wind the wind vector to predict with
     * @param out the predictions object to hold the results
     * @param startingTime the starting time, or the current time if not provided
     * @param startingFob the starting fob, or the current fob if not provided
     */
    predictLinearly(startLla, endLla, distance, speed, speedIsMach, altitude, oatTemperature, oatAltitude, wind, out, startingTime, startingFob) {
        var _a;
        const unixTimestamp = startingTime !== null && startingTime !== void 0 ? startingTime : (this.simTimeValue.get() / 1000);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.METER);
        const distanceNm = UnitType.NMILE.convertFrom(distance, UnitType.METER);
        let predictionFuelFlow;
        const predictionOatIsaDev = oatTemperature - AeroMath.isaTemperature(oatAltitude);
        let predictionTrueAirspeed;
        if (speedIsMach) {
            predictionTrueAirspeed = AeroMath.machToTasIsa(speed, altitude, predictionOatIsaDev);
        }
        else {
            const predictionCasMps = UnitType.MPS.convertFrom(speed, UnitType.KNOT);
            predictionTrueAirspeed = AeroMath.casToTasIsa(predictionCasMps, altitude, predictionOatIsaDev);
        }
        const predictionTrueAirSpeedKnots = UnitType.KNOT.convertFrom(predictionTrueAirspeed, UnitType.MPS);
        const currentWeight = ((_a = this.performancePlanRepository.getActivePlan().manualZfw.get()) !== null && _a !== void 0 ? _a : 0) + this.fobValue.get();
        predictionFuelFlow = this.getInstantaneousFuelFlowIsa(altitude, predictionTrueAirspeed, predictionOatIsaDev, currentWeight, 0);
        // Cache great circle between positions
        this.geoCircleCache[0].setAsGreatCircle(startLla, endLla);
        let windKnots = FlightPathUtils.projectVelocityToCircle(wind.speed, startLla, wind.trueDegrees ? wind.direction : MagVar.magneticToTrue(wind.direction, startLla), this.geoCircleCache[0]);
        if (!Number.isFinite(windKnots)) {
            windKnots = 0;
        }
        const predictionGroundSpeed = predictionTrueAirSpeedKnots + windKnots;
        const durationSeconds = (distanceNm / predictionGroundSpeed) * 3600;
        if (predictionFuelFlow === undefined) {
            const fuelFlowPph = this.fuelFlowValue.get() * this.fuelWeightValue.get();
            predictionFuelFlow = fuelFlowPph / 3600;
        }
        const currentFob = startingFob !== null && startingFob !== void 0 ? startingFob : this.fobValue.get();
        out.valid = true;
        out.position.set(endLla);
        out.distance = distanceMetres;
        out.estimatedTimeOfArrival = unixTimestamp + durationSeconds;
        out.fob = currentFob - (durationSeconds * predictionFuelFlow);
        out.altitude = altitude;
        out.speed = speed;
        out.isSpeedMach = speedIsMach;
        out.duration = durationSeconds;
    }
    /**
     * Predicts performance linearly, with current conditions
     *
     * @param startLla the start point of the predictions
     * @param endLla the end point of the predictions
     * @param out the predictions object to hold the results
     */
    predictLinearlyWithCurrentConditions(startLla, endLla, out) {
        const distance = GeoPoint.distance(startLla, endLla);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        const speed = Math.max(MIN_PREDICTIONS_IAS, this.casValue.get());
        const altitude = this.indicatedAltValue.get();
        const altitudeMetres = UnitType.METER.convertFrom(altitude, UnitType.FOOT);
        const oat = this.oatValue.get();
        const wind = {
            speed: this.ambientWindMagnitudeValue.get(),
            direction: this.ambientWindDirectionValue.get(),
            trueDegrees: true,
        };
        this.predictLinearly(startLla, endLla, distanceMetres, speed, false, altitudeMetres, oat, altitudeMetres, wind, out);
    }
    /**
     * Offsets the present position along a vectors leg
     *
     * @param vectorsLeg the vectors leg
     * @param distanceToAdd the distance, in nautical miles, to offset by
     * @param out where the resulting position will be stored
     */
    offsetPposAlongVectorsLeg(vectorsLeg, distanceToAdd, out) {
        var _a;
        const distanceAlong = this.activeLegDistanceAlongValue.get();
        const distanceAlongGa = UnitType.GA_RADIAN.convertFrom(Math.max(0, distanceAlong) + distanceToAdd, UnitType.NMILE);
        if (((_a = vectorsLeg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) === undefined || vectorsLeg.calculated.startLon === undefined || vectorsLeg.calculated.initialDtk === undefined) {
            return;
        }
        this.geoPointCache[1].set(vectorsLeg.calculated.startLat, vectorsLeg.calculated.startLon);
        this.geoCircleCache[1].setAsGreatCircle(this.geoPointCache[1], vectorsLeg.calculated.initialDtk + vectorsLeg.calculated.courseMagVar);
        this.geoCircleCache[1].offsetDistanceAlong(this.geoPointCache[1], distanceAlongGa, out);
    }
    /**
     * Gets the predicited ground speed at the end of a vertical leg.
     * @param verticalLeg The vertical leg to get the predicted ground speed for.
     * @returns The predicted grouns speed, or undefined if one could not be determined.
     */
    getPredictedGroundSpeedAtEndOfLeg(verticalLeg) {
        if (verticalLeg.vectors.length === 0) {
            return undefined;
        }
        const lastVector = this.getVerticalVectorForPredictions(verticalLeg);
        return lastVector.gs;
    }
    /**
     * Returns the total distance of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDistance(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
        }
        return distance;
    }
    /**
     * Returns the total duration of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDuration(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.duration;
        }
        return distance;
    }
    /**
     * Returns the vertical path vector of a vertical leg that should be used for predictions, or the last vector if none are eligible
     *
     * **Note:** this function assumes the leg contains at least one vector
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a {@link VerticalFlightPathVector}
     */
    getVerticalVectorForPredictions(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return verticalLeg.vectors[verticalLeg.vectors.length - 1];
        }
        return verticalLeg.vectors[lastVectorIndex];
    }
    /**
     * Returns the index of the last vertical path vector that is contained within the lateral path of a leg
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a number, or -1 if no eligible vectors found
     */
    getLastVerticalVectorIndexAlongLegPath(verticalLeg) {
        for (let i = verticalLeg.vectors.length - 1; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            if (vector.startDistanceToLegEnd >= 0) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Calculates the instantaneous fuel flow for given parameters at ISA conditions
     *
     * @param altitude the altitude, in metres
     * @param tas the true airspeed, in metres per second
     * @param isaDev the ISA temperature deviation, in degrees Celsius
     * @param weight the weight, in pounds
     * @param flapsIndex The flaps index to use, or zero for a clean configuration.
     *
     * @returns the fuel flow, in pounds per second
     */
    getInstantaneousFuelFlowIsa(altitude, tas, isaDev, weight, flapsIndex) {
        const weightForce = UnitType.NEWTON.convertFrom(weight, UnitType.POUND_FORCE);
        const density = AeroMath.isaDensity(altitude, isaDev);
        const cl = AeroMath.liftCoefficient(weightForce, this.perfProvider.getWingArea(), density, tas);
        const thrust = this.perfProvider.getLevelFlightRequiredThrust(weight, cl, flapsIndex);
        const mach = AeroMath.tasToMachIsa(tas, altitude, AeroMath.soundSpeedIsa(altitude, isaDev));
        const grossThrust = this.perfProvider.estimateGrossThrustFromNetThrust(thrust, mach, AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + isaDev);
        return this.perfProvider.getEngineFuelFlow(grossThrust) / 3600;
    }
    /**
     * Returns the predictions object for a tracked facility entry, creating a new empty and invalid object if none is present
     *
     * @param id the unique id for the tracked facility entry
     * @param entry the tracked facility entry
     *
     * @returns a {@link Predictions} object
     */
    getTrackedFacilityPredictions(id, entry) {
        var _a;
        const predictions = this.trackedFacilityEntryPredictions.get(id);
        if (!predictions) {
            const emptyPredictions = {
                ident: (_a = ICAO.getIdent(entry.facIcao)) !== null && _a !== void 0 ? _a : '',
                position: new GeoPoint(NaN, NaN),
                valid: false,
                distance: NaN,
                estimatedTimeOfArrival: NaN,
                fob: NaN,
                altitude: NaN,
                groundSpeed: NaN,
                speed: NaN,
                isSpeedMach: false,
                duration: NaN,
            };
            this.trackedFacilityEntryPredictions.set(id, emptyPredictions);
            return emptyPredictions;
        }
        return predictions;
    }
    /**
     * Updates the destination prediction
     *
     * @param computeAdvancedPredictions whether to computer advanced predictions, or just distance
     */
    updateDestinationPredictions(computeAdvancedPredictions) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let mapIndex = -1;
        if (plan.length > 0) {
            for (let i = plan.length - 1; i > 0; i--) {
                const planLeg = plan.tryGetLeg(i);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    mapIndex = i;
                }
            }
        }
        // Use the MAP index if it is available
        if (mapIndex !== -1) {
            const mapLegPredictions = this.planPredictions.get(mapIndex);
            if (mapLegPredictions && mapLegPredictions.valid) {
                this.destinationPredictions.valid = true;
                Object.assign(this.destinationPredictions, mapLegPredictions);
                return;
            }
        }
        // Otherwise, predict using the prediction at the last non-missed-approach plan leg + great circle direct
        // distance to the destination airport reference point
        if (plan.length > 0 && plan.destinationAirport) {
            let lastNonMissedApproachLegIndex = -1;
            for (let i = plan.length - 1; i > 0; i--) {
                const leg = plan.getLeg(i);
                if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
                    lastNonMissedApproachLegIndex = i;
                    break;
                }
            }
            if (lastNonMissedApproachLegIndex !== -1) {
                const backwardsIterator = this.iteratePredictionsReverse(lastNonMissedApproachLegIndex);
                let lastLegPredictions;
                let prevLastLegPredictions;
                for (const predictions of backwardsIterator) {
                    if (!prevLastLegPredictions && lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        prevLastLegPredictions = predictions;
                        break;
                    }
                    if (!lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        lastLegPredictions = predictions;
                    }
                }
                if (prevLastLegPredictions && lastLegPredictions) {
                    this.destinationPredictions.valid = true;
                    Object.assign(this.destinationPredictions, lastLegPredictions);
                    const airportFacility = this.resolvedFacilities.get(plan.destinationAirport);
                    if (!airportFacility) {
                        this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                        this.destinationPredictions.valid = false;
                        return;
                    }
                    const distance = lastLegPredictions.position.distance(airportFacility);
                    const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    if (Math.abs(prevLastLegPredictions.distance - lastLegPredictions.distance) > Number.EPSILON) {
                        BoeingFlightPlanPredictionsProvider.extrapolatePrediction(prevLastLegPredictions, lastLegPredictions, distanceMetres, this.destinationPredictions);
                    }
                    else {
                        this.predictLinearly(lastLegPredictions.position, this.geoPointCache[0].set(airportFacility.lat, airportFacility.lon), distanceMetres, UnitType.MPS.convertFrom(MIN_PREDICTIONS_IAS, UnitType.KNOT), false, lastLegPredictions.altitude, 15, 0, NULL_WIND_ENTRY, this.destinationPredictions);
                    }
                    return;
                }
            }
        }
        // In the worst case scenario, predict the great circle direct distance from PPOS to the destination airport reference point
        if (plan.destinationAirport) {
            const facility = this.resolvedFacilities.get(plan.destinationAirport);
            if (!facility) {
                this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                this.destinationPredictions.valid = false;
                return;
            }
            const ppos = this.pposValue.get();
            this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, this.destinationPredictions);
            if (!computeAdvancedPredictions) {
                this.destinationPredictions.estimatedTimeOfArrival = NaN;
                this.destinationPredictions.fob = NaN;
                this.destinationPredictions.altitude = NaN;
                this.destinationPredictions.speed = NaN;
                this.destinationPredictions.isSpeedMach = false;
                this.destinationPredictions.duration = NaN;
            }
            return;
        }
        // Otherwise mark the destination predictions as invalid
        this.destinationPredictions.valid = false;
    }
    /**
     * Invalidates all tracked facility predictions
     */
    invalidateAllTrackedFacilities() {
        for (const [, predictions] of this.trackedFacilityEntryPredictions.entries()) {
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Invalidates all tracked facility predictions attached to a given position
     *
     * @param position the position
     */
    invalidateTrackedFacilitiesForPosition(position) {
        const entries = this.getTrackedFacilityEntriesForPosition(position);
        for (const [entry] of entries) {
            const predictions = this.trackedFacilityEntryPredictions.get(entry);
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Returns all facility tracking entries for a given position
     *
     * @param position the position
     *
     * @returns an array of {@link FacilityPredictionsTrackingEntry} objects
     */
    getTrackedFacilityEntriesForPosition(position) {
        const indices = [];
        for (const mapEntry of this.trackedFacilityEntries.entries()) {
            const [, entry] = mapEntry;
            if (entry.startAfterFlightPlanLeg === position) {
                indices.push(mapEntry);
            }
        }
        return indices;
    }
    /** @inheritDoc */
    *iteratePredictions(startGlobalLegIndex = 0) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = startGlobalLegIndex; i < plan.length; i++) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    *iteratePredictionsReverse(startGlobalLegIndex = this.flightPlanner.getFlightPlan(this.planIndex).length - 1) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = Math.min(plan.length - 1, startGlobalLegIndex); i > 0; i--) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    getPredictionsForLeg(globalLegIndex) {
        return this.planPredictions.get(globalLegIndex);
    }
    /** @inheritDoc */
    getDestinationPredictions() {
        return this.destinationPredictions;
    }
    /** @inheritDoc */
    getPredictionsForTrackedFacility(id) {
        var _a;
        return (_a = this.trackedFacilityEntryPredictions.get(id)) !== null && _a !== void 0 ? _a : undefined;
    }
    /** @inheritDoc */
    startTrackingFacility(id, entry) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_start_tracking_facility', { id, entry }, true);
            return;
        }
        this.trackedFacilityEntries.set(id, entry);
        this.facLoader.getFacility(ICAO.getFacilityType(entry.facIcao), entry.facIcao).then((facility) => {
            this.resolvedFacilities.set(entry.facIcao, facility);
            this.requestPredictionsUpdate();
        });
    }
    /** @inheritDoc */
    stopTrackingFacility(id) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_stop_tracking_facility', id, true);
            return true;
        }
        return this.trackedFacilityEntries.delete(id) && this.trackedFacilityEntryPredictions.delete(id);
    }
    /** @inheritDoc */
    getPredictionsForTime(time, predictActiveLeg = false) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('estimatedTimeOfArrival', time, 1, predictActiveLeg);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const ratio = (time - predictionsBefore.estimatedTimeOfArrival) / (predictionsAfter.estimatedTimeOfArrival - predictionsBefore.estimatedTimeOfArrival);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, ratio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForAltitude(altitude, predictActiveLeg = false) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let startAltitude;
        let crossingDirection = 1;
        for (let i = plan.activeLateralLeg; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (!predictions) {
                continue;
            }
            const isActiveLeg = i === plan.activeLateralLeg;
            if (isActiveLeg && predictActiveLeg) {
                startAltitude = this.pposPrediction.altitude;
                crossingDirection = startAltitude > altitude ? -1 : 1;
            }
            else if (startAltitude === undefined && predictions.valid) {
                startAltitude = predictions.altitude;
                crossingDirection = startAltitude > altitude ? -1 : 1;
            }
            if (crossingDirection > 0 && predictions.altitude > altitude) {
                predictionsBefore = isActiveLeg && predictActiveLeg ? this.pposPrediction : this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
            if (crossingDirection < 0 && predictions.altitude < altitude) {
                predictionsBefore = isActiveLeg && predictActiveLeg ? this.pposPrediction : this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return undefined;
        }
        const altitudeRatio = Math.abs(altitude - predictionsBefore.altitude) / Math.abs(predictionsAfter.altitude - predictionsBefore.altitude);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, altitudeRatio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForDistance(distance, predictActiveLeg = false) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('distance', distance, 1, predictActiveLeg);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const distanceRatio = (distance - predictionsBefore.distance) / (predictionsAfter.distance - predictionsBefore.distance);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, distanceRatio, out);
        return out;
    }
    /**
     * Gets the bounding (previous and next) leg predictions that surround a given value of a property
     *
     * @param discriminant the property to evaluate
     * @param value the value (the value the previous prediction must be below, and the next prediction above)
     * @param progression the progression direction: if -1, inverts the example conditions of the {@link value} param
     * @param predictActiveLeg Whether to use the current aircraft state to predict the active leg.
     * Defaults to false.
     * @returns a tuple of {@link Predictions} objects, or null if none found
     */
    getBoundingLegPredictions(discriminant, value, progression, predictActiveLeg = false) {
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = plan.activeLateralLeg; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (!predictions) {
                continue;
            }
            if (progression > 0 ? predictions[discriminant] < value : predictions[discriminant] > value) {
                predictionsBefore = predictions;
                continue;
            }
            if (progression > 0 ? predictions[discriminant] > value : predictions[discriminant] < value) {
                predictionsAfter = predictions;
                if (i === plan.activeLateralLeg && predictActiveLeg) {
                    predictionsBefore = this.pposPrediction;
                }
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return null;
        }
        return [predictionsBefore, predictionsAfter];
    }
    /**
     * Loads a facility and schedules a predictions update
     *
     * @param facilityIcao the facility ICAO
     */
    loadFacilityAndScheduleUpdate(facilityIcao) {
        this.facLoader.getFacility(ICAO.getFacilityType(facilityIcao), facilityIcao).then((loadedFac) => {
            this.resolvedFacilities.set(facilityIcao, loadedFac);
            this.requestPredictionsUpdate();
        });
    }
    /**
     * Linearly interpolates two prediction objects
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param ratio the ratio to interpolate at
     * @param out the output value object
     */
    static linearlyInterpolatePredictions(predictionsA, predictionsB, ratio, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsA.distance + (ratio * (predictionsB.distance - predictionsA.distance));
            out.estimatedTimeOfArrival = predictionsA.estimatedTimeOfArrival + (ratio * (predictionsB.estimatedTimeOfArrival - predictionsA.estimatedTimeOfArrival));
            out.fob = predictionsA.fob + (ratio * (predictionsB.fob - predictionsA.fob));
            out.altitude = predictionsA.altitude + (ratio * (predictionsB.altitude - predictionsA.altitude));
            out.speed = predictionsA.speed + (ratio * (predictionsB.speed - predictionsA.speed));
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
    /**
     * Linearly extrapolates two prediction objects into another prediction given an additional distance flown
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param additionalDistance the additional distance to extrapolate to
     * @param out the output value object
     */
    static extrapolatePrediction(predictionsA, predictionsB, additionalDistance, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsB.distance + additionalDistance;
            out.estimatedTimeOfArrival = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival);
            out.fob = MathUtils.lerp(out.estimatedTimeOfArrival, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival, predictionsA.fob, predictionsB.fob);
            out.altitude = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.altitude, predictionsB.altitude);
            out.speed = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.speed, predictionsB.speed);
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
}

/**
 * Boeing EFB data store
 */
class BoeingEfbStore {
    constructor() {
        this.flightInitializationDataAcceptedEvent = new SubEvent();
        this.GreenOutlineHandler = new SubEvent();
        this.FlightDataUpdate = new SubEvent();
        this.airportOrigin = Subject.create('');
        this.airportDestination = Subject.create('');
        this.availableTakeoffRunways = Subject.create([]);
        this.takeoffRunway = Subject.create(null);
        this.takeoffRunwayCondition = Subject.create(null);
        this.takeoffRunwayDisplacement = Subject.create(null);
        this.takeoffOatCelsius = Subject.create(null);
        this.takeoffWind = Subject.create(null);
        this.takeoffQnhHpa = Subject.create(null);
        this.takeoffGwLbs = Subject.create(null);
        this.takeoffZfwKg = Subject.create(null);
        this.takeoffCg = Subject.create(null);
    }
    /**
     * Accepts flight initialization data and sets store fields accordingly
     *
     * @param data the flight initialization data
     */
    acceptFlightInitializationData(data,value) {
        
        if (data && value) {
        // FIXME should erase data if it's not set in the FMC?
        data.airportOrigin && this.airportOrigin.set(data.airportOrigin);
        data.airportDestination && this.airportDestination.set(data.airportDestination);
        data.availableTakeoffRunways && this.availableTakeoffRunways.set(data.availableTakeoffRunways);
      
        data.takeoffRunway && this.takeoffRunway.set(data.takeoffRunway);
        
        data.rwyCondition && this.takeoffRunwayCondition.set(data.rwyCondition);
        data.runwayDisplacement && this.takeoffRunwayDisplacement.set(data.runwayDisplacement);
        data.oatCelsius && this.takeoffOatCelsius.set(data.oatCelsius);
       // data.takeoffRunwayWind && this.takeoffWind.set(data.takeoffRunwayWind);
       
        data.qnhHpa && this.takeoffQnhHpa.set(data.qnhHpa);
        data.gwLbs && this.takeoffGwLbs.set(data.gwLbs);
        data.zfwLbs && this.takeoffZfwKg.set(UnitType.POUND.convertTo(data.zfwLbs, UnitType.KILOGRAM));
       // data.cg && this.takeoffCg.set(data.cg);
        this.flightInitializationDataAcceptedEvent.notify(this, undefined);
        this.GreenOutlineHandler.notify(data);
        }
        else{
           
            this.airportOrigin.set(data.airportOrigin || '');
            this.airportDestination.set(data.airportDestination || '');
            this.availableTakeoffRunways.set(data.availableTakeoffRunways || []);
            this.takeoffRunway.set(data.takeoffRunway || null);
            this.takeoffRunwayCondition.set(data.rwyCondition || null);
            this.takeoffRunwayDisplacement.set(data.runwayDisplacement || null);
            this.takeoffOatCelsius.set(data.oatCelsius || null);
          //  this.takeoffWind.set(data.takeoffRunwayWind || null);
            this.takeoffQnhHpa.set(data.qnhHpa || null);
            this.takeoffGwLbs.set(data.gwLbs || null);
            this.takeoffZfwKg.set(data.zfwLbs ? UnitType.POUND.convertTo(data.zfwLbs, UnitType.KILOGRAM) : null);
           // this.takeoffCg.set(data.cg || null);
            this.flightInitializationDataAcceptedEvent.notify(this, undefined);
        }
       
    }
    
}
class MenuCheckbox extends DisplayComponent {
    constructor() {
       super(...arguments);
       // super(props);
       // this.root = FSComponent.createRef();
        this.el = FSComponent.createRef();
        this.uncheckedRef = FSComponent.createRef();
        this.checkedRef = FSComponent.createRef();
        
    }
    /** @inheritdoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.ConversionBtn) {
            this.el.instance.addEventListener('click', () => {
                this.props.isChecked.set(true)
                //this.props.isChecked.set(!this.props.isChecked.get());
              
            });
            this.props.isChecked.sub((v) => {
                this.uncheckedRef.instance.classList.toggle('hidden', v);
                this.checkedRef.instance.classList.toggle('hidden', !v);
            }, true);
            
          //  if (this.props.onClick) {
            //    this.root.instance.addEventListener('click', () => !this.isDisabled.get() && this.props.onClick && this.props.onClick());
          //  }
        }
    }
    /** @inheritdoc */
    render() {
       
         if (this.props.ConversionBtn == true) {
            
            return (FSComponent.buildComponent("div", { class: "nd-map-menu-dropdown-section-checkbox-container", ref: this.el },
                FSComponent.buildComponent("div", { class: "nd-map-menu-checkbox-svg-container", ref: this.uncheckedRef },
                    FSComponent.buildComponent("svg", { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 10 30 36", "shape-rendering": "geometricPrecision", "text-rendering": "geometricPrecision" },
                        FSComponent.buildComponent("path", { d: "M14.96,0L4,18L14.96,36L25.92,18L14.96,0Z",transform: "matrix(.898458 0 0 0.824377 1.559068 13.161214)", fill: BoeingColors.white, "stroke-width": "0.5" }),
                        FSComponent.buildComponent("path", { d: "M14.96,0L4,18L14.96,36L25.92,18L14.96,0Z",transform: "matrix(.82443 0 0 0.753566 2.666527 14.435812)", fill: BoeingColors.black, "stroke-width": "0.5" }),
                        //FSComponent.buildComponent("path", { d: "M14.96,0L4,18L14.96,36L25.92,18L14.96,0Z",transform: "matrix(0.5 0 0 0.412188 7.52 20.580616)", fill: BoeingColors.green, "stroke-width": "0.5" }),
                        
                    
                    
                       
                    
                        
                        
                        
                    )),
                FSComponent.buildComponent("div", { class: "nd-map-menu-checkbox-svg-container", ref: this.checkedRef },
                    FSComponent.buildComponent("svg", { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 10 30 36", "shape-rendering": "geometricPrecision", "text-rendering": "geometricPrecision" },
                    FSComponent.buildComponent("path", { d: "M14.96,0L4,18L14.96,36L25.92,18L14.96,0Z",transform: "matrix(.898458 0 0 0.824377 1.559068 13.161214)", fill: BoeingColors.white, "stroke-width": "0.5" }),
                    FSComponent.buildComponent("path", { d: "M14.96,0L4,18L14.96,36L25.92,18L14.96,0Z",transform: "matrix(.82443 0 0 0.753566 2.666527 14.435812)", fill: BoeingColors.black, "stroke-width": "0.5" }),
                    FSComponent.buildComponent("path", { d: "M14.96,0L4,18L14.96,36L25.92,18L14.96,0Z",transform: "matrix(.449229 0 0 0.412188 8.279534 20.580616)", fill: BoeingColors.green, "stroke-width": "0.5" }),
                        
                       
                      )),
                FSComponent.buildComponent("label", { class: "checkbox-label", for: this.props.label }, this.props.label)));
        }
      
      
        return (FSComponent.buildComponent("div", { class: "nd-map-menu-dropdown-section-checkbox-container placeholder", key: this.props.label },
        FSComponent.buildComponent("div", { class: "nd-map-menu-checkbox-svg-container-Placeholder" },
            FSComponent.buildComponent("svg", { viewBox: "0 0 40 40" },
                FSComponent.buildComponent("rect", { x: 2, y: 2, width: this.props.width, height: this.props.height, fill: "none", "stroke-width": "4", stroke: BoeingColors.cyan }))),
        FSComponent.buildComponent("label", { class: "checkbox-label" }, this.props.label)));
       
    }
    /** @inheritdoc */
    destroy() {
        this.el.instance.removeEventListener('click', () => null);
    }
}
/** A efb generic button */
class BoeingEfbButton extends DisplayComponent {
    /**
     * The constructor of the BoeingMfdButton, used for formatting button text on creation.
     * @param props The props of the BoeingMfdButton.
     */
    constructor(props) {
        super(props);
        this.root = FSComponent.createRef();
        this.buttonText = [];
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable(this.props.isDisabled, true);
        this.isInop = SubscribableUtils.toSubscribable(this.props.isInop, true);
        this.isInactive = SubscribableUtils.toSubscribable(this.props.isInactive, true);
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => this.props.onClick && this.props.onClick());
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        return (FSComponent.buildComponent("span", { ref: this.root, style: style, class: Object.assign({ 'boeing-mfd-button': true, 'boeing-mfd-button-selected': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-mfd-button-disabled': this.isDisabled.map(x => x === true), 'boeing-mfd-button-inop': this.isInop.map(x => x === true), 'boeing-mfd-button-inactive': this.isInactive.map(x => x === true), 'boeing-mfd-button-alerted': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                previous[current] = true;
                return previous;
            }, {}))) }, ...this.buttonText));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}
class BoeingEfbDynamicLabel extends DisplayComponent {
    /**
      * The constructor of the BoeingMfdButton, used for formatting button text on creation.
      * @param props The props of the BoeingMfdButton.
      */
    constructor(props) {
     super(props);
     this.root = FSComponent.createRef();
     this.buttonText = Subject.create('');
     this.secondaryText = Subject.create('');
     this.TertiaryText = Subject.create('');
     
   
    
    
     
    
     if (this.props.children) {
       
         this.buttonText.set(this.props.Name);
         this.secondaryText.set(this.props.SecondaryText)
         this.TertiaryText.set(this.props.TertiaryText)
     }
 }
 /** @inheritDoc */
 onAfterRender(node) {
     super.onAfterRender(node);
    
 }
 /** @inheritDoc */
 render() {
    var _a;
    const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
    const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
    
    const style = `${customWidthStyleString} ${customHeightStyleString}`;
  
   
    const classObject = {
        'efb-middle-top-left2-title': !this.props.Smaller, 
        'efb-middle-top-left5-title': this.props.Smaller   
    };
    
    const primaryTextContent =   this.buttonText.get();
    const primaryTextComponent = FSComponent.buildComponent("span", null, primaryTextContent);

   
    const secondaryTextContent =  this.secondaryText.get();
    const secondaryTextComponent = FSComponent.buildComponent("span", null, secondaryTextContent);

    const TertiaryTextContent =  this.TertiaryText.get();
    const TertiaryTextComponent = FSComponent.buildComponent("span", null, TertiaryTextContent);

    return (
        FSComponent.buildComponent("div", { 
            ref: this.theEntireButtonRef 
        },
            FSComponent.buildComponent("div", { 
                ref: this.buttonNameRef, 
                class: 'button-name' 
            }, 
                this.props.dropdownButtonName
            ),
            FSComponent.buildComponent("span", { 
                ref: this.root, 
                style: style, 
                class: Object.assign(classObject, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                    previous[current] = true;
                    return previous;
                }, {})))
            }, 
                secondaryTextComponent, 
                ' ', 
                primaryTextComponent ,
                ' ', 
                TertiaryTextComponent
            )
        )
    );
}




     /** @inheritDoc */
     destroy() {
         this.root.instance.removeEventListener('click', () => null);
     }
 }

/** A EFB DropDown Menu button */
class BoeingEfbDropdownButton extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.root = FSComponent.createRef();
        this.dropDownMenuItemsRef = FSComponent.createRef();
        this.theEntireButtonRef = FSComponent.createRef();
        this.buttonNameRef = FSComponent.createRef();
        this.arrowRef = FSComponent.createRef();
        this.buttonText = Subject.create('');
        this.isButtonPressed = Subject.create(false);
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable(this.props.isDisabled, true);
        this.hasGreenOutline = SubscribableUtils.toSubscribable(this.props.hasGreenOutline, true);
         
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => this.props.onClick && this.props.onClick());
        }
           
           
        else {
            this.root.instance.style.color = 'var(--boeing-colors-white)';
        }
        if (this.props.hasArrow) {
            this.arrowRef.instance.classList.remove('hidden');
        }
        if (this.props.isNameOnLeftSide) {
            this.buttonNameRef.instance.classList.add('dropdown-button-name-left');
        }
        else {
            this.buttonNameRef.instance.classList.add('dropdown-button-name-right');
        }
        this.root.instance.addEventListener('click', () => this.handleDropdownClicked());
        this.props.dropdownItems.sub(this.updateList.bind(this), true);
        //Gets the first item of the list and sets the name to be that
        if (this.props.onFmcLoadedName) {
            this.props.onFmcLoadedName.sub(this.updateAiport.bind(this), true);
        }
        this.buttonText.set(this.props.dropDownDefaultName);
    }
    /**
     * Picks an item programmatically
     * @param item the item to pick
     */
    pickItem(item) {
        this.handleItemPicked(item);
    }
    /**
     * Handles changes to the backing ArraySubject
     * @param index The index of the change.
     * @param type The type of change.
     * @param data The item that was changed.
     */
    updateList(index, type, data) {
        // TODO check if/how we do EXIT
        switch (type) {
            case SubscribableArrayEventType.Added:
                this.onListItemAdded(index, data);
                break;
            case SubscribableArrayEventType.Removed:
                this.onListItemRemoved(index, data);
                break;
            case SubscribableArrayEventType.Cleared:
                this.onListCleared();
                break;
        }
    }
    /**
     * Handles addition of items to the backing ArraySubject.
     * @param index The index at which the data items were added.
     * @param data The data item(s) that were added.
     */
    onListItemAdded(index, data) {
        if (data !== undefined) {
            if (Array.isArray(data)) {
                for (const item of data) {
                    this.addListItem(index++, item);
                }
            }
            else {
                this.addListItem(index, data);
            }
        }
    }
    /**
     * Adds an item to the menu list.
     * @param index Index to insert the item at.
     * @param data Data for the item.
     */
    addListItem(index, data) {
        var _a;
        const listItem = document.createElement('div');
        
        listItem.innerText = (data === null || data === undefined) ? ((_a = this.props.dropdownItemFormatter.nullValueString) !== null && _a !== void 0 ? _a : '') : this.props.dropdownItemFormatter.format(data);
        listItem.classList.add('boeing-efb-dropdown-button');
        listItem.classList.add('boeing-efb-dropdown-item');
        listItem.addEventListener('click', () => this.handleItemPicked(data));
        const menuItems = this.dropDownMenuItemsRef.instance;
        if (index >= menuItems.children.length) {
            menuItems.appendChild(listItem);
        }
        else if (index > 0) {
            const itemBefore = menuItems.children.item(index - 1);
            itemBefore === null || itemBefore === void 0 ? void 0 : itemBefore.insertAdjacentElement('afterend', listItem);
        }
        else {
            const itemAfter = menuItems.children.item(index);
            itemAfter === null || itemAfter === void 0 ? void 0 : itemAfter.insertAdjacentElement('beforebegin', listItem);
        }
    }
    /**
     * Handles removal of items from the backing ArraySubject.
     * @param index Index to remove the item from.
     * @param data Data for the list item(s) to remove.
     */
    onListItemRemoved(index, data) {
        if (data !== undefined) {
            if (Array.isArray(data)) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                for (const item of data) {
                    this.removeListItem(index);
                }
            }
            else {
                this.removeListItem(index);
            }
        }
    }
    /**
     * Removes an item from the menu list.
     * @param index Index to remove the item from.
     */
    removeListItem(index) {
        const menuItems = this.dropDownMenuItemsRef.instance;
        const item = menuItems.children.item(index);
        if (item) {
            item.remove();
        }
    }
    /**
     * Handles clearing of the backing ArraySubject.
     */
    onListCleared() {
        const menuItems = this.dropDownMenuItemsRef.instance;
        for (; menuItems.hasChildNodes();) {
            const item = menuItems.children.item(0);
            if (item) {
                item.remove();
            }
        }
    }
    /**
     * updates the textbox for the name of the airport origin/dest
     */
    SetDefault() {
       
        this.buttonText.set(this.props.dropDownDefaultName);
        this.root.instance.style.color = 'white';
        this.root.instance.classList.add('boeing-efb-dropdown-button');
    }
    

    updateAiport() {
        if (this.props.onFmcLoadedName) {
            this.buttonText.set(this.props.onFmcLoadedName.get());
        }
    }
    /**
     * when the user clicks the dropdown menu to show option
     */
    handleDropdownClicked() {
        if (!this.props.isDropDownDisabled) {
            if (this.isButtonPressed.get()) {
                this.isButtonPressed.set(false);
                this.dropDownMenuItemsRef.instance.classList.add('hidden');
            }
            else {
                this.isButtonPressed.set(true);
                this.dropDownMenuItemsRef.instance.classList.remove('hidden');
            }
        }
    }
    /**
     * When the user picks an item from the dropdown list.
     * @param item the item that was chosen, or, `undefined` if it is EXIT
     */
    handleItemPicked(item) {
        var _a, _b, _c;
        this.isButtonPressed.set(false);
        
        if (item !== undefined && (typeof item !== 'string' || item !== 'EXIT')) {
           
            this.root.instance.style.color = 'var(--b78x-efb-green)';
            const formattedItem = (item === null && item !== undefined) ? ((_a = this.props.dropdownItemFormatter.nullValueString) !== null && _a !== void 0 ? _a : '') : this.props.dropdownItemFormatter.format(item);
            this.buttonText.set(formattedItem);
            (_c = (_b = this.props).onItemSelected) === null || _c === void 0 ? void 0 : _c.call(_b, item);
            this.dropDownMenuItemsRef.instance.classList.add('hidden');
        }
        else {
            this.dropDownMenuItemsRef.instance.classList.add('hidden');
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        return (FSComponent.buildComponent("div", { ref: this.theEntireButtonRef },
            FSComponent.buildComponent("div", { ref: this.buttonNameRef, class: 'button-name' }, this.props.dropdownButtonName),
            FSComponent.buildComponent("span", { ref: this.root, style:Object.assign({}, style, {
                outline: this.hasGreenOutline.map(x => x === true ? '3px solid var(--b78x-efb-green)' : 'none')
            }), class: Object.assign({ 'boeing-efb-dropdown-button': true, 'boeing-efb-dropdown-button-selected': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-efb-dropdown-button-disabled': this.isDisabled.map(x => x === true), 'boeing-efb-dropdown-button-alerted': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                    previous[current] = true;
                    return previous;
                }, {}))) },
                FSComponent.buildComponent("span", null, this.buttonText),
                FSComponent.buildComponent("div", { ref: this.arrowRef, class: 'boeing-efb-dropdown-arrow hidden' },
                    FSComponent.buildComponent("svg", { width: "15px", viewBox: "0 0 20 25" },
                        FSComponent.buildComponent("path", { d: "M 0 0 l 0 25 L 20 12.5 z", fill: "black" })))),
            FSComponent.buildComponent("div", { class: 'dropdown-items hidden', ref: this.dropDownMenuItemsRef })));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}
/** A EFB DropDown Menu button */
class BoeingEfbLargeDropdownButton extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.root = FSComponent.createRef();
        this.dropDownMenuItemsRef = FSComponent.createRef();
        this.theEntireButtonRef = FSComponent.createRef();
        this.buttonNameRef = FSComponent.createRef();
        this.arrowRef = FSComponent.createRef();
        this.buttonText = Subject.create('');
        this.isButtonPressed = Subject.create(false);
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable(this.props.isDisabled, true);
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => this.props.onClick && this.props.onClick());
        }
        if (this.props.hasGreenOutline === true) {
           
           
           this.root.instance.style.outline = 'var(--boeing-colors-white)';
        }
        else {
            this.root.instance.style.color = 'var(--boeing-colors-white)';
        }
        if (this.props.hasArrow) {
            this.arrowRef.instance.classList.remove('hidden');
        }
        if (this.props.isNameOnLeftSide) {
            this.buttonNameRef.instance.classList.add('dropdown-button-name-left');
        }
        else {
            this.buttonNameRef.instance.classList.add('dropdown-button-name-right');
        }
        this.root.instance.addEventListener('click', () => this.handleDropdownClicked());
        this.props.dropdownItems.sub(this.updateList.bind(this), true);
        //Gets the first item of the list and sets the name to be that
        if (this.props.onFmcLoadedName) {
            this.props.onFmcLoadedName.sub(this.updateAiport.bind(this), true);
        }
        this.buttonText.set(this.props.dropDownDefaultName);
    }
    /**
     * Picks an item programmatically
     * @param item the item to pick
     */
    pickItem(item) {
       
        this.handleItemPicked(item);
    }
    /**
     * Handles changes to the backing ArraySubject
     * @param index The index of the change.
     * @param type The type of change.
     * @param data The item that was changed.
     */
    updateList(index, type, data) {
        // TODO check if/how we do EXIT
        switch (type) {
            case SubscribableArrayEventType.Added:
                this.onListItemAdded(index, data);
                break;
            case SubscribableArrayEventType.Removed:
                this.onListItemRemoved(index, data);
                break;
            case SubscribableArrayEventType.Cleared:
                this.onListCleared();
                break;
        }
    }
    /**
     * Handles addition of items to the backing ArraySubject.
     * @param index The index at which the data items were added.
     * @param data The data item(s) that were added.
     */
    onListItemAdded(index, data) {
        if (data !== undefined) {
            if (Array.isArray(data)) {
                for (const item of data) {
                    this.addListItem(index++, item);
                }
            }
            else {
                this.addListItem(index, data);
            }
        }
    }
    /**
     * Adds an item to the menu list.
     * @param index Index to insert the item at.
     * @param data Data for the item.
     */
    addListItem(index, data) {
        var _a;
        const listItem = document.createElement('div');
        listItem.innerText = (data === null || data === undefined) ? ((_a = this.props.dropdownItemFormatter.nullValueString) !== null && _a !== void 0 ? _a : '') : this.props.dropdownItemFormatter.format(data);
        listItem.classList.add('boeing-efb-dropdown3-button');
        listItem.classList.add('boeing-efb-dropdown2-item');
        listItem.addEventListener('click', () => this.handleItemPicked(data));
        const menuItems = this.dropDownMenuItemsRef.instance;
        if (index >= menuItems.children.length) {
            menuItems.appendChild(listItem);
        }
        else if (index > 0) {
            const itemBefore = menuItems.children.item(index - 1);
            itemBefore === null || itemBefore === void 0 ? void 0 : itemBefore.insertAdjacentElement('afterend', listItem);
        }
        else {
            const itemAfter = menuItems.children.item(index);
            itemAfter === null || itemAfter === void 0 ? void 0 : itemAfter.insertAdjacentElement('beforebegin', listItem);
        }
    }
    /**
     * Handles removal of items from the backing ArraySubject.
     * @param index Index to remove the item from.
     * @param data Data for the list item(s) to remove.
     */
    onListItemRemoved(index, data) {
        if (data !== undefined) {
            if (Array.isArray(data)) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                for (const item of data) {
                    this.removeListItem(index);
                }
            }
            else {
                this.removeListItem(index);
            }
        }
    }
    /**
     * Removes an item from the menu list.
     * @param index Index to remove the item from.
     */
    removeListItem(index) {
        const menuItems = this.dropDownMenuItemsRef.instance;
        const item = menuItems.children.item(index);
        if (item) {
            item.remove();
        }
    }
    /**
     * Handles clearing of the backing ArraySubject.
     */
    onListCleared() {
        const menuItems = this.dropDownMenuItemsRef.instance;
        for (; menuItems.hasChildNodes();) {
            const item = menuItems.children.item(0);
            if (item) {
                item.remove();
            }
        }
    }
    /**
     * updates the textbox for the name of the airport origin/dest
     */
    updateAiport() {
        if (this.props.onFmcLoadedName) {
            this.buttonText.set(this.props.onFmcLoadedName.get());
        }
    }
    /**
     * when the user clicks the dropdown menu to show option
     */
    handleDropdownClicked() {
        if (!this.props.isDropDownDisabled) {
            if (this.isButtonPressed.get()) {
                this.isButtonPressed.set(false);
                this.dropDownMenuItemsRef.instance.classList.add('hidden');
            }
            else {
                this.isButtonPressed.set(true);
                this.dropDownMenuItemsRef.instance.classList.remove('hidden');
            }
        }
    }
    /**
     * When the user picks an item from the dropdown list.
     * @param item the item that was chosen, or, `undefined` if it is EXIT
     */
    handleItemPicked(item) {
        var _a, _b, _c;
        this.isButtonPressed.set(false);
        if (item !== undefined && (typeof item !== 'string' || item !== 'EXIT')) {
            this.root.instance.style.color = 'var(--boeing-colors-white)';
            const formattedItem = (item === null && item !== undefined) ? ((_a = this.props.dropdownItemFormatter.nullValueString) !== null && _a !== void 0 ? _a : '') : this.props.dropdownItemFormatter.format(item);
            this.buttonText.set(formattedItem);
            (_c = (_b = this.props).onItemSelected) === null || _c === void 0 ? void 0 : _c.call(_b, item);
            this.dropDownMenuItemsRef.instance.classList.add('hidden');
        }
        else {
            this.dropDownMenuItemsRef.instance.classList.add('hidden');
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;

        return (FSComponent.buildComponent("div", { ref: this.theEntireButtonRef },
            FSComponent.buildComponent("div", { ref: this.buttonNameRef, class: 'button-name' }, this.props.dropdownButtonName),
            FSComponent.buildComponent("span", { ref: this.root, style: style, class: Object.assign({ 'boeing-efb-dropdown2-button': true, 'boeing-efb-dropdown-button-selected': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-efb-dropdown-button-disabled': this.isDisabled.map(x => x === true), 'boeing-efb-dropdown-button-alerted': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                    previous[current] = true;
                    return previous;
                }, {}))) },
                FSComponent.buildComponent("div", { ref: this.theEntireButtonRef, class: 'boeing-efb-dropdown2-buttonspan' }, this.buttonText),
                FSComponent.buildComponent("div", { ref: this.arrowRef, class: 'boeing-efb-dropdown-arrow2 hidden' },
                    FSComponent.buildComponent("svg", { width: "25px", viewBox: "0 0 30 35" },

                    FSComponent.buildComponent("path", { d: "M0,0v25L20,12.5L0,0Z",transform: "matrix(1.395685 0 0 1.065036 1.550673 4.18705)", fill: BoeingColors.gray, "stroke-width": "0.5" }),
                    FSComponent.buildComponent("path", { d: "M0,0v25L20,12.5L0,0Z",transform: "matrix(1.24343 0 0 0.924528 2.5657 5.9434)", fill: BoeingColors.black }),
                      ))),

                        
            FSComponent.buildComponent("div", { class: 'dropdown-items2 hidden', ref: this.dropDownMenuItemsRef },
            FSComponent.buildComponent("span", { class: 'boeing-efb-ArrowUP-Holder' },
            FSComponent.buildComponent("path", { d: "M0,0v25L20,12.5L0,0Z",transform: "matrix(1.24343 0 0 0.924528 2.5657 5.9434)", fill: BoeingColors.black })
        ),
            FSComponent.buildComponent("div", { class: 'boeing-efb-Scroll-button' },
            
            
            FSComponent.buildComponent("div", { class: 'boeing-efb-Scroll2-button' })),
           

)));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}
/** A EFB ProgressBar  */
class BoeingEfbProgressBar extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.root = FSComponent.createRef();
        this.progressBar = FSComponent.createRef();
        this.progressBarFullRef = FSComponent.createRef();
        this.dataInProgressBar = FSComponent.createRef();
        this.runway = Subject.create('');
        this.weight = Subject.create('');
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        this.progressBar.instance.style.width = 0 + '%';
        this.props.isHidden.sub(() => {
            if (!this.props.isHidden.get()) {
                this.progressBarFullRef.instance.classList.add('hidden');
            }
            else {
                this.progressBarFullRef.instance.classList.remove('hidden');
            }
        });
    }
    /**
     * Updates the progress bar.
     * @param p Number to increment by.
     */
    update(p) {
        this.progressBar.instance.style.width = p + '%';
    }
    /**
     * Sets info given by the performace plan in the progress bar once done calculating.
     * @param runway Runways name.
     * @param weight Weight.
     */
    setBarInfo(runway, weight) {
        if (runway !== undefined) {
            this.runway.set(runway);
        }
        this.weight.set(weight);
        this.progressBar.instance.style.backgroundColor = 'var(--boeing-max-efb-dark-green)';
        this.progressBarFullRef.instance.style.border = 'none';
    }
    /**
     * Resets the progress bar so that it can be simulated again
     */
    resetProgressBar() {
        //set the data to nothing
        this.runway.set('');
        this.weight.set('');
        //set the transition speed to 0 so it can reset faster
        this.progressBar.instance.style.transition = 'none';
        //set the bar to hidden
        this.progressBar.instance.style.width = 0 + '%';
        //then set the speed back to normal for it to be used again
        this.progressBar.instance.style.transition = 'width 0.2s linear';
        this.progressBarFullRef.instance.style.border = '3px solid var(--boeing-colors-magenta)';
    }
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.progressBarFullRef, class: 'progress hidden' },
            FSComponent.buildComponent("div", { ref: this.progressBar, class: "progress-bar" },
                FSComponent.buildComponent("div", { ref: this.dataInProgressBar, class: 'data-in-progress-bar' },
                    FSComponent.buildComponent("div", null, this.runway),
                    FSComponent.buildComponent("div", null, this.weight)))));
    }
}

/** A EFB side menu button */
class BoeingEfbSideButton extends DisplayComponent {
    /**
     * The constructor of the BoeingMfdButton, used for formatting button text on creation.
     * @param props The props of the BoeingMfdButton.
     */
    constructor(props) {
        var _a;
        super(props);
        this.root = FSComponent.createRef();
        this.buttonText = [];
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable((_a = this.props.isDisabled) !== null && _a !== void 0 ? _a : false, true);
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => !this.isDisabled.get() && this.props.onClick && this.props.onClick());
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        return (FSComponent.buildComponent("span", { ref: this.root, style: style, class: Object.assign({ 'boeing-efb-button': true, 'boeing-efb-button-selected': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-efb-button-disabled': this.isDisabled.map(x => x === true), 'boeing-efb-button-alerted': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                previous[current] = true;
                return previous;
            }, {}))) }, ...this.buttonText));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}

/* eslint-disable no-useless-escape */
var TextFieldState;
(function (TextFieldState) {
    TextFieldState[TextFieldState["Inactive"] = 0] = "Inactive";
    TextFieldState[TextFieldState["Typing"] = 1] = "Typing";
    TextFieldState[TextFieldState["Valid"] = 2] = "Valid";
})(TextFieldState || (TextFieldState = {}));
/** A EFB Text Field button */
class BoeingEfbTextBox extends DisplayComponent {
    /**
     * The constructor of the BoringEfbTextFields
     * @param props The props of the BoringEfbTextFields.
     */
    constructor(props) {
        super(props);
        this.root = FSComponent.createRef();
        
        this.textFieldState = Subject.create(TextFieldState.Inactive);
       
        this.theEntireButtonRef = FSComponent.createRef();
        this.buttonNameRef = FSComponent.createRef();
        this.buttonText = [];
        this.textBox = FSComponent.createRef();
        
      
        this.unitForTextField = SubscribableUtils.toSubscribable(this.props.unitForTextField, true);
        this.inputId = this.genGuid();
        this.setValueFromOS = (text) => {
            this.textBox.instance.value = text.toUpperCase();
            this.onTextTyped();
            this.textBox.instance.blur();
            Coherent.off('SetInputTextFromOS', this.setValueFromOS);
        };
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /**
     * Types a text value into the field
     * @param value the string
     */
    async typeValue(value) {
        this.textBox.instance.value = value;
        this.textBox.instance.blur();
        this.textFieldState.set(TextFieldState.Inactive);
        const parsed = await this.props.validator.parse(this.textBox.instance.value);
        if (parsed !== null) {
            this.textFieldState.set(TextFieldState.Valid);
            this.props.onValueChanged(parsed);
        }
        await this.onTextTyped();
        //Add the unit back onto the textbox after all the parsing has been done.
        //do nothing since the textbox is empty
        if (this.textBox.instance.value !== '' && this.props.unitForTextField !== undefined) {
            this.textBox.instance.value = value + ' ' + this.unitForTextField.get();
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => this.props.onClick && this.props.onClick());
        }
        
        this.textBox.instance.onkeyup = (e) => this.onKeyboardEvent(e);
        this.textBox.instance.onfocus = (e) => this.onKeyboardFocus(e);
        this.textBox.instance.onblur = async (e) => await this.onKeyboardBlur(e);
        this.textFieldState.sub((style) => {
            let borderStyle;
            switch (style) {
                case TextFieldState.Inactive:
                    borderStyle = '3px solid var(--boeing-colors-white)';
                    break;
              
            }
            this.root.instance.style.border = borderStyle;
        });
       
        if (this.props.valueOnStartUp !== undefined) {
          
        }
        if (this.props.valueOnStartUp) {
            this.props.valueOnStartUp.sub(this.onTextTyped.bind(this), true);
        }
    }
    /**
     * Generates a unique id.
     * @returns A unique ID string.
     */
    genGuid() {
        return 'INPT-xxxyxxyy'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * An event fired when keyboard focus receives a key event.
     * @param e The keyboard event.
     */
    onKeyboardEvent(e) {
        var _a;
        // Validate entered text. Accept 0-9, /, +, -, ., backspace, and t if allowed to
        if (!((_a = this.props.onlyNumberEntry) !== null && _a !== void 0 ? _a : false) || (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_9) ||
            (e.keyCode === KeyCode.KEY_SLASH || e.keyCode === KeyCode.KEY_DIVIDE) ||
            (e.keyCode >= KeyCode.KEY_NUMPAD0 && e.keyCode <= KeyCode.KEY_NUMPAD9) ||
            (e.keyCode === KeyCode.KEY_PERIOD || e.keyCode === KeyCode.KEY_DECIMAL) ||
            (e.keyCode === KeyCode.KEY_BACK_SPACE) || e.keyCode === KeyCode.KEY_SUBTRACT ||
            e.keyCode === KeyCode.KEY_ADD || e.keyCode === KeyCode.KEY_SUBTRACT_TOP) {
            this.onTextTyped();
        }
        else if (this.props.allowTforWind && e.keyCode === KeyCode.KEY_T) {
            // this is if the text box is allowed T to be typed
            this.onTextTyped();
        }
        else {
            //If the wrong key is entered to keydoes not show up for the calc
            this.textBox.instance.value = this.textBox.instance.value.slice(0, -1);
        }
    
        e.preventDefault();
    }
    /**
     * An event triggered when keyboard focus is entered.
     * @param e The event that was triggered.
     */
    onKeyboardFocus(e) {
        e.preventDefault();
        this.textBox.instance.value = '';
        this.textBox.instance.focus({ preventScroll: true });
        //this.textFieldState.set(TextFieldState.Typing);
        Coherent.on('SetInputTextFromOS', this.setValueFromOS);
        Coherent.trigger('FOCUS_INPUT_FIELD', this.inputId, '', '', '', false);
        Coherent.on('mousePressOutsideView', () => {
            this.textBox.instance.blur();
        });
    }
    /**
     * An event triggered when keyboard focus is exited.
     * @param e The event that was triggered.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onKeyboardBlur(e) {
        var _a;
        e.preventDefault();
        //this.textFieldState.set(TextFieldState.Inactive);
        Coherent.off('SetInputTextFromOS', this.setValueFromOS);
        Coherent.trigger('UNFOCUS_INPUT_FIELD', '');
        Coherent.off('mousePressOutsideView');
        const parsed = await this.props.validator.parse(this.textBox.instance.value);
        if (parsed !== null) {
            //this.textFieldState.set(TextFieldState.Valid);
            this.props.onValueChanged(parsed);
        }
       
        //Add the unit back onto the textbox after all the parsing has been done.
        //do nothing since the textbox is empty
        if (this.textBox.instance.value !== '' && this.props.unitForTextField !== undefined) {
            let valueText;
            if (this.props.textFieldFormatter) {
               
                if (parsed === null) {
                    valueText = ((_a = this.props.textFieldFormatter.nullValueString) !== null && _a !== void 0 ? _a : '');
                }
                else {
                    valueText = this.props.textFieldFormatter.format(parsed);
                }
            }
            else {
                valueText = this.textBox.instance.value;
            }
            this.textBox.instance.value = `${valueText} ${this.unitForTextField.get()}`;
        }
    }
    /**
     * This is the logic that will fill out the text field when the user goes to the next one
     * it adds in the units of the textfield
     * @param parsedValue The Parsed value.
     */
    
    /**
     * This is the logic of what shows below the text when entering input from the textfield
     * Text starts blank if not numbers are entered
     * will also become blank if '/' does not have anything after it
     */
    async onTextTyped() {
        this.textBox.instance.value = this.textBox.instance.value.toUpperCase();
        const parsed = await this.props.validator.parse(this.textBox.instance.value);
      
    }
    /**
     * Sets the text field to inactive to give the white boarder back
     */
    setTextFieldToInactive() {
        
        this.textFieldState.set(TextFieldState.Inactive);
       
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const customTextWidthStyleString = this.props.width ? `width: ${this.props.TextWidth}px !important;` : '';
        const customTextHeightStyleString = this.props.height ? `height: ${this.props.TextHeight}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        const styleText = `${customTextWidthStyleString} ${customTextHeightStyleString}`;
        return (FSComponent.buildComponent("div", { class: 'boeing-efb-top-textfield', ref: this.theEntireButtonRef },
            FSComponent.buildComponent("div", { ref: this.buttonNameRef,style: style, class: 'button-name' }, this.props.buttonName),
            FSComponent.buildComponent("textarea", { ref: this.root, style: style, class: Object.assign({ 'boeing-efb-textbox-button': true,    }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                    previous[current] = true;
                    return previous;
                }, {}))) },
                FSComponent.buildComponent("input", { class: 'boeing-efb-text-field-keyboard-input', ref: this.textBox })),
           ));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}


/**
 * Setting modes for date/time format.
 */
var DateTimeFormatSettingMode;
(function (DateTimeFormatSettingMode) {
    DateTimeFormatSettingMode["UTC"] = "UTC";
    DateTimeFormatSettingMode["Local24"] = "Local24";
    DateTimeFormatSettingMode["Local12"] = "Local12";
})(DateTimeFormatSettingMode || (DateTimeFormatSettingMode = {}));
/**
 * Utility class for retrieving date/time user setting managers.
 */
class DateTimeUserSettings {
    /**
     * Retrieves a manager for date/time user settings.
     * @param bus The event bus.
     * @returns A manager for date/time user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = DateTimeUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (DateTimeUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'dateTimeFormat',
                defaultValue: DateTimeFormatSettingMode.UTC
            },
            {
                name: 'dateTimeLocalOffset',
                defaultValue: 0
            }
        ]));
    }
}

/**
 * Date display formats.
 */
var DateDisplayFormat;
(function (DateDisplayFormat) {
    /** UTC time. */
    DateDisplayFormat[DateDisplayFormat["UTC"] = 0] = "UTC";
    /** Local time in 24-hour format. */
    DateDisplayFormat[DateDisplayFormat["Local24"] = 1] = "Local24";
    /** Local time in 12-hour format. */
    DateDisplayFormat[DateDisplayFormat["Local12"] = 2] = "Local12";
})(DateDisplayFormat || (DateDisplayFormat = {}));
/**
 * Displays date in DD MMM YY format.
 */
class DateDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.timeSeconds = typeof this.props.time === 'object'
            ? (this.timeSub = this.props.time.map(DateDisplay.SECOND_PRECISION_MAP))
            : Subject.create(DateDisplay.SECOND_PRECISION_MAP(this.props.time));
        this.localOffset = typeof this.props.localOffset === 'object'
            ? this.props.localOffset
            : Subject.create(this.props.localOffset);
        this.date = new Date();
        this.dateText = Subject.create('');
        this.monthText = Subject.create('');
        this.yearText = Subject.create('');
        this.updateHandler = this.updateDisplayedTime.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.localOffsetSub = this.localOffset.sub(this.updateHandler);
        this.timeSeconds.sub(this.updateHandler, true);
    }
    /**
     * Updates the displayed time.
     */
    updateDisplayedTime() {
        const utcTime = this.timeSeconds.get();
        if (isNaN(utcTime)) {
            this.dateText.set('__');
            this.monthText.set('___');
            this.yearText.set('__');
        }
        else {
            const displayTime = utcTime + this.localOffset.get();
            this.date.setTime(displayTime);
            this.dateText.set(this.date.getUTCDate().toString());
            this.monthText.set(` ${DateDisplay.MONTH_NAMES[this.date.getUTCMonth()]} `);
            this.yearText.set(this.date.getUTCFullYear().toString().substring(2, 4));
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : 'date-display' },
            FSComponent.buildComponent("span", { class: 'time-month' },this.monthText),
            FSComponent.buildComponent("span", { class: 'time-date' }, this.dateText),
            FSComponent.buildComponent("Divider", { class: 'time-Divider' }, "/"),
            FSComponent.buildComponent("span", { class: 'time-year' }, this.yearText)));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.timeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.formatSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.localOffsetSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}
DateDisplay.SECOND_PRECISION_MAP = SubscribableMapFunctions.withPrecision(1000);
DateDisplay.MONTH_NAMES = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];

/** Time display formats. */
var TimeDisplayFormat;
(function (TimeDisplayFormat) {
    /** UTC time. */
    TimeDisplayFormat[TimeDisplayFormat["UTC"] = 0] = "UTC";
    /** Local time in 24-hour format. */
    TimeDisplayFormat[TimeDisplayFormat["Local24"] = 1] = "Local24";
    /** Local time in 12-hour format. */
    TimeDisplayFormat[TimeDisplayFormat["Local12"] = 2] = "Local12";
})(TimeDisplayFormat || (TimeDisplayFormat = {}));
/** Displays time in HH:MM:SS format. */
class TimeDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.date = new Date();
        this.hourText = Subject.create('');
        this.minText = Subject.create('');
        this.secText = Subject.create('');
        this.suffixText = Subject.create('');
    }
    /** @inheritdoc */
    onAfterRender() {
        this.formatSub = this.props.format.sub(this.updateDisplayedTime.bind(this), true);
        this.localOffsetSub = this.props.localOffset.sub(this.updateDisplayedTime.bind(this), true);
        this.timeSub = this.props.time.sub(this.updateDisplayedTime.bind(this), true);
    }
    /**
     * Updates the displayed time.
     */
    updateDisplayedTime() {
        const utcTime = this.props.time.get();
        const format = this.props.format.get();
        const localOffset = this.props.localOffset.get();
        let isAm = true;
        if (isNaN(utcTime)) {
            this.hourText.set('__');
            this.minText.set('__');
            this.secText.set('__');
        }
        else {
            const offset = format === TimeDisplayFormat.UTC ? 0 : localOffset;
            const displayTime = utcTime + offset;
            this.date.setTime(displayTime);
            const hour = this.date.getUTCHours();
            isAm = hour < 12;
            const displayHour = format === TimeDisplayFormat.Local12
                ? 12 - (12 - (hour % 12)) % 12 // Need to display hours 0 and 12 as '12'
                : hour % 24;
            this.hourText.set(displayHour.toString().padStart(2, '0'));
            this.minText.set(this.date.getUTCMinutes().toString().padStart(2, '0'));
            this.secText.set(this.date.getUTCSeconds().toString().padStart(2, '0'));
        }
        this.suffixText.set(this.getSuffix(format, isAm));
    }
    /**
     * Gets the suffix to append to the time display.
     * @param format The format of the time display.
     * @param isAm Whether or not the current time is AM or PM.
     * @returns The time display suffix.
     */
    getSuffix(format, isAm) {
        if (format === TimeDisplayFormat.UTC) {
            return 'Z';
        }
        else if (format === TimeDisplayFormat.Local24) {
            return 'LCL';
        }
        else {
            return isAm ? 'AM' : 'PM';
        }
    }
    /** @inheritdoc */
    render() {
        if (this.props.AltFormat) {
        return (FSComponent.buildComponent("div", { style: 'white-space: nowrap;' },
            FSComponent.buildComponent("span", { class: 'time-hour' }, this.hourText),
            FSComponent.buildComponent("span", { class: 'time-min' },
                ":",
                this.minText),
            FSComponent.buildComponent("span", { class: 'time-sec' },
                ":",
                this.secText),
            FSComponent.buildComponent("span", { class: 'time-suffix' }, this.suffixText)));
        }
        else
        {
            return (FSComponent.buildComponent("div", { style: 'white-space: nowrap;' },
            FSComponent.buildComponent("span", { class: 'time-hour' }, this.hourText),
            FSComponent.buildComponent("span", { class: 'time-min' },
                ":",
                this.minText),
            
            FSComponent.buildComponent("span", { class: 'time-suffix' }, this.suffixText)));


         }
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.timeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.formatSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.localOffsetSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}

class BoeingEfbTextField extends DisplayComponent {
    /**
     * The constructor of the BoringEfbTextFields
     * @param props The props of the BoringEfbTextFields.
     */
    constructor(props) {
        super(props);
        this.root = FSComponent.createRef();
        this.textUnderTextFieldRef = FSComponent.createRef();
        this.textFieldState = Subject.create(TextFieldState.Inactive);
        this.bottomText = Subject.create('');
        this.theEntireButtonRef = FSComponent.createRef();
        this.buttonNameRef = FSComponent.createRef();
        this.buttonText = [];
        this.textBox = FSComponent.createRef();
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable(this.props.isDisabled, true);
        this.unitForTextField = SubscribableUtils.toSubscribable(this.props.unitForTextField, true);
        this.hasGreenOutline = SubscribableUtils.toSubscribable(this.props.hasGreenOutline, true);

        this.inputId = this.genGuid();
        this.setValueFromOS = (text) => {
            this.textBox.instance.value = text.toUpperCase();
            this.onTextTyped();
            this.textBox.instance.blur();
            Coherent.off('SetInputTextFromOS', this.setValueFromOS);
        };
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /**
     * Types a text value into the field
     * @param value the string
     */
    async typeValue(value) {
        if (value !== null) {
        this.textBox.instance.value = value;
        this.textBox.instance.blur();
        this.textFieldState.set(TextFieldState.Inactive);
        const parsed = await this.props.validator.parse(this.textBox.instance.value);
        if (parsed !== null) {
            this.textFieldState.set(TextFieldState.Valid);
            this.props.onValueChanged(parsed);
        }
        await this.onTextTyped();
        //Add the unit back onto the textbox after all the parsing has been done.
        //do nothing since the textbox is empty
        if (this.textBox.instance.value !== '' && this.props.unitForTextField !== undefined) {
            this.textBox.instance.value = value + ' ' + this.unitForTextField.get();
        }
        
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => this.props.onClick && this.props.onClick());
        }
        if (!this.props.hasBottomText) {
            this.textUnderTextFieldRef.instance.classList.add('hidden');
        }
        this.textBox.instance.onkeyup = (e) => this.onKeyboardEvent(e);
        this.textBox.instance.onfocus = (e) => this.onKeyboardFocus(e);
        this.textBox.instance.onblur = async (e) => await this.onKeyboardBlur(e);
        this.textFieldState.sub((style) => {
            let borderStyle;
            switch (style) {
                case TextFieldState.Inactive:
                    borderStyle = '3px solid var(--boeing-colors-white)';
                    break;
                case TextFieldState.Typing:
                    borderStyle = '3px solid var(--boeing-colors-magenta)';
                    break;
                case TextFieldState.Valid:
                    borderStyle = '3px solid var(--boeing-colors-white)';
                    break;
            }
            this.root.instance.style.border = borderStyle;
        });
        if (this.props.isNameOnLeftSide) {
            this.buttonNameRef.instance.classList.add('textfield-button-name-left');
        }
        else {
            this.buttonNameRef.instance.classList.add('textfield-button-name-right');
        }
        if (this.props.valueOnStartUp !== undefined) {
            this.bottomText.set('' + this.props.valueOnStartUp.get());
        }
        if (this.props.valueOnStartUp) {
            this.props.valueOnStartUp.sub(this.onTextTyped.bind(this), true);
        }
    }
    /**
     * Generates a unique id.
     * @returns A unique ID string.
     */
    genGuid() {
        return 'INPT-xxxyxxyy'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * An event fired when keyboard focus receives a key event.
     * @param e The keyboard event.
     */
    onKeyboardEvent(e) {
        var _a;
        // Validate entered text. Accept 0-9, /, +, -, ., backspace, and t if allowed to
        if (!((_a = this.props.onlyNumberEntry) !== null && _a !== void 0 ? _a : false) || (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_9) ||
            (e.keyCode === KeyCode.KEY_SLASH || e.keyCode === KeyCode.KEY_DIVIDE) ||
            (e.keyCode >= KeyCode.KEY_NUMPAD0 && e.keyCode <= KeyCode.KEY_NUMPAD9) ||
            (e.keyCode === KeyCode.KEY_PERIOD || e.keyCode === KeyCode.KEY_DECIMAL) ||
            (e.keyCode === KeyCode.KEY_BACK_SPACE) || e.keyCode === KeyCode.KEY_SUBTRACT ||
            e.keyCode === 187 || e.keyCode === 189) {
            this.onTextTyped();
        }
        else if (this.props.allowTforWind && e.keyCode === KeyCode.KEY_T) {
            // this is if the text box is allowed T to be typed
            this.onTextTyped();
        }
        else {
            //If the wrong key is entered to keydoes not show up for the calc
            this.textBox.instance.value = this.textBox.instance.value.slice(0, -1);
        }
        e.preventDefault();
    }
    /**
     * An event triggered when keyboard focus is entered.
     * @param e The event that was triggered.
     */
    onKeyboardFocus(e) {
        e.preventDefault();
        this.textBox.instance.value = '';
        this.textBox.instance.focus({ preventScroll: true });
        this.textFieldState.set(TextFieldState.Typing);
        Coherent.on('SetInputTextFromOS', this.setValueFromOS);
        Coherent.trigger('FOCUS_INPUT_FIELD', this.inputId, '', '', '', false);
        Coherent.on('mousePressOutsideView', () => {
            this.textBox.instance.blur();
        });
    }
    /**
     * An event triggered when keyboard focus is exited.
     * @param e The event that was triggered.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onKeyboardBlur(e) {
        var _a;
        e.preventDefault();
        this.textFieldState.set(TextFieldState.Inactive);
        Coherent.off('SetInputTextFromOS', this.setValueFromOS);
        Coherent.trigger('UNFOCUS_INPUT_FIELD', '');
        Coherent.off('mousePressOutsideView');
        const parsed = await this.props.validator.parse(this.textBox.instance.value);
        if (parsed !== null) {
            this.textFieldState.set(TextFieldState.Valid);
            this.props.onValueChanged(parsed);
        }
        this.calculateBottomText(parsed);
        //Add the unit back onto the textbox after all the parsing has been done.
        //do nothing since the textbox is empty
        if (this.textBox.instance.value !== '' && this.props.unitForTextField !== undefined) {
            let valueText;
            if (this.props.textFieldFormatter) {
                
                if (parsed === null) {
                    valueText = ((_a = this.props.textFieldFormatter.nullValueString) !== null && _a !== void 0 ? _a : '');
                }
                else {
                    valueText = this.props.textFieldFormatter.format(parsed);
                }
            }
            else {
                valueText = this.textBox.instance.value;
            }
            this.textBox.instance.value = `${valueText} ${this.unitForTextField.get()}`;
        }
    }
    /**
     * This is the logic that will fill out the text field when the user goes to the next one
     * it adds in the units of the textfield
     * @param parsedValue The Parsed value.
     */
    calculateBottomText(parsedValue) {
        var _a;
        if (parsedValue === null) {
            this.bottomText.set('');
            return;
        }
        
        const formatted = (parsedValue === undefined) ? ((_a = this.props.bottomTextFormatter.nullValueString) !== null && _a !== void 0 ? _a : '') : this.props.bottomTextFormatter.format(parsedValue);
        this.bottomText.set(formatted);
    }
    /**
     * This is the logic of what shows below the text when entering input from the textfield
     * Text starts blank if not numbers are entered
     * will also become blank if '/' does not have anything after it
     */
    async onTextTyped() {
        this.textBox.instance.value = this.textBox.instance.value.toUpperCase();
        const parsed = await this.props.validator.parse(this.textBox.instance.value);
        this.calculateBottomText(parsed);
    }
    /**
     * Sets the text field to inactive to give the white boarder back
     */
    setTextFieldToInactive() {
        
        
        this.textFieldState.set(TextFieldState.Inactive);
    }
    /** @inheritDoc */
    render() {
        var _a;
      
       
      
        
        return (FSComponent.buildComponent("div", { class: 'boeing-efb-top-textfield', ref: this.theEntireButtonRef },
            FSComponent.buildComponent("div", { ref: this.buttonNameRef, class: 'button-name' }, this.props.buttonName),
            FSComponent.buildComponent("span", { ref: this.root, style:Object.assign({},  {
                outline: this.hasGreenOutline.map(x => x === true ? '3px solid var(--b78x-efb-green)' : 'none'),
                width: this.props.width ? `${this.props.width}px` : undefined, 
                height: this.props.height ? `${this.props.height}px` : undefined
            }), 
            class: Object.assign({ 'boeing-efb-textfield-button': true, 'boeing-efb-textfield-button-selected': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-efb-textfield-button-disabled': this.isDisabled.map(x => x === true), 'boeing-efb-textfield-button-alerted': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                    previous[current] = true;
                    return previous;
                }, {}))) },
                FSComponent.buildComponent("input", { class: 'boeing-efb-text-field-keyboard-input', ref: this.textBox })),
            FSComponent.buildComponent("div", { class: 'text-under-text-field', ref: this.textUnderTextFieldRef }, this.bottomText)));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}

/**
 * B787 EFB parsers and formatters
 */
class EfbFormatters {
}
EfbFormatters.RunwayFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        return value.designation;
    },
};
EfbFormatters.NumberParser = {
    /** @inheritDoc */
    parse(input) {
        const number = parseFloat(input);
        return Number.isFinite(number) ? number : null;
    },
};
EfbFormatters.TowParser = {
    /**
     * For the takeoff weight, an empty input field shall reset the takeoff weight to 0:
     * @param input New string to parse
     * @returns the obtained weight or 0 if the string is empty.
     */
    parse(input) {
        let result = 0;
        if (input.length > 0) {
            result = parseFloat(input);
        }
        return Number.isFinite(result) ? result : null;
    },
};
EfbFormatters.RawFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        return value.toString();
    },
};
EfbFormatters.NumberFormatter = (decimalPlaces) => ({
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        return value.toFixed(decimalPlaces);
    },
});
EfbFormatters.FahrenheitTemperatureFormatter = {
    nullValueString: '(?? F)',
    /** @inheritDoc */
    format(value) {
        const fahrenheit = UnitType.FAHRENHEIT.convertFrom(value, UnitType.CELSIUS);
        return `(${fahrenheit.toFixed(0)} F)`;
    },
};
EfbFormatters.PressureParser = {
    /** @inheritDoc */
    parse(input) {
        const number = parseFloat(input);
        if (!Number.isFinite(number)) {
            return null;
        }
        if (number >= 2800 && number <= 3100) {
            return number / 100;
        }
        else if ((number >= 28 && number <= 31) || (number >= 925.6 && number <= 1050)) {
            return number;
        }
        else {
            return null;
        }
    },
};
EfbFormatters.StopWatchParse = {
    /** @inheritDoc */
    parse(input) {
        const number = parseFloat(input);
        if (!Number.isFinite(number)) {
            return null;
        }
        if (number >= 0 && number <= 60) {
            return number;
        }
        else {
            return null;
        }
    },
};

EfbFormatters.FieldPressureFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        if (value > 925.5 && value < 1050) {
            return value.toFixed(1);
        }
        if (value >= 28 && value <= 31) {
            return value.toFixed(2);
        }
        return '';
    },
};
EfbFormatters.BottomTextPressureFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        //if the value is higher (HPa) then bottom text will be in IN HG
        if (value > 925.5 && value < 1050) {
            const inHg = UnitType.IN_HG.convertFrom(value, UnitType.HPA);
            return `(${inHg.toFixed(2)} IN HG)`;
        }
        //If the value is lower (IN) Then bottom text will show HPa
        if (value >= 28 && value <= 31) {
            const hpa = UnitType.HPA.convertFrom(value, UnitType.IN_HG);
            return `(${hpa.toFixed(1)} HPa)`;
        }
        //if conditions not met then dont do anything
        return '';
    },
};
EfbFormatters.TimerStopWatch = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        
        if (value > 0 && value < 60) {
          
            return `(${value.toFixed(2)} )`;
        }
        
        
        
        return '';
    },
};
EfbFormatters.EngineAntiIceSettingFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        switch (value) {
            case EFBAntiIceSetting.OFF: return 'OFF';
            case EFBAntiIceSetting.ENGINE: return 'ENGINE';
            case EFBAntiIceSetting.ENGINE_AUTO: return 'ENGINE AUTO';
            case EFBAntiIceSetting.EXIT: return 'EXIT';
        }
    },
};
EfbFormatters.WindParser = {
    /** @inheritDoc */
    parse(input) {
        if (input.includes('/')) {
            const split = input.split('/', 2);
            const direction = split[0];
            let speed = parseInt(split[1]);
            // first number has to be in range (0 -> 360)
            if (!Number.isFinite(Number(direction) || Number(direction) > 360)) {
                return null;
            }
            if (!Number.isFinite(speed)) {
                speed = 0;
            }
            if (Number(speed) > 400) {
                return null;
            }
            return { direction: Number(direction), trueDegrees: false, speed };
        }
        else {
            //fill direction with 0 for now since we use runway later
            const direction = NaN;
            if (input.startsWith('T') || input.endsWith('T') || Number(input) < 0) {
                //if the input contains either T or - then we make the value negative
                //Take the T out if it has it then make it a number then absolute value is
                const speed = -Math.abs(Number(input.replace('T', '')));
                if (!Number.isFinite(speed)) {
                    return null;
                }
                return { direction, trueDegrees: false, speed };
            }
            else {
                const speed = Number(input);
                return { direction, trueDegrees: false, speed };
            }
        }
    }
};
EfbFormatters.WindFormatter = (takeoffRunwaySub) => ({
    nullValueString: '(???/??) KT',
    /** @inheritDoc */
    format: (value) => {
        const runway = takeoffRunwaySub.get();
        if (!runway || !Number.isFinite(value.speed)) {
            return '(???/??) KT';
        }
        const runwayCourseMagnetic = MagVar.trueToMagnetic(runway.course, runway.latitude, runway.longitude);
        const [headwind, crosswind] = BoeingAeroMath.calcRelativeWindComponents(runwayCourseMagnetic, value.speed, Number.isNaN(value.direction) ? runwayCourseMagnetic : value.direction);
        const headwindStr = `${Math.abs(headwind).toFixed(0)} ${headwind > 0 ? 'H' : 'T'}`;
        const crosswindStr = `${Math.abs(crosswind).toFixed(0)} XW`;
        return `(${headwindStr}/${crosswindStr}) KT`;
    },
});
EfbFormatters.AssumedTemperatureModeParser = {
    /** @inheritDoc */
    parse(input) {
        if (input.trim() === 'MAX') {
            return 0;
        }
        const parsed = parseInt(input);
        if (!Number.isFinite(parsed)) {
            return null;
        }
        return parsed;
    }
};

var TextFieldDataType;
(function (TextFieldDataType) {
    TextFieldDataType[TextFieldDataType["Oat"] = 0] = "Oat";
    TextFieldDataType[TextFieldDataType["Wind"] = 1] = "Wind";
    TextFieldDataType[TextFieldDataType["Qnh"] = 2] = "Qnh";
})(TextFieldDataType || (TextFieldDataType = {}));
var textAreaSetting;
(function (textAreaSetting) {
    textAreaSetting[textAreaSetting["Full"] = 0] = "Full";
    textAreaSetting[textAreaSetting["Atm"] = 1] = "Atm";
})(textAreaSetting || (textAreaSetting = {}));
/**
 * A Boeing EFB Performace Page.
 */


var EfbPages;

(function (EfbPages) {
    EfbPages[EfbPages["MainMenu"] = 0] = "MainMenu";
    EfbPages[EfbPages["Performance"] = 1] = "Performance";
    EfbPages[EfbPages["Doors"] = 2] = "Doors";
    EfbPages[EfbPages["PilotUtilities"] = 3] = "PilotUtilities";
    EfbPages[EfbPages["IdentPage"] = 4] = "IdentPage";
    EfbPages[EfbPages["EnrouteCharts"] = 5] = "EnrouteCharts";
    EfbPages[EfbPages["TerminalCharts"] = 6] = "TerminalCharts";
    EfbPages[EfbPages["CalculatorPage"] = 7] = "CalculatorPage";
    EfbPages[EfbPages["TimerPage"] = 8] = "TimerPage";
    EfbPages[EfbPages["ScratchpadPage"] = 9] = "ScratchpadPage";
    EfbPages[EfbPages["FuelWeightVolPage"] = 10] = "FuelWeightVolPage";
    EfbPages[EfbPages["FuelVolWeightPage"] = 11] = "FuelVolWeightPage";
    EfbPages[EfbPages["SpeedConversionPage"] = 12] = "SpeedConversionPage";
    EfbPages[EfbPages["LengthConversionPage"] = 13] = "LengthConversionPage";
    EfbPages[EfbPages["WeightConversionPage"] = 14] = "WeightConversionPage";
    EfbPages[EfbPages["TemperatureConversionPage"] = 15] = "TemperatureConversionPage";
    EfbPages[EfbPages["VolumeConversionPage"] = 16] = "VolumeConversionPage";
    EfbPages[EfbPages["TimeZoneConversionPage"] = 17] = "TimeZoneConversionPage";
    EfbPages[EfbPages["PerformanceARPTINFO"] = 18] = "PerformanceARPTINFO";
    EfbPages[EfbPages["PerformanceMEL"] = 19] = "PerformanceMEL";
   EfbPages[EfbPages["Video"] = 20] = "Video";
EfbPages[EfbPages["dataLOAD"] = 21] = "dataLOAD";
EfbPages[EfbPages["LandingPerformancePG"] = 22] = "LandingPerformancePG";

   


})(EfbPages || (EfbPages = {}));
/**
 * EFB MAIN MENU page
 */
class EfbMainMenuPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.flightButtonDisabled = Subject.create(false);
        this.PerformanceDisabled = Subject.create(false);
        this.DoorsDisabled = Subject.create(false);
        this.PilotUtlitiesDisabled = Subject.create(false);
        this.DataLoadDisabled = Subject.create(false);
        this.VideoDisabled = Subject.create(false);
        this.flightButtonText = Subject.create('INITIALIZE FLIGHT');
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        this.props.visible.sub((visible) => {
            this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
        }, true);
    }
    /**
     * Handles the INITIALIZE/CLOSE flight button
     * @private
     */
    async handleFlightButton() {
        this.flightButtonText.set('CLOSE FLIGHT');
        this.flightButtonDisabled.set(true);
        this.props.communicationsManager.requestFlightInitializationData().then((data) => {
            this.flightButtonDisabled.set(false);
          //  this.props.store.arptinfobuttondisabled.set(false);
            this.props.store.acceptFlightInitializationData(data,true);
            

        }).catch(() => {
            console.error('Flight initialization data request timed out');
            this.flightButtonDisabled.set(false);
            this.flightButtonText.set('INITIALIZE FLIGHT');
        });
    }
   
    async CloseFlight() {
        this.props.store.GreenOutlineHandler.notify();
       this.flightButtonDisabled.set(false);
       this.flightButtonText.set('INITIALIZE FLIGHT');
       this.props.store.acceptFlightInitializationData();
      
   
      
    }
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef, class: "efb-main-menu" },
            FSComponent.buildComponent("div", { class: 'efb-title-page' }, "MAIN MENU"),
            FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
            
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: true},
                    FSComponent.buildComponent("span", null, "TERMINAL CHARTS")),

                    FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: true },
                    FSComponent.buildComponent("span", null, "ENROUTE CHARTS")),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),

                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70,isDisabled: this.PilotUtlitiesDisabled, onClick: () => this.props.onPageSelect(EfbPages.PilotUtilities) },
                    FSComponent.buildComponent("span", null, "PILOT UTILITIES")),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, onClick: () => this.props.onPageSelect(EfbPages.IdentPage) },
                    FSComponent.buildComponent("span", null, "IDENT PAGE")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: true },
                    FSComponent.buildComponent("span", null, "SYSTEM PAGE"))),
            FSComponent.buildComponent("div", { class: "efb-main-menu-button-column efb-main-menu-button-column-right" },
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: true },
                    FSComponent.buildComponent("span", null, "DOCUMENTS")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: this.PerformanceDisabled, onClick: () => this.props.onPageSelect(EfbPages.Performance) },
                    FSComponent.buildComponent("span", null, "PERFORMANCE")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: this.DoorsDisabled, onClick: () => this.props.onPageSelect(EfbPages.Doors) },
                    FSComponent.buildComponent("span", null, "DOORS")),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70,isDisabled: this.VideoDisabled, onClick: () => this.props.onPageSelect(EfbPages.Video)},
                    FSComponent.buildComponent("span", null, "VIDEO")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: this.DataLoadDisabled,onClick: () => this.props.onPageSelect(EfbPages.dataLOAD) },
                    FSComponent.buildComponent("span", null, "DATA LOAD")),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                
                FSComponent.buildComponent(BoeingEfbSideButton, {
                    width: 300,
                    height: 70,
                    isDisabled: this.flightButtonDisabled,
                    onClick: () => {
                      if (this.flightButtonText.get() ==="INITIALIZE FLIGHT") {
                      
                        this.handleFlightButton()
                        this.PerformanceDisabled.set(true)
                        this.DoorsDisabled.set(true)
                        this.PilotUtlitiesDisabled.set(true)
                        this.DataLoadDisabled.set(true)
                        this.VideoDisabled.set(true)
                        setTimeout(() => {
                           
                        this.DoorsDisabled.set(false)
                        this.PilotUtlitiesDisabled.set(false)
                        this.DataLoadDisabled.set(false)
                        this.VideoDisabled.set(false)
                        }, 2560); 
                        setTimeout(() => {
                           
                            this.PerformanceDisabled.set(false)
                            }, 2760); 
                        
                        
                      } 
                      else if (this.flightButtonText.get() === "CLOSE FLIGHT") {
                       
                        this.CloseFlight()
                        
                      }
                     
                    }
                  },
                    FSComponent.buildComponent("span", null, this.flightButtonText)))));
    }
}
/**
 * EFB <-> FMC communications manager
 */
class BoeingEfbCommunicationManager {
    /**
     * Ctor
     * @param bus the event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.commSub = this.bus.getSubscriber();
        this.commPub = this.bus.getPublisher();
        this.setupEventListeners();
    }
    /**
     * Sets up the event listeners for communication
     */
    setupEventListeners() {
        this.commSub.on('fmc_send_flight_initialization_data').handle((data) => {
            if (this.flightInitializationDataRejectTimer) {
                clearTimeout(this.flightInitializationDataRejectTimer);
                this.flightInitializationDataRejectTimer = undefined;
            }
            if (this.flightInitializationDataResolveFn) {
                this.flightInitializationDataResolveFn(data);
                this.flightInitializationDataResolveFn = undefined;
            }
        });
    }
    /**
     * Requests flight initialization data for the FMC
     */
    async requestFlightInitializationData() {
        if (this.flightInitializationDataResolveFn) {
            throw new Error('Cannot request flight initialization data as a request is already pending');
        }
        return new Promise((resolve, reject) => {
            this.flightInitializationDataResolveFn = resolve;
            this.flightInitializationDataRejectTimer = setTimeout(() => {
                this.flightInitializationDataResolveFn = undefined;
                this.flightInitializationDataResolveFn = undefined;
                reject();
            }, 5000);
            this.commPub.pub('efb_request_flight_initialization_data', null, true);
        });
    }
    /**
     * Sends a takeoff data uplink to the FMC
     * @param data the takeoff data
     */
    async sendTakeoffDataUplinkToFmc(data) {
        this.commPub.pub('efb_send_takeoff_data', data, true);
    }
}

/**
 * FMS positioning system data modes.
 */
var FmsPositionMode;
(function (FmsPositionMode) {
    /** No position data is available. */
    FmsPositionMode["None"] = "None";
    /** Position data is sourced from GPS. */
    FmsPositionMode["Gps"] = "Gps";
    /** Position data is sourced from DME/DME. */
    FmsPositionMode["Dme"] = "Dme";
    /** Position data is sourced from HNS (hybrid inertial navigation). */
    FmsPositionMode["Hns"] = "Hns";
    /** Position data is sourced from dead reckoning. */
    FmsPositionMode["DeadReckoning"] = "DeadReckoning";
    /** Position data is sourced from dead reckoning and more than 20 minutes have elapsed since the last accurate position fix. */
    FmsPositionMode["DeadReckoningExpired"] = "DeadReckoningExpired";
})(FmsPositionMode || (FmsPositionMode = {}));
/**
 * A Boeing FMS geo-positioning system.
 */
class FmsPositionSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an FMS geo-positioning system.
     * @param index The index of the FMS geo-positioning system.
     * @param bus An instance of the event bus.
     * @param gpsReceiverIndex The index of the GPS receiver used by this system. No GPS data will be used if the index
     * is negative.
     * @param adcIndex The index of the ADC used by this system in dead reckoning mode to obtain airspeed data.
     * @param ahrsIndex The index of the AHRS used by this system in dead reckoning mode to obtain heading data.
     * @param hnsIndex The index of the HNS used by this system. No HNS data will be used if the index is negative.
     * Defaults to `-1`.
     * @param dmeIndex The index of the DME/DME navigation system used by this system. No DME/DME data will be used if
     * the index is negative. Defaults to `-1`.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsReceiverIndex, adcIndex, ahrsIndex, hnsIndex, dmeIndex, powerSource) {
        super(index, bus, `fms_pos_state_${index}`);
        this.initializationTime = 0;
        this.gnssDataSourceTopicMap = {
            [`fms_pos_gps-position_${this.index}`]: 'gps-position',
            [`fms_pos_ground_speed_${this.index}`]: 'ground_speed',
            [`fms_pos_track_deg_true_${this.index}`]: 'track_deg_true',
            [`fms_pos_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.modeTopic = `fms_pos_mode_${this.index}`;
        this.gpsIndexTopic = `fms_pos_gps_index_${this.index}`;
        this.hnsIndexTopic = `fms_pos_hns_index_${this.index}`;
        this.iruAnpTopic = `fms_pos_iru_anp_${this.index}`;
        this.gpsAnpTopic = `fms_pos_gps_anp_${this.index}`;
        this.radioAnpTopic = `fms_pos_radio_anp_${this.index}`;
        this.anpTopic = `fms_pos_anp_${this.index}`;
        this.verticalAnpTopic = `fms_pos_vertical_anp_${this.index}`;
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), 0);
        this.gpsStateSource = ConsumerSubject.create(null, GPSSystemState.Searching);
        this.gpsState = Subject.create(GPSSystemState.Searching);
        this.gpsPdop = ConsumerSubject.create(null, -1);
        this.gpsGroundSpeed = ConsumerSubject.create(null, -1);
        this.adcSystemState = ConsumerSubject.create(null, null);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.pitch = 0;
        /** filtered pitch rate in degrees per second */
        this.pitchRate = Subject.create(0);
        this.verticalAnp = MappedSubject.create(([zp, pitchRate]) => MathUtils.round(MathUtils.clamp(2.6 * zp ** 3 * Math.pow(10, -12) + 49, 49, 169) + 6 * Math.abs(pitchRate)), this.pressureAlt, this.pitchRate);
        this.mode = FmsPositionMode.None;
        this.lastFixTime = undefined;
        this.gpsIndex = SubscribableUtils.toSubscribable(gpsReceiverIndex, true);
        this.hnsIndex = SubscribableUtils.toSubscribable(-1, true);
        this.dmeIndex = SubscribableUtils.toSubscribable(-1, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        this.ahrsIndex = SubscribableUtils.toSubscribable(ahrsIndex, true);
        this.publisher.pub(this.modeTopic, this.mode, false, true);
        this.publisher.pub(this.iruAnpTopic, -1, false, true);
        this.publisher.pub(this.gpsAnpTopic, -1, false, true);
        this.publisher.pub(this.radioAnpTopic, -1, false, true);
        this.publisher.pub(this.anpTopic, -1, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.gnssDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onGnssTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.gnssDataSourceTopicMap) {
                this.onGnssTopicSubscribed(topic);
            }
        });
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.gpsIndex.sub(index => this.publisher.pub(this.gpsIndexTopic, index, false, true), !paused, paused));
        this.dataSubs.push(this.hnsIndex.sub(index => this.publisher.pub(this.hnsIndexTopic, index, false, true), !paused, paused));
        const gpsStatePipe = this.gpsStateSource.pipe(this.gpsState, true);
        this.gpsIndex.sub(index => {
            if (index < 0) {
                this.gpsStateSource.setConsumer(null);
                gpsStatePipe.pause();
                this.gpsState.set(GPSSystemState.Searching);
            }
            else {
                this.gpsStateSource.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_state_changed_${index}`));
                gpsStatePipe.resume(true);
            }
        }, true);
        this.dataSubs.push(this.gpsPdop.sub(this.updateAnp.bind(this), !paused, paused));
        this.verticalAnpSub = this.verticalAnp.sub((verAnp) => this.publisher.pub(this.verticalAnpTopic, verAnp, false, true));
        this.dataSubs.push(this.dataSourceSubscriber.on('actual_pitch_deg').atFrequency(5).handle((pitch) => {
            this.pitchRate.set(0.8 * this.pitchRate.get() + 0.2 * 5 * (pitch - this.pitch));
            this.pitch = pitch;
        }));
        this.adcSystemState.sub(this.updateAdcSystemState.bind(this));
        this.dataSubs.push(this.gpsIndex.sub((index) => this.gpsPdop.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_pdop_${index}`)), !paused, paused));
        this.gpsGroundSpeed.setConsumer(this.dataSourceSubscriber.on('ground_speed').withPrecision(0));
        this.dataSubs.push(this.adcIndex.sub((index) => this.pressureAlt.setConsumer(this.dataSourceSubscriber.on(`adc_pressure_alt_${index}`).withPrecision(-2)), !paused, paused));
        this.dataSubs.push(this.adcIndex.sub((index) => this.adcSystemState.setConsumer(this.dataSourceSubscriber.on(`adc_state_${index}`)), !paused, paused));
    }
    /**
     * Responds to when someone first subscribes to one of this system's GNSS-sourced data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onGnssTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.gnssDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.setMode(FmsPositionMode.None);
            this.lastFixTime = undefined;
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.updateMode();
        }
    }
    /**
     * Updates this system's data mode.
     */
    updateMode() {
        const gpsState = this.gpsState.get();
        if (gpsState === GPSSystemState.SolutionAcquired || gpsState === GPSSystemState.DiffSolutionAcquired) {
            this.setMode(FmsPositionMode.Gps);
            this.lastFixTime = this.simTime.get();
        }
        else if (this.lastFixTime !== undefined) {
            if (this.simTime.get() - this.lastFixTime > FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME) {
                this.setMode(FmsPositionMode.DeadReckoningExpired);
            }
            else {
                this.setMode(FmsPositionMode.DeadReckoning);
            }
        }
        else {
            this.setMode(FmsPositionMode.None);
        }
    }
    /**
     * Sets this system's data mode, and publishes the new value to the event bus if it differs from the current value.
     * @param mode The new data mode.
     */
    setMode(mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this.publisher.pub(this.modeTopic, this.mode, false, true);
    }
    /** Update the ANP from data sources */
    updateAnp() {
        // The Boeing ANP includes navigation system error (aka position uncertainty),
        // but excludes Flight Technical Error (this is shown on the EFIS as a function of ANP and RNP),
        // and excludes path computation error as this is assumed negligable
        // https://www.boeing.com/commercial/aeromagazine/aero_16/navigation_story.html
        const pdop = this.gpsPdop.get();
        if (pdop >= 0) {
            const anp = FmsPositionSystem.ANP(pdop);
            this.publisher.pub(this.gpsAnpTopic, anp, false, true);
            this.publisher.pub(this.anpTopic, anp, false, true);
        }
        else {
            this.publisher.pub(this.gpsAnpTopic, pdop, false, true);
            this.publisher.pub(this.anpTopic, pdop, false, true);
        }
        // TODO IRU and radio position
    }
    /**
     * Updates the ADC derived values when the ADC system state changes
     * @param state ADC system state event
     */
    updateAdcSystemState(state) {
        var _a, _b;
        if ((state === null || state === void 0 ? void 0 : state.current) === AvionicsSystemState.On) {
            (_a = this.verticalAnpSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        }
        else {
            (_b = this.verticalAnpSub) === null || _b === void 0 ? void 0 : _b.pause();
            this.publisher.pub(this.verticalAnpTopic, -1, false, true);
        }
    }
}
FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME = UnitType.MINUTE.convertTo(20, UnitType.MILLISECOND);
/** Calculates the ANP as the circle radius where the airplane position is estimated to be within 95% of the time.
 * Uses the statistic formula of estimating a 95% confidence interval with a (hypothetical) sample size of 1.
 * @param pdop The geometric dilution of precision computation (GDOP).
 * @returns The estimated ANP.
 */
FmsPositionSystem.ANP = (pdop) => {
    /** In meters. Used for calculating the ANP. Sets at 222 under the assumption that airplane cruises at 800 km/h,
     * hence if gps position is updated every second, the deviation would be 222 m/s.
     * Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR = 222;
    /** In meters. Used for calculating the ANP. Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const ESTIMATED_NUMERICAL_ERROR = 200;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL = 1.96;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const HYPOTHETICAL_SAMPLE_SIZE = 1;
    const STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS = () => {
        return Math.sqrt((pdop * STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR) ^ 2 + ESTIMATED_NUMERICAL_ERROR ^ 2);
    };
    const anpMeter = Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL * STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS() / Math.sqrt(HYPOTHETICAL_SAMPLE_SIZE);
    return MathUtils.round(UnitType.NMILE.convertFrom(anpMeter, UnitType.METER), 0.01);
};

/**
 * A Boeing ADC system.
 */
class AdcSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an ADC system.
     * @param index The index of the ADC.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this ADC derives its data.
     * @param altimeterIndex The index of the sim altimeter from which this ADC derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, airspeedIndicatorIndex, altimeterIndex, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.airspeedIndicatorIndex = airspeedIndicatorIndex;
        this.altimeterIndex = altimeterIndex;
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_ias_${this.index}`]: `ias_${this.airspeedIndicatorIndex}`,
            [`adc_tas_${this.index}`]: `tas_${this.airspeedIndicatorIndex}`,
            [`adc_mach_to_kias_factor_${this.index}`]: `mach_to_kias_factor_${this.airspeedIndicatorIndex}`,
            [`adc_indicated_alt_${this.index}`]: `indicated_alt_${this.altimeterIndex}`,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: `altimeter_baro_setting_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: `altimeter_baro_preselect_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: `altimeter_baro_preselect_mb_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: `altimeter_baro_preselect_raw_${this.altimeterIndex}`,
            [`adc_altimeter_baro_is_std_${this.index}`]: `altimeter_baro_is_std_${this.altimeterIndex}`,
            [`adc_mach_number_${this.index}`]: 'mach_number',
            [`adc_pressure_alt_${this.index}`]: 'pressure_alt',
            [`adc_vertical_speed_${this.index}`]: 'vertical_speed',
            [`adc_ambient_density_${this.index}`]: 'ambient_density',
            [`adc_ambient_temp_c_${this.index}`]: 'ambient_temp_c',
            [`adc_ambient_pressure_inhg_${this.index}`]: 'ambient_pressure_inhg',
            [`adc_isa_temp_c_${this.index}`]: 'isa_temp_c',
            [`adc_ram_air_temp_c_${this.index}`]: 'ram_air_temp_c'
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, true, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing ADC data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.dataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.speedDataValidTopic, true, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.speedDataValidTopic, false, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, false, false, true);
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best ADC from a set of candidates based on the current states of all systems. System state
 * desiribility depends on whether it is providing valid airspeed and altitude data.
 */
class AdcSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the ADC systems from which to select.
     * @param systemPriorities The priorities for selecting individual ADC systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of ADC system indexes or a map of
     * ADC system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     * @param dataBias Whether to bias system desirability toward valid airspeed data, valid altitude data, or neither.
     * Defaults to `'none'`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities, dataBias) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isSpeedDataValid = Subject.create(false);
        this.isAltitudeDataValid = Subject.create(false);
        this.adcEntries = new Map();
        this.adcOrder = [];
        this.adcComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        switch (dataBias) {
            case 'airspeed':
                this.adcStateComparator = (a, b) => (Number(b[0]) * 1.5 + Number(b[1])) - (Number(a[0]) * 1.5 + Number(a[1]));
                break;
            case 'airspeed-only':
                this.adcStateComparator = (a, b) => Number(b[0]) - Number(a[0]);
                break;
            case 'altitude':
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1]) * 1.5) - (Number(a[0]) + Number(a[1]) * 1.5);
                break;
            case 'altitude-only':
                this.adcStateComparator = (a, b) => Number(b[1]) - Number(a[1]);
                break;
            default:
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1])) - (Number(a[0]) + Number(a[1]));
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `adc_selector_selected_index_${index}`), true);
        this.isSpeedDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_speed_data_valid_${index}`), true);
        this.isAltitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_altitude_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best ADC among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('AdcSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.adcEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`adc_speed_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`adc_altitude_data_valid_${key}`), false),
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.adcEntries.set(key, entry);
                // When there is a change in an ADC state, we don't reselect immediately because the ADC could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.adcEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the ADC with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.adcEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.adcEntries.size === 1) {
            const entry = this.adcEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.adcOrder.length = 0;
            for (const index of this.adcEntries.keys()) {
                this.adcOrder.push(index);
            }
            this.adcOrder.sort(this.adcComparator);
            bestIndex = -1;
            for (let i = 0; i < this.adcOrder.length; i++) {
                const index = this.adcOrder[i];
                const state = this.adcEntries.get(index).state.get();
                if (!bestState || this.adcStateComparator(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isSpeedDataValid.set(bestState[0]);
            this.isAltitudeDataValid.set(bestState[1]);
        }
        else {
            this.isSpeedDataValid.set(false);
            this.isAltitudeDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.adcEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}

/**
 * A Boeing angle of attack computer system.
 */
class AoaSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an angle of attack computer system.
     * @param index The index of the AoA computer.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `aoa_state_${index}`);
        this.initializationTime = 15000;
        this.simVarPublisher = new SimVarPublisher(new Map([
            [`aoa_load_factor_${this.index}`, { name: 'SEMIBODY LOADFACTOR Y', type: SimVarValueType.Number }]
        ]), this.bus);
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.isAoaSubbed = false;
        this.isStallAoaSubbed = false;
        this.isZeroLiftAoaSubbed = false;
        this.normAoaTopic = `aoa_norm_aoa_${this.index}`;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing angle of attack data on the event bus.
     */
    startDataPublish() {
        const topics = [
            `aoa_aoa_${this.index}`,
            `aoa_stall_aoa_${this.index}`,
            `aoa_zero_lift_aoa_${this.index}`,
            `aoa_norm_aoa_${this.index}`
        ];
        for (const topic of topics) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topics.includes(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
        this.simVarPublisher.startPublish();
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        let shouldSubAoa = false;
        let shouldSubStallAoa = false;
        let shouldSubZeroLiftAoa = false;
        switch (topic) {
            case `aoa_aoa_${this.index}`:
                shouldSubAoa = true;
                break;
            case `aoa_stall_aoa_${this.index}`:
                shouldSubStallAoa = true;
                break;
            case `aoa_zero_lift_aoa_${this.index}`:
                shouldSubZeroLiftAoa = true;
                break;
            case `aoa_norm_aoa_${this.index}`:
                shouldSubAoa = true;
                shouldSubStallAoa = true;
                shouldSubZeroLiftAoa = true;
                break;
        }
        if (shouldSubAoa && !this.isAoaSubbed) {
            this.isAoaSubbed = true;
            const pubTopic = `aoa_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('aoa').handle(val => {
                this.aoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubStallAoa && !this.isStallAoaSubbed) {
            this.isStallAoaSubbed = true;
            const pubTopic = `aoa_stall_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('stall_aoa').handle(val => {
                this.stallAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubZeroLiftAoa && !this.isZeroLiftAoaSubbed) {
            this.isZeroLiftAoaSubbed = true;
            const pubTopic = `aoa_zero_lift_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('zero_lift_aoa').handle(val => {
                this.zeroLiftAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.Failed
            || this._state === AvionicsSystemState.Off
            || this.aoa === undefined
            || this.stallAoa === undefined
            || this.zeroLiftAoa === undefined) {
            return;
        }
        this.publisher.pub(this.normAoaTopic, (this.aoa - this.zeroLiftAoa) / (this.stallAoa - this.zeroLiftAoa), false, true);
        this.simVarPublisher.onUpdate();
    }
}

/**
 * A publisher that publishes Boeing Game Units events.
 */
class BoeingGameUnitsPublisher extends GameVarPublisher {
    /**
     * Creates an instance of the BoeingGameUnitsPublisher.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        super(BoeingGameUnitsPublisher.gamevars, bus);
    }
}
BoeingGameUnitsPublisher.gamevars = new Map([
    ['game_units_metric', { name: 'GAME UNIT IS METRIC', type: SimVarValueType.Bool }],
]);

/**
 * Automatically selects the best GPS receiver from a set of candidates based on the current states of all receivers.
 * Receivers that have computed a 3D position solution with differential corrections are favored over those that have
 * computed a 3D solution without corrections, and either of these are favored over those that have not computed any
 * position solution.
 */
class GpsReceiverSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param enabledReceiverIndexes The indexes of the GPS receivers from which to select.
     * @param preferredReceiverIndex The index of this selector's preferred GPS receiver, or `-1` if there is no such
     * receiver. This selector is guaranteed to select the preferred GPS receiver if its state is at least as desirable
     * as the state of all other receivers from which to select. Defaults to `-1`.
     */
    constructor(bus, enabledReceiverIndexes, preferredReceiverIndex) {
        this.bus = bus;
        this._selectedIndex = Subject.create(-1);
        this.selectedIndex = this._selectedIndex;
        this.gpsStates = new Map();
        this.isAlive = true;
        this.isInit = false;
        this.enabledReceiverIndexes = 'isSubscribableSet' in enabledReceiverIndexes ? enabledReceiverIndexes : SetSubject.create(enabledReceiverIndexes);
        this.preferredReceiverIndex = SubscribableUtils.toSubscribable(preferredReceiverIndex !== null && preferredReceiverIndex !== void 0 ? preferredReceiverIndex : -1, true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best GPS receiver among
     * its candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('GpsReceiverSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const selectIndex = this.selectIndex.bind(this);
        this.enabledReceiverIndexesSub = this.enabledReceiverIndexes.sub((set, type, key) => {
            var _a;
            (_a = this.gpsStates.get(key)) === null || _a === void 0 ? void 0 : _a.destroy();
            if (type === SubscribableSetEventType.Added) {
                const gpsState = ConsumerSubject.create(sub.on(`gps_rec_gps_system_state_changed_${key}`), GPSSystemState.Acquiring);
                this.gpsStates.set(key, gpsState);
                gpsState.sub(selectIndex);
            }
            else {
                this.gpsStates.delete(key);
            }
            selectIndex();
        }, true);
        this.preferredReceiverIndexSub = this.preferredReceiverIndex.sub(selectIndex);
    }
    /**
     * Selects the index of the GPS receiver with the most desirable state.
     */
    selectIndex() {
        var _a, _b;
        if (this.gpsStates.size === 0) {
            this._selectedIndex.set(-1);
            return;
        }
        if (this.gpsStates.size === 1) {
            this._selectedIndex.set(this.gpsStates.keys().next().value);
            return;
        }
        let bestIndex = this._selectedIndex.get();
        let bestState = (_a = this.gpsStates.get(bestIndex)) === null || _a === void 0 ? void 0 : _a.get();
        for (const index of this.gpsStates.keys()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const state = this.gpsStates.get(index).get();
            if (bestIndex < 0 || !bestState || GpsReceiverSelector.compareGpsState(state, bestState) < 0) {
                bestIndex = index;
                bestState = state;
            }
        }
        const preferredIndex = this.preferredReceiverIndex.get();
        if (preferredIndex >= 0) {
            const preferredIndexState = (_b = this.gpsStates.get(preferredIndex)) === null || _b === void 0 ? void 0 : _b.get();
            if (preferredIndexState !== undefined && GpsReceiverSelector.compareGpsState(preferredIndexState, bestState) <= 0) {
                bestIndex = preferredIndex;
            }
        }
        this._selectedIndex.set(bestIndex);
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        for (const state of this.gpsStates.values()) {
            state.destroy();
        }
        (_a = this.enabledReceiverIndexesSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.preferredReceiverIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
    /**
     * Compares two GPS system states and returns a number whose sign indicates which one is more desirable.
     * @param a The first GPS system state to compare.
     * @param b The second GPS system state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareGpsState(a, b) {
        return GpsReceiverSelector.GPS_STATE_PRIORITIES[a] - GpsReceiverSelector.GPS_STATE_PRIORITIES[b];
    }
}
GpsReceiverSelector.GPS_STATE_PRIORITIES = {
    [GPSSystemState.DiffSolutionAcquired]: 0,
    [GPSSystemState.SolutionAcquired]: 1,
    [GPSSystemState.Acquiring]: 2,
    [GPSSystemState.Searching]: 2
};

/**
 * A Garmin GPS receiver system.
 */
class GpsReceiverSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a GPS receiver system.
     * @param index The index of the GPS receiver.
     * @param bus An instance of the event bus.
     * @param gpsSatComputer This system's GPS computer system.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsSatComputer, powerSource) {
        super(index, bus, `gps_rec_state_${index}`);
        this.gpsSatComputer = gpsSatComputer;
        this.initializationTime = 0;
        this.cachedDataSourceTopicMap = {
            [`gps_rec_gps_system_state_changed_${this.index}`]: `gps_system_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_sbas_state_changed_${this.index}`]: `gps_system_sbas_state_changed_${this.gpsSatComputer.index}`
        };
        this.uncachedDataSourceTopicMap = {
            [`gps_rec_gps_sat_state_changed_${this.index}`]: `gps_sat_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_sat_pos_calculated_${this.index}`]: `gps_sat_pos_calculated_${this.gpsSatComputer.index}`
        };
        this.dopDataSourceTopicMap = {
            [`gps_rec_gps_system_pdop_${this.index}`]: `gps_system_pdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_hdop_${this.index}`]: `gps_system_hdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_vdop_${this.index}`]: `gps_system_vdop_${this.gpsSatComputer.index}`
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.dopSources = [];
        this.sbasState = ConsumerSubject.create(null, GPSSystemSBASState.Disabled);
        gpsSatComputer.init();
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        else if (gpsSatComputer.syncRole !== 'replica') {
            // If our power source is undefined, then the system is always considered to be in the on state. Therefore we
            // will force the GPS to immediately acquire and use all the satellites it can since a system that is always on
            // never needs to initialize.
            gpsSatComputer.acquireAndUseSatellites();
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.cachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.cachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, true);
            }));
        }
        for (const topic of Object.keys(this.uncachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.uncachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, false);
            }));
        }
        // Garmin seems to halve DOP values when SBAS is active. It could be a trainer-specific behavior, but in the
        // absence of any other information, we will implement it here.
        this.sbasState.setConsumer(this.dataSourceSubscriber.on(`gps_system_sbas_state_changed_${this.gpsSatComputer.index}`));
        for (const topic of Object.keys(this.dopDataSourceTopicMap)) {
            const dopSource = ConsumerSubject.create(this.dataSourceSubscriber.on(this.dopDataSourceTopicMap[topic]), -1);
            this.dopSources.push(dopSource);
            const processedDop = MappedSubject.create(([dop, sbasState]) => dop <= 0 ? dop : dop * (sbasState === GPSSystemSBASState.Active ? 0.5 : 1), dopSource, this.sbasState);
            this.dataSubs.push(processedDop.sub(dop => {
                this.publisher.pub(topic, dop, false, false);
            }, true));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        // If this is the first time we are setting our state and the state is on, then we assume that the system was on at
        // flight load, in which case we will force the GPS to immediately acquire and use all the satellites it can so
        // that we don't force people to wait for satellite acquisition when loading onto the runway/in the air.
        if (previousState === undefined && currentState === AvionicsSystemState.On && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.acquireAndUseSatellites();
        }
        // Reset the GPS sat computer if the system is not operating and its receiver is not a replica (a replica receiver
        // will get the reset command from its primary).
        if ((currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.reset();
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.gpsSatComputer.onUpdate();
        }
    }
}

/**
 * IRS operating modes.
 */
var IrsSystemOperatingMode;
(function (IrsSystemOperatingMode) {
    /** The IRS is not operating. */
    IrsSystemOperatingMode["Off"] = "Off";
    /** The IRS is in Standby mode. No data are available. */
    IrsSystemOperatingMode["Standby"] = "Standby";
    /** The IRS is performing a full alignment. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlign"] = "FullAlign";
    /** The IRS has completed a full alignment but is awaiting a position input. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlignPositionPending"] = "FullAlignPositionPending";
    /** The IRS is in Navigation mode. All data are available. */
    IrsSystemOperatingMode["Navigation"] = "Navigation";
    /** The IRS is performing a realignment. All data are available. */
    IrsSystemOperatingMode["Realign"] = "Realign";
    /** The IRS is performing an attitude alignment. No data are available. */
    IrsSystemOperatingMode["AttitudeAlign"] = "AttitudeAlign";
    /** The IRS is in Attitude mode. Attitude and heading data are available. */
    IrsSystemOperatingMode["Attitude"] = "Attitude";
})(IrsSystemOperatingMode || (IrsSystemOperatingMode = {}));
/**
 * IRS system operating mode setting commands.
 */
var IrsSystemOperatingModeSetting;
(function (IrsSystemOperatingModeSetting) {
    /** Forces the IRS into Off mode. */
    IrsSystemOperatingModeSetting["Off"] = "Off";
    /** Commands Navigation mode. The IRS will perform a full alignment (if required), then enter Navigation mode. */
    IrsSystemOperatingModeSetting["Navigation"] = "Navigation";
    /**
     * Arms IRS realignment. If the IRS is in Navigation mode, then the next time Navigation mode is selected and the
     * airplane is on the ground and not moving, it will attempt an realignment.
     */
    IrsSystemOperatingModeSetting["Align"] = "Align";
    /** Commands Attitude mode. The IRS will perform an attitude alignment (if required), then enter Attitude mode. */
    IrsSystemOperatingModeSetting["Attitude"] = "Attitude";
})(IrsSystemOperatingModeSetting || (IrsSystemOperatingModeSetting = {}));
/**
 * A Boeing inertial reference system (IRS). Provides attitude, heading, and inertial (position, velocity,
 * acceleration) data.
 */
class IrsSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an IRS system.
     * @param index The index of the IRS.
     * @param bus An instance of the event bus.
     * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this IRS derives its data.
     * @param directionIndicatorIndex The index of the sim direction indicator from which this IRS derives its data.
     * @param supportInFlightAlign Whether this IRS supports full alignment while in flight. In-flight full alignment
     * requires position input from GPS receivers.
     * @param operatingModeSetting The operating mode setting commanded for this IRS.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     * @param gpsReceiverIndexes The indexes of the GPS receiver systems from which the IRS receives position input data.
     * If no indexes are supplied, then the IRS will not automatically initialize its position from GPS and will require
     * manual position input during alignment.
     * @param attitudeAlignDuration The duration, in milliseconds, required for this IRS to complete attitude alignment.
     * Defaults to 30000 milliseconds.
     * @param fullAlignDuration The duration, in milliseconds, required for this IRS to complete a full alignment. If not
     * defined, full alignment duration will be simulated based on the airplane's current latitude.
     * @param realignDuration The duration, in milliseconds, required for this IRS to complete realignment. Defaults to
     * 30000 milliseconds.
     */
    constructor(index, bus, attitudeIndicatorIndex, directionIndicatorIndex, supportInFlightAlign, operatingModeSetting, powerSource, gpsReceiverIndexes, attitudeAlignDuration, fullAlignDuration, realignDuration) {
        var _a;
        super(index, bus, `irs_state_${index}`);
        this.attitudeIndicatorIndex = attitudeIndicatorIndex;
        this.directionIndicatorIndex = directionIndicatorIndex;
        this.supportInFlightAlign = supportInFlightAlign;
        this.operatingModeSetting = operatingModeSetting;
        this.powerSource = powerSource;
        this.initializationTime = 0;
        this.simulatedFullAlignDuration = Subject.create(0);
        this.operatingModeTopic = `irs_operating_mode_${this.index}`;
        this.headingDataValidTopic = `irs_heading_data_valid_${this.index}`;
        this.attitudeDataValidTopic = `irs_attitude_data_valid_${this.index}`;
        this.inertialDataValidTopic = `irs_inertial_data_valid_${this.index}`;
        this.positionDataValidTopic = `irs_position_data_valid_${this.index}`;
        this.acceptingPositionTopic = `irs_is_accepting_position_${this.index}`;
        this.requestingPositionTopic = `irs_is_requesting_position_${this.index}`;
        this.fullAlignTimeTopic = `irs_full_align_time_remaining_${this.index}`;
        this.attitudeAlignTimeTopic = `irs_att_align_time_remaining_${this.index}`;
        this.operatingMode = IrsSystemOperatingMode.Navigation;
        this.isHeadingDataValid = true;
        this.isAttitudeDataValid = true;
        this.isInertialDataValid = true;
        this.isInertialHeadingDataValid = true;
        this.isPositionDataValid = true;
        this.isPositionInit = Subject.create(true);
        // When true, the next time isAcceptingPosition becomes true, isPositionInit will automatically be set to true
        this.autoPositionInit = false;
        this.isAcceptingPosition = Subject.create(false);
        this.isRealignArmed = false;
        this.attitudeAlignTime = 0;
        this.fullAlignTime = 0;
        this.realignTime = 0;
        this.publishedFullAlignTimeRemaining = undefined;
        this.publishedAttitudeAlignTimeRemaining = undefined;
        this.lastUpdateSimTime = undefined;
        this.simTime = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.speed = ConsumerValue.create(null, 0);
        this.position = ConsumerValue.create(null, new LatLongAlt(0, 0, 0));
        this.headingDataSourceTopicMap = {
            [`irs_hdg_deg_${this.index}`]: `hdg_deg_${this.directionIndicatorIndex}`,
            [`irs_hdg_deg_true_${this.index}`]: `hdg_deg_true_${this.directionIndicatorIndex}`
        };
        this.attitudeDataSourceTopicMap = {
            [`irs_delta_heading_rate_${this.index}`]: `delta_heading_rate_${this.attitudeIndicatorIndex}`,
            [`irs_pitch_deg_${this.index}`]: `pitch_deg_${this.attitudeIndicatorIndex}`,
            [`irs_roll_deg_${this.index}`]: `roll_deg_${this.attitudeIndicatorIndex}`,
            [`irs_turn_coordinator_ball_${this.index}`]: 'turn_coordinator_ball'
        };
        this.inertialDataSourceTopicMap = {
            [`irs_inertial_speed_${this.index}`]: 'inertial_speed',
            [`irs_inertial_vertical_speed_${this.index}`]: 'inertial_vertical_speed',
            [`irs_inertial_acceleration_${this.index}`]: 'inertial_acceleration',
            [`irs_inertial_track_acceleration_${this.index}`]: 'inertial_track_acceleration',
            [`irs_ground_speed_${this.index}`]: 'ground_speed'
        };
        this.inertialHeadingDataSourceTopicMap = {
            [`irs_track_deg_true_${this.index}`]: 'track_deg_true',
            [`irs_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.positionDataSourceTopicMap = {
            [`irs_gps-position_${this.index}`]: 'gps-position',
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.headingDataSubs = [];
        this.attitudeDataSubs = [];
        this.inertialDataSubs = [];
        this.inertialHeadingDataSubs = [];
        this.positionDataSubs = [];
        this.overrideAttitudeAlignDuration = SubscribableUtils.toSubscribable(attitudeAlignDuration, true);
        this.overrideFullAlignDuration = SubscribableUtils.toSubscribable(fullAlignDuration, true);
        this.overrideRealignDuration = SubscribableUtils.toSubscribable(realignDuration, true);
        this.attitudeAlignDuration = this.overrideAttitudeAlignDuration.map(duration => duration === undefined ? IrsSystem.ATTITUDE_ALIGN_DURATION : duration);
        this.fullAlignDuration = MappedSubject.create(([simulated, override, attitudeAlign]) => Math.max(override === undefined ? simulated : override, attitudeAlign), this.simulatedFullAlignDuration, this.overrideFullAlignDuration, this.attitudeAlignDuration);
        this.realignDuration = this.overrideRealignDuration.map(duration => duration === undefined ? IrsSystem.REALIGN_DURATION : duration);
        if (this.powerSource !== undefined) {
            this.connectToPower(this.powerSource);
        }
        // Initialize some cached topics.
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid);
        this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid);
        this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid);
        this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid);
        this.publishFullAlignTimeRemaining(null);
        this.publishAttitudeAlignTimeRemaining(null);
        // Set up automatic position initialization from GPS.
        const gpsReceiverIndexArray = Array.from(new Set(gpsReceiverIndexes)); // Ensure no duplicates
        if (gpsReceiverIndexArray.length > 0) {
            const gpsSub = bus.getSubscriber();
            this.isGpsAvailable = MappedSubject.create(states => states.includes(GPSSystemState.SolutionAcquired) || states.includes(GPSSystemState.DiffSolutionAcquired), ...gpsReceiverIndexArray.map(gpsReceiverIndex => ConsumerSubject.create(gpsSub.on(`gps_rec_gps_system_state_changed_${gpsReceiverIndex}`), GPSSystemState.Searching)));
            this.gpsPositionSub = this.isGpsAvailable.sub(isAvail => {
                if (isAvail) {
                    this.isPositionInit.set(true);
                }
            }, false, true);
        }
        const sub = bus.getSubscriber();
        this.simTime.setConsumer(sub.on('simTime'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.speed.setConsumer(sub.on('inertial_speed'));
        this.position.setConsumer(sub.on('gps-position'));
        this.setPositionSub = sub.on(`irs_set_position_${index}`).handle(() => {
            this.isPositionInit.set(true);
        }, true);
        this.autoSetPositionSub = sub.on('hEvent').handle(hEvent => {
            if (hEvent === 'WT_AUTO_SET_IRS_POS') {
                if (this.isAcceptingPosition.get()) {
                    this.isPositionInit.set(true);
                }
                else {
                    this.autoPositionInit = true;
                }
            }
        });
        this.isAcceptingPosition.sub(val => {
            var _a, _b;
            if (val) {
                this.setPositionSub.resume();
                (_a = this.gpsPositionSub) === null || _a === void 0 ? void 0 : _a.resume(true);
                if (this.autoPositionInit) {
                    this.isPositionInit.set(true);
                    this.autoPositionInit = false;
                }
            }
            else {
                this.setPositionSub.pause();
                (_b = this.gpsPositionSub) === null || _b === void 0 ? void 0 : _b.pause();
            }
            this.publisher.pub(this.acceptingPositionTopic, val);
        }, true);
        // Request manual position input when the system is accepting position inputs, has not received a position input
        // yet, and GPS position is not available.
        this.isRequestingPosition = MappedSubject.create(([isAccepting, isInit, isGpsAvail]) => isAccepting && !isInit && !isGpsAvail, this.isAcceptingPosition, this.isPositionInit, (_a = this.isGpsAvailable) !== null && _a !== void 0 ? _a : Subject.create(false));
        this.isPositionInit.sub(isInit => {
            SimVar.SetSimVarValue(`L:WT_IRS_POS_SET_${this.index}`, SimVarValueType.Bool, isInit);
        }, true);
        this.isRequestingPosition.sub(val => { this.publisher.pub(this.requestingPositionTopic, val); }, true);
        this.startDataPublish();
    }
    /**
     * Starts publishing IRS data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.headingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.attitudeDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onAttitudeTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialHeadingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.positionDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onPositionTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.headingDataSourceTopicMap) {
                this.onHeadingTopicSubscribed(topic);
            }
            else if (topic in this.attitudeDataSourceTopicMap) {
                this.onAttitudeTopicSubscribed(topic);
            }
            else if (topic in this.inertialDataSourceTopicMap) {
                this.onInertialTopicSubscribed(topic);
            }
            else if (topic in this.inertialHeadingDataSourceTopicMap) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
            else if (topic in this.positionDataSourceTopicMap) {
                this.onPositionTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onHeadingTopicSubscribed(topic) {
        this.headingDataSubs.push(this.dataSourceSubscriber.on(this.headingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's attitude data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onAttitudeTopicSubscribed(topic) {
        this.attitudeDataSubs.push(this.dataSourceSubscriber.on(this.attitudeDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isAttitudeDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialTopicSubscribed(topic) {
        this.inertialDataSubs.push(this.dataSourceSubscriber.on(this.inertialDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial/heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialHeadingTopicSubscribed(topic) {
        this.inertialHeadingDataSubs.push(this.dataSourceSubscriber.on(this.inertialHeadingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid || !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onPositionTopicSubscribed(topic) {
        this.positionDataSubs.push(this.dataSourceSubscriber.on(this.positionDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isPositionDataValid));
    }
    /**
     * Publishes the time remaining for full alignment to complete.
     * @param time The time to publish, in seconds, or `null` if full alignment is not in process.
     */
    publishFullAlignTimeRemaining(time) {
        if (time === this.publishedFullAlignTimeRemaining) {
            return;
        }
        this.publishedFullAlignTimeRemaining = time;
        this.publisher.pub(this.fullAlignTimeTopic, time, false, true);
    }
    /**
     * Publishes the time remaining for attitude alignment to complete.
     * @param time The time to publish, in seconds, or `null` if attitude alignment is not in process.
     */
    publishAttitudeAlignTimeRemaining(time) {
        if (time === this.publishedAttitudeAlignTimeRemaining) {
            return;
        }
        this.publishedAttitudeAlignTimeRemaining = time;
        this.publisher.pub(this.attitudeAlignTimeTopic, time, false, true);
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        this.isPowered = isPowered;
        this.setState(isPowered ? AvionicsSystemState.On : AvionicsSystemState.Off);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Off) {
            this.setOperatingMode(IrsSystemOperatingMode.Off);
        }
    }
    /**
     * Sets this system's operating mode.
     * @param mode The operating mode to set.
     */
    setOperatingMode(mode) {
        if (this.operatingMode === mode) {
            return;
        }
        this.operatingMode = mode;
        let resetRealignTime = true;
        let disarmRealign = true;
        switch (mode) {
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                this.fullAlignTime = 0;
                this.attitudeAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.publishAttitudeAlignTimeRemaining(null);
            // fallthrough
            case IrsSystemOperatingMode.AttitudeAlign:
                this.fullAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.publishFullAlignTimeRemaining(0);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Navigation:
                disarmRealign = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Realign:
                this.isAcceptingPosition.set(true);
                resetRealignTime = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
        }
        if (resetRealignTime) {
            this.realignTime = 0;
        }
        if (disarmRealign) {
            this.isRealignArmed = false;
        }
        this.isRealignArmed = false;
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.updateHeadingDataState();
        this.updateAttitudeDataState();
        this.updateInertialDataState();
        this.updateInertialHeadingDataState();
        this.updatePositionDataState();
    }
    /**
     * Updates the validity state of this system's heading data. If heading data is valid, this system will start
     * publishing heading data. If heading data is invalid, this system will stop publishing heading data.
     */
    updateHeadingDataState() {
        // TODO: Heading data requires manual heading input in Attitude mode if the IRS does not have an AHRU component.
        let isHeadingDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isHeadingDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isHeadingDataValid = false;
                break;
            default:
                isHeadingDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isHeadingDataValid !== this.isHeadingDataValid) {
            this.isHeadingDataValid = isHeadingDataValid;
            if (isHeadingDataValid) {
                for (const sub of this.headingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.headingDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's attitude data. If attitude data is valid, this system will start
     * publishing attitude data. If attitude data is invalid, this system will stop publishing attitude data.
     */
    updateAttitudeDataState() {
        let isAttitudeDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isAttitudeDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isAttitudeDataValid = false;
                break;
            default:
                isAttitudeDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isAttitudeDataValid !== this.isAttitudeDataValid) {
            this.isAttitudeDataValid = isAttitudeDataValid;
            if (isAttitudeDataValid) {
                for (const sub of this.attitudeDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.attitudeDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial data. If inertial data is valid, this system will start
     * publishing inertial data. If inertial data is invalid, this system will stop publishing inertial data.
     */
    updateInertialDataState() {
        const isInertialDataValid = this.operatingMode === IrsSystemOperatingMode.Navigation
            || this.operatingMode === IrsSystemOperatingMode.Realign;
        if (isInertialDataValid !== this.isInertialDataValid) {
            this.isInertialDataValid = isInertialDataValid;
            if (isInertialDataValid) {
                for (const sub of this.inertialDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial/heading data. If inertial/heading data is valid, this system
     * will start publishing inertial/heading data. If inertial/heading data is invalid, this system will stop publishing
     * inertial/heading data.
     */
    updateInertialHeadingDataState() {
        const isInertialHeadingDataValid = this.isHeadingDataValid && this.isInertialDataValid;
        if (isInertialHeadingDataValid !== this.isInertialHeadingDataValid) {
            this.isInertialHeadingDataValid = isInertialHeadingDataValid;
            if (isInertialHeadingDataValid) {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.pause();
                }
            }
        }
    }
    /**
     * Updates the validity state of this system's position data. If position data is valid, this system will start
     * publishing position data. If position data is invalid, this system will stop publishing position data.
     */
    updatePositionDataState() {
        const isPositionDataValid = this.isInertialDataValid;
        if (isPositionDataValid !== this.isPositionDataValid) {
            this.isPositionDataValid = isPositionDataValid;
            if (isPositionDataValid) {
                for (const sub of this.positionDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.positionDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.state === AvionicsSystemState.Off) {
            return;
        }
        const simTime = this.simTime.get();
        const dt = this.lastUpdateSimTime === undefined ? 0 : Math.max(0, simTime - this.lastUpdateSimTime);
        this.lastUpdateSimTime = simTime;
        this.updateSimulatedFullAlignDuration();
        const modeSetting = this.operatingModeSetting.get();
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Off:
                this.updateOff(modeSetting);
                break;
            case IrsSystemOperatingMode.Standby:
                this.updateStandby(modeSetting);
                break;
            case IrsSystemOperatingMode.FullAlign:
                this.updateFullAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.updateFullAlignPositionPending(modeSetting);
                break;
            case IrsSystemOperatingMode.Navigation:
                this.updateNavigation(modeSetting);
                break;
            case IrsSystemOperatingMode.Realign:
                this.updateRealign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.AttitudeAlign:
                this.updateAttitudeAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.updateAttitude(modeSetting);
                break;
        }
    }
    /**
     * Updates the simulated time required to complete a full alignment.
     */
    updateSimulatedFullAlignDuration() {
        // 5 min at equator, 17 min at 70 degrees latitude
        this.simulatedFullAlignDuration.set(MathUtils.lerp(Math.cos(this.position.get().lat * Avionics.Utils.DEG2RAD), 1, 0.342, 300e3, 1020e3, true, true));
    }
    /**
     * Attempts to start a new full or attitude alignment cycle.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @returns Whether a new alignment cycle was started.
     */
    tryStartFreshAlign(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isOnGround.get()) {
                    if (this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                        return true;
                    }
                }
                else if (this.supportInFlightAlign && this.isGpsAvailable && this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
                    this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                    return true;
                }
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                return true;
        }
        return false;
    }
    /**
     * Updates this system while it is in the Off operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateOff(modeSetting) {
        if (this.tryStartFreshAlign(modeSetting)) {
            return;
        }
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                break;
            default:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
        }
    }
    /**
     * Updates this system while it is in the Standby operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateStandby(modeSetting) {
        this.tryStartFreshAlign(modeSetting);
    }
    /**
     * Updates this system while it is in the FullAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateFullAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                if (this.attitudeAlignTime >= IrsSystem.ATTITUDE_ALIGN_DURATION) {
                    this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                }
                else {
                    this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                }
                return;
        }
        let isInFlightAlign = false;
        if (this.isOnGround.get()) {
            this.isAcceptingPosition.set(true);
            if (this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
                this.fullAlignTime = 0;
            }
        }
        else if (!this.supportInFlightAlign || !this.isGpsAvailable || !this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
            this.setOperatingMode(IrsSystemOperatingMode.Standby);
            return;
        }
        else {
            this.isAcceptingPosition.set(false);
            isInFlightAlign = true;
        }
        this.attitudeAlignTime += dt;
        this.fullAlignTime += dt;
        const fullAlignDuration = this.fullAlignDuration.get();
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration
            && (!this.isAttitudeDataValid || !this.isHeadingDataValid)) {
            this.updateAttitudeDataState();
            this.updateHeadingDataState();
        }
        if (this.fullAlignTime >= fullAlignDuration) {
            if (this.isPositionInit.get() || isInFlightAlign) {
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            }
            else {
                this.setOperatingMode(IrsSystemOperatingMode.FullAlignPositionPending);
            }
        }
        else {
            if (this.attitudeAlignTime >= attitudeAlignDuration) {
                this.publishAttitudeAlignTimeRemaining(null);
            }
            else {
                this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
            }
            this.publishFullAlignTimeRemaining((fullAlignDuration - this.fullAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the FullAlignPositionPending operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateFullAlignPositionPending(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        if (this.isPositionInit.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the Navigation operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateNavigation(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.isAcceptingPosition.set(true);
                this.isRealignArmed = true;
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isRealignArmed) {
                    // Realignment requires the airplane be on the ground and not moving.
                    if (this.isOnGround.get() && this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.Realign);
                        return;
                    }
                    else {
                        this.isRealignArmed = false;
                    }
                }
                this.isAcceptingPosition.set(false);
                break;
        }
    }
    /**
     * Updates this system while it is in the Realign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateRealign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        // Realignment requires the airplane be on the ground and not moving.
        if (!this.isOnGround.get() || this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            return;
        }
        this.realignTime += dt;
        if (this.realignTime >= this.realignDuration.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the AttitudeAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateAttitudeAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                return;
        }
        this.attitudeAlignTime += dt;
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration) {
            this.setOperatingMode(IrsSystemOperatingMode.Attitude);
        }
        else {
            this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the Attitude operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateAttitude(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                break;
        }
    }
}
IrsSystem.ATTITUDE_ALIGN_DURATION = 30000; // milliseconds
IrsSystem.REALIGN_DURATION = 30000; // milliseconds
IrsSystem.ALIGN_SPEED_THRESHOLD = 1; // meters per second

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best IRS from a set of candidates based on the current states of all systems. System state
 * desiribility is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class IrsSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the IRS systems from which to select.
     * @param systemPriorities The priorities for selecting individual IRS systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of IRS system indexes or a map of
     * IRS system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isAttitudeDataValid = Subject.create(false);
        this.isHeadingDataValid = Subject.create(false);
        this.isInertialDataValid = Subject.create(false);
        this.isInertialHeadingDataValid = Subject.create(false);
        this.isPositionDataValid = Subject.create(false);
        this.irsEntries = new Map();
        this.irsOrder = [];
        this.irsComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `irs_selector_selected_index_${index}`), true);
        this.isAttitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_attitude_data_valid_${index}`), true);
        this.isHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_heading_data_valid_${index}`), true);
        this.isInertialDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_data_valid_${index}`), true);
        this.isInertialHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_heading_data_valid_${index}`), true);
        this.isPositionDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_position_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.irsEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`irs_attitude_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_heading_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_inertial_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_position_data_valid_${key}`), false)
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.irsEntries.set(key, entry);
                // When there is a change in an IRS state, we don't reselect immediately because the IRS could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.irsEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the IRS with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.irsEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.irsEntries.size === 1) {
            const entry = this.irsEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.irsOrder.length = 0;
            for (const index of this.irsEntries.keys()) {
                this.irsOrder.push(index);
            }
            this.irsOrder.sort(this.irsComparator);
            bestIndex = -1;
            for (let i = 0; i < this.irsOrder.length; i++) {
                const index = this.irsOrder[i];
                const state = this.irsEntries.get(index).state.get();
                if (!bestState || IrsSystemSelector.compareadiruState(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isAttitudeDataValid.set(bestState[0]);
            this.isHeadingDataValid.set(bestState[1]);
            this.isInertialDataValid.set(bestState[2]);
            this.isInertialHeadingDataValid.set(bestState[1] && bestState[2]);
            this.isPositionDataValid.set(bestState[3]);
        }
        else {
            this.isAttitudeDataValid.set(false);
            this.isHeadingDataValid.set(false);
            this.isInertialDataValid.set(false);
            this.isInertialHeadingDataValid.set(false);
            this.isPositionDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.irsEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
    /**
     * Compares two IRS states and returns a number whose sign indicates which one is more desirable.
     * @param a The first IRS state to compare.
     * @param b The second IRS state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareadiruState(a, b) {
        // The data validity flags within the state array are ordered such that a false flag cannot precede a true flag,
        // so we can exploit this fact.
        return b.lastIndexOf(true) - a.lastIndexOf(true);
    }
}

/**
 * The GMU44 magnetometer system.
 */
class MagnetometerSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the MagnetometerSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `magnetometer_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.initializationTime = 5000;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
}

/**
 * The Radio Altimeter system.
 */
class RASystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the RASystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param radioAltOffset The radio altimeter offset.
     * @param powerSource The power source.
     */
    constructor(index, bus, radioAltOffset, powerSource) {
        super(index, bus, `ra_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.radioAltOffset = radioAltOffset;
        this.powerSource = powerSource;
        this.initializationTime = 7000;
        const radioAltTopic = `ra_radio_alt_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's radar altitude data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `ra_radio_alt_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.radioAltSub = this.bus.getSubscriber().on('radio_alt').atFrequency(3).handle(val => {
            this.publisher.pub(topic, val + this.radioAltOffset);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.radioAltSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.radioAltSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

/** A class to publish events related to all IRS systems as a whole. */
class IrsSystemGroupStatusPublisher {
    /** @inheritDoc */
    constructor(bus, irsCount) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        const sub = bus.getSubscriber();
        MappedSubject.create(modes => {
            for (let i = 0; i < modes.length; i++) {
                if (modes[i] !== IrsSystemOperatingMode.Navigation && modes[i] !== IrsSystemOperatingMode.Realign) {
                    return false;
                }
            }
            return true;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_operating_mode_${index + 1}`), IrsSystemOperatingMode.Off))).sub(allOperating => this.publisher.pub('all_irs_systems_operating', allOperating), true);
        const anIrsIsAcceptingPos = MappedSubject.create(irsSystemIsAcceptingPos => {
            for (let i = 0; i < irsSystemIsAcceptingPos.length; i++) {
                if (irsSystemIsAcceptingPos[i]) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_is_accepting_position_${index + 1}`), false)));
        const anIrsIsRequestingPos = MappedSubject.create(irsSystemIsRequestingPos => {
            for (let i = 0; i < irsSystemIsRequestingPos.length; i++) {
                if (irsSystemIsRequestingPos[i]) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_is_requesting_position_${index + 1}`), false)));
        anIrsIsAcceptingPos.sub(acceptingPos => this.publisher.pub('an_irs_is_accepting_pos', acceptingPos), true);
        anIrsIsRequestingPos.sub(requestingPos => this.publisher.pub('an_irs_is_requesting_pos', requestingPos), true);
        MappedSubject.create(([isAccepting, isRequesting]) => isAccepting || isRequesting, anIrsIsAcceptingPos, anIrsIsRequestingPos).sub(accOrReqPos => this.publisher.pub('an_irs_is_accepting_or_requesting_pos', accOrReqPos), true);
        const anIrsIsOperating = MappedSubject.create((irsOperatingMode) => {
            for (let i = 0; i < irsOperatingMode.length; i++) {
                if (irsOperatingMode[i] === IrsSystemOperatingMode.Navigation || irsOperatingMode[i] === IrsSystemOperatingMode.Realign) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_operating_mode_${index + 1}`), IrsSystemOperatingMode.Navigation)));
        anIrsIsOperating.sub(isAnyOperating => this.publisher.pub('an_irs_system_is_operating', isAnyOperating), true);
        const maxIrsAlignSecondsRemaining = MappedSubject.create((irsFullAlignSecondsRemaining) => {
            let maxSeconds = null;
            for (let i = 0; i < irsFullAlignSecondsRemaining.length; i++) {
                const remaining = irsFullAlignSecondsRemaining[i];
                if (remaining !== null) {
                    if (maxSeconds === null || remaining > maxSeconds) {
                        maxSeconds = remaining;
                    }
                }
            }
            return maxSeconds;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_full_align_time_remaining_${index + 1}`), null)));
        maxIrsAlignSecondsRemaining.sub(maxRemaining => this.publisher.pub('max_irs_align_seconds_remaining', maxRemaining), true);
        const minIrsAlignSecondsRemaining = MappedSubject.create((irsFullAlignSecondsRemaining) => {
            let minSeconds = null;
            for (let i = 0; i < irsFullAlignSecondsRemaining.length; i++) {
                const remaining = irsFullAlignSecondsRemaining[i];
                if (remaining !== null) {
                    if (minSeconds === null || remaining < minSeconds) {
                        minSeconds = remaining;
                    }
                }
            }
            return minSeconds;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_full_align_time_remaining_${index + 1}`), null)));
        minIrsAlignSecondsRemaining.sub(minRemaining => this.publisher.pub('min_irs_align_seconds_remaining', minRemaining), true);
        const anIrsIsAligning = maxIrsAlignSecondsRemaining.map(x => x !== null);
        anIrsIsAligning.sub(isAligning => this.publisher.pub('an_irs_is_aligning', isAligning), true);
    }
}

/**
 * A TCAS II implementation for the Boeing airplanes.
 */
class BoeingTCAS extends Tcas {
    constructor() {
        super(...arguments);
        this.settings = TrafficUserSettings.getManager(this.bus);
        /** All RAs are inhibited when airplane is on ground, or when airplane's radio altitude < 1100ft. */
        this.isRAsInhibited = MappedSubject.create(([radarAlt, isClimbing]) => {
            return radarAlt < (isClimbing ? 900 : 1100);
        }, this.ownAirplaneSubs.radarAltitude.map(radarAlt => Math.round(radarAlt.asUnit(UnitType.FOOT))), this.ownAirplaneSubs.verticalSpeed.map(verticalSpeed => verticalSpeed.number >= 0));
    }
    /** @inheritdoc */
    init() {
        super.init();
        this.settings.whenSettingChanged('trafficOperatingMode').handle(mode => {
            switch (mode) {
                case TcasOperatingModeSetting.Standby:
                    this.setOperatingMode(TcasOperatingMode.Standby);
                    break;
                case TcasOperatingModeSetting.TAOnly:
                    this.setOperatingMode(TcasOperatingMode.TAOnly);
                    break;
                case TcasOperatingModeSetting.TA_RA:
                    if (this.isRAsInhibited.get()) {
                        this.setOperatingMode(TcasOperatingMode.TAOnly);
                    }
                    else {
                        this.setOperatingMode(TcasOperatingMode.TA_RA);
                    }
                    break;
            }
        });
        this.isRAsInhibited.sub(isInhibited => {
            if (this.settings.getSetting('trafficOperatingMode').value === TcasOperatingModeSetting.TA_RA) {
                this.setOperatingMode(isInhibited ? TcasOperatingMode.TAOnly : TcasOperatingMode.TA_RA);
            }
        });
    }
    /** @inheritdoc */
    createSensitivity() {
        return new TcasIISensitivity();
    }
    /** @inheritdoc */
    createIntruderEntry(contact) {
        return new DefaultTcasIntruder(contact);
    }
    /** @inheritdoc */
    updateSensitivity() {
        this.sensitivity.updateLevel(this.ownAirplaneSubs.altitude.get(), this.ownAirplaneSubs.radarAltitude.get());
    }
}

/** Stores wind data associated with a flightplan */
class WindPlan {
    /**
     * Constructs a new WindPlan
     * @param options Options for the WindPlanner
     * @param numberOfLegs Number of legs to initialise the plan with (will be filled with empty data)
     */
    constructor(options, numberOfLegs = 0) {
        this.options = options;
        this.climbData = [];
        this.descentData = [];
        /** Maps global flight plan leg index to wind records */
        this.legWindData = [];
        /** Maps global flight plan leg index to temparture records */
        this.legTemperatureData = [];
        if (numberOfLegs > 0) {
            this.legWindData = Array.from({ length: numberOfLegs }, () => []);
        }
    }
    /**
     * Set wind for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature === null;
            this.refreshTemperaturePropagation(this.climbData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Deletes a climb wind record
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(altitude) {
        const deleteIndex = this.climbData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.climbData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the climb wind records for a flight plan
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures() {
        return this.climbData;
    }
    /**
     * Set wind for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.descentData.length >= ((_b = this.options.numberOfDescentAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature === null;
            this.refreshTemperaturePropagation(this.descentData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.descentData.length >= ((_b = this.options.numberOfDescentAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Deletes a descent wind record
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWind(altitude) {
        const deleteIndex = this.descentData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.descentData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the descent wind records for a flight plan
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures() {
        return this.descentData;
    }
    /**
     * Deletes the record for a leg (when the leg is deleted from the flightplan)
     * @param globalLegIndex Index of leg in entire flight plan
     */
    deleteLeg(globalLegIndex) {
        // Does not removed propagated data from other legs... may need an option for this later with other FMS types
        if (this.legWindData[globalLegIndex]) {
            this.legWindData.splice(globalLegIndex, 1);
        }
        if (this.legTemperatureData[globalLegIndex]) {
            this.legTemperatureData.splice(globalLegIndex, 1);
        }
    }
    /**
     * Inserts a new flight plan leg and propagates data from existing legs
     * @param globalLegIndex Index of leg in entire flight plan
     */
    insertLegAndPropagate(globalLegIndex) {
        this.legWindData.splice(globalLegIndex, 0, []);
        const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : 0;
        const propagationData = this.legWindData[propagationIndex];
        if (propagationData) {
            const records = propagationData.map(({ altitude, direction, speed }) => ({ altitude, direction, speed, windPropagated: true }));
            this.legWindData.splice(globalLegIndex, 0, records);
        }
        else {
            this.legWindData.splice(globalLegIndex, 0, []);
        }
        const tempData = this.legTemperatureData[propagationIndex];
        if (tempData) {
            this.legTemperatureData.splice(globalLegIndex, 0, Object.assign(Object.assign({}, tempData), { temperaturePropagated: true }));
        }
    }
    /**
     * Check if all the available leg altitudes are already used
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed() {
        if (this.legWindData.length === 0 || this.options.numberOfLegAltitudes === undefined) {
            return false;
        }
        const windData = this.legWindData[0];
        return windData.length >= this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.legWindData[globalLegIndex]) === null || _a === void 0 ? void 0 : _a.some((record) => record.windPropagated === false)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(globalLegIndex, altitude, speed, direction) {
        var _a, _b, _c, _d;
        const windData = this.legWindData[globalLegIndex];
        if (windData === undefined) {
            return false;
        }
        /** index of existing record for this altitude (same in all legs) */
        const existingRecordIndex = (_a = windData === null || windData === void 0 ? void 0 : windData.findIndex((v) => v.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (existingRecordIndex < 0 && isFinite((_b = this.options.numberOfLegAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
            if (((_c = windData === null || windData === void 0 ? void 0 : windData.length) !== null && _c !== void 0 ? _c : 0) >= ((_d = this.options.numberOfLegAltitudes) !== null && _d !== void 0 ? _d : Infinity)) {
                return false;
            }
        }
        if (existingRecordIndex >= 0 && windData) {
            const existingRecord = windData[existingRecordIndex];
            existingRecord.altitude = altitude;
            existingRecord.speed = speed;
            existingRecord.direction = direction;
            existingRecord.windPropagated = false;
            // propagate backward if needed
            if (this.findNextNonPropagatedLeg(globalLegIndex, altitude, -1) < 0) {
                this.propagateWind(0, globalLegIndex - 1, windData[existingRecordIndex], existingRecordIndex);
            }
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLeg(globalLegIndex, altitude);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateWind(globalLegIndex + 1, propagateTo, windData[existingRecordIndex], existingRecordIndex);
        }
        else {
            const newRecord = {
                altitude,
                speed,
                direction,
                windPropagated: true,
            };
            this.legWindData.forEach((r, index) => r.push(index === globalLegIndex ? Object.assign(Object.assign({}, newRecord), { windPropagated: speed === null }) : Object.assign({}, newRecord)));
        }
        return true;
    }
    /**
     * Delete an altitude from all leg wind records
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(altitude) {
        this.legWindData.forEach((leg) => {
            const idx = leg.findIndex((r) => r.altitude === altitude);
            if (idx >= 0) {
                leg.splice(idx, 1);
            }
        });
    }
    /**
     * Delete wind at a leg at a given altitude (does not delete this altitude globally)
     * @param globalLegIndex Flight plan leg index
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(globalLegIndex, altitude) {
        var _a;
        const leg = this.legWindData[globalLegIndex];
        const recordIndex = (_a = leg === null || leg === void 0 ? void 0 : leg.findIndex((r) => r.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (recordIndex >= 0 && leg) {
            const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : globalLegIndex + 1;
            const propagationData = this.legWindData[propagationIndex][recordIndex];
            if (propagationData) {
                const record = leg[recordIndex];
                Object.assign(record, propagationData);
                record.windPropagated = true;
            }
            else {
                // we must be the only leg
                this.deleteLegAltitude(altitude);
            }
        }
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(globalLegIndex, altitude, temperature) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            const tempData = this.legTemperatureData[globalLegIndex];
            tempData.altitude = altitude;
            tempData.temperature = temperature;
            tempData.temperaturePropagated = temperature === null;
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, 1);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateTemperature(globalLegIndex + 1, propagateTo, tempData);
            // propagate backward if no non-propagated legs behind
            const prevNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, -1);
            if (prevNonPropagatedLeg < 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
        }
        else {
            const tempData = { altitude, temperature, temperaturePropagated: temperature === null };
            this.legTemperatureData[globalLegIndex] = tempData;
            // no data exists, so we can propagate to all legs
            if (globalLegIndex > 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
            if (globalLegIndex < (this.legWindData.length - 1)) {
                this.propagateTemperature(globalLegIndex + 1, this.legWindData.length - 1, tempData);
            }
        }
        return true;
    }
    /**
     * Deletes a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(globalLegIndex) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            this.legTemperatureData[globalLegIndex].temperature = null;
            // TODO propagate from other leg
        }
    }
    /**
     * Gets a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     * @returns the leg temperature record if it exists, else undefined
     */
    getLegTemperature(globalLegIndex) {
        return this.legTemperatureData[globalLegIndex];
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from
     * @param recordIndex The index of the altitude record to propagate
     */
    propagateWind(fromIndex, toIndex, fromRecord, recordIndex) {
        for (let i = fromIndex; i <= toIndex; i++) {
            const record = this.legWindData[i][recordIndex];
            if (!record.windPropagated) {
                console.warn('Overwriting non-propagated wind record with propagated record at global leg', i);
                record.windPropagated = true;
            }
            record.altitude = fromRecord.altitude;
            record.direction = fromRecord.direction;
            record.speed = fromRecord.speed;
        }
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from.
     * @throws if parameters are incompatible with options
     */
    propagateTemperature(fromIndex, toIndex, fromRecord) {
        for (let i = fromIndex; i <= toIndex; i++) {
            if (this.legTemperatureData[i] === undefined) {
                this.legTemperatureData[i] = Object.assign(Object.assign({}, fromRecord), { temperaturePropagated: true });
            }
            else {
                const record = this.legTemperatureData[i];
                if (!record.temperaturePropagated) {
                    console.warn('Overwriting non-propagated temperature record with propagated record at global leg', i);
                    record.temperaturePropagated = true;
                }
                record.altitude = fromRecord.altitude;
                record.temperature = fromRecord.temperature;
            }
        }
    }
    /**
     * Find the next leg that doesn't have a propagated wind
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLeg(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legWindData.length : i >= 0); i += direction) {
            const legData = this.legWindData[i];
            if (legData.find((w) => w.altitude === altitude && !w.windPropagated)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Find the next leg that doesn't have a propagated temperature
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLegTemperature(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legTemperatureData.length : i >= 0); i += direction) {
            const legData = this.legTemperatureData[i];
            if (!legData.temperaturePropagated) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Get the wind records for a flight plan leg
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(globalLegIndex) {
        return this.legWindData[globalLegIndex];
    }
    /**
     * Get the number of legs in the plan
     * @returns the number of legs in the plan
     */
    get legLength() {
        return this.legWindData.length;
    }
    /**
     * Copy all data from another plan into this one
     * @param fromPlan the plan to copy from
     */
    copyFrom(fromPlan) {
        // TODO make this cheaper by re-using existing objects
        this.climbData = fromPlan.climbData.map((r) => (Object.assign({}, r)));
        this.descentData = fromPlan.descentData.map((r) => (Object.assign({}, r)));
        this.legWindData = fromPlan.legWindData.map((r) => r.map((v) => (Object.assign({}, v))));
        this.legTemperatureData = fromPlan.legTemperatureData.map((r) => (Object.assign({}, r)));
    }
    /**
     * Clears all leg wind and temperature data in the plan.
     */
    deleteAllClimbWindsAndTemperatures() {
        this.climbData.length = 0;
    }
    /**
     * Clears all leg wind and temperature data in the plan.
     */
    deleteAllDescentWindsAndTemperatures() {
        this.descentData.length = 0;
    }
    /**
     * Clears all leg wind and temperature data in the plan.
     */
    deleteAllLegWindsAndTemperatures() {
        this.legTemperatureData.length = 0;
        this.legWindData.forEach((r) => r.length = 0);
    }
    /**
     * Insert a climb or descent record into the array, taking care of temperature propagation and sorting
     * @param records climb or descent records
     * @param newRecord new record to insert
     */
    insertClimbDescentRecord(records, newRecord) {
        const insertAt = Math.max(0, records.findIndex((r) => r.altitude > newRecord.altitude));
        records.splice(insertAt, 0, newRecord);
        this.refreshTemperaturePropagation(records);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Refresh propagated temperature values for climb and descent from the non-propagated records
     * @param records Climb or Descent records
     */
    refreshTemperaturePropagation(records) {
        var _a;
        const anyNonPropagated = records.some((r) => r.temperaturePropagated === false);
        if (anyNonPropagated) {
            let previousAlt = null;
            let previousTemp = null;
            for (const record of records) {
                if ((_a = record.temperaturePropagated) !== null && _a !== void 0 ? _a : true) {
                    const nextHighestNonPropagated = records.find((r) => r.altitude > record.altitude && r.temperature !== null && r.temperaturePropagated === false);
                    if (nextHighestNonPropagated !== undefined && previousTemp !== null && previousAlt !== null && nextHighestNonPropagated.altitude !== previousAlt) {
                        // we have a temp above and below, interpolate isa delta between them
                        /** proportion of the higher ISA delta to take */
                        const k = (record.altitude - previousAlt) / (nextHighestNonPropagated.altitude - previousAlt);
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + k * isaAbove + (1 - k) * isaBelow;
                    }
                    else if (nextHighestNonPropagated !== undefined) {
                        // we have a temp above but not below, use isaDelta directly
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaAbove;
                    }
                    else if (previousTemp !== null && previousAlt !== null) {
                        // we have a temp below but not above, use isaDelta directly
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaBelow;
                    }
                }
                else {
                    previousAlt = record.altitude;
                    previousTemp = record.temperature;
                }
            }
        }
        else {
            records.forEach((r) => r.temperature = this.isaTemperatureFeet(r.altitude));
        }
    }
}

/** Stores and manages wind plans */
class WindPlanner {
    /**
     * Constructs a WindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.plans = [];
        this.syncPublisher = this.bus.getPublisher();
        this.eventPublisher = this.bus.getPublisher();
        this.ignoreSync = false;
        const fpln = this.bus.getSubscriber();
        fpln.on('fplCreated').handle(this.onPlanCreated.bind(this));
        fpln.on('fplCopied').handle(this.onPlanCopied.bind(this));
        fpln.on('fplLoaded').handle(this.onPlanLoaded.bind(this));
        fpln.on('fplDeleted').handle(this.onPlanDeleted.bind(this));
        fpln.on('fplSegmentChange').handle(this.onSegmentChanged.bind(this));
        fpln.on('fplLegChange').handle(this.onLegChanged.bind(this));
        const sync = this.bus.getSubscriber();
        sync.on('windsync_climb_wind_deleted').handle(this.handleClimbWindDelete.bind(this));
        sync.on('windsync_climb_wind_set').handle(this.handleClimbWindSet.bind(this));
        sync.on('windsync_climb_temperature_set').handle(this.handleClimbTemperatureSet.bind(this));
        sync.on('windsync_climb_all_deleted').handle(this.handleDeleteAllClimbWindsAndTemperatures.bind(this));
        sync.on('windsync_descent_wind_deleted').handle(this.handleDescentWindDelete.bind(this));
        sync.on('windsync_descent_wind_set').handle(this.handleDescentWindSet.bind(this));
        sync.on('windsync_descent_temperature_set').handle(this.handleDescentTemperatureSet.bind(this));
        sync.on('windsync_descent_all_deleted').handle(this.handleDeleteAllDescentWindsAndTemperatures.bind(this));
        sync.on('windsync_leg_wind_deleted').handle(this.handleLegWindDelete.bind(this));
        sync.on('windsync_leg_altitude_deleted').handle(this.handleLegAltitudeDelete.bind(this));
        sync.on('windsync_leg_wind_set').handle(this.handleLegWindSet.bind(this));
        sync.on('windsync_leg_temperature_deleted').handle(this.handleLegTempDelete.bind(this));
        sync.on('windsync_leg_temperature_set').handle(this.handleLegTempSet.bind(this));
        sync.on('windsync_leg_all_deleted').handle(this.handleDeleteAllLegWindsAndTemperatures.bind(this));
    }
    /**
     * Set wind for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbWindSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a climb wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleClimbWindDelete(ev);
    }
    /**
     * Handles climb wind delete events
     * @param ev the event
     */
    handleClimbWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteClimbWindAndTemperature(ev.altitude);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set temperature for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbTemperatureSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the climb wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getClimbWindsAndTemperatures();
    }
    /**
     * Deletes all climb wind records
     * @param planIndex Flight Plan index
     */
    deleteAllClimbWindsAndTemperatures(planIndex) {
        const ev = {
            planIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_all_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDeleteAllClimbWindsAndTemperatures(ev);
    }
    /**
     * Handles delete all climb wind events
     * @param ev the event
     */
    handleDeleteAllClimbWindsAndTemperatures(ev) {
        const plan = this.getPlan(ev.planIndex);
        plan.deleteAllClimbWindsAndTemperatures();
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentWindSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a descent wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDescentWindDelete(ev);
    }
    /**
     * Handles descent wind delete events
     * @param ev the event
     */
    handleDescentWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteDescentWind(ev.altitude);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentTemperatureSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the descent wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getDescentWindsAndTemperatures();
    }
    /**
     * Deletes all descent wind records
     * @param planIndex Flight Plan index
     */
    deleteAllDescentWindsAndTemperatures(planIndex) {
        const ev = {
            planIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_all_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDeleteAllDescentWindsAndTemperatures(ev);
    }
    /**
     * Handles delete all descent wind events
     * @param ev the event
     */
    handleDeleteAllDescentWindsAndTemperatures(ev) {
        const plan = this.getPlan(ev.planIndex);
        plan.deleteAllDescentWindsAndTemperatures();
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(planIndex, globalLegIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegWindSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegWind(ev.globalLegIndex, ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg wind record
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(planIndex, globalLegIndex, altitude) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegWindDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegWind(ev.globalLegIndex, ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Deletes all leg wind records for a given altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_altitude_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegAltitudeDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegAltitudeDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegAltitude(ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the wind records for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegWinds(globalLegIndex);
    }
    /**
     * Deletes all leg wind records
     * @param planIndex Flight Plan index
     */
    deleteAllLegWindsAndTemperatures(planIndex) {
        const ev = {
            planIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_all_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDeleteAllLegWindsAndTemperatures(ev);
    }
    /**
     * Handles delete all leg wind events
     * @param ev the event
     */
    handleDeleteAllLegWindsAndTemperatures(ev) {
        const plan = this.getPlan(ev.planIndex);
        plan.deleteAllLegWindsAndTemperatures();
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(planIndex, globalLegIndex, altitude, temperature = null) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegTempSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegTempSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegTemperature(ev.globalLegIndex, ev.altitude, ev.temperature);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg temperature record,
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(planIndex, globalLegIndex) {
        const ev = {
            planIndex,
            globalLegIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegTempDelete(ev);
    }
    /**
     * Handles leg temperature delete events
     * @param ev the event
     */
    handleLegTempDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegTemperature(ev.globalLegIndex);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the temperature record for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns A temperature record if one exists, else undefined
     */
    getLegTemperature(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegTemperature(globalLegIndex);
    }
    /**
     * Clears all data from a wind plan.
     * Note: this will happen automatically when a flight plan is deleted.
     * @param planIndex Flight Plan index
     */
    clearPlan(planIndex) {
        this.deleteAllClimbWindsAndTemperatures(planIndex);
        this.deleteAllDescentWindsAndTemperatures(planIndex);
        this.deleteAllLegWindsAndTemperatures(planIndex);
    }
    /**
     * Handles flight plan creation events
     * @param data Event Data
     */
    onPlanCreated(data) {
        this.plans[data.planIndex] = new WindPlan(this.options);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handle flight plan copy events by copying related wind data
     * @param data Event Data
     */
    onPlanCopied(data) {
        const targetPlan = this.plans[data.targetPlanIndex];
        const fromPlan = this.plans[data.planIndex];
        if (!targetPlan || !fromPlan) {
            console.error('WindPlanner: failed to copy plan!');
            return;
        }
        targetPlan.copyFrom(fromPlan);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handles flight plan load events
     * @param data Event Data
     */
    onPlanLoaded(data) {
        const flightPlan = this.flightPlanner.getFlightPlan(data.planIndex);
        if (!flightPlan) {
            this.plans[data.planIndex] = undefined;
            return;
        }
        this.plans[data.planIndex] = new WindPlan(this.options, flightPlan.length);
    }
    /**
     * Handles flight plan deletion events
     * @param data Event Data
     */
    onPlanDeleted(data) {
        this.plans[data.planIndex] = undefined;
    }
    /**
     * Handles flight plan segment change events
     * @param data Event Data
     */
    onSegmentChanged(data) {
        var _a, _b;
        const windPlan = this.plans[data.planIndex];
        if (!windPlan) {
            return;
        }
        switch (data.type) {
            case SegmentEventType.Removed:
                for (let i = 0; i < ((_b = (_a = data.segment) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0); i++) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    windPlan.deleteLeg(data.segment.offset);
                }
                break;
            case SegmentEventType.Changed:
            // fall through, airway changes don't matter to us
            case SegmentEventType.Added:
            case SegmentEventType.Inserted:
            default:
                // nothing we need to do for these as they don't add or remove legs
                return;
        }
    }
    /**
     * Handles flight plan leg change events
     * @param data Event Data
     */
    onLegChanged(data) {
        const globalLegIndex = WindPlanner.getGlobalLegIndex(this.flightPlanner.getFlightPlan(data.planIndex), data.segmentIndex, data.legIndex);
        const plan = this.plans[data.planIndex];
        if (!plan) {
            console.warn('onLegChanged, but the flightplan doesn\'t exist!');
            return;
        }
        switch (data.type) {
            case LegEventType.Added:
                plan.insertLegAndPropagate(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
            case LegEventType.Removed:
                plan.deleteLeg(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
        }
    }
    /**
     * Get a flight plan or error if it doesn't exist
     * @param planIndex Flight Plan index
     * @throws if flight plan doesn't exist
     * @returns FlightPlan
     */
    getPlan(planIndex) {
        const plan = this.plans[planIndex];
        if (plan === undefined) {
            throw new Error(`WindPlanner: wind plan ${planIndex} does not exist!`);
        }
        return plan;
    }
    /**
     * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param segmentIndex The Segment Index.
     * @param segmentLegIndex The Segment Leg Index.
     * @returns The global leg index.
     */
    static getGlobalLegIndex(lateralPlan, segmentIndex, segmentLegIndex) {
        if (segmentIndex < lateralPlan.segmentCount) {
            const segment = lateralPlan.getSegment(segmentIndex);
            return segment.offset + segmentLegIndex;
        }
        return -1;
    }
    /**
     * Check if all the available leg altitudes are already used
     * @param planIndex Flight Plan index
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed(planIndex) {
        const plan = this.getPlan(planIndex);
        return plan.areAllLegAltitudesUsed();
    }
    /**
     * Get the number of leg wind altitudes permitted
     * @returns the maximum number of leg wind altitudes, or undefined if no limit
     */
    getNumberOfLegAltitudes() {
        return this.options.numberOfLegAltitudes;
    }
    /**
     * Get the number of climb wind altitudes permitted
     * @returns the maximum number of climb wind altitudes, or undefined if no limit
     */
    getNumberOfClimbAltitudes() {
        return this.options.numberOfClimbAltitudes;
    }
    /**
     * Get the number of descent wind altitudes permitted
     * @returns the maximum number of climb wind altitudes, or undefined if no limit
     */
    getNumberOfDescentAltitudes() {
        return this.options.numberOfDescentAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.legHasNonPropagatedWind(globalLegIndex);
    }
}

// TODO consider average wind entry instead of individual winds
/** Wind Planner that interpolates live wind data along the route for a Boeing FMS */
class InterpolatingWindPlanner extends WindPlanner {
    /**
     * Constructs an InterpolatingWindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        super(bus, flightPlanner, options);
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.vec2Cache = [Vec2Math.create(), Vec2Math.create(), Vec2Math.create()];
        this.filteredLiveWind = Vec2Math.create();
        /** sim wind direction in degrees true */
        this.liveWindDirection = ConsumerValue.create(null, 0);
        /** sim wind speed in knots */
        this.liveWindSpeed = ConsumerValue.create(null, 0);
        /** plane altitude in feet */
        this.planeAltitude = ConsumerValue.create(null, 0);
        /** plane is on the ground */
        this.onGround = ConsumerValue.create(null, true);
        /** static/outside air temperature in degrees celsius */
        this.staticAirTemperature = ConsumerValue.create(null, 0);
        this.filteredCache = [];
        const sub = this.bus.getSubscriber();
        this.liveWindDirection.setConsumer(sub.on('ambient_wind_direction').withPrecision(0));
        this.liveWindSpeed.setConsumer(sub.on('ambient_wind_velocity').withPrecision(0));
        this.planeAltitude.setConsumer(sub.on('indicated_alt').withPrecision(-2));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.staticAirTemperature.setConsumer(sub.on('ambient_temp_c').withPrecision(0));
        sub.on('simTime').atFrequency(1).handle(this.updateLiveWind.bind(this));
    }
    /** Apply an IIR filter to the live wind */
    updateLiveWind() {
        Vec2Math.setFromPolar(this.liveWindSpeed.get(), UnitType.RADIAN.convertFrom(this.liveWindDirection.get(), UnitType.DEGREE), this.vec2Cache[0]);
        Vec2Math.multScalar(this.vec2Cache[0], 0.1, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 0.9, this.filteredLiveWind);
        Vec2Math.add(this.filteredLiveWind, this.vec2Cache[0], this.filteredLiveWind);
    }
    /**
     * Transform a cartesian wind vector to polar direction/speed
     * @param vector Cartesian wind vector or null if no vector
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    windVectorToDirectionSpeed(vector, out) {
        if (vector === null) {
            return null;
        }
        out[0] = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Vec2Math.theta(vector), UnitType.DEGREE));
        out[1] = Vec2Math.abs(vector);
        return out;
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO Does the Boeing use climb and/or descent wind if no leg winds?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.tryGetLeg(globalLegIndex);
        if (!fpLeg) {
            return null;
        }
        /** Stored in this.vec2Cache[0] */
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        /** proportion of live wind to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        Vec2Math.multScalar(forecastWind, 1 - k, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
        return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedWindAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        const wind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get the wind at a given altitude on a given leg
     * @param windPlan The wind plan to use
     * @param globalLegIndex The global index of the desired leg
     * @param altitude Altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getLegWindAtAltitude(windPlan, globalLegIndex, altitude, out) {
        const legWinds = windPlan.getLegWinds(globalLegIndex);
        if (legWinds === undefined) {
            return null;
        }
        return this.getAltitudeInterpolatedWind(legWinds, altitude, out);
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(climbWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = this.vec2Cache[0][0];
        out[1] = this.vec2Cache[0][1];
        return out;
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedClimbWind(planIndex, altitude, liveWind, out) {
        const wind = this.getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get a descent wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedDescentWind(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const desWinds = windPlan.getDescentWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(desWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = UnitType.RADIAN.convertTo(Vec2Math.theta(this.vec2Cache[0]), UnitType.DEGREE);
        out[1] = Vec2Math.abs(this.vec2Cache[0]);
        return out;
    }
    /**
     * Get the wind at a given altitude from a WindRecord, interpolated when it lies between altitudes for which wind is defined
     * Caution: clobbers first 2 elements of this.vec2Cache
     * @param winds Wind records to use
     * @param altitude Desired altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getAltitudeInterpolatedWind(winds, altitude, out) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < winds.length; i++) {
            const wind = winds[i];
            if (wind.direction !== null && wind.speed !== null) {
                this.filteredCache[index++] = wind;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredWinds = this.filteredCache;
        if (filteredWinds.length < 1) {
            return null;
        }
        if (filteredWinds.length === 1 || altitude >= filteredWinds[0].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[0].speed, UnitType.RADIAN.convertFrom(filteredWinds[0].direction, UnitType.DEGREE), out);
        }
        if (altitude <= filteredWinds[filteredWinds.length - 1].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[filteredWinds.length - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[filteredWinds.length - 1].direction, UnitType.DEGREE), out);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredWinds.length; i++) {
            if (filteredWinds[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper wind to take */
            const k = (altitude - filteredWinds[i].altitude) / (filteredWinds[i - 1].altitude - filteredWinds[i].altitude);
            const windUpper = Vec2Math.setFromPolar(filteredWinds[i - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[i - 1].direction, UnitType.DEGREE), this.vec2Cache[0]);
            const windLower = Vec2Math.setFromPolar(filteredWinds[i].speed, UnitType.RADIAN.convertFrom(filteredWinds[i].direction, UnitType.DEGREE), this.vec2Cache[1]);
            Vec2Math.multScalar(windUpper, k, this.vec2Cache[0]);
            Vec2Math.multScalar(windLower, 1 - k, this.vec2Cache[1]);
            return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
        }
        return null;
    }
    /**
     * Get the ISA delta temperature interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @returns ISA temperature delta in °C or null if no data
     */
    getInterpolatedIsaDeltaAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO use climb and/or descent temp if no leg temp?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.getLeg(globalLegIndex);
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        const legTemp = windPlan.getLegTemperature(globalLegIndex);
        if (legTemp === undefined || legTemp.temperature === null) {
            return null;
        }
        /** proportion of live data to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        const isaTemp = this.isaTemperatureFeet(altitude);
        const interpolatedTemp = k * this.staticAirTemperature.get() + (1 - k) * legTemp.temperature;
        return interpolatedTemp - isaTemp;
    }
    /**
     * Get a climb ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedClimbIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(climbWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get a descent ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedDescentIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const descentWinds = windPlan.getDescentWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(descentWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get the ISA temperature delta at a given altitude from a WindAndTemperatureRecord,
     * interpolated when it lies between altitudes for which temperature is defined
     * @param temps Wind/Temperature records to use
     * @param altitude Desired altitude in feet MSL
     * @returns An ISA delta in °C or null if unavailable
     */
    getAltitudeInterpolatedIsaDelta(temps, altitude) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < temps.length; i++) {
            const temp = temps[i];
            if (temp.temperature !== null) {
                this.filteredCache[index++] = temp;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredTemps = this.filteredCache;
        if (filteredTemps.length < 1) {
            return null;
        }
        if (filteredTemps.length === 1 || altitude >= filteredTemps[0].altitude) {
            return filteredTemps[0].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        else if (altitude <= filteredTemps[filteredTemps.length - 1].altitude) {
            return filteredTemps[filteredTemps.length - 1].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredTemps.length; i++) {
            if (filteredTemps[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper temperature to take */
            const k = (altitude - filteredTemps[i].altitude) / (filteredTemps[i - 1].altitude - filteredTemps[i].altitude);
            // we have filtered out null temps above, but the linter isn't quite smart enough to figure that out
            const upperIsaDelta = filteredTemps[i - 1].temperature - this.isaTemperatureFeet(filteredTemps[i - 1].altitude);
            const lowerIsaDelta = filteredTemps[i].temperature - this.isaTemperatureFeet(filteredTemps[i].altitude);
            return k * upperIsaDelta + (1 - k) * lowerIsaDelta;
        }
        return null;
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a distance from the aircraft
     * @param distance distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportion(distance) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        if (distance < 277800) {
            return 1 - 1 / 3 * (distance / 277800) ** 2;
        }
        return 2 / 3 * (Math.E ** (-5 * ((distance - 277800) / 1852000)));
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a height from the aircraft
     * @param height vertical distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportionHeight(height) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        // 243.045 = 6076.12 feet/NM / (17500 ft / 700 NM), the latter from FMS documentation
        return this.getLiveDataProportion(Math.abs(height) * 243.045);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Calculate the wind speed for the ECON speed calculation.
     * Before takeoff, when planning the flight, this shall be taken from the wind plan.
     * Once flying at cruise flight level, ECON speed controls the AT so we want to base the calculation
     * on the actual live wind.
     * @param planIndex Flight Plan index
     * @param cruiseAltitude Planned cruise altitude
     * @param globalLegIndex Index of active leg
     * @param distanceAlongLeg Distance along the active leg
     * @param trueHeading Heading of the aircraft, degree
     * @returns Headwind component (knots)
     */
    getHeadwindForEconSpeedCalculation(planIndex, cruiseAltitude, globalLegIndex, distanceAlongLeg, trueHeading) {
        // Retrieve planned wind (first wind along leg, if unavailble climb wind).
        let planWind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, distanceAlongLeg, this.vec2Cache[2]);
        if (planWind === null) {
            planWind = this.getInterpolatedClimbWindCartesian(planIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, true, this.vec2Cache[2]);
        }
        if (planWind === null) {
            planWind = this.vec2Cache[2];
            this.vec2Cache[2][0] = 0;
            this.vec2Cache[2][1] = 0;
        }
        // Blend gradually between planned wind and live wind using 100% live wind @(plane alt = cruiseAlt) 
        // and 100% planned wind @(alt deviates 500ft or more from cruise alt):
        const planWindProportion = Math.min(1, Math.abs(cruiseAltitude - this.planeAltitude.get()) / 500);
        Vec2Math.multScalar(planWind, planWindProportion, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 1 - planWindProportion, this.vec2Cache[1]);
        Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        // Create unit vector in heading direction:
        Vec2Math.setFromPolar(1, UnitType.RADIAN.convertFrom(trueHeading, UnitType.DEGREE), this.vec2Cache[1]);
        // The dot product returns the projected length of the wind vector onto the heading (unit) vector:
        return VecNMath.dot(this.vec2Cache[0], this.vec2Cache[1]);
    }
}
InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT = (a, b) => b.altitude - a.altitude;

/**
 * For the calculation of the takeoff performance, called from the EFB:
 */
class B787TakeoffCalculator {
    /**
     * Constructs a B787 takeoff calculator.
     * @param vSpeedData Speed data provider to retrieve the V speeds.
     */
    constructor(vSpeedData) {
        this.vSpeedData = vSpeedData;
        this.dryRwyLengthSlopeCorrection = new LerpLookupTable([
            [1200, 1200, 0], [1190, 1200, 0.5], [1170, 1200, 1], [1160, 1200, 1.5], [1140, 1200, 2],
            [1420, 1400, -2], [1420, 1400, -1.5], [1410, 1400, -1], [1410, 1400, -.5], [1400, 1400, 0], [1380, 1400, 0.5], [1350, 1400, 1], [1330, 1400, 1.5], [1300, 1400, 2],
            [1640, 1600, -2], [1630, 1600, -1.5], [1620, 1600, -1], [1610, 1600, -.5], [1600, 1600, 0], [1560, 1600, 0.5], [1530, 1600, 1], [1490, 1600, 1.5], [1460, 1600, 2],
            [1860, 1800, -2], [1850, 1800, -1.5], [1830, 1800, -1], [1820, 1800, -.5], [1800, 1800, 0], [1750, 1800, 0.5], [1710, 1800, 1], [1660, 1800, 1.5], [1610, 1800, 2],
            [2080, 2000, -2], [2060, 2000, -1.5], [2040, 2000, -1], [2020, 2000, -.5], [2000, 2000, 0], [1940, 2000, 0.5], [1890, 2000, 1], [1830, 2000, 1.5], [1770, 2000, 2],
            [2300, 2200, -2], [2280, 2200, -1.5], [2250, 2200, -1], [2230, 2200, -.5], [2200, 2200, 0], [2130, 2200, 0.5], [2060, 2200, 1], [2000, 2200, 1.5], [1930, 2200, 2],
            [2520, 2400, -2], [2490, 2400, -1.5], [2460, 2400, -1], [2430, 2400, -.5], [2400, 2400, 0], [2320, 2400, 0.5], [2240, 2400, 1], [2160, 2400, 1.5], [2090, 2400, 2],
            [2740, 2600, -2], [2710, 2600, -1.5], [2670, 2600, -1], [2640, 2600, -.5], [2600, 2600, 0], [2510, 2600, 0.5], [2420, 2600, 1], [2330, 2600, 1.5], [2240, 2600, 2],
            [2960, 2800, -2], [2920, 2800, -1.5], [2880, 2800, -1], [2840, 2800, -.5], [2800, 2800, 0], [2700, 2800, 0.5], [2600, 2800, 1], [2500, 2800, 1.5], [2400, 2800, 2],
            [3180, 3000, -2], [3130, 3000, -1.5], [3090, 3000, -1], [3050, 3000, -.5], [3000, 3000, 0], [2890, 3000, 0.5], [2780, 3000, 1], [2670, 3000, 1.5], [2560, 3000, 2],
            [3400, 3200, -2], [3350, 3200, -1.5], [3300, 3200, -1], [3250, 3200, -.5], [3200, 3200, 0], [3080, 3200, 0.5], [2960, 3200, 1], [2840, 3200, 1.5], [2710, 3200, 2],
            [3620, 3400, -2], [3570, 3400, -1.5], [3510, 3400, -1], [3460, 3400, -.5], [3400, 3400, 0], [3270, 3400, 0.5], [3140, 3400, 1], [3000, 3400, 1.5], [2870, 3400, 2],
            [3840, 3600, -2], [3780, 3600, -1.5], [3720, 3600, -1], [3660, 3600, -.5], [3600, 3600, 0], [3460, 3600, 0.5], [3310, 3600, 1], [3170, 3600, 1.5], [3030, 3600, 2],
            [4060, 3800, -2], [4000, 3800, -1.5], [3930, 3800, -1], [3870, 3800, -.5], [3800, 3800, 0], [3650, 3800, 0.5], [3490, 3800, 1], [3340, 3800, 1.5], [3190, 3800, 2],
            [4280, 4000, -2], [4210, 4000, -1.5], [4140, 4000, -1], [4070, 4000, -.5], [4000, 4000, 0], [3840, 4000, 0.5], [3670, 4000, 1], [3510, 4000, 1.5], [3340, 4000, 2],
            [4500, 4200, -2], [4430, 4200, -1.5], [4350, 4200, -1], [4280, 4200, -.5], [4200, 4200, 0], [4030, 4200, 0.5], [3850, 4200, 1], [3680, 4200, 1.5], [3500, 4200, 2],
            [4720, 4400, -2], [4640, 4400, -1.5], [4560, 4400, -1], [4480, 4400, -.5], [4400, 4400, 0], [4210, 4400, 0.5], [4030, 4400, 1], [3840, 4400, 1.5], [3660, 4400, 2],
            [4940, 4600, -2], [4860, 4600, -1.5], [4770, 4600, -1], [4690, 4600, -.5], [4600, 4600, 0], [4400, 4600, 0.5], [4210, 4600, 1], [4010, 4600, 1.5], [3810, 4600, 2],
            [5160, 4800, -2], [5070, 4800, -1.5], [4980, 4800, -1], [4890, 4800, -.5], [4800, 4800, 0], [4590, 4800, 0.5], [4390, 4800, 1], [4180, 4800, 1.5], [3970, 4800, 2],
            [5380, 5000, -2], [5290, 5000, -1.5], [5190, 5000, -1], [5100, 5000, -.5], [5000, 5000, 0], [4780, 5000, 0.5], [4560, 5000, 1], [4350, 5000, 1.5], [4130, 5000, 2] // Available field length 5000m
        ]);
        this.wetRwyLengthSlopeCorrection = new LerpLookupTable([
            [2080, 2000, -2], [2060, 2000, -1.5], [2040, 2000, -1], [2020, 2000, -.5], [2000, 2000, 0], [1940, 2000, 0.5], [1880, 2000, 1], [1830, 2000, 1.5], [1770, 2000, 2],
            [2300, 2200, -2], [2280, 2200, -1.5], [2250, 2200, -1], [2230, 2200, -.5], [2200, 2200, 0], [2130, 2200, 0.5], [2070, 2200, 1], [2000, 2200, 1.5], [1930, 2200, 2],
            [2520, 2400, -2], [2490, 2400, -1.5], [2460, 2400, -1], [2430, 2400, -.5], [2400, 2400, 0], [2330, 2400, 0.5], [2250, 2400, 1], [2180, 2400, 1.5], [2100, 2400, 2],
            [2740, 2600, -2], [2710, 2600, -1.5], [2670, 2600, -1], [2640, 2600, -.5], [2600, 2600, 0], [2520, 2600, 0.5], [2430, 2600, 1], [2350, 2600, 1.5], [2270, 2600, 2],
            [2960, 2800, -2], [2920, 2800, -1.5], [2880, 2800, -1], [2840, 2800, -.5], [2800, 2800, 0], [2710, 2800, 0.5], [2620, 2800, 1], [2530, 2800, 1.5], [2430, 2800, 2],
            [3180, 3000, -2], [3130, 3000, -1.5], [3090, 3000, -1], [3050, 3000, -.5], [3000, 3000, 0], [2900, 3000, 0.5], [2800, 3000, 1], [2700, 3000, 1.5], [2600, 3000, 2],
            [3400, 3200, -2], [3350, 3200, -1.5], [3300, 3200, -1], [3250, 3200, -.5], [3200, 3200, 0], [3090, 3200, 0.5], [2980, 3200, 1], [2880, 3200, 1.5], [2770, 3200, 2],
            [3620, 3400, -2], [3570, 3400, -1.5], [3510, 3400, -1], [3460, 3400, -.5], [3400, 3400, 0], [3280, 3400, 0.5], [3170, 3400, 1], [3050, 3400, 1.5], [2930, 3400, 2],
            [3840, 3600, -2], [3780, 3600, -1.5], [3720, 3600, -1], [3660, 3600, -.5], [3600, 3600, 0], [3480, 3600, 0.5], [3350, 3600, 1], [3230, 3600, 1.5], [3100, 3600, 2],
            [4060, 3800, -2], [4000, 3800, -1.5], [3930, 3800, -1], [3870, 3800, -.5], [3800, 3800, 0], [3670, 3800, 0.5], [3530, 3800, 1], [3400, 3800, 1.5], [3270, 3800, 2],
            [4280, 4000, -2], [4210, 4000, -1.5], [4140, 4000, -1], [4070, 4000, -.5], [4000, 4000, 0], [3860, 4000, 0.5], [3720, 4000, 1], [3580, 4000, 1.5], [3430, 4000, 2],
            [4500, 4200, -2], [4430, 4200, -1.5], [4350, 4200, -1], [4280, 4200, -.5], [4200, 4200, 0], [4050, 4200, 0.5], [3900, 4200, 1], [3750, 4200, 1.5], [3600, 4200, 2],
            [4720, 4400, -2], [4640, 4400, -1.5], [4560, 4400, -1], [4480, 4400, -.5], [4400, 4400, 0], [4240, 4400, 0.5], [4080, 4400, 1], [3930, 4400, 1.5], [3770, 4400, 2],
            [4940, 4600, -2], [4860, 4600, -1.5], [4770, 4600, -1], [4690, 4600, -.5], [4600, 4600, 0], [4430, 4600, 0.5], [4270, 4600, 1], [4100, 4600, 1.5], [3930, 4600, 2],
            [5160, 4800, -2], [5070, 4800, -1.5], [4980, 4800, -1], [4890, 4800, -.5], [4800, 4800, 0], [4630, 4800, 0.5], [4450, 4800, 1], [4270, 4800, 1.5], [4100, 4800, 2],
            [5380, 5000, -2], [5290, 5000, -1.5], [5190, 5000, -1], [5100, 5000, -.5], [5000, 5000, 0], [4820, 5000, 0.5], [4630, 5000, 1], [4450, 5000, 1.5], [4270, 5000, 2] // Available field length 5000m
        ]);
        this.dryRwyLengthHeadwindCorrection = new LerpLookupTable([
            [370, 1200, -15], [650, 1200, -10], [920, 1200, -5], [1200, 1200, 0], [1250, 1200, 10], [1310, 1200, 20], [1390, 1200, 30], [1490, 1200, 40],
            [570, 1400, -15], [850, 1400, -10], [1120, 1400, -5], [1400, 1400, 0], [1460, 1400, 10], [1530, 1400, 20], [1610, 1400, 30], [1710, 1400, 40],
            [770, 1600, -15], [1050, 1600, -10], [1320, 1600, -5], [1600, 1600, 0], [1660, 1600, 10], [1740, 1600, 20], [1830, 1600, 30], [1930, 1600, 40],
            [970, 1800, -15], [1240, 1800, -10], [1520, 1800, -5], [1800, 1800, 0], [1870, 1800, 10], [1950, 1800, 20], [2040, 1800, 30], [2150, 1800, 40],
            [1160, 2000, -15], [1440, 2000, -10], [1720, 2000, -5], [2000, 2000, 0], [2080, 2000, 10], [2160, 2000, 20], [2260, 2000, 30], [2370, 2000, 40],
            [1360, 2200, -15], [1640, 2200, -10], [1920, 2200, -5], [2200, 2200, 0], [2280, 2200, 10], [2280, 2200, 20], [2480, 2200, 30], [2590, 2200, 40],
            [1560, 2400, -15], [1840, 2400, -10], [2120, 2400, -5], [2400, 2400, 0], [2490, 2400, 10], [2590, 2400, 20], [2700, 2400, 30], [2810, 2400, 40],
            [1760, 2600, -15], [2040, 2600, -10], [2320, 2600, -5], [2600, 2600, 0], [2700, 2600, 10], [2800, 2600, 20], [2910, 2600, 30], [3030, 2600, 40],
            [1960, 2800, -15], [2240, 2800, -10], [2520, 2800, -5], [2800, 2800, 0], [2900, 2800, 10], [3010, 2800, 20], [3130, 2800, 30], [3250, 2800, 40],
            [2160, 3000, -15], [2440, 3000, -10], [2720, 3000, -5], [3000, 3000, 0], [3110, 3000, 10], [3230, 3000, 20], [3350, 3000, 30], [3480, 3000, 40],
            [2350, 3200, -15], [2640, 3200, -10], [2920, 3200, -5], [3200, 3200, 0], [3320, 3200, 10], [3440, 3200, 20], [3560, 3200, 30], [3700, 3200, 40],
            [2550, 3400, -15], [2830, 3400, -10], [3120, 3400, -5], [3400, 3400, 0], [3520, 3400, 10], [3650, 3400, 20], [3780, 3400, 30], [3920, 3400, 40],
            [2750, 3600, -15], [3030, 3600, -10], [3320, 3600, -5], [3600, 3600, 0], [3730, 3600, 10], [3860, 3600, 20], [4000, 3600, 30], [4140, 3600, 40],
            [2950, 3800, -15], [3230, 3800, -10], [3520, 3800, -5], [3800, 3800, 0], [3940, 3800, 10], [4080, 3800, 20], [4220, 3800, 30], [4360, 3800, 40],
            [3150, 4000, -15], [3430, 4000, -10], [3720, 4000, -5], [4000, 4000, 0], [4140, 4000, 10], [4290, 4000, 20], [4430, 4000, 30], [4580, 4000, 40],
            [3350, 4200, -15], [3630, 4200, -10], [3920, 4200, -5], [4200, 4200, 0], [4350, 4200, 10], [4500, 4200, 20], [4650, 4200, 30], [4800, 4200, 40],
            [3540, 4400, -15], [3830, 4400, -10], [4110, 4400, -5], [4400, 4400, 0], [4560, 4400, 10], [4710, 4400, 20], [4870, 4400, 30], [5020, 4400, 40],
            [3740, 4600, -15], [4030, 4600, -10], [4310, 4600, -5], [4600, 4600, 0], [4760, 4600, 10], [4930, 4600, 20], [5080, 4600, 30], [5340, 4600, 40],
            [3940, 4800, -15], [4230, 4800, -10], [4510, 4800, -5], [4800, 4800, 0], [4970, 4800, 10], [5140, 4800, 20], [5300, 4800, 30], [5460, 4800, 40],
            [4140, 5000, -15], [4430, 5000, -10], [4710, 5000, -5], [5000, 5000, 0], [5180, 5000, 10], [5350, 5000, 20], [5520, 5000, 30], [5680, 5000, 40], // Available field length 5000m
        ]);
        this.wetRwyLengthHeadwindCorrection = new LerpLookupTable([
            [140, 2000, -15], [760, 2000, -10], [1380, 2000, -5], [2000, 2000, 0], [2100, 2000, 10], [2190, 2000, 20], [2290, 2000, 30], [2380, 2000, 40],
            [400, 2200, -15], [1000, 2200, -10], [1600, 2200, -5], [2200, 2200, 0], [2300, 2200, 10], [2400, 2200, 20], [2500, 2200, 30], [2600, 2200, 40],
            [660, 2400, -15], [1240, 2400, -10], [1820, 2400, -5], [2400, 2400, 0], [2510, 2400, 10], [2610, 2400, 20], [2720, 2400, 30], [2820, 2400, 40],
            [920, 2600, -15], [1480, 2600, -10], [2040, 2600, -5], [2600, 2600, 0], [2710, 2600, 10], [2820, 2600, 20], [2930, 2600, 30], [3040, 2600, 40],
            [1180, 2800, -15], [1720, 2800, -10], [2260, 2800, -5], [2800, 2800, 0], [2920, 2800, 10], [3030, 2800, 20], [3150, 2800, 30], [3260, 2800, 40],
            [1440, 3000, -15], [1960, 3000, -10], [2480, 3000, -5], [3000, 3000, 0], [3120, 3000, 10], [3240, 3000, 20], [3360, 3000, 30], [3480, 3000, 40],
            [1700, 3200, -15], [2200, 3200, -10], [2700, 3200, -5], [3200, 3200, 0], [3330, 3200, 10], [3450, 3200, 20], [3580, 3200, 30], [3700, 3200, 40],
            [1960, 3400, -15], [2440, 3400, -10], [2920, 3400, -5], [3400, 3400, 0], [3530, 3400, 10], [3660, 3400, 20], [3790, 3400, 30], [3920, 3400, 40],
            [2220, 3600, -15], [2680, 3600, -10], [3140, 3600, -5], [3600, 3600, 0], [3740, 3600, 10], [3870, 3600, 20], [4010, 3600, 30], [4140, 3600, 40],
            [2480, 3800, -15], [2920, 3800, -10], [3360, 3800, -5], [3800, 3800, 0], [3940, 3800, 10], [4080, 3800, 20], [4220, 3800, 30], [4360, 3800, 40],
            [2740, 4000, -15], [3160, 4000, -10], [3580, 4000, -5], [4000, 4000, 0], [4150, 4000, 10], [4290, 4000, 20], [4440, 4000, 30], [4780, 4000, 40],
            [3000, 4200, -15], [3400, 4200, -10], [3800, 4200, -5], [4200, 4200, 0], [4350, 4200, 10], [4500, 4200, 20], [4650, 4200, 30], [4800, 4200, 40],
            [3260, 4400, -15], [3640, 4400, -10], [4020, 4400, -5], [4400, 4400, 0], [4560, 4400, 10], [4710, 4400, 20], [4870, 4400, 30], [5020, 4400, 40],
            [3520, 4600, -15], [3880, 4600, -10], [4240, 4600, -5], [4600, 4600, 0], [4760, 4600, 10], [4920, 4600, 20], [5080, 4600, 30], [5240, 4600, 40],
            [3780, 4800, -15], [4120, 4800, -10], [4460, 4800, -5], [4800, 4800, 0], [4970, 4800, 10], [5130, 4800, 20], [5300, 4800, 30], [5460, 4800, 40],
            [4040, 5000, -15], [4360, 5000, -10], [4680, 5000, -5], [5000, 5000, 0], [5170, 5000, 10], [5340, 5000, 20], [5510, 5000, 30], [5680, 5000, 40], // Available field length 5000m
        ]);
    }
    /**
     * Returns the takeoff performance parameter for a given set of input data.
     * @param toRwy                         Takeoff runway
     * @param rwyCondition                  Runway condition
     * @param windDirection                 Wind direction, from where the wind is coming from [°]
     * @param windVelocity                  Wind speed [kts]
     * @param oat                           Outside air temperature [°C]
     * @param qnh                           The QNH altimeter setting at the runway, in hectopascals.
     * @param requestedThrustRating         Selected thrust rating, could be OPTIMUM
     * @param requestedAssumedTemperature   Selected assumed temperature [°C], 0 if MAX (retrieve optimum), neg. if to be subtracted from MAX
     * @param requestedFlapSetting          Selected flaps position, could be OPTIMUM
     * @param requestedAntiIce              Selected anti ice option
     * @param takeoffWeight                 Selected takeoff weight, if 0 -> calculation of max possible takeoff weight, in pounds
     * @returns []
     */
    getTakeoffPerformanceData(toRwy, rwyCondition, windDirection, windVelocity, oat, qnh, requestedThrustRating, requestedAssumedTemperature, requestedFlapSetting, requestedAntiIce, takeoffWeight) {
        // Return variables:
        let isPossible = false;
        let determinedMaxTakeoffWeight = 0;
        let determinedThrustRating = requestedThrustRating;
        let determinedAssumedTemperature = 0;
        const resultArray = [];
        // Helper variables:
        
        const rwyPressureAlt = toRwy.elevation - AeroMath.baroPressureAltitudeOffset(qnh);
        const rwyPressureAltFeet = UnitType.METER.convertTo(rwyPressureAlt, UnitType.FOOT);
        const tempDeviationVsIsaDay = oat - AeroMath.isaTemperature(rwyPressureAlt);
        const initialOat = oat;
// Determine a breaking action coefficient for a given rwy condition based on the table on page 849:
        //     coefficient -> reported breaking action
        //     6 -> Dry
        //     5 -> Good
        //     4 -> Good to Medium
        //     3 -> Medium
        //     2 -> Medium to Poor
        //     1 -> Poor
        //     0 -> Nil
        // Based on FCOM or https://www.icao.int/safety/SiteAssets/Pages/GRF/RCAM%20Poster_v1.0.pd
        let breakingActionCoefficient = 6; // For DRY
        switch (rwyCondition) {
            case EfbRunwayCondition.GOOD:
            case EfbRunwayCondition.WET:
                breakingActionCoefficient = 5;
                break;
            case EfbRunwayCondition.CMPCT_SNOW:
                if (oat <= -15) {
                    breakingActionCoefficient = 4;
                }
                else {
                    breakingActionCoefficient = 3;
                }
                break;
            case EfbRunwayCondition.MEDIUM:
            case EfbRunwayCondition.DRY_SNOW:
                breakingActionCoefficient = 3;
                break;
            case EfbRunwayCondition.SLUSH:
            case EfbRunwayCondition.STNDNG_WTR:
                breakingActionCoefficient = 2;
                break;
            case EfbRunwayCondition.POOR:
            case EfbRunwayCondition.ICE:
                breakingActionCoefficient = 1;
                break;
        }
        // Prepare the modes, for which we need to run the calculation:
        let calculableModes = [];
        if (takeoffWeight < 1) {
            // If the weight is not available as input, we fallback to a RTOW only calculation.
            calculableModes = [EFBTakeoffCalculationMode.RTOW];
        }
        else {
            // If the weight is available, all modes are calculated.
            // At first the ATM and FULL modes are calculated, return both if any of them is valid or fallback to RTOW otherwise.
            calculableModes = [EFBTakeoffCalculationMode.ATM, EFBTakeoffCalculationMode.FULL, EFBTakeoffCalculationMode.RTOW];
        }
        // The top level loop runs for each required calculation mode:
        for (const calculationMode of calculableModes) {
            isPossible = false;
            // First we condition the input parameter for each of the modes:
        let optimizeAssumedTemperature = false;
        switch (calculationMode) {
                case EFBTakeoffCalculationMode.ATM:
                    // ATM method is not allowed on contaminated runways (anything below good)
                    if (breakingActionCoefficient < 5) {
                        continue;
                    }
                    // For ATM, evaluate requestedAssumedTemperature to setup the calculation:
        if (requestedAssumedTemperature === undefined) {
            // If assumed temperature is not provided in the input, run the calculation with oat instead of it:
            determinedAssumedTemperature = oat;
        }
        else if (requestedAssumedTemperature >= 1) {
            // Positive user input, use directly as assumed temperature, don't enable the optimization:
            determinedAssumedTemperature = oat = requestedAssumedTemperature;
        }
        else {
            // For all the other input values (0: calculate atm, < 0: subtract as offset from calculated assumed temperature)
            // we simply run the atm optimization:
            optimizeAssumedTemperature = true;
        }
        break;
                case EFBTakeoffCalculationMode.FULL:
                    // For FULL, we want to calculate the same performance, just without the assumed temperature part.
            optimizeAssumedTemperature = false;
                    // User jon on Avsim (787 captain) confirmed that the FULL case also is using the TO rating.
                    requestedThrustRating = EFBTakeoffThrustMode.TO;
                    oat = initialOat;
                    determinedAssumedTemperature = 0;
        break;
                case EFBTakeoffCalculationMode.RTOW:
                    // For RTOW, disable assumed temperature and overwrite any OPTIMUM option:
                    optimizeAssumedTemperature = false;
                    if (requestedFlapSetting === OptimumRequest.OPTIMUM) {
            requestedFlapSetting = 20;
            }
            if (requestedThrustRating === EFBTakeoffThrustMode.OPTIMUM) {
                requestedThrustRating = EFBTakeoffThrustMode.TO;
            }
                    // We need one pass which will always be possible, therefore preempt the exit of the loop:
                    isPossible = true;
                    break;
        }
        // We run the following calculation steps:
        // 1. Obtain the field length corrections.
        // 1.1 Correct the runway length for any present slope:
        let rwyLengthSlopeCorrection;
        if (rwyCondition === EfbRunwayCondition.DRY) {
            rwyLengthSlopeCorrection = this.dryRwyLengthSlopeCorrection;
        }
        else {
            rwyLengthSlopeCorrection = this.wetRwyLengthSlopeCorrection;
        }
        const slopeCorrectedRwyLength = rwyLengthSlopeCorrection.get(toRwy.length, toRwy.gradient);
        // 1.2 Correct the runway length for headwind:
        const magVar = MagVar.get(toRwy.latitude, toRwy.longitude);
        const [headwind,] = BoeingAeroMath.calcRelativeWindComponents(toRwy.course - magVar, windVelocity, windDirection);
        let rwyLengthHeadwindCorrection;
        if (rwyCondition === EfbRunwayCondition.DRY) {
            rwyLengthHeadwindCorrection = this.dryRwyLengthHeadwindCorrection;
        }
        else {
            rwyLengthHeadwindCorrection = this.wetRwyLengthHeadwindCorrection;
        }
        const windAndSlopeCorrectedRwyLength = rwyLengthHeadwindCorrection.get(slopeCorrectedRwyLength, headwind);
        // 2. Limit runway length based on tire speed limit and brake energy limit:
        let tireSpeedAndBrakeLimitRwyLength;
        if (calculationMode !== EFBTakeoffCalculationMode.RTOW) {
            // Only possible, if take off weight has been specified:
            const tireSpeedAndBrakeEnergyLimitVsWeight = new LerpLookupTable([[4370, 0], [4380, 450000], [4870, 535000], [4690, 560000]]);
            tireSpeedAndBrakeLimitRwyLength = tireSpeedAndBrakeEnergyLimitVsWeight.get(takeoffWeight) - tempDeviationVsIsaDay * 3;
        }
        else {
            tireSpeedAndBrakeLimitRwyLength = 4570;
        }
        let correctedRwyLength = MathUtils.clamp(windAndSlopeCorrectedRwyLength, 0, tireSpeedAndBrakeLimitRwyLength);
        // We conclude the basic runway length calculation, by reducing the calculated length artificially by 10%. This provides the headroom
        // for unavoidable inaccuracies:
        correctedRwyLength *= 0.9;
        // 3. Correct runway length based on flap setting. If input was OPTIMUM loop over all flap settings:
        let calculableFlapPositions;
        if (requestedFlapSetting === OptimumRequest.OPTIMUM) {
            calculableFlapPositions = B787TakeoffCalculator.possibleFlapPositions;
        }
        else {
            calculableFlapPositions = [requestedFlapSetting];
        }
        const flapsRelatedRwyLengthReduction = new LerpLookupTable([[485, 5], [349, 10], [181, 15], [91, 17], [65, 18], [0, 20]]); // [m] vs flaps positions
                for (const flapPos of calculableFlapPositions) {
                        // For the simulation of lower flaps settings, the curve needs to be moved horizontally to the right. We therefore move the curve by
            // subtracting a flap setting-related constant from the x-value, which is rwy length:
            const fullyCorrectedRwyLength = correctedRwyLength - flapsRelatedRwyLengthReduction.get(flapPos);
            // 4. Get zero ref mtow:
            // Now we determine the zero reference MTOW from a spline interpolated curve, which is extracted from the airport planning
            // PDF.
            // The zero reference curve interpolates the highest possible MTOW for any given runway length. It applies to these conditions:
                // - Flaps 20
                // - At sealevel
                // - At the lowest charted temperature isa-temp
            const zeroReferenceMtow = this.getZeroReferenceCurve(fullyCorrectedRwyLength);
            // 5. Reduce zero ref mtow based on isaTempDeviation and pressurealt:
            // For this we apply a reduction value, which is empirically retrieved from the 8 Takeoff Runway Length Requirements-diagrams
            // from the 787-10 airport planning PDF.
            const isaTempAndPressAltMtowReductionTable = new LerpLookupTable(
            // The elements are: output (= mtow reduction due to temperature deviations from isatemp and pressureAltitude deviations from
            // sealevel) in [lb], isaTempDeviation [°C], rwyPressureAltFeet [ft]:
            [[0, 0, 0], [22500, 0, 2000], [53000, 0, 4000], [81000, 0, 6000], [108000, 0, 8000], [136000, 0, 10000], [166000, 0, 12000], [202500, 0, 14000],
                [11000, 15, 0], [33500, 15, 2000], [59500, 15, 4000], [88000, 15, 6000], [117500, 15, 8000], [145000, 15, 10000], [176000, 15, 12000], [203500, 15, 14000],
                [34500, 25, 0], [58000, 25, 2000], [80000, 25, 4000], [105000, 25, 6000], [131000, 25, 8000], [161000, 25, 10000], [194500, 25, 12000], [220000, 25, 14000],
                [68500, 34, 0], [89000, 34, 2000], [110000, 34, 4000], [131000, 34, 6000], [153500, 34, 8000], [184000, 34, 10000], [216000, 34, 12000], [240000, 34, 14000],
                // For the calculation of high assumed temperatures, we add another estimated row for ISA + 50:
                [200000, 50, 0], [230000, 50, 2000], [260000, 50, 4000], [290000, 50, 6000], [320000, 50, 8000], [350000, 50, 10000], [380000, 50, 12000], [410000, 50, 14000]]);
            const isaTempAndPressAltMtowReduction = isaTempAndPressAltMtowReductionTable.get(tempDeviationVsIsaDay, rwyPressureAltFeet);
            let athmosphereCorrectedMtow = zeroReferenceMtow - isaTempAndPressAltMtowReduction;
            // 6. Reduce mtow based on antiIce setting
            if (oat < 10) {
                if (requestedAntiIce !== EFBAntiIceSetting.OFF) {
                    athmosphereCorrectedMtow -= 331; // [lb], page 386 FCOM
                }
            }
            else if (10 <= oat && oat < 20) {
                if (requestedAntiIce === EFBAntiIceSetting.ENGINE) {
                    athmosphereCorrectedMtow -= 3307; // [lb]
                }
            }
            // 7. Reduce mtow based on rwy condition. We apply the coefficient, which has been determined above:
            const rwyConditionMtowReductionTable = new LerpLookupTable(
            // The elements are: output (= mtow reduction in [lb]), breaking action coefficient, achievable mtow [lb].
            // Based on the table in the FCOM on page 755, Slippery Runway Takeoff, Weight Adjustment, only column 5000ft
            [[0, 6, 573201], [0, 6, 418878], [0, 6, 264555],
                [12345, 5, 573201], [5291, 5, 418878], [3307, 5, 264555],
                [25794, 3, 573201], [18959, 3, 418878], [12787, 3, 264555],
                [72973, 1, 573201], [50045, 1, 418878], [30644, 1, 264555],
                // Estimated for nil breaking action:
                [25000, 0, 573201], [15000, 0, 418878], [10000, 0, 264555]] // breaking action 0
            );
            athmosphereCorrectedMtow -= rwyConditionMtowReductionTable.get(breakingActionCoefficient, athmosphereCorrectedMtow);
            // 8. TODO Get V1(MCG) limit weight based on rwy condition and corrected field length
            // 9. TODO Lower of 7 or 8 is mtow.
            // 10. Run thrust ratings considerations
            // The entire calculation so far covers the un-derated TO thrust rating. If requested, we now need to consider either one of the
            // two derated takeoff ratings TO-1 or TO-2 - or - if OPTIMUM is requested, we need to iterate over both, starting from the
            // lower, until the achievable mtow is larger than the takeoff weight of this flight.
            // Remember, we are still in the loop of all flaps settings, if OPTIMUM has been requested for the flaps as well. If for both
            // options OPTIMUM has been requested, we cycle as follows through them, until the achievable mtow is larger than
            // current weight:
            // flaps 5 -> TO-2 -> TO-1 -> TO -> flaps 10 -> TO-2 -> TO-1 -> TO -> .... (basically raise the achievable mtow from the lowest
            // possible value more and more until the current weight is lower).
            let calculableThrustRatings;
            if (requestedThrustRating === EFBTakeoffThrustMode.OPTIMUM) {
                calculableThrustRatings = [EFBTakeoffThrustMode.TO2, EFBTakeoffThrustMode.TO1, EFBTakeoffThrustMode.TO];
            }
            else {
                calculableThrustRatings = [requestedThrustRating];
            }
            // For the isaTempDeviation/pressureAlt-pairs from the above lerp table we have determined the mtow weight reductions for TO-1.
            // For TO-2 we will simply consider 1.3 times the mtow reduction which we obtain from this table.
            const deratedThrustMtowReduction = new LerpLookupTable(
            // The elements are: output (= mtow reduction due to TO-1 derating), isaTempDeviation, rwyPressureAltFeet:
            [[10000, 0, 0], [12000, 0, 2000], [10000, 0, 4000], [7000, 0, 6000], [6000, 0, 8000], [6000, 0, 10000], [5000, 0, 12000], [5000, 0, 14000],
                [9000, 15, 0], [10000, 15, 2000], [7000, 15, 4000], [5000, 15, 6000], [5000, 15, 8000], [4000, 15, 10000], [4000, 15, 12000], [4000, 15, 14000],
                [12000, 25, 0], [14000, 25, 2000], [12000, 25, 4000], [11000, 25, 6000], [10000, 25, 8000], [9000, 25, 10000], [8000, 25, 12000], [7000, 25, 14000],
                [9000, 34, 0], [10000, 34, 2000], [11000, 34, 4000], [10000, 34, 6000], [10000, 34, 8000], [9000, 34, 10000], [9000, 34, 12000], [8000, 34, 14000]] // ISA + 34
            );
            const deratedMtowReduction = deratedThrustMtowReduction.get(tempDeviationVsIsaDay, rwyPressureAltFeet);
            for (const thrustRating of calculableThrustRatings) {
                switch (thrustRating) {
                    case EFBTakeoffThrustMode.TO2:
                        determinedMaxTakeoffWeight = athmosphereCorrectedMtow - 1.3 * deratedMtowReduction;
                        break;
                    case EFBTakeoffThrustMode.TO1:
                        determinedMaxTakeoffWeight = athmosphereCorrectedMtow - deratedMtowReduction;
                        break;
                    case EFBTakeoffThrustMode.TO:
                        determinedMaxTakeoffWeight = athmosphereCorrectedMtow;
                        break;
                }
            // Now, let's cap the determined MTOW at the certified MTOW! Entering the calculation with a takeoff weight in excess of MTOW
                    // will then guarantee  to trigger the "takeoff weight allowed"-error:
                    determinedMaxTakeoffWeight = Math.min(560000, determinedMaxTakeoffWeight);
                if (determinedMaxTakeoffWeight > takeoffWeight) {
                    // We have found a configuration, which allows taking off!
                    isPossible = true;
                    determinedThrustRating = thrustRating;
                    if (optimizeAssumedTemperature) {
                        // Assumed temperature calculation:
                        // The assumed temperature is a hypothetical temperature, which allows a continuos thrust
                        // derating (basically achieving any thrust between TO - TO-1 - TO-2, and below TO-2). To calculate the assumed temperature,
                        // we start at tempDeviationVsIsaDay, increase it in iterations until the resulting athmosphereCorrectedMtow
                        // would become smaller than current takeoff weight. The max supported assumed temperature is 70°C.
                        let assumedTemperatureSupplement = 0;
                        while (determinedAssumedTemperature < 70) {
                            const isaTempAndPressAltMtowReductionAtAT = isaTempAndPressAltMtowReductionTable.get(tempDeviationVsIsaDay + assumedTemperatureSupplement, rwyPressureAltFeet);
                            const achieveableMtowAtAssumedTemp = determinedMaxTakeoffWeight - (isaTempAndPressAltMtowReductionAtAT - isaTempAndPressAltMtowReduction);
                            if (achieveableMtowAtAssumedTemp < takeoffWeight) {
                                determinedAssumedTemperature--; // Reduce the determined temp by 1 degree to match the last number, that worked
                                break;
                            }
                            determinedAssumedTemperature = tempDeviationVsIsaDay + assumedTemperatureSupplement + AeroMath.isaTemperature(rwyPressureAlt);
                            assumedTemperatureSupplement++;
                        }
                        // If assumed temperature is below oat+1 right away, the ATM mode is not possible:
                            if (determinedAssumedTemperature < oat + 1) {
                                isPossible = false;
                            }
                            else {
                                // Subtract any negative requested assumed temperature from the result but stay within in the oat+1...70°C range:
                                determinedAssumedTemperature = MathUtils.clamp(determinedAssumedTemperature + (requestedAssumedTemperature !== null && requestedAssumedTemperature !== void 0 ? requestedAssumedTemperature : 0), oat + 1, 70);
                            }
                        }
                    break;
                }
            }
            if (isPossible) {
                // A valid config is found, complete the data with the V speeds:
        let speedDataThrustMode = TakeoffThrustMode.TO;
        switch (determinedThrustRating) {
            case EFBTakeoffThrustMode.TO1:
                speedDataThrustMode = TakeoffThrustMode.TO1;
                break;
            case EFBTakeoffThrustMode.TO2:
                speedDataThrustMode = TakeoffThrustMode.TO2;
                break;
        }
        const vSpeeds = this.vSpeedData.getVSpeed(takeoffWeight, rwyPressureAltFeet, oat, flapPos, toRwy.gradient, headwind, speedDataThrustMode, rwyCondition !== EfbRunwayCondition.DRY);
        if (calculationMode === EFBTakeoffCalculationMode.RTOW) {
                        // For the RTOW case, the reported isPossible has a different meaning:
                        // It shall only be true, if no takeoffweight has been specified.
                        isPossible = (takeoffWeight < 1);
                    }
                    resultArray.push({
                        resultMode: calculationMode,
                        isPossible: isPossible,
                        assumedTemperatureOut: determinedAssumedTemperature,
                        thrustRatingOut: determinedThrustRating,
                        flapSettingOut: flapPos,
                        maxTakeoffWeightOut: (calculationMode === EFBTakeoffCalculationMode.RTOW) ? determinedMaxTakeoffWeight : takeoffWeight,
                        v1Out: vSpeeds.V1,
                        vrOut: vSpeeds.Vr,
                        v2Out: vSpeeds.V2
                    });
                    break;
                }
            }
            // Skip the RTOW calculation, if any of ATM or FULL support a takeoff:
            if (calculationMode === EFBTakeoffCalculationMode.FULL) {
                //As the order is ATM -> FULL -> RTOW, we know after the FULL calculation run, whether ATM or FULL have yielded a result:
                if (resultArray.length > 0) {
                    break;
                }
            }
        }
        return resultArray;
    }
    /**
     * Returns the maximum achievable takeoff weight (mtow) for a given runwaylength at the best possible conditions.
     * @param rwyLength [m]
     * @returns mtow [lbs]
     */
    getZeroReferenceCurve(rwyLength) {
        if (rwyLength < 1158) {
            return 307500;
        }
        else if (rwyLength < 1524) {
            return -0.00013844767560641807 * Math.pow(rwyLength, 3) + 0.4809672250566964 * Math.pow(rwyLength, 2) + -272.0207071591703 * rwyLength + 192526.82290303396;
        }
        else if (rwyLength < 2134) {
            return 0.000060317733551210726 * Math.pow(rwyLength, 3) + -0.4277882256119825 * Math.pow(rwyLength, 2) + 1112.9225996598964 * rwyLength + -511024.3769610519;
        }
        else if (rwyLength < 3505) {
            return 0.000006921152316466039 * Math.pow(rwyLength, 3) + -0.085943312547147 * Math.pow(rwyLength, 2) + 383.42555517953747 * rwyLength + 7891.1873459767385;
        }
        else if (rwyLength < 5221) {
            return 0.000002557769219018377 * Math.pow(rwyLength, 3) + -0.040062339277484836 * Math.pow(rwyLength, 2) + 222.61274386937154 * rwyLength + 195774.15522668723;
        }
        else {
            return 630000;
        }
    }
}
B787TakeoffCalculator.possibleFlapPositions = [5, 10, 15, 17, 18, 20];

/* eslint-disable max-len */
/**
 * V-Speed data for the B787-10.
 */
class B787VSpeedData {
    /** @inheritDoc */
    getVSpeed(weight, pressAlt, temperature, flaps, slope, headwind, takeoffThrustMode, isRwyWet) {
        // TODO WET tables
        let vSpeedsTable;
        let altTempAdjustmentsTable;
        const slopeAdjustmentsTable = B787VSpeedData.MAX_TO_DRY_SLOPE_ADJUST;
        const windAdjustmentsTable = B787VSpeedData.MAX_TO_DRY_WIND_ADJUST;
        let v1McgTable;
        let vrMinTable;
        let v2MinTable;
        const flapsNotInTables = flaps === 10 || flaps === 17 || flaps === 18;
        if (flaps === 5) {
            vSpeedsTable = B787VSpeedData.MAX_TO_DRY_FLAPS_5_VSPEEDS_TABLE;
            altTempAdjustmentsTable = B787VSpeedData.MAX_TO_DRY_FLAPS_5_VSPEED_ADJUSTMENTS_TABLE;
            v1McgTable = B787VSpeedData.MAX_TO_DRY_FLAPS_5_V1MCG_TABLE;
            vrMinTable = B787VSpeedData.MAX_TO_DRY_FLAPS_5_MINIMUM_VR;
            v2MinTable = B787VSpeedData.MAX_TO_DRY_FLAPS_5_MINIMUM_V2;
        }
        else if (flaps == 10 || flaps === 15) {
            vSpeedsTable = B787VSpeedData.MAX_TO_DRY_FLAPS_15_VSPEEDS_TABLE;
            altTempAdjustmentsTable = B787VSpeedData.MAX_TO_DRY_FLAPS_15_VSPEED_ADJUSTMENTS_TABLE;
            v1McgTable = B787VSpeedData.MAX_TO_DRY_FLAPS_15_V1MCG_TABLE;
            vrMinTable = B787VSpeedData.MAX_TO_DRY_FLAPS_15_MINIMUM_VR;
            v2MinTable = B787VSpeedData.MAX_TO_DRY_FLAPS_15_MINIMUM_V2;
        }
        else {
            vSpeedsTable = B787VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEEDS_TABLE;
            altTempAdjustmentsTable = B787VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEED_ADJUSTMENTS_TABLE;
            v1McgTable = B787VSpeedData.MAX_TO_DRY_FLAPS_20_V1MCG_TABLE;
            vrMinTable = B787VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_VR;
            v2MinTable = B787VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_V2;
        }
        //     1. Determine V1, VR, and V2 from the Takeoff Speeds table (Table 1) with brake release weight.
        const vSpeeds = B787VSpeedData.mapValuesToSpeedType(vSpeedsTable.get(B787VSpeedData.TMP_DATA, weight));
        const adjustments = B787VSpeedData.mapValuesToSpeedType(altTempAdjustmentsTable.get(B787VSpeedData.TMP_DATA, pressAlt, temperature));
        let thrustReduction;
        switch (takeoffThrustMode) {
            case TakeoffThrustMode.TO:
            case TakeoffThrustMode.DTO:
                thrustReduction = 0;
                break;
            case TakeoffThrustMode.TO1:
            case TakeoffThrustMode.DTO1:
                thrustReduction = 1;
                break;
            case TakeoffThrustMode.TO2:
            case TakeoffThrustMode.DTO2:
                thrustReduction = 2;
                break;
        }
        let v1Modifier = isRwyWet ? -9 : 0;
        v1Modifier += 2 * thrustReduction;
        vSpeeds[VSpeedType.V1] += v1Modifier;
        const vrModifier = 1 * thrustReduction;
        vSpeeds[VSpeedType.Vr] += vrModifier;
        const v2Modifier = 1 * thrustReduction;
        vSpeeds[VSpeedType.V2] += v2Modifier;
        // 2. Adjust V1, VR, and V2 for temperature and pressure altitude from the V1, VR, V2 Adjustments table (Table 2).
        for (const key in vSpeeds) {
            // apply adjustments
            const adjustedKey = key;
            vSpeeds[adjustedKey] += adjustments[adjustedKey];
            if (flapsNotInTables) {
                // adjust for flaps setting not in the tables
                const flapsDiff = flaps > 15 ? flaps - 20 : -5;
                vSpeeds[adjustedKey] -= flapsDiff * 0.6;
            }
        }
        // 3. Adjust V1 for wind and slope from the Slope and Wind V1 Adjustments table (Table 3).
        vSpeeds[VSpeedType.V1] += slopeAdjustmentsTable.get(weight, slope);
        vSpeeds[VSpeedType.V1] += windAdjustmentsTable.get(weight, -(headwind));
        // Make sure v1 is <= vr
        if (vSpeeds[VSpeedType.V1] > vSpeeds[VSpeedType.Vr]) {
            vSpeeds[VSpeedType.V1] = vSpeeds[VSpeedType.Vr];
        }
        // Make sure v2 is >= vr
        if (vSpeeds[VSpeedType.V2] < vSpeeds[VSpeedType.Vr]) {
            vSpeeds[VSpeedType.V2] = vSpeeds[VSpeedType.Vr];
        }
        // 4. Determine the V1(MCG) from the V1(MCG) table (Table 4).
        const v1Mcg = v1McgTable.get(temperature, pressAlt);
        // 5. If V1 from Step 3 is less than V1(MCG), set V1=V1(MCG).
        if (vSpeeds[VSpeedType.V1] < v1Mcg) {
            vSpeeds[VSpeedType.V1] = v1Mcg;
        }
        // 6. Using V1(MCG) from Step (4), determine Minimum VR (MIN VR) from the Minimum VR table (Table 5).
        const minVr = vrMinTable.get(weight, v1Mcg);
        // 7. Using V1(MCG) from Step (4), determine Minimum V2 (MIN V2) from the Minimum V2 table (Table 6).
        const minV2 = v2MinTable.get(weight, v1Mcg);
        // 8. If VR from Step 2 is less than MIN VR, set VR=MIN VR.
        if (vSpeeds[VSpeedType.Vr] < minVr) {
            vSpeeds[VSpeedType.Vr] = minVr;
        }
        // 9. If V2 from Step 2 is less than MIN V2, set V2=MIN V2.
        if (vSpeeds[VSpeedType.V2] < minV2) {
            vSpeeds[VSpeedType.V2] = minV2;
        }
        vSpeeds[VSpeedType.V1] = MathUtils.round(vSpeeds[VSpeedType.V1]);
        vSpeeds[VSpeedType.Vr] = MathUtils.round(vSpeeds[VSpeedType.Vr]);
        vSpeeds[VSpeedType.V2] = MathUtils.round(vSpeeds[VSpeedType.V2]);
        return vSpeeds;
    }
    /**
     * Maps values to VSpeedType.
     * 0 = V1, 1 = Vr, 2 = V2
     * @param values The values to map.
     * @returns The mapped values.
     */
    static mapValuesToSpeedType(values) {
        return {
            [VSpeedType.V1]: values[0],
            [VSpeedType.Vr]: values[1],
            [VSpeedType.V2]: values[2]
        };
    }
}
/** weight -> [v1,vr,v2] at flaps 5 */
B787VSpeedData.MAX_TO_DRY_FLAPS_5_VSPEEDS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 168, 174, 179), 573000],
    [VecNMath.create(3, 166, 172, 177), 551000],
    [VecNMath.create(3, 163, 169, 174), 529000],
    [VecNMath.create(3, 159, 165, 171), 507000],
    [VecNMath.create(3, 156, 161, 167), 485000],
    [VecNMath.create(3, 151, 157, 164), 463000],
    [VecNMath.create(3, 147, 153, 160), 441000],
    [VecNMath.create(3, 142, 148, 156), 419000],
    [VecNMath.create(3, 137, 144, 153), 397000],
    [VecNMath.create(3, 132, 139, 148), 375000],
    [VecNMath.create(3, 127, 134, 144), 353000],
    [VecNMath.create(3, 122, 130, 140), 331000],
    [VecNMath.create(3, 117, 124, 136), 309000],
    [VecNMath.create(3, 111, 119, 132), 287000],
    [VecNMath.create(3, 105, 113, 127), 265000],
    [VecNMath.create(3, 99, 108, 122), 243000],
]);
/** weight -> [v1,vr,v2] at flaps 15 */
B787VSpeedData.MAX_TO_DRY_FLAPS_15_VSPEEDS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 161, 166, 171), 573000],
    [VecNMath.create(3, 158, 163, 169), 551000],
    [VecNMath.create(3, 156, 161, 166), 529000],
    [VecNMath.create(3, 152, 157, 163), 507000],
    [VecNMath.create(3, 148, 153, 160), 485000],
    [VecNMath.create(3, 144, 149, 156), 463000],
    [VecNMath.create(3, 140, 145, 153), 441000],
    [VecNMath.create(3, 135, 141, 150), 419000],
    [VecNMath.create(3, 131, 137, 145), 397000],
    [VecNMath.create(3, 127, 133, 142), 375000],
    [VecNMath.create(3, 123, 127, 138), 353000],
    [VecNMath.create(3, 118, 122, 134), 331000],
    [VecNMath.create(3, 113, 117, 130), 309000],
    [VecNMath.create(3, 109, 112, 126), 287000],
    [VecNMath.create(3, 104, 109, 123), 265000],
    [VecNMath.create(3, 100, 107, 121), 243000],
]);
/** weight -> [v1,vr,v2] at flaps 20 */
B787VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEEDS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 148, 152, 158), 529000],
    [VecNMath.create(3, 144, 149, 155), 507000],
    [VecNMath.create(3, 141, 146, 153), 485000],
    [VecNMath.create(3, 138, 142, 149), 463000],
    [VecNMath.create(3, 135, 138, 145), 441000],
    [VecNMath.create(3, 132, 135, 139), 419000],
    [VecNMath.create(3, 129, 132, 137), 397000],
    [VecNMath.create(3, 125, 128, 133), 375000],
    [VecNMath.create(3, 122, 124, 128), 353000],
    [VecNMath.create(3, 118, 120, 125), 331000],
    [VecNMath.create(3, 115, 116, 122), 309000],
    [VecNMath.create(3, 110, 113, 118), 287000],
    [VecNMath.create(3, 107, 109, 115), 265000],
    [VecNMath.create(3, 104, 105, 112), 243000],
]);
/**
 * adjustments altitude, temp -> adjustment value at flaps 5
 * columns are temps, rows are pressure altitude
 */
B787VSpeedData.MAX_TO_DRY_FLAPS_5_VSPEED_ADJUSTMENTS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 3, 2, -1), -2000, 60], [VecNMath.create(3, 3, 1, -1), -2000, 50], [VecNMath.create(3, 1, 0, 0), -2000, 40], [VecNMath.create(3, 0, 0, 0), -2000, 30], [VecNMath.create(3, 0, 0, 0), -2000, 20], [VecNMath.create(3, 0, 0, 0), -2000, 10], [VecNMath.create(3, 0, 0, 0), -2000, 0], [VecNMath.create(3, 1, 0, 0), -2000, -60],
    [VecNMath.create(3, 5, 2, -1), 0, 60], [VecNMath.create(3, 4, 1, -1), 0, 50], [VecNMath.create(3, 1, 0, 0), 0, 40], [VecNMath.create(3, 0, 0, 0), 0, 30], [VecNMath.create(3, 0, 0, 0), 0, 20], [VecNMath.create(3, 0, 0, 0), 0, 10], [VecNMath.create(3, 0, 0, 0), 0, 0], [VecNMath.create(3, 1, 0, 0), 0, -60],
    [VecNMath.create(3, 5, 3, -2), 2000, 60], [VecNMath.create(3, 5, 2, -2), 2000, 50], [VecNMath.create(3, 3, 1, -1), 2000, 40], [VecNMath.create(3, 1, 0, 0), 2000, 30], [VecNMath.create(3, 1, 0, 0), 2000, 20], [VecNMath.create(3, 1, 0, 0), 2000, 10], [VecNMath.create(3, 1, 0, 0), 2000, 0], [VecNMath.create(3, 2, 0, 0), 2000, -60],
    [VecNMath.create(3, 7, 4, -2), 4000, 60], [VecNMath.create(3, 6, 3, -2), 4000, 50], [VecNMath.create(3, 5, 2, -2), 4000, 40], [VecNMath.create(3, 3, 1, -1), 4000, 30], [VecNMath.create(3, 2, 1, 0), 4000, 20], [VecNMath.create(3, 2, 1, 0), 4000, 10], [VecNMath.create(3, 2, 1, 0), 4000, 0], [VecNMath.create(3, 3, 1, 0), 4000, -60],
    [VecNMath.create(3, 8, 4, -2), 6000, 60], [VecNMath.create(3, 7, 4, -2), 6000, 50], [VecNMath.create(3, 6, 3, -2), 6000, 40], [VecNMath.create(3, 4, 2, -1), 6000, 30], [VecNMath.create(3, 2, 1, -1), 6000, 20], [VecNMath.create(3, 2, 1, -1), 6000, 10], [VecNMath.create(3, 2, 1, -1), 6000, 0], [VecNMath.create(3, 4, 1, -1), 6000, -60],
    [VecNMath.create(3, 9, 4, -2), 8000, 60], [VecNMath.create(3, 8, 4, -2), 8000, 50], [VecNMath.create(3, 8, 4, -2), 8000, 40], [VecNMath.create(3, 6, 3, -2), 8000, 30], [VecNMath.create(3, 5, 2, -1), 8000, 20], [VecNMath.create(3, 4, 2, -1), 8000, 10], [VecNMath.create(3, 4, 2, -1), 8000, 0], [VecNMath.create(3, 5, 2, -1), 8000, -60],
    [VecNMath.create(3, 9, 4, -2), 10000, 60], [VecNMath.create(3, 9, 4, -2), 10000, 50], [VecNMath.create(3, 9, 4, -2), 10000, 40], [VecNMath.create(3, 8, 4, -2), 10000, 30], [VecNMath.create(3, 6, 3, -2), 10000, 20], [VecNMath.create(3, 5, 3, -1), 10000, 10], [VecNMath.create(3, 5, 3, -1), 10000, 0], [VecNMath.create(3, 6, 3, -1), 10000, -60],
    [VecNMath.create(3, 9, 4, -3), 12000, 60], [VecNMath.create(3, 9, 4, -3), 12000, 50], [VecNMath.create(3, 9, 4, -2), 12000, 40], [VecNMath.create(3, 9, 4, -2), 12000, 30], [VecNMath.create(3, 8, 4, -2), 12000, 20], [VecNMath.create(3, 7, 4, -2), 12000, 10], [VecNMath.create(3, 6, 4, -2), 12000, 0], [VecNMath.create(3, 7, 4, -2), 12000, -60],
    [VecNMath.create(3, 10, 4, -3), 14000, 60], [VecNMath.create(3, 10, 4, -3), 14000, 50], [VecNMath.create(3, 10, 4, -3), 14000, 40], [VecNMath.create(3, 10, 4, -3), 14000, 30], [VecNMath.create(3, 10, 4, -3), 14000, 20], [VecNMath.create(3, 9, 4, -2), 14000, 10], [VecNMath.create(3, 8, 4, -2), 14000, 0], [VecNMath.create(3, 8, 4, -2), 14000, -60],
]);
/**
 * adjustments altitude, temp -> adjustment value at flaps 15
 * columns are temps, rows are pressure altitude
 */
B787VSpeedData.MAX_TO_DRY_FLAPS_15_VSPEED_ADJUSTMENTS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 3, 2, -2), -2000, 60], [VecNMath.create(3, 2, 1, -1), -2000, 50], [VecNMath.create(3, 0, 0, 0), -2000, 40], [VecNMath.create(3, 0, 0, 0), -2000, 30], [VecNMath.create(3, 0, 0, 0), -2000, 20], [VecNMath.create(3, 0, 0, 0), -2000, 10], [VecNMath.create(3, 0, 0, 0), -2000, 0], [VecNMath.create(3, 1, 0, 0), -2000, -60],
    [VecNMath.create(3, 4, 3, -2), 0, 60], [VecNMath.create(3, 3, 1, -1), 0, 50], [VecNMath.create(3, 1, 0, 0), 0, 40], [VecNMath.create(3, 0, 0, 0), 0, 30], [VecNMath.create(3, 0, 0, 0), 0, 20], [VecNMath.create(3, 0, 0, 0), 0, 10], [VecNMath.create(3, 0, 0, 0), 0, 0], [VecNMath.create(3, 0, 0, 0), 0, -60],
    [VecNMath.create(3, 6, 4, -2), 2000, 60], [VecNMath.create(3, 5, 2, -2), 2000, 50], [VecNMath.create(3, 3, 1, -1), 2000, 40], [VecNMath.create(3, 1, 0, 0), 2000, 30], [VecNMath.create(3, 1, 0, 0), 2000, 20], [VecNMath.create(3, 1, 0, 0), 2000, 10], [VecNMath.create(3, 1, 0, 0), 2000, 0], [VecNMath.create(3, 2, 0, 0), 2000, -60],
    [VecNMath.create(3, 6, 5, -2), 4000, 60], [VecNMath.create(3, 5, 4, -2), 4000, 50], [VecNMath.create(3, 5, 2, -1), 4000, 40], [VecNMath.create(3, 3, 1, -1), 4000, 30], [VecNMath.create(3, 1, 1, 0), 4000, 20], [VecNMath.create(3, 1, 1, 0), 4000, 10], [VecNMath.create(3, 1, 1, 0), 4000, 0], [VecNMath.create(3, 2, 1, 0), 4000, -60],
    [VecNMath.create(3, 6, 5, -2), 6000, 60], [VecNMath.create(3, 5, 4, -2), 6000, 50], [VecNMath.create(3, 5, 3, -2), 6000, 40], [VecNMath.create(3, 3, 2, -1), 6000, 30], [VecNMath.create(3, 2, 1, -1), 6000, 20], [VecNMath.create(3, 2, 1, -1), 6000, 10], [VecNMath.create(3, 2, 1, -1), 6000, 0], [VecNMath.create(3, 3, 1, -1), 6000, -60],
    [VecNMath.create(3, 6, 6, -2), 8000, 60], [VecNMath.create(3, 5, 5, -2), 8000, 50], [VecNMath.create(3, 5, 4, -2), 8000, 40], [VecNMath.create(3, 5, 3, -1), 8000, 30], [VecNMath.create(3, 3, 2, -1), 8000, 20], [VecNMath.create(3, 3, 2, -1), 8000, 10], [VecNMath.create(3, 3, 2, -1), 8000, 0], [VecNMath.create(3, 4, 2, -1), 8000, -60],
    [VecNMath.create(3, 6, 6, -2), 10000, 60], [VecNMath.create(3, 6, 5, -2), 10000, 50], [VecNMath.create(3, 6, 4, -2), 10000, 40], [VecNMath.create(3, 5, 4, -2), 10000, 30], [VecNMath.create(3, 5, 3, -1), 10000, 20], [VecNMath.create(3, 4, 3, -1), 10000, 10], [VecNMath.create(3, 4, 3, -1), 10000, 0], [VecNMath.create(3, 5, 3, -1), 10000, -60],
    [VecNMath.create(3, 6, 8, -3), 12000, 60], [VecNMath.create(3, 6, 7, -3), 12000, 50], [VecNMath.create(3, 6, 6, -2), 12000, 40], [VecNMath.create(3, 6, 5, -2), 12000, 30], [VecNMath.create(3, 5, 4, -2), 12000, 20], [VecNMath.create(3, 5, 4, -1), 12000, 10], [VecNMath.create(3, 5, 3, -1), 12000, 0], [VecNMath.create(3, 5, 3, -1), 12000, -60],
    [VecNMath.create(3, 7, 8, -3), 14000, 60], [VecNMath.create(3, 7, 7, -3), 14000, 50], [VecNMath.create(3, 7, 6, -3), 14000, 40], [VecNMath.create(3, 7, 5, -3), 14000, 30], [VecNMath.create(3, 7, 5, -3), 14000, 20], [VecNMath.create(3, 6, 5, -3), 14000, 10], [VecNMath.create(3, 5, 5, -2), 14000, 0], [VecNMath.create(3, 5, 5, -1), 14000, -60],
]);
/**
 * adjustments altitude, temp -> adjustment value at flaps 20
 * columns are temps, rows are pressure altitude
 */
B787VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEED_ADJUSTMENTS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 4, 2, -2), -2000, 60], [VecNMath.create(3, 3, 2, 0), -2000, 50], [VecNMath.create(3, 2, 0, 0), -2000, 40], [VecNMath.create(3, 2, 0, 0), -2000, 30], [VecNMath.create(3, 2, 0, 0), -2000, 20], [VecNMath.create(3, 2, 0, 0), -2000, 10], [VecNMath.create(3, 2, 0, 0), -2000, 0], [VecNMath.create(3, 3, 0, 0), -2000, -60],
    [VecNMath.create(3, 2, 2, -2), 0, 60], [VecNMath.create(3, 2, 1, -1), 0, 50], [VecNMath.create(3, 1, 0, 0), 0, 40], [VecNMath.create(3, 0, 0, 0), 0, 30], [VecNMath.create(3, 0, 0, 0), 0, 20], [VecNMath.create(3, 0, 0, 0), 0, 10], [VecNMath.create(3, 0, 0, 0), 0, 0], [VecNMath.create(3, 2, 0, 0), 0, -60],
    [VecNMath.create(3, 4, 2, -2), 2000, 60], [VecNMath.create(3, 3, 1, -1), 2000, 50], [VecNMath.create(3, 2, 1, 0), 2000, 40], [VecNMath.create(3, 2, 0, 0), 2000, 30], [VecNMath.create(3, 1, 0, 0), 2000, 20], [VecNMath.create(3, 1, 0, 0), 2000, 10], [VecNMath.create(3, 1, 0, 0), 2000, 0], [VecNMath.create(3, 2, 0, 0), 2000, -60],
    [VecNMath.create(3, 4, 2, -2), 4000, 60], [VecNMath.create(3, 4, 2, -2), 4000, 50], [VecNMath.create(3, 2, 2, -1), 4000, 40], [VecNMath.create(3, 2, 0, 0), 4000, 30], [VecNMath.create(3, 1, 0, 0), 4000, 20], [VecNMath.create(3, 1, 0, 0), 4000, 10], [VecNMath.create(3, 1, 0, 0), 4000, 0], [VecNMath.create(3, 2, 0, 0), 4000, -60],
    [VecNMath.create(3, 4, 2, -2), 6000, 60], [VecNMath.create(3, 4, 2, -2), 6000, 50], [VecNMath.create(3, 2, 2, -1), 6000, 40], [VecNMath.create(3, 2, 1, -1), 6000, 30], [VecNMath.create(3, 1, 0, 0), 6000, 20], [VecNMath.create(3, 1, 0, 0), 6000, 10], [VecNMath.create(3, 1, 0, 0), 6000, 0], [VecNMath.create(3, 2, 0, 0), 6000, -60],
    [VecNMath.create(3, 4, 2, -2), 8000, 60], [VecNMath.create(3, 4, 2, -2), 8000, 50], [VecNMath.create(3, 3, 2, -2), 8000, 40], [VecNMath.create(3, 2, 1, -1), 8000, 30], [VecNMath.create(3, 1, 0, -1), 8000, 20], [VecNMath.create(3, 1, 0, -1), 8000, 10], [VecNMath.create(3, 1, 0, -1), 8000, 0], [VecNMath.create(3, 2, 0, -1), 8000, -60],
    [VecNMath.create(3, 4, 2, -2), 10000, 60], [VecNMath.create(3, 4, 2, -2), 10000, 50], [VecNMath.create(3, 3, 2, -2), 10000, 40], [VecNMath.create(3, 2, 1, -2), 10000, 30], [VecNMath.create(3, 2, 1, -1), 10000, 20], [VecNMath.create(3, 1, 1, -1), 10000, 10], [VecNMath.create(3, 1, 1, -1), 10000, 0], [VecNMath.create(3, 2, 1, -1), 10000, -60],
    [VecNMath.create(3, 4, 3, -3), 12000, 60], [VecNMath.create(3, 4, 2, -3), 12000, 50], [VecNMath.create(3, 4, 2, -2), 12000, 40], [VecNMath.create(3, 3, 2, -2), 12000, 30], [VecNMath.create(3, 2, 1, -2), 12000, 20], [VecNMath.create(3, 1, 1, -2), 12000, 10], [VecNMath.create(3, 1, 1, -2), 12000, 0], [VecNMath.create(3, 3, 1, -2), 12000, -60],
    [VecNMath.create(3, 5, 3, -4), 14000, 60], [VecNMath.create(3, 5, 2, -3), 14000, 50], [VecNMath.create(3, 5, 2, -3), 14000, 40], [VecNMath.create(3, 4, 2, -3), 14000, 30], [VecNMath.create(3, 3, 2, -3), 14000, 20], [VecNMath.create(3, 1, 2, -2), 14000, 10], [VecNMath.create(3, 2, 1, -2), 14000, 0], [VecNMath.create(3, 3, 1, -2), 14000, -60],
]);
/**
 * V1 MCG for temp, altitude -> v1 mcg at flaps 5
 */
B787VSpeedData.MAX_TO_DRY_FLAPS_5_V1MCG_TABLE = new LerpLookupTable([
    [119, 60, -2000], [119, 55, -2000], [122, 50, -2000], [125, 45, -2000], [127, 40, -2000], [130, 35, -2000], [131, 30, -2000], [131, 25, -2000], [131, 20, -2000], [131, 15, -2000], [131, 10, -2000], [131, 5, -2000], [131, 0, -2000], [133, -60, -2000],
    [116, 60, 0], [116, 55, 0], [119, 50, 0], [122, 45, 0], [125, 40, 0], [127, 35, 0], [130, 30, 0], [130, 25, 0], [130, 20, 0], [131, 15, 0], [131, 10, 0], [131, 5, 0], [131, 0, 0], [132, -60, 0],
    [113, 60, 2000], [113, 55, 2000], [113, 50, 2000], [117, 45, 2000], [120, 40, 2000], [122, 35, 2000], [125, 30, 2000], [127, 25, 2000], [127, 20, 2000], [127, 15, 2000], [127, 10, 2000], [127, 5, 2000], [128, 0, 2000], [129, -60, 2000],
    [111, 60, 4000], [111, 55, 4000], [111, 50, 4000], [111, 45, 4000], [115, 40, 4000], [117, 35, 4000], [120, 30, 4000], [123, 25, 4000], [124, 20, 4000], [124, 15, 4000], [124, 10, 4000], [124, 5, 4000], [124, 0, 4000], [125, -60, 4000],
    [108, 60, 6000], [108, 55, 6000], [108, 50, 6000], [108, 45, 6000], [110, 40, 6000], [112, 35, 6000], [115, 30, 6000], [118, 25, 6000], [120, 20, 6000], [121, 15, 6000], [121, 10, 6000], [121, 5, 6000], [121, 0, 6000], [122, -60, 6000],
    [105, 60, 8000], [105, 55, 8000], [105, 50, 8000], [105, 45, 8000], [105, 40, 8000], [107, 35, 8000], [110, 30, 8000], [112, 25, 8000], [115, 20, 8000], [116, 15, 8000], [117, 10, 8000], [117, 5, 8000], [117, 0, 8000], [118, -60, 8000],
    [101, 60, 10000], [101, 55, 10000], [101, 50, 10000], [101, 45, 10000], [101, 40, 10000], [101, 35, 10000], [104, 30, 10000], [107, 25, 10000], [109, 20, 10000], [111, 15, 10000], [112, 10, 10000], [112, 5, 10000], [113, 0, 10000], [114, -60, 10000],
    [101, 60, 12000], [101, 55, 12000], [101, 50, 12000], [101, 45, 12000], [101, 40, 12000], [101, 35, 12000], [101, 30, 12000], [102, 25, 12000], [104, 20, 12000], [106, 15, 12000], [107, 10, 12000], [108, 5, 12000], [109, 0, 12000], [110, -60, 12000],
    [97, 60, 14000], [97, 55, 14000], [97, 50, 14000], [97, 45, 14000], [97, 40, 14000], [97, 35, 14000], [97, 30, 14000], [97, 25, 14000], [98, 20, 14000], [100, 15, 14000], [102, 10, 14000], [103, 5, 14000], [104, 0, 14000], [105, -60, 14000],
]);
/**
 * V1 MCG for temp, altitude -> v1 mcg at flaps 15
 */
B787VSpeedData.MAX_TO_DRY_FLAPS_15_V1MCG_TABLE = new LerpLookupTable([
    [118, 60, -2000], [118, 55, -2000], [121, 50, -2000], [124, 45, -2000], [127, 40, -2000], [130, 35, -2000], [130, 30, -2000], [130, 25, -2000], [130, 20, -2000], [131, 15, -2000], [131, 10, -2000], [131, 5, -2000], [131, 0, -2000], [132, -60, -2000],
    [115, 60, 0], [115, 55, 0], [118, 50, 0], [121, 45, 0], [124, 40, 0], [127, 35, 0], [130, 30, 0], [130, 25, 0], [130, 20, 0], [130, 15, 0], [130, 10, 0], [130, 5, 0], [130, 0, 0], [131, -60, 0],
    [113, 60, 2000], [113, 55, 2000], [113, 50, 2000], [116, 45, 2000], [119, 40, 2000], [122, 35, 2000], [124, 30, 2000], [126, 25, 2000], [127, 20, 2000], [127, 15, 2000], [127, 10, 2000], [127, 5, 2000], [127, 0, 2000], [128, -60, 2000],
    [110, 60, 4000], [110, 55, 4000], [110, 50, 4000], [111, 45, 4000], [114, 40, 4000], [117, 35, 4000], [119, 30, 4000], [122, 25, 4000], [123, 20, 4000], [124, 15, 4000], [124, 10, 4000], [124, 5, 4000], [124, 0, 4000], [125, -60, 4000],
    [107, 60, 6000], [107, 55, 6000], [107, 50, 6000], [107, 45, 6000], [109, 40, 6000], [112, 35, 6000], [115, 30, 6000], [117, 25, 6000], [119, 20, 6000], [120, 15, 6000], [120, 10, 6000], [120, 5, 6000], [120, 0, 6000], [121, -60, 6000],
    [104, 60, 8000], [104, 55, 8000], [104, 50, 8000], [104, 45, 8000], [104, 40, 8000], [106, 35, 8000], [109, 30, 8000], [112, 25, 8000], [114, 20, 8000], [116, 15, 8000], [116, 10, 8000], [116, 5, 8000], [116, 0, 8000], [117, -60, 8000],
    [101, 60, 10000], [101, 55, 10000], [101, 50, 10000], [101, 45, 10000], [101, 40, 10000], [101, 35, 10000], [104, 30, 10000], [107, 25, 10000], [108, 20, 10000], [111, 15, 10000], [112, 10, 10000], [112, 5, 10000], [112, 0, 10000], [113, -60, 10000],
    [101, 60, 12000], [101, 55, 12000], [101, 50, 12000], [101, 45, 12000], [101, 40, 12000], [101, 35, 12000], [101, 30, 12000], [101, 25, 12000], [104, 20, 12000], [105, 15, 12000], [106, 10, 12000], [108, 5, 12000], [109, 0, 12000], [110, -60, 12000],
    [97, 60, 14000], [97, 55, 14000], [97, 50, 14000], [97, 45, 14000], [97, 40, 14000], [97, 35, 14000], [97, 30, 14000], [97, 25, 14000], [98, 20, 14000], [100, 15, 14000], [101, 10, 14000], [102, 5, 14000], [104, 0, 14000], [105, -60, 14000],
]);
/**
 * V1 MCG for temp, altitude -> v1 mcg at flaps 20
 */
B787VSpeedData.MAX_TO_DRY_FLAPS_20_V1MCG_TABLE = new LerpLookupTable([
    [118, 60, -2000], [118, 55, -2000], [120, 50, -2000], [123, 45, -2000], [126, 40, -2000], [129, 35, -2000], [129, 30, -2000], [129, 25, -2000], [129, 20, -2000], [130, 15, -2000], [130, 10, -2000], [130, 5, -2000], [130, 0, -2000], [131, -60, -2000],
    [114, 60, 0], [114, 55, 0], [117, 50, 0], [120, 45, 0], [123, 40, 0], [126, 35, 0], [129, 30, 0], [129, 25, 0], [129, 20, 0], [129, 15, 0], [129, 10, 0], [129, 5, 0], [129, 0, 0], [130, -60, 0],
    [112, 60, 2000], [112, 55, 2000], [112, 50, 2000], [115, 45, 2000], [118, 40, 2000], [121, 35, 2000], [123, 30, 2000], [126, 25, 2000], [126, 20, 2000], [126, 15, 2000], [126, 10, 2000], [126, 5, 2000], [126, 0, 2000], [127, -60, 2000],
    [109, 60, 4000], [109, 55, 4000], [109, 50, 4000], [110, 45, 4000], [113, 40, 4000], [116, 35, 4000], [119, 30, 4000], [121, 25, 4000], [123, 20, 4000], [123, 15, 4000], [123, 10, 4000], [123, 5, 4000], [123, 0, 4000], [124, -60, 4000],
    [107, 60, 6000], [107, 55, 6000], [107, 50, 6000], [107, 45, 6000], [108, 40, 6000], [111, 35, 6000], [114, 30, 6000], [116, 25, 6000], [118, 20, 6000], [119, 15, 6000], [119, 10, 6000], [119, 5, 6000], [119, 0, 6000], [120, -60, 6000],
    [103, 60, 8000], [103, 55, 8000], [103, 50, 8000], [103, 45, 8000], [103, 40, 8000], [106, 35, 8000], [109, 30, 8000], [111, 25, 8000], [113, 20, 8000], [115, 15, 8000], [115, 10, 8000], [115, 5, 8000], [115, 0, 8000], [116, -60, 8000],
    [100, 60, 10000], [100, 55, 10000], [100, 50, 10000], [100, 45, 10000], [100, 40, 10000], [100, 35, 10000], [103, 30, 10000], [106, 25, 10000], [108, 20, 10000], [110, 15, 10000], [111, 10, 10000], [111, 5, 10000], [111, 0, 10000], [112, -60, 10000],
    [100, 60, 12000], [100, 55, 12000], [100, 50, 12000], [100, 45, 12000], [100, 40, 12000], [100, 35, 12000], [100, 30, 12000], [100, 25, 12000], [103, 20, 12000], [104, 15, 12000], [106, 10, 12000], [107, 5, 12000], [108, 0, 12000], [109, -60, 12000],
    [96, 60, 14000], [96, 55, 14000], [96, 50, 14000], [96, 45, 14000], [96, 40, 14000], [96, 35, 14000], [96, 30, 14000], [96, 25, 14000], [97, 20, 14000], [99, 15, 14000], [100, 10, 14000], [102, 5, 14000], [103, 0, 14000], [104, -60, 14000],
]);
/** Minimum VR for weight, v1 -> min vr at flaps 5 */
B787VSpeedData.MAX_TO_DRY_FLAPS_5_MINIMUM_VR = new LerpLookupTable([
    [139, 353000, 96], [136, 331000, 96], [131, 309000, 96], [125, 287000, 96], [120, 265000, 96], [115, 243000, 96],
    [139, 353000, 98], [135, 331000, 98], [130, 309000, 98], [124, 287000, 98], [119, 265000, 98], [114, 243000, 98],
    [139, 353000, 100], [134, 331000, 100], [129, 309000, 100], [124, 287000, 100], [119, 265000, 100], [113, 243000, 100],
    [139, 353000, 102], [134, 331000, 102], [129, 309000, 102], [124, 287000, 102], [118, 265000, 102], [113, 243000, 102],
    [138, 353000, 104], [134, 331000, 104], [129, 309000, 104], [123, 287000, 104], [118, 265000, 104], [112, 243000, 104],
    [138, 353000, 106], [133, 331000, 106], [128, 309000, 106], [123, 287000, 106], [117, 265000, 106], [112, 243000, 106],
    [138, 353000, 108], [133, 331000, 108], [128, 309000, 108], [122, 287000, 108], [117, 265000, 108], [113, 243000, 108],
    [137, 353000, 110], [132, 331000, 110], [128, 309000, 110], [122, 287000, 110], [116, 265000, 110], [114, 243000, 110],
    [137, 353000, 112], [132, 331000, 112], [127, 309000, 112], [122, 287000, 112], [117, 265000, 112], [116, 243000, 112],
    [137, 353000, 114], [132, 331000, 114], [127, 309000, 114], [121, 287000, 114], [118, 265000, 114], [118, 243000, 114],
    [136, 353000, 116], [132, 331000, 116], [126, 309000, 116], [121, 287000, 116], [120, 265000, 116], [120, 243000, 116],
    [136, 353000, 118], [131, 331000, 118], [126, 309000, 118], [122, 287000, 118], [122, 265000, 118], [122, 243000, 118],
    [135, 353000, 120], [131, 331000, 120], [125, 309000, 120], [124, 287000, 120], [124, 265000, 120], [124, 243000, 120],
    [135, 353000, 122], [130, 331000, 122], [126, 309000, 122], [126, 287000, 122], [126, 265000, 122], [126, 243000, 122],
    [135, 353000, 124], [130, 331000, 124], [128, 309000, 124], [128, 287000, 124], [128, 265000, 124], [128, 243000, 124],
    [134, 353000, 126], [130, 331000, 126], [130, 309000, 126], [130, 287000, 126], [130, 265000, 126], [130, 243000, 126],
    [134, 353000, 128], [131, 331000, 128], [131, 309000, 128], [131, 287000, 128], [131, 265000, 128], [131, 243000, 128],
    [134, 353000, 130], [133, 331000, 130], [133, 309000, 130], [133, 287000, 130], [133, 265000, 130], [133, 243000, 130],
    [135, 353000, 132], [135, 331000, 132], [135, 309000, 132], [135, 287000, 132], [135, 265000, 132], [135, 243000, 132],
]);
/** Minimum VR for weight, v1 -> min vr at flaps 5 */
B787VSpeedData.MAX_TO_DRY_FLAPS_15_MINIMUM_VR = new LerpLookupTable([
    [139, 397000, 96], [135, 375000, 96], [132, 353000, 96], [128, 331000, 96], [124, 309000, 96], [119, 287000, 96], [116, 265000, 96], [116, 243000, 96],
    [139, 397000, 98], [135, 375000, 98], [132, 353000, 98], [128, 331000, 98], [123, 309000, 98], [118, 287000, 98], [115, 265000, 98], [115, 243000, 98],
    [139, 397000, 100], [135, 375000, 100], [132, 353000, 100], [128, 331000, 100], [123, 309000, 100], [118, 287000, 100], [114, 265000, 100], [114, 243000, 100],
    [139, 397000, 102], [135, 375000, 102], [132, 353000, 102], [127, 331000, 102], [122, 309000, 102], [118, 287000, 102], [114, 265000, 102], [112, 243000, 102],
    [139, 397000, 104], [135, 375000, 104], [132, 353000, 104], [127, 331000, 104], [122, 309000, 104], [118, 287000, 104], [114, 265000, 104], [112, 243000, 104],
    [139, 397000, 106], [135, 375000, 106], [131, 353000, 106], [127, 331000, 106], [122, 309000, 106], [118, 287000, 106], [115, 265000, 106], [111, 243000, 106],
    [139, 397000, 108], [135, 375000, 108], [131, 353000, 108], [126, 331000, 108], [122, 309000, 108], [119, 287000, 108], [115, 265000, 108], [112, 243000, 108],
    [139, 397000, 110], [135, 375000, 110], [131, 353000, 110], [126, 331000, 110], [123, 309000, 110], [119, 287000, 110], [115, 265000, 110], [114, 243000, 110],
    [139, 397000, 112], [135, 375000, 112], [131, 353000, 112], [127, 331000, 112], [123, 309000, 112], [119, 287000, 112], [117, 265000, 112], [116, 243000, 112],
    [139, 397000, 114], [134, 375000, 114], [131, 353000, 114], [127, 331000, 114], [123, 309000, 114], [120, 287000, 114], [118, 265000, 114], [118, 243000, 114],
    [139, 397000, 116], [134, 375000, 116], [130, 353000, 116], [127, 331000, 116], [123, 309000, 116], [121, 287000, 116], [120, 265000, 116], [120, 243000, 116],
    [138, 397000, 118], [134, 375000, 118], [130, 353000, 118], [127, 331000, 118], [124, 309000, 118], [122, 287000, 118], [122, 265000, 118], [122, 243000, 118],
    [138, 397000, 120], [134, 375000, 120], [130, 353000, 120], [127, 331000, 120], [125, 309000, 120], [124, 287000, 120], [124, 265000, 120], [124, 243000, 120],
    [138, 397000, 122], [134, 375000, 122], [131, 353000, 122], [127, 331000, 122], [126, 309000, 122], [126, 287000, 122], [126, 265000, 122], [126, 243000, 122],
    [137, 397000, 124], [134, 375000, 124], [131, 353000, 124], [128, 331000, 124], [128, 309000, 124], [128, 287000, 124], [128, 265000, 124], [128, 243000, 124],
    [137, 397000, 126], [134, 375000, 126], [131, 353000, 126], [130, 331000, 126], [130, 309000, 126], [130, 287000, 126], [130, 265000, 126], [130, 243000, 126],
    [137, 397000, 128], [134, 375000, 128], [132, 353000, 128], [131, 331000, 128], [131, 309000, 128], [131, 287000, 128], [131, 265000, 128], [131, 243000, 128],
    [134, 397000, 130], [134, 375000, 130], [133, 353000, 130], [133, 331000, 130], [133, 309000, 130], [133, 287000, 130], [133, 265000, 130], [133, 243000, 130],
    [135, 397000, 132], [135, 375000, 132], [135, 353000, 132], [135, 331000, 132], [135, 309000, 132], [135, 287000, 132], [135, 265000, 132], [135, 243000, 132],
]);
/** Minimum VR for weight, v1 -> min vr at flaps 20 */
B787VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_VR = new LerpLookupTable([
    [142, 463000, 96], [139, 441000, 96], [135, 419000, 96], [132, 397000, 96], [128, 375000, 96], [124, 353000, 96], [120, 331000, 96], [117, 309000, 96], [116, 287000, 96], [115, 265000, 96], [114, 243000, 96],
    [142, 463000, 98], [139, 441000, 98], [135, 419000, 98], [132, 397000, 98], [128, 375000, 98], [124, 353000, 98], [120, 331000, 98], [117, 309000, 98], [115, 287000, 98], [115, 265000, 98], [114, 243000, 98],
    [142, 463000, 100], [139, 441000, 100], [135, 419000, 100], [132, 397000, 100], [128, 375000, 100], [124, 353000, 100], [120, 331000, 100], [118, 309000, 100], [115, 287000, 100], [114, 265000, 100], [114, 243000, 100],
    [142, 463000, 102], [139, 441000, 102], [135, 419000, 102], [132, 397000, 102], [128, 375000, 102], [124, 353000, 102], [121, 331000, 102], [119, 309000, 102], [116, 287000, 102], [113, 265000, 102], [113, 243000, 102],
    [142, 463000, 104], [139, 441000, 104], [135, 419000, 104], [132, 397000, 104], [128, 375000, 104], [124, 353000, 104], [122, 331000, 104], [119, 309000, 104], [117, 287000, 104], [114, 265000, 104], [112, 243000, 104],
    [142, 463000, 106], [139, 441000, 106], [135, 419000, 106], [132, 397000, 106], [128, 375000, 106], [124, 353000, 106], [122, 331000, 106], [120, 309000, 106], [118, 287000, 106], [115, 265000, 106], [113, 243000, 106],
    [142, 463000, 108], [139, 441000, 108], [135, 419000, 108], [132, 397000, 108], [128, 375000, 108], [125, 353000, 108], [123, 331000, 108], [121, 309000, 108], [119, 287000, 108], [116, 265000, 108], [114, 243000, 108],
    [142, 463000, 110], [139, 441000, 110], [135, 419000, 110], [132, 397000, 110], [128, 375000, 110], [126, 353000, 110], [124, 331000, 110], [122, 309000, 110], [120, 287000, 110], [117, 265000, 110], [115, 243000, 110],
    [142, 463000, 112], [139, 441000, 112], [135, 419000, 112], [132, 397000, 112], [129, 375000, 112], [128, 353000, 112], [125, 331000, 112], [123, 309000, 112], [120, 287000, 112], [118, 265000, 112], [116, 243000, 112],
    [142, 463000, 114], [139, 441000, 114], [135, 419000, 114], [132, 397000, 114], [130, 375000, 114], [128, 353000, 114], [126, 331000, 114], [123, 309000, 114], [121, 287000, 114], [119, 265000, 114], [117, 243000, 114],
    [142, 463000, 116], [139, 441000, 116], [135, 419000, 116], [132, 397000, 116], [130, 375000, 116], [129, 353000, 116], [127, 331000, 116], [124, 309000, 116], [122, 287000, 116], [120, 265000, 116], [118, 243000, 116],
    [142, 463000, 118], [139, 441000, 118], [136, 419000, 118], [134, 397000, 118], [131, 375000, 118], [130, 353000, 118], [127, 331000, 118], [126, 309000, 118], [123, 287000, 118], [121, 265000, 118], [119, 243000, 118],
    [142, 463000, 120], [139, 441000, 120], [137, 419000, 120], [135, 397000, 120], [132, 375000, 120], [130, 353000, 120], [128, 331000, 120], [127, 309000, 120], [124, 287000, 120], [122, 265000, 120], [120, 243000, 120],
    [142, 463000, 122], [140, 441000, 122], [138, 419000, 122], [136, 397000, 122], [133, 375000, 122], [131, 353000, 122], [129, 331000, 122], [128, 309000, 122], [125, 287000, 122], [123, 265000, 122], [121, 243000, 122],
    [142, 463000, 124], [140, 441000, 124], [138, 419000, 124], [136, 397000, 124], [133, 375000, 124], [132, 353000, 124], [130, 331000, 124], [129, 309000, 124], [126, 287000, 124], [124, 265000, 124], [122, 243000, 124],
    [143, 463000, 126], [141, 441000, 126], [139, 419000, 126], [137, 397000, 126], [134, 375000, 126], [132, 353000, 126], [131, 331000, 126], [130, 309000, 126], [127, 287000, 126], [125, 265000, 126], [123, 243000, 126],
    [144, 463000, 128], [141, 441000, 128], [139, 419000, 128], [137, 397000, 128], [135, 375000, 128], [134, 353000, 128], [132, 331000, 128], [131, 309000, 128], [128, 287000, 128], [126, 265000, 128], [124, 243000, 128],
    [144, 463000, 130], [142, 441000, 130], [140, 419000, 130], [138, 397000, 130], [135, 375000, 130], [135, 353000, 130], [133, 331000, 130], [132, 309000, 130], [129, 287000, 130], [127, 265000, 130], [125, 243000, 130],
    [145, 463000, 132], [143, 441000, 132], [141, 419000, 132], [139, 397000, 132], [136, 375000, 132], [136, 353000, 132], [134, 331000, 132], [133, 309000, 132], [130, 287000, 132], [128, 265000, 132], [126, 243000, 132],
]);
/** Minimum V2 for weight, v1 -> min v2 at flaps 5 */
B787VSpeedData.MAX_TO_DRY_FLAPS_5_MINIMUM_V2 = new LerpLookupTable([
    [150, 397000, 96], [146, 375000, 96], [142, 353000, 96], [137, 331000, 96], [133, 309000, 96], [128, 287000, 96], [124, 265000, 96], [120, 243000, 96],
    [150, 397000, 98], [146, 375000, 98], [142, 353000, 98], [137, 331000, 98], [133, 309000, 98], [128, 287000, 98], [124, 265000, 98], [120, 243000, 98],
    [150, 397000, 100], [146, 375000, 100], [142, 353000, 100], [137, 331000, 100], [133, 309000, 100], [128, 287000, 100], [124, 265000, 100], [120, 243000, 100],
    [150, 397000, 102], [146, 375000, 102], [142, 353000, 102], [137, 331000, 102], [133, 309000, 102], [129, 287000, 102], [124, 265000, 102], [120, 243000, 102],
    [150, 397000, 104], [146, 375000, 104], [142, 353000, 104], [138, 331000, 104], [133, 309000, 104], [129, 287000, 104], [124, 265000, 104], [121, 243000, 104],
    [150, 397000, 106], [146, 375000, 106], [142, 353000, 106], [138, 331000, 106], [134, 309000, 106], [130, 287000, 106], [125, 265000, 106], [121, 243000, 106],
    [150, 397000, 108], [146, 375000, 108], [142, 353000, 108], [138, 331000, 108], [134, 309000, 108], [130, 287000, 108], [125, 265000, 108], [122, 243000, 108],
    [150, 397000, 110], [146, 375000, 110], [143, 353000, 110], [139, 331000, 110], [134, 309000, 110], [130, 287000, 110], [126, 265000, 110], [124, 243000, 110],
    [150, 397000, 112], [147, 375000, 112], [143, 353000, 112], [139, 331000, 112], [134, 309000, 112], [131, 287000, 112], [127, 265000, 112], [127, 243000, 112],
    [150, 397000, 114], [147, 375000, 114], [143, 353000, 114], [139, 331000, 114], [135, 309000, 114], [131, 287000, 114], [128, 265000, 114], [128, 243000, 114],
    [151, 397000, 116], [147, 375000, 116], [143, 353000, 116], [139, 331000, 116], [135, 309000, 116], [131, 287000, 116], [131, 265000, 116], [131, 243000, 116],
    [151, 397000, 118], [147, 375000, 118], [143, 353000, 118], [139, 331000, 118], [135, 309000, 118], [133, 287000, 118], [133, 265000, 118], [133, 243000, 118],
    [151, 397000, 120], [148, 375000, 120], [144, 353000, 120], [140, 331000, 120], [136, 309000, 120], [135, 287000, 120], [135, 265000, 120], [135, 243000, 120],
    [152, 397000, 122], [148, 375000, 122], [144, 353000, 122], [140, 331000, 122], [137, 309000, 122], [137, 287000, 122], [137, 265000, 122], [137, 243000, 122],
    [152, 397000, 124], [148, 375000, 124], [145, 353000, 124], [140, 331000, 124], [139, 309000, 124], [139, 287000, 124], [139, 265000, 124], [139, 243000, 124],
    [152, 397000, 126], [148, 375000, 126], [145, 353000, 126], [142, 331000, 126], [142, 309000, 126], [142, 287000, 126], [141, 265000, 126], [141, 243000, 126],
    [152, 397000, 128], [149, 375000, 128], [145, 353000, 128], [144, 331000, 128], [143, 309000, 128], [143, 287000, 128], [143, 265000, 128], [143, 243000, 128],
    [153, 397000, 130], [149, 375000, 130], [146, 353000, 130], [146, 331000, 130], [146, 309000, 130], [146, 287000, 130], [145, 265000, 130], [145, 243000, 130],
    [153, 397000, 132], [150, 375000, 132], [147, 353000, 132], [147, 331000, 132], [147, 309000, 132], [147, 287000, 132], [146, 265000, 132], [146, 243000, 132],
]);
/** Minimum V2 for weight, v1 -> min v2 at flaps 15 */
B787VSpeedData.MAX_TO_DRY_FLAPS_15_MINIMUM_V2 = new LerpLookupTable([
    [148, 419000, 96], [144, 397000, 96], [140, 375000, 96], [136, 353000, 96], [131, 331000, 96], [127, 309000, 96], [123, 287000, 96], [119, 265000, 96], [119, 243000, 96],
    [148, 419000, 98], [144, 397000, 98], [140, 375000, 98], [136, 353000, 98], [131, 331000, 98], [127, 309000, 98], [123, 287000, 98], [119, 265000, 98], [119, 243000, 98],
    [148, 419000, 100], [144, 397000, 100], [140, 375000, 100], [136, 353000, 100], [131, 331000, 100], [127, 309000, 100], [123, 287000, 100], [119, 265000, 100], [119, 243000, 100],
    [148, 419000, 102], [144, 397000, 102], [140, 375000, 102], [136, 353000, 102], [131, 331000, 102], [127, 309000, 102], [123, 287000, 102], [119, 265000, 102], [119, 243000, 102],
    [148, 419000, 104], [144, 397000, 104], [140, 375000, 104], [136, 353000, 104], [132, 331000, 104], [128, 309000, 104], [124, 287000, 104], [121, 265000, 104], [119, 243000, 104],
    [148, 419000, 106], [144, 397000, 106], [140, 375000, 106], [136, 353000, 106], [132, 331000, 106], [128, 309000, 106], [125, 287000, 106], [122, 265000, 106], [120, 243000, 106],
    [148, 419000, 108], [144, 397000, 108], [140, 375000, 108], [136, 353000, 108], [132, 331000, 108], [129, 309000, 108], [126, 287000, 108], [123, 265000, 108], [121, 243000, 108],
    [148, 419000, 110], [144, 397000, 110], [140, 375000, 110], [136, 353000, 110], [133, 331000, 110], [130, 309000, 110], [127, 287000, 110], [124, 265000, 110], [123, 243000, 110],
    [148, 419000, 112], [144, 397000, 112], [140, 375000, 112], [137, 353000, 112], [134, 331000, 112], [132, 309000, 112], [129, 287000, 112], [126, 265000, 112], [125, 243000, 112],
    [148, 419000, 114], [144, 397000, 114], [141, 375000, 114], [138, 353000, 114], [135, 331000, 114], [132, 309000, 114], [130, 287000, 114], [127, 265000, 114], [127, 243000, 114],
    [148, 419000, 116], [144, 397000, 116], [141, 375000, 116], [139, 353000, 116], [136, 331000, 116], [133, 309000, 116], [130, 287000, 116], [130, 265000, 116], [130, 243000, 116],
    [148, 419000, 118], [144, 397000, 118], [142, 375000, 118], [139, 353000, 118], [137, 331000, 118], [134, 309000, 118], [132, 287000, 118], [132, 265000, 118], [132, 243000, 118],
    [148, 419000, 120], [145, 397000, 120], [143, 375000, 120], [140, 353000, 120], [137, 331000, 120], [135, 309000, 120], [135, 287000, 120], [135, 265000, 120], [134, 243000, 120],
    [148, 419000, 122], [146, 397000, 122], [143, 375000, 122], [141, 353000, 122], [138, 331000, 122], [137, 309000, 122], [137, 287000, 122], [137, 265000, 122], [136, 243000, 122],
    [148, 419000, 124], [146, 397000, 124], [144, 375000, 124], [141, 353000, 124], [139, 331000, 124], [139, 309000, 124], [139, 287000, 124], [138, 265000, 124], [138, 243000, 124],
    [148, 419000, 126], [147, 397000, 126], [144, 375000, 126], [142, 353000, 126], [141, 331000, 126], [141, 309000, 126], [141, 287000, 126], [140, 265000, 126], [140, 243000, 126],
    [148, 419000, 128], [147, 397000, 128], [144, 375000, 128], [142, 353000, 128], [142, 331000, 128], [142, 309000, 128], [142, 287000, 128], [142, 265000, 128], [141, 243000, 128],
    [148, 419000, 130], [147, 397000, 130], [145, 375000, 130], [144, 353000, 130], [145, 331000, 130], [144, 309000, 130], [144, 287000, 130], [144, 265000, 130], [143, 243000, 130],
    [148, 419000, 132], [147, 397000, 132], [146, 375000, 132], [146, 353000, 132], [146, 331000, 132], [146, 309000, 132], [145, 287000, 132], [145, 265000, 132], [144, 243000, 132],
]);
/** Minimum V2 for weight, v1 -> min v2 at flaps 20 */
B787VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_V2 = new LerpLookupTable([
    [148, 463000, 96], [145, 441000, 96], [142, 419000, 96], [138, 397000, 96], [134, 375000, 96], [129, 353000, 96], [125, 331000, 96], [121, 309000, 96], [119, 287000, 96], [119, 265000, 96], [119, 243000, 96],
    [148, 463000, 98], [145, 441000, 98], [142, 419000, 98], [138, 397000, 98], [134, 375000, 98], [129, 353000, 98], [125, 331000, 98], [121, 309000, 98], [119, 287000, 98], [119, 265000, 98], [119, 243000, 98],
    [148, 463000, 100], [145, 441000, 100], [142, 419000, 100], [138, 397000, 100], [134, 375000, 100], [129, 353000, 100], [125, 331000, 100], [122, 309000, 100], [121, 287000, 100], [119, 265000, 100], [119, 243000, 100],
    [148, 463000, 102], [145, 441000, 102], [142, 419000, 102], [138, 397000, 102], [134, 375000, 102], [129, 353000, 102], [125, 331000, 102], [124, 309000, 102], [122, 287000, 102], [119, 265000, 102], [119, 243000, 102],
    [148, 463000, 104], [145, 441000, 104], [142, 419000, 104], [138, 397000, 104], [134, 375000, 104], [129, 353000, 104], [126, 331000, 104], [125, 309000, 104], [123, 287000, 104], [121, 265000, 104], [119, 243000, 104],
    [148, 463000, 106], [145, 441000, 106], [142, 419000, 106], [138, 397000, 106], [134, 375000, 106], [129, 353000, 106], [127, 331000, 106], [126, 309000, 106], [124, 287000, 106], [122, 265000, 106], [122, 243000, 106],
    [148, 463000, 108], [145, 441000, 108], [142, 419000, 108], [138, 397000, 108], [134, 375000, 108], [131, 353000, 108], [129, 331000, 108], [127, 309000, 108], [126, 287000, 108], [123, 265000, 108], [125, 243000, 108],
    [148, 463000, 110], [145, 441000, 110], [142, 419000, 110], [138, 397000, 110], [134, 375000, 110], [133, 353000, 110], [131, 331000, 110], [129, 309000, 110], [127, 287000, 110], [126, 265000, 110], [127, 243000, 110],
    [148, 463000, 112], [145, 441000, 112], [142, 419000, 112], [138, 397000, 112], [136, 375000, 112], [134, 353000, 112], [132, 331000, 112], [130, 309000, 112], [128, 287000, 112], [129, 265000, 112], [130, 243000, 112],
    [148, 463000, 114], [145, 441000, 114], [142, 419000, 114], [139, 397000, 114], [137, 375000, 114], [135, 353000, 114], [134, 331000, 114], [131, 309000, 114], [130, 287000, 114], [132, 265000, 114], [132, 243000, 114],
    [148, 463000, 116], [145, 441000, 116], [142, 419000, 116], [140, 397000, 116], [138, 375000, 116], [136, 353000, 116], [134, 331000, 116], [132, 309000, 116], [132, 287000, 116], [134, 265000, 116], [134, 243000, 116],
    [148, 463000, 118], [145, 441000, 118], [142, 419000, 118], [141, 397000, 118], [139, 375000, 118], [137, 353000, 118], [136, 331000, 118], [134, 309000, 118], [135, 287000, 118], [136, 265000, 118], [136, 243000, 118],
    [148, 463000, 120], [145, 441000, 120], [143, 419000, 120], [142, 397000, 120], [140, 375000, 120], [138, 353000, 120], [137, 331000, 120], [135, 309000, 120], [137, 287000, 120], [137, 265000, 120], [137, 243000, 120],
    [148, 463000, 122], [146, 441000, 122], [145, 419000, 122], [143, 397000, 122], [141, 375000, 122], [140, 353000, 122], [139, 331000, 122], [137, 309000, 122], [139, 287000, 122], [139, 265000, 122], [139, 243000, 122],
    [149, 463000, 124], [147, 441000, 124], [146, 419000, 124], [144, 397000, 124], [142, 375000, 124], [141, 353000, 124], [140, 331000, 124], [140, 309000, 124], [140, 287000, 124], [140, 265000, 124], [140, 243000, 124],
    [150, 463000, 126], [148, 441000, 126], [147, 419000, 126], [145, 397000, 126], [144, 375000, 126], [142, 353000, 126], [142, 331000, 126], [142, 309000, 126], [142, 287000, 126], [142, 265000, 126], [142, 243000, 126],
    [151, 463000, 128], [149, 441000, 128], [148, 419000, 128], [146, 397000, 128], [145, 375000, 128], [143, 353000, 128], [143, 331000, 128], [143, 309000, 128], [143, 287000, 128], [143, 265000, 128], [143, 243000, 128],
    [153, 463000, 130], [150, 441000, 130], [149, 419000, 130], [147, 397000, 130], [146, 375000, 130], [144, 353000, 130], [144, 331000, 130], [144, 309000, 130], [144, 287000, 130], [144, 265000, 130], [144, 243000, 130],
    [154, 463000, 132], [152, 441000, 132], [150, 419000, 132], [148, 397000, 132], [147, 375000, 132], [145, 353000, 132], [145, 331000, 132], [145, 309000, 132], [145, 287000, 132], [145, 265000, 132], [145, 243000, 132],
]);
/**
 * Slope adjustments for weight, slope -> adjustment
 * The table is the same for all flaps settings
 */
B787VSpeedData.MAX_TO_DRY_SLOPE_ADJUST = new LerpLookupTable([
    [-4, 573000, -2], [-3, 529000, -2], [-3, 485000, -2], [-3, 441000, -2], [-3, 397000, -2], [-3, 353000, -2], [-3, 309000, -2], [-2, 265000, -2], [-3, 220000, -2],
    [-2, 573000, -1], [-2, 529000, -1], [-2, 485000, -1], [-1, 441000, -1], [-1, 397000, -1], [-1, 353000, -1], [-1, 309000, -1], [-1, 265000, -1], [-1, 220000, -1],
    [0, 573000, 0], [0, 529000, 0], [0, 485000, 0], [0, 441000, 0], [0, 397000, 0], [0, 353000, 0], [0, 309000, 0], [0, 265000, 0], [0, 220000, 0],
    [2, 573000, 1], [2, 529000, 1], [1, 485000, 1], [1, 441000, 1], [1, 397000, 1], [1, 353000, 1], [1, 309000, 1], [1, 265000, 1], [1, 220000, 1],
    [3, 573000, 2], [3, 529000, 2], [3, 485000, 2], [3, 441000, 2], [2, 397000, 2], [2, 353000, 2], [2, 309000, 2], [2, 265000, 2], [2, 220000, 2],
]);
/**
 * Wind adjustments for weight, wind -> adjustment
 * * The table is the same for all flaps settings
 */
B787VSpeedData.MAX_TO_DRY_WIND_ADJUST = new LerpLookupTable([
    [-3, 573000, -15], [-3, 529000, -15], [-2, 485000, -15], [-2, 441000, -15], [-2, 397000, -15], [-2, 353000, -15], [-2, 309000, -15], [-2, 265000, -15], [-2, 220000, -15],
    [-2, 573000, -10], [-1, 529000, -10], [-1, 485000, -10], [-1, 441000, -10], [-1, 397000, -10], [-1, 353000, -10], [-1, 309000, -10], [-1, 265000, -10], [-1, 220000, -10],
    [-1, 573000, -5], [-1, 529000, -5], [-1, 485000, -5], [-1, 441000, -5], [-1, 397000, -5], [-1, 353000, -5], [-1, 309000, -5], [-1, 265000, -5], [-1, 220000, -5],
    [0, 573000, 0], [0, 529000, 0], [0, 485000, 0], [0, 441000, 0], [0, 397000, 0], [0, 353000, 0], [0, 309000, 0], [0, 265000, 0], [0, 220000, 0],
    [1, 573000, 20], [1, 529000, 20], [1, 485000, 20], [1, 441000, 20], [1, 397000, 20], [1, 353000, 20], [1, 309000, 20], [1, 265000, 20], [1, 220000, 20],
    [2, 573000, 40], [2, 529000, 40], [2, 485000, 40], [2, 441000, 40], [2, 397000, 40], [2, 353000, 40], [2, 309000, 40], [2, 265000, 40], [2, 220000, 40],
]);
B787VSpeedData.TMP_DATA = new Float64Array(3);

/**
 * Boeing 787 MFD side selections.
 */
var MFD_SIDE_SELECT;
(function (MFD_SIDE_SELECT) {
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["LEFT"] = 0] = "LEFT";
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["RIGHT"] = 1] = "RIGHT";
})(MFD_SIDE_SELECT || (MFD_SIDE_SELECT = {}));
/**
 * Boeing 787 transponder modes.
 */
var B78_XPDR_MODE;
(function (B78_XPDR_MODE) {
    B78_XPDR_MODE[B78_XPDR_MODE["STBY"] = 0] = "STBY";
    B78_XPDR_MODE[B78_XPDR_MODE["ON"] = 1] = "ON";
    B78_XPDR_MODE[B78_XPDR_MODE["TA_Only"] = 2] = "TA_Only";
    B78_XPDR_MODE[B78_XPDR_MODE["TA_RA"] = 3] = "TA_RA";
})(B78_XPDR_MODE || (B78_XPDR_MODE = {}));
/**
 * Boeing 787 hydraulic pump modes.
 */
var B78_HYDRAULIC_PUMP_MODE;
(function (B78_HYDRAULIC_PUMP_MODE) {
    B78_HYDRAULIC_PUMP_MODE[B78_HYDRAULIC_PUMP_MODE["OFF"] = 0] = "OFF";
    B78_HYDRAULIC_PUMP_MODE[B78_HYDRAULIC_PUMP_MODE["AUTO"] = 1] = "AUTO";
    B78_HYDRAULIC_PUMP_MODE[B78_HYDRAULIC_PUMP_MODE["ON"] = 2] = "ON";
})(B78_HYDRAULIC_PUMP_MODE || (B78_HYDRAULIC_PUMP_MODE = {}));
/**
 * Boeing 787 IRS knob states.
 */
var IrsKnobState;
(function (IrsKnobState) {
    IrsKnobState[IrsKnobState["Off"] = 0] = "Off";
    IrsKnobState[IrsKnobState["On"] = 1] = "On";
})(IrsKnobState || (IrsKnobState = {}));
/**
 * Boeing 787 AIR DATA/ATT source select knob states.
 */
var AirDataAttSourceKnobState;
(function (AirDataAttSourceKnobState) {
    AirDataAttSourceKnobState[AirDataAttSourceKnobState["Auto"] = 0] = "Auto";
    AirDataAttSourceKnobState[AirDataAttSourceKnobState["Alternate"] = 1] = "Alternate";
})(AirDataAttSourceKnobState || (AirDataAttSourceKnobState = {}));
/** Boeing 787 Alternate Mode Flap Selector states. */
var B78AlternateFlapSelectorState;
(function (B78AlternateFlapSelectorState) {
    B78AlternateFlapSelectorState[B78AlternateFlapSelectorState["Retract"] = -1] = "Retract";
    B78AlternateFlapSelectorState[B78AlternateFlapSelectorState["Off"] = 0] = "Off";
    B78AlternateFlapSelectorState[B78AlternateFlapSelectorState["Extend"] = 1] = "Extend";
})(B78AlternateFlapSelectorState || (B78AlternateFlapSelectorState = {}));
/**
 * Boeing 787 wing/engine anti-ice knob states.
 */
var AntiIceKnobState;
(function (AntiIceKnobState) {
    AntiIceKnobState[AntiIceKnobState["Off"] = 0] = "Off";
    AntiIceKnobState[AntiIceKnobState["Auto"] = 1] = "Auto";
    AntiIceKnobState[AntiIceKnobState["On"] = 2] = "On";
})(AntiIceKnobState || (AntiIceKnobState = {}));
/**
 * A publisher for Boeing 787 cockpit state data.
 */
class CockpitVarsPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of CockpitVarsPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(new Map([
            ['b78_minimums_mode', { name: 'L:XMLVAR_Mins_Selector_Baro', type: SimVarValueType.Number }],
            ['b78_fpa_mode', { name: 'L:XMLVAR_FPA_MODE_ACTIVE', type: SimVarValueType.Bool }],
            ['b78_trk_mode', { name: 'L:XMLVAR_TRK_MODE_ACTIVE', type: SimVarValueType.Bool }],
            ['b78_fpv_mode', { name: 'L:XMLVAR_FPV_MODE_ACTIVE', type: SimVarValueType.Bool }],
            ['pilot_transmitting', { name: 'PILOT TRANSMITTING', type: SimVarValueType.Bool }],
            ['b78_xpdr_mode', { name: 'L:XMLVAR_Transponder_Mode', type: SimVarValueType.Number }],
            ['b78_apu_knob_state', { name: 'L:XMLVAR_APU_StarterKnob_Pos', type: SimVarValueType.Number }],
            ['b78_hyd_pump_left', { name: 'L:XMLVAR_HYDRAULICS_DEMAND_LEFT', type: SimVarValueType.Number }],
            ['b78_hyd_pump_c1', { name: 'L:XMLVAR_HYDRAULICS_C1', type: SimVarValueType.Number }],
            ['b78_hyd_pump_c2', { name: 'L:XMLVAR_HYDRAULICS_C2', type: SimVarValueType.Number }],
            ['b78_hyd_pump_right', { name: 'L:XMLVAR_HYDRAULICS_DEMAND_RIGHT', type: SimVarValueType.Number }],
            ['b78_elec_cabin_util', { name: 'L:XMLVAR_Utility_Cabin', type: SimVarValueType.Bool }],
            ['b78_elec_ife_seats', { name: 'L:XMLVAR_Utility_Ife', type: SimVarValueType.Bool }],
            ['b78_elec_emer_lights', { name: 'L:XMLVAR_EMER_LIGHTS_ARMED', type: SimVarValueType.Number }],
            ['b78_elec_fddoor_pwr', { name: 'L:XMLVAR_FdDoor_Power', type: SimVarValueType.Bool }],
            ['b78_elec_packsL', { name: 'L:XMLVAR_Packs_L_Switch', type: SimVarValueType.Bool }],
            ['b78_elec_packsR', { name: 'L:XMLVAR_Packs_R_Switch', type: SimVarValueType.Bool }],
            ['b78_trim_airL', { name: 'L:XMLVAR_TrimAir_L', type: SimVarValueType.Bool }],
            ['b78_trim_airR', { name: 'L:XMLVAR_TrimAir_R', type: SimVarValueType.Bool }],
            ['b78_fuel_balance_button_on', { name: 'L:XMLVAR_FuelBalance_Switch_On', type: SimVarValueType.Bool }],
            ['b78_fuel_balance_inhb', { name: 'L:XMLVAR_FuelBalance_Fault', type: SimVarValueType.Bool }],
            ['b78_altn_flaps_arm', { name: 'L:XMLVAR_ALTN_FLAPS_ARMED', type: SimVarValueType.Bool }],
            ['b78_altn_flaps_selector', { name: 'L:XMLVAR_ALTN_FLAPS_SELECTOR', type: SimVarValueType.Number }],
            ['b78_fltdeck_temp_target', { name: 'L:XMLVAR_Heat_FltDeck', type: SimVarValueType.Number }],
            ['b78_cabin_master_temp_target', { name: 'L:XMLVAR_Heat_Cabin', type: SimVarValueType.Number }],
            ['b78_fwd_cargo_temp_target', { name: 'L:XMLVAR_Heat_Cargo', type: SimVarValueType.Number }],
            ['b78_recirc_upper', { name: 'L:XMLVAR_RecircUpper', type: SimVarValueType.Bool }],
            ['b78_recirc_lower', { name: 'L:XMLVAR_FansLower', type: SimVarValueType.Bool }],
            ['b78_equip_cool_fwd', { name: 'L:XMLVAR_Equip_Fwd', type: SimVarValueType.Bool }],
            ['b78_equip_cool_aft', { name: 'L:XMLVAR_Cooling_Aft', type: SimVarValueType.Bool }],
            ['mfd_side_select', { name: 'L:XMLVAR_MFD_Side_#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['mfd_nd_wx_terr_contrast_1', { name: 'L:WT_MFD_1_CONTRAST', type: SimVarValueType.Number }],
            ['mfd_nd_wx_terr_contrast_2', { name: 'L:WT_MFD_2_CONTRAST', type: SimVarValueType.Number }],
            ['pfd_minimap_wx_terr_contrast', { name: 'L:WT_PFD_1_CONTRAST', type: SimVarValueType.Number }],
            ['b78_engine_anti_ice_knob_state', { name: 'L:B787_Engine_AntiIce_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b78_wing_anti_ice_knob_state', { name: 'L:B787_Wing_AntiIce_Knob_State', type: SimVarValueType.Number }],
            ['b78_windshield_deice', { name: 'L:XMLVAR_DeiceWindshield:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['baro_ref_hpa', { name: 'L:XMLVAR_Baro_Selector_HPA_#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b78_irs_knob_state', { name: 'L:B787_IRS_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b78_air_data_att_source_knob_state', { name: 'L:B787_Air_Data_Att_Source_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b78_ext_pwr', { name: 'L:EXT_PWR_COMMANDED:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['b78_beacon_light_switch', { name: 'LIGHT BEACON', type: SimVarValueType.Bool }],
            ['b78_spoilers_armed', { name: 'SPOILERS ARMED', type: SimVarValueType.Bool }],
        ]), bus);
    }
}

/* eslint-disable max-len */
/**
 * B787-10 Trent 1000-J Engine Data Utility Class.
 */
class B787EngineData {
    /**
     * Creates an instance of B787 Engine Data
     * @param bus The Event Bus.
     * @param performanceData An instance of the BoeingPerformanceDataProvider.
     */
    constructor(bus, performanceData) {
        this.performanceData = performanceData;
        this.engineCount = 2;
        // 20 is best guess, and matches engines.cfg
        this.IDLE_N1 = 20;
        // 96.5 is the highest N1 value found in perf tables.
        // (This is still a best guess as to what maximum rated thrust means, we know max rated is below redline, based on the FCOM)
        this.MAX_RATED_N1 = 96.5;
        // 101.5 from the GEnx-1B + GEnx-2B series cert docs for Trent engines (LP).
        this.RED_LINE_N1 = 101.5;
        // 58 is best guess from looking at videos.
        this.IDLE_N2 = 58;
        // 103 from the GEnx-1B + GEnx-2B series cert docs for Trent engines (IP).
        this.RED_LINE_N2 = 106;
        // 750 comes from the GEnx-1B + GEnx-2B series cert docs.
        this.START_LIMIT_EGT = 750;
        // 850 comes from GEnx-1B + GEnx-2B series cert docs, EGT Max Continuous max temp C
        this.CONTINUOUS_LIMIT_EGT = 1030;
        // 1065 comes from GEnx-1B + GEnx-2B series cert docs, Max T/O Temp C
        // (we used the highest egt limit in that table)
        this.RED_LINE_EGT = 1065;
        this.mach = ConsumerValue.create(null, 0);
        this.sat = ConsumerValue.create(null, 0);
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.tprAltCorrection = new LerpLookupTable([[1, 0], [1.43, 20000], [1.38, 25000], [1.28, 30000], [1.18, 35000], [1.155, 38000], [1.09525, 40000]]);
        this.mach.setConsumer(bus.getSubscriber().on('mach_number').withPrecision(2));
        this.sat.setConsumer(bus.getSubscriber().on('ambient_temp_c').withPrecision(0));
        this.pressureAlt.setConsumer(bus.getSubscriber().on('pressure_alt').withPrecision(0));
    }
    /** @inheritdoc */
    getMaxConN1(pressureAltitude, tat) {
        return B787EngineData.max_con_n1.get(tat, pressureAltitude);
    }
    /** @inheritdoc */
    getMaxConTpr(pressureAltitude, tat) {
        return this.getTprFromN1(this.getMaxConN1(pressureAltitude, tat), tat, pressureAltitude);
    }
    /** @inheritdoc */
    getToMaxTpr(airportPressureAltitude, airportTemp) {
        return this.getTprFromN1(this.getToMaxN1(airportPressureAltitude, airportTemp), airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getToMaxN1(airportPressureAltitude, airportTemp) {
        return B787EngineData.to_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getTo1Tpr(airportPressureAltitude, airportTemp) {
        return this.getTprFromN1(this.getTo1N1(airportPressureAltitude, airportTemp), airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getTo1N1(airportPressureAltitude, airportTemp) {
        const maxTo = this.getToMaxN1(airportPressureAltitude, airportTemp);
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(0, maxTo);
        // 10% derate
        const deratedThrustScalar = 0.9 * thrustScalar;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(0, deratedThrustScalar);
    }
    /** @inheritdoc */
    getTo2Tpr(airportPressureAltitude, airportTemp) {
        return this.getTprFromN1(this.getTo2N1(airportPressureAltitude, airportTemp), airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getTo2N1(airportPressureAltitude, airportTemp) {
        const maxTo = this.getToMaxN1(airportPressureAltitude, airportTemp);
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(0, maxTo);
        // 20% derate
        const deratedThrustScalar = 0.8 * thrustScalar;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(0, deratedThrustScalar);
    }
    /** @inheritdoc */
    getClbMaxTpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getClbMaxN1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClbMaxN1(pressureAltitude, totalAirTemp) {
        return B787EngineData.clb_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClb1Tpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getClb1N1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClb1N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 5% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, maxClb);
        const derate = thrustScalar * 0.05 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(mach, thrustScalar - derate);
    }
    /** @inheritdoc */
    getClb2Tpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getClb2N1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClb2N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 15% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(mach, maxClb);
        const derate = thrustScalar * 0.15 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(mach, thrustScalar - derate);
    }
    /** @inheritdoc */
    getGaMaxTpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getGaMaxN1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getGaMaxN1(pressureAltitude, totalAirTemp) {
        return B787EngineData.ga_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getCruiseMaxN1(pressureAltitude, totalAirTemp) {
        return B787EngineData.cru_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getOptimumAltitude(aircraftWeight) {
        return Math.min(B787EngineData.alt_opt.get(aircraftWeight), 41000);
    }
    /** @inheritdoc */
    getMaximumAltitude(aircraftWeight) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(this.pressureAlt.get());
        const isaTempC = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const isaDev = this.sat.get() - isaTempC;
        return Math.min(B787EngineData.alt_max.get(aircraftWeight, isaDev), 41000);
    }
    /** @inheritdoc */
    getLongRangeCruiseMach(aircraftWeight, pressureAltitude) {
        return B787EngineData.lrc_mach.get(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    getEconCruiseMach(aircraftWeight, pressureAltitude) {
        return 0.95 * this.getLongRangeCruiseMach(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    getTprFromN1(n1, tat, pressureAltitude) {
        const isaTemp = UnitType.CELSIUS.convertTo(AeroMath.isaTemperature(pressureAltitude), UnitType.KELVIN);
        const deltaIsa = UnitType.CELSIUS.convertTo(tat, UnitType.KELVIN) - isaTemp;
        const rangeScalar = 1.33;
        const densityRatio = isaTemp / (isaTemp + deltaIsa * rangeScalar);
        const maxThrust = this.performanceData.calculateThrustFromCorrectedN1(100, this.mach.get());
        const n1Thrust = this.performanceData.calculateThrustFromCorrectedN1(n1, this.mach.get()) * densityRatio;
        const tpr = (n1Thrust / maxThrust) * 100 * 1.04 * this.tprAltCorrection.get(pressureAltitude);
        return (tpr <= 96) ? tpr : MathUtils.lerp(tpr, 96, 115, 96, 100);
    }
    /** @inheritDoc */
    getTakeoffDeratePercentage(targetN1, maxN1) {
        const targetThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(0, targetN1);
        const maxThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(0, maxN1);
        return (maxThrustScalar - targetThrustScalar) / maxThrustScalar * 100;
    }
}
B787EngineData.to_tpr_max = new LerpLookupTable([
    [50.7, 75, -2000], [50.8, 75, -1000], [50.8, 75, 0], [49.8, 75, 1000], [48.8, 75, 2000], [47.8, 75, 3000], [46.8, 75, 4000], [45.8, 75, 5000], [44.7, 75, 6000],
    [43.2, 75, 7000], [41.7, 75, 8000], [40.2, 75, 9000], [38.6, 75, 10000], [37.1, 75, 11000], [35.5, 75, 12000], [33.6, 75, 13000], [31.7, 75, 14000],
    [54.6, 70, -2000], [54.8, 70, -1000], [55, 70, 0], [54, 70, 1000], [53.1, 70, 2000], [52.2, 70, 3000], [51.3, 70, 4000], [50.3, 70, 5000], [49.3, 70, 6000],
    [47.9, 70, 7000], [46.4, 70, 8000], [44.9, 70, 9000], [43.4, 70, 10000], [42, 70, 11000], [40.4, 70, 12000], [38.5, 70, 13000], [36.6, 70, 14000],
    [58.4, 65, -2000], [58.8, 65, -1000], [59.2, 65, 0], [58.2, 65, 1000], [57.4, 65, 2000], [56.6, 65, 3000], [55.7, 65, 4000], [54.8, 65, 5000], [53.9, 65, 6000],
    [52.5, 65, 7000], [51.1, 65, 8000], [49.7, 65, 9000], [48.2, 65, 10000], [46.8, 65, 11000], [45.3, 65, 12000], [43.4, 65, 13000], [41.5, 65, 14000],
    [62.3, 60, -2000], [62.9, 60, -1000], [63.3, 60, 0], [62.4, 60, 1000], [61.7, 60, 2000], [60.9, 60, 3000], [60.2, 60, 4000], [59.3, 60, 5000], [58.5, 60, 6000],
    [57.2, 60, 7000], [55.8, 60, 8000], [54.4, 60, 9000], [53, 60, 10000], [51.6, 60, 11000], [50.2, 60, 12000], [48.3, 60, 13000], [46.4, 60, 14000],
    [65.9, 55, -2000], [66.8, 55, -1000], [67.5, 55, 0], [66.6, 55, 1000], [66, 55, 2000], [65.3, 55, 3000], [64.6, 55, 4000], [63.9, 55, 5000], [63.1, 55, 6000],
    [61.8, 55, 7000], [60.4, 55, 8000], [59.2, 55, 9000], [57.7, 55, 10000], [56.5, 55, 11000], [55.1, 55, 12000], [53.2, 55, 13000], [51.3, 55, 14000],
    [69.5, 50, -2000], [70.5, 50, -1000], [71.4, 50, 0], [70.7, 50, 1000], [70.2, 50, 2000], [69.7, 50, 3000], [69.1, 50, 4000], [68.4, 50, 5000], [67.7, 50, 6000],
    [66.4, 50, 7000], [65.1, 50, 8000], [63.9, 50, 9000], [62.5, 50, 10000], [61.3, 50, 11000], [60, 50, 12000], [58.1, 50, 13000], [56.2, 50, 14000],
    [72.8, 45, -2000], [74.1, 45, -1000], [75.4, 45, 0], [74.7, 45, 1000], [74.3, 45, 2000], [73.9, 45, 3000], [73.4, 45, 4000], [72.9, 45, 5000], [72.3, 45, 6000],
    [71.1, 45, 7000], [69.8, 45, 8000], [68.6, 45, 9000], [67.3, 45, 10000], [66.1, 45, 11000], [64.9, 45, 12000], [63, 45, 13000], [61.1, 45, 14000],
    [76.1, 40, -2000], [77.6, 40, -1000], [78.9, 40, 0], [78.5, 40, 1000], [78.4, 40, 2000], [78.1, 40, 3000], [77.7, 40, 4000], [77.3, 40, 5000], [76.8, 40, 6000],
    [75.7, 40, 7000], [74.5, 40, 8000], [73.4, 40, 9000], [72.1, 40, 10000], [71, 40, 11000], [69.8, 40, 12000], [67.9, 40, 13000], [66, 40, 14000],
    [79.6, 35, -2000], [81.2, 35, -1000], [82.7, 35, 0], [82.2, 35, 1000], [82.1, 35, 2000], [82, 35, 3000], [81.9, 35, 4000], [81.7, 35, 5000], [81.3, 35, 6000],
    [80.4, 35, 7000], [79.3, 35, 8000], [78.2, 35, 9000], [76.9, 35, 10000], [75.8, 35, 11000], [74.7, 35, 12000], [72.8, 35, 13000], [70.9, 35, 14000],
    [80.6, 30, -2000], [83.6, 30, -1000], [86.7, 30, 0], [86.3, 30, 1000], [86.2, 30, 2000], [86, 30, 3000], [85.9, 30, 4000], [85.7, 30, 5000], [85.6, 30, 6000],
    [84.9, 30, 7000], [84.1, 30, 8000], [83.1, 30, 9000], [81.9, 30, 10000], [80.8, 30, 11000], [79.6, 30, 12000], [77.7, 30, 13000], [75.8, 30, 14000],
    [80.8, 25, -2000], [83.9, 25, -1000], [87, 25, 0], [88.1, 25, 1000], [89.6, 25, 2000], [90.4, 25, 3000], [90.2, 25, 4000], [90.1, 25, 5000], [90, 25, 6000],
    [89.1, 25, 7000], [88.2, 25, 8000], [87.8, 25, 9000], [87, 25, 10000], [85.9, 25, 11000], [84.7, 25, 12000], [82.7, 25, 13000], [80.8, 25, 14000],
    [81, 20, -2000], [84.1, 20, -1000], [87.2, 20, 0], [88.3, 20, 1000], [89.9, 20, 2000], [91.4, 20, 3000], [92.8, 20, 4000], [94.3, 20, 5000], [94.1, 20, 6000],
    [93.6, 20, 7000], [92.9, 20, 8000], [92.1, 20, 9000], [90.3, 20, 10000], [89.8, 20, 11000], [89.3, 20, 12000], [87.8, 20, 13000], [85.9, 20, 14000],
    [81.2, 15, -2000], [84.3, 15, -1000], [87.4, 15, 0], [88.6, 15, 1000], [90.1, 15, 2000], [91.6, 15, 3000], [93.1, 15, 4000], [94.5, 15, 5000], [95.7, 15, 6000],
    [96.6, 15, 7000], [96.9, 15, 8000], [96.3, 15, 9000], [94.8, 15, 10000], [93.5, 15, 11000], [92.6, 15, 12000], [91.4, 15, 13000], [90.1, 15, 14000],
    [81.4, 10, -2000], [84.5, 10, -1000], [87.6, 10, 0], [88.8, 10, 1000], [90.3, 10, 2000], [91.9, 10, 3000], [93.3, 10, 4000], [94.8, 10, 5000], [96, 10, 6000],
    [96.9, 10, 7000], [97.8, 10, 8000], [98.6, 10, 9000], [98.6, 10, 10000], [97.4, 10, 11000], [96.1, 10, 12000], [94.7, 10, 13000], [93.4, 10, 14000],
    [81.6, 5, -2000], [84.8, 5, -1000], [87.9, 5, 0], [89, 5, 1000], [90.6, 5, 2000], [92.1, 5, 3000], [93.6, 5, 4000], [95, 5, 5000], [96.2, 5, 6000], [97.1, 5, 7000],
    [98, 5, 8000], [98.8, 5, 9000], [98.9, 5, 10000], [99.8, 5, 11000], [99.8, 5, 12000], [98.4, 5, 13000], [97, 5, 14000],
    [81.8, 0, -2000], [85, 0, -1000], [88.1, 0, 0], [89.3, 0, 1000], [90.8, 0, 2000], [92.4, 0, 3000], [93.8, 0, 4000], [95.3, 0, 5000], [96.5, 0, 6000], [97.4, 0, 7000],
    [98.3, 0, 8000], [99.1, 0, 9000], [99.1, 0, 10000], [100.1, 0, 11000], [102.8, 0, 12000], [102.2, 0, 13000], [100.8, 0, 14000],
    [82.3, -10, -2000], [85.4, -10, -1000], [88.6, -10, 0], [89.7, -10, 1000], [91.3, -10, 2000], [92.8, -10, 3000], [94.3, -10, 4000], [95.8, -10, 5000],
    [97, -10, 6000], [97.9, -10, 7000], [98.8, -10, 8000], [99.6, -10, 9000], [99.7, -10, 10000], [100.6, -10, 11000], [103.3, -10, 12000], [103.3, -10, 13000],
    [103.2, -10, 14000], [82.7, -20, -2000], [85.9, -20, -1000], [89, -20, 0], [90.2, -20, 1000], [91.7, -20, 2000], [93.3, -20, 3000], [94.8, -20, 4000], [96.3, -20, 5000],
    [97.5, -20, 6000], [98.4, -20, 7000], [99.3, -20, 8000], [100.1, -20, 9000], [100.2, -20, 10000], [101.1, -20, 11000], [103.9, -20, 12000], [103.8, -20, 13000],
    [103.7, -20, 14000], [83.1, -30, -2000], [86.3, -30, -1000], [89.5, -30, 0], [90.7, -30, 1000], [92.2, -30, 2000], [93.8, -30, 3000], [95.3, -30, 4000], [96.8, -30, 5000],
    [98, -30, 6000], [98.9, -30, 7000], [99.8, -30, 8000], [100.7, -30, 9000], [100.7, -30, 10000], [101.7, -30, 11000], [104.4, -30, 12000], [104.3, -30, 13000],
    [104.3, -30, 14000], [83.5, -40, -2000], [86.7, -40, -1000], [89.9, -40, 0], [91.1, -40, 1000], [92.7, -40, 2000], [94.3, -40, 3000], [95.8, -40, 4000], [97.3, -40, 5000],
    [98.5, -40, 6000], [99.4, -40, 7000], [100.4, -40, 8000], [101.2, -40, 9000], [101.2, -40, 10000], [102.2, -40, 11000], [104.9, -40, 12000], [104.9, -40, 13000],
    [104.8, -40, 14000], [84, -50, -2000], [87.2, -50, -1000], [90.4, -50, 0], [91.6, -50, 1000], [93.2, -50, 2000], [94.8, -50, 3000], [96.3, -50, 4000], [97.8, -50, 5000],
    [99, -50, 6000], [100, -50, 7000], [100.9, -50, 8000], [101.7, -50, 9000], [101.8, -50, 10000], [102.7, -50, 11000], [105.5, -50, 12000], [105.4, -50, 13000],
    [105.4, -50, 14000]
]);
B787EngineData.to_n1_max = new LerpLookupTable([
    [87, 55, -2000], [87.4, 55, -1000], [87.8, 55, 0], [87.4, 55, 1000], [87, 55, 2000], [86.7, 55, 3000], [86.3, 55, 4000], [85.9, 55, 5000], [85.4, 55, 6000], [84.7, 55, 7000],
    [83.9, 55, 8000], [83.2, 55, 9000], [82.3, 55, 10000], [81.6, 55, 11000], [80.8, 55, 12000], [79.5, 55, 13000], [78.2, 55, 14000],
    [88.2, 50, -2000], [88.7, 50, -1000], [89.1, 50, 0], [88.8, 50, 1000], [88.6, 50, 2000], [88.3, 50, 3000], [88, 50, 4000], [87.7, 50, 5000], [87.3, 50, 6000], [86.6, 50, 7000],
    [86, 50, 8000], [85.3, 50, 9000], [84.5, 50, 10000], [83.8, 50, 11000], [83.1, 50, 12000], [82, 50, 13000], [80.8, 50, 14000],
    [89, 45, -2000], [89.6, 45, -1000], [90.2, 45, 0], [89.9, 45, 1000], [89.7, 45, 2000], [89.5, 45, 3000], [89.3, 45, 4000], [89.1, 45, 5000], [88.8, 45, 6000], [88.3, 45, 7000],
    [87.7, 45, 8000], [87.1, 45, 9000], [86.5, 45, 10000], [85.8, 45, 11000], [85.2, 45, 12000], [84.1, 45, 13000], [83.1, 45, 14000],
    [89.8, 40, -2000], [90.4, 40, -1000], [91, 40, 0], [90.9, 40, 1000], [90.8, 40, 2000], [90.7, 40, 3000], [90.5, 40, 4000], [90.4, 40, 5000], [90.2, 40, 6000], [89.7, 40, 7000],
    [89.1, 40, 8000], [88.6, 40, 9000], [88.1, 40, 10000], [87.6, 40, 11000], [87.1, 40, 12000], [86.1, 40, 13000], [85.1, 40, 14000],
    [90.6, 35, -2000], [91.3, 35, -1000], [92, 35, 0], [91.8, 35, 1000], [91.8, 35, 2000], [91.7, 35, 3000], [91.7, 35, 4000], [91.6, 35, 5000], [91.4, 35, 6000], [91, 35, 7000],
    [90.5, 35, 8000], [90.1, 35, 9000], [89.5, 35, 10000], [89, 35, 11000], [88.5, 35, 12000], [87.7, 35, 13000], [86.9, 35, 14000],
    [90.3, 30, -2000], [91.7, 30, -1000], [93, 30, 0], [92.8, 30, 1000], [92.8, 30, 2000], [92.7, 30, 3000], [92.7, 30, 4000], [92.6, 30, 5000], [92.6, 30, 6000], [92.3, 30, 7000],
    [91.9, 30, 8000], [91.5, 30, 9000], [91, 30, 10000], [90.5, 30, 11000], [90, 30, 12000], [89.1, 30, 13000], [88.3, 30, 14000],
    [89.6, 25, -2000], [91, 25, -1000], [92.4, 25, 0], [92.8, 25, 1000], [93.5, 25, 2000], [93.9, 25, 3000], [93.8, 25, 4000], [93.7, 25, 5000], [93.7, 25, 6000], [93.3, 25, 7000],
    [92.9, 25, 8000], [92.8, 25, 9000], [92.4, 25, 10000], [91.9, 25, 11000], [91.4, 25, 12000], [90.6, 25, 13000], [89.8, 25, 14000],
    [89, 20, -2000], [90.3, 20, -1000], [91.7, 20, 0], [92.2, 20, 1000], [92.8, 20, 2000], [93.5, 20, 3000], [94.2, 20, 4000], [94.9, 20, 5000], [94.8, 20, 6000], [94.6, 20, 7000],
    [94.3, 20, 8000], [93.9, 20, 9000], [93.1, 20, 10000], [92.9, 20, 11000], [92.7, 20, 12000], [92, 20, 13000], [91.2, 20, 14000],
    [88.3, 15, -2000], [89.7, 15, -1000], [91, 15, 0], [91.5, 15, 1000], [92.1, 15, 2000], [92.8, 15, 3000], [93.5, 15, 4000], [94.2, 15, 5000], [94.8, 15, 6000], [95.3, 15, 7000],
    [95.4, 15, 8000], [95.1, 15, 9000], [94.3, 15, 10000], [93.7, 15, 11000], [93.4, 15, 12000], [92.8, 15, 13000], [92.2, 15, 14000],
    [87.6, 10, -2000], [89, 10, -1000], [90.3, 10, 0], [90.8, 10, 1000], [91.4, 10, 2000], [92.1, 10, 3000], [92.8, 10, 4000], [93.5, 10, 5000], [94.1, 10, 6000], [94.6, 10, 7000],
    [95.1, 10, 8000], [95.5, 10, 9000], [95.5, 10, 10000], [94.9, 10, 11000], [94.2, 10, 12000], [93.5, 10, 13000], [92.9, 10, 14000],
    [86.9, 5, -2000], [88.3, 5, -1000], [89.6, 5, 0], [90.1, 5, 1000], [90.7, 5, 2000], [91.4, 5, 3000], [92.1, 5, 4000], [92.7, 5, 5000], [93.4, 5, 6000], [93.9, 5, 7000],
    [94.4, 5, 8000], [94.8, 5, 9000], [94.8, 5, 10000], [95.3, 5, 11000], [95.4, 5, 12000], [94.6, 5, 13000], [93.9, 5, 14000],
    [86.2, 0, -2000], [87.6, 0, -1000], [88.9, 0, 0], [89.4, 0, 1000], [90, 0, 2000], [90.7, 0, 3000], [91.4, 0, 4000], [92, 0, 5000], [92.7, 0, 6000], [93.2, 0, 7000],
    [93.6, 0, 8000], [94.1, 0, 9000], [94.1, 0, 10000], [94.6, 0, 11000], [96.1, 0, 12000], [95.8, 0, 13000], [95.1, 0, 14000],
    [84.8, -10, -2000], [86.1, -10, -1000], [87.4, -10, 0], [87.9, -10, 1000], [88.6, -10, 2000], [89.3, -10, 3000], [89.9, -10, 4000], [90.6, -10, 5000], [91.2, -10, 6000],
    [91.7, -10, 7000], [92.2, -10, 8000], [92.6, -10, 9000], [92.6, -10, 10000], [93.2, -10, 11000], [94.7, -10, 12000], [94.7, -10, 13000], [94.7, -10, 14000],
    [83.4, -20, -2000], [84.7, -20, -1000], [85.9, -20, 0], [86.4, -20, 1000], [87.1, -20, 2000], [87.7, -20, 3000], [88.4, -20, 4000], [89.1, -20, 5000], [89.7, -20, 6000],
    [90.2, -20, 7000], [90.7, -20, 8000], [91.1, -20, 9000], [91.1, -20, 10000], [91.7, -20, 11000], [93.1, -20, 12000], [93.1, -20, 13000], [93.1, -20, 14000],
    [81.9, -30, -2000], [83.1, -30, -1000], [84.4, -30, 0], [84.9, -30, 1000], [85.5, -30, 2000], [86.2, -30, 3000], [86.8, -30, 4000], [87.6, -30, 5000], [88.2, -30, 6000],
    [88.7, -30, 7000], [89.1, -30, 8000], [89.5, -30, 9000], [89.6, -30, 10000], [90.1, -30, 11000], [91.6, -30, 12000], [91.6, -30, 13000], [91.6, -30, 14000],
    [80.3, -40, -2000], [81.6, -40, -1000], [82.8, -40, 0], [83.3, -40, 1000], [83.9, -40, 2000], [84.6, -40, 3000], [85.3, -40, 4000], [86, -40, 5000], [86.6, -40, 6000],
    [87.1, -40, 7000], [87.5, -40, 8000], [88, -40, 9000], [88, -40, 10000], [88.5, -40, 11000], [90, -40, 12000], [89.9, -40, 13000], [89.9, -40, 14000],
    [78.8, -50, -2000], [80, -50, -1000], [81.2, -50, 0], [81.7, -50, 1000], [82.3, -50, 2000], [83, -50, 3000], [83.7, -50, 4000], [84.4, -50, 5000], [85, -50, 6000],
    [85.4, -50, 7000], [85.9, -50, 8000], [86.3, -50, 9000], [86.4, -50, 10000], [86.9, -50, 11000], [88.3, -50, 12000], [88.3, -50, 13000], [88.3, -50, 14000]
]);
B787EngineData.to_tpr_1 = new LerpLookupTable([
    [46.5, 75, -2000], [46.6, 75, -1000], [46.6, 75, 0], [45.7, 75, 1000], [45, 75, 2000], [45, 75, 3000], [45, 75, 4000], [45, 75, 5000], [44.7, 75, 6000], [43.2, 75, 7000],
    [41.7, 75, 8000], [40.2, 75, 9000], [38.6, 75, 10000], [37.1, 75, 11000], [35.5, 75, 12000], [33.6, 75, 13000], [31.7, 75, 14000],
    [50, 70, -2000], [50.2, 70, -1000], [50.4, 70, 0], [49.5, 70, 1000], [48.7, 70, 2000], [47.9, 70, 3000], [47, 70, 4000], [46.2, 70, 5000], [45.3, 70, 6000], [45, 70, 7000],
    [45, 70, 8000], [44.9, 70, 9000], [43.4, 70, 10000], [42, 70, 11000], [40.4, 70, 12000], [38.5, 70, 13000], [36.6, 70, 14000],
    [53.5, 65, -2000], [53.8, 65, -1000], [54.1, 65, 0], [53.3, 65, 1000], [52.6, 65, 2000], [51.8, 65, 3000], [51.1, 65, 4000], [50.2, 65, 5000], [49.4, 65, 6000],
    [48.1, 65, 7000], [46.9, 65, 8000], [45.6, 65, 9000], [45, 65, 10000], [45, 65, 11000], [45, 65, 12000], [43.4, 65, 13000], [41.5, 65, 14000],
    [57, 60, -2000], [57.5, 60, -1000], [57.9, 60, 0], [57.1, 60, 1000], [56.4, 60, 2000], [55.7, 60, 3000], [55, 60, 4000], [54.3, 60, 5000], [53.5, 60, 6000], [52.3, 60, 7000],
    [51.1, 60, 8000], [49.9, 60, 9000], [48.6, 60, 10000], [47.4, 60, 11000], [46.1, 60, 12000], [45, 60, 13000], [45, 60, 14000],
    [60.2, 55, -2000], [61, 55, -1000], [61.6, 55, 0], [60.8, 55, 1000], [60.3, 55, 2000], [59.7, 55, 3000], [59, 55, 4000], [58.4, 55, 5000], [57.7, 55, 6000], [56.5, 55, 7000],
    [55.3, 55, 8000], [54.1, 55, 9000], [52.9, 55, 10000], [51.7, 55, 11000], [50.5, 55, 12000], [48.8, 55, 13000], [47, 55, 14000],
    [63.4, 50, -2000], [64.3, 50, -1000], [65.1, 50, 0], [64.4, 50, 1000], [64, 50, 2000], [63.5, 50, 3000], [63, 50, 4000], [62.4, 50, 5000], [61.8, 50, 6000], [60.7, 50, 7000],
    [59.5, 50, 8000], [58.4, 50, 9000], [57.2, 50, 10000], [56, 50, 11000], [54.9, 50, 12000], [53.2, 50, 13000], [51.4, 50, 14000],
    [66.2, 45, -2000], [67.4, 45, -1000], [68.5, 45, 0], [68, 45, 1000], [67.6, 45, 2000], [67.2, 45, 3000], [66.8, 45, 4000], [66.4, 45, 5000], [65.8, 45, 6000], [64.8, 45, 7000],
    [63.6, 45, 8000], [62.6, 45, 9000], [61.4, 45, 10000], [60.4, 45, 11000], [59.3, 45, 12000], [57.6, 45, 13000], [55.8, 45, 14000],
    [69.1, 40, -2000], [70.4, 40, -1000], [71.5, 40, 0], [71.2, 40, 1000], [71.1, 40, 2000], [70.9, 40, 3000], [70.6, 40, 4000], [70.2, 40, 5000], [69.8, 40, 6000],
    [68.8, 40, 7000], [67.8, 40, 8000], [66.8, 40, 9000], [65.6, 40, 10000], [64.7, 40, 11000], [63.6, 40, 12000], [61.9, 40, 13000], [60.2, 40, 14000],
    [72.2, 35, -2000], [73.6, 35, -1000], [74.7, 35, 0], [74.4, 35, 1000], [74.3, 35, 2000], [74.1, 35, 3000], [74.1, 35, 4000], [73.9, 35, 5000], [73.6, 35, 6000],
    [72.8, 35, 7000], [71.9, 35, 8000], [71, 35, 9000], [69.8, 35, 10000], [68.9, 35, 11000], [67.9, 35, 12000], [66.2, 35, 13000], [64.6, 35, 14000],
    [73, 30, -2000], [75.6, 30, -1000], [78.1, 30, 0], [77.8, 30, 1000], [77.6, 30, 2000], [77.5, 30, 3000], [77.4, 30, 4000], [77.3, 30, 5000], [77.2, 30, 6000], [76.6, 30, 7000],
    [75.9, 30, 8000], [75.1, 30, 9000], [74.1, 30, 10000], [73.2, 30, 11000], [72.2, 30, 12000], [70.5, 30, 13000], [68.9, 30, 14000],
    [73.2, 25, -2000], [75.7, 25, -1000], [78.3, 25, 0], [79.2, 25, 1000], [80.5, 25, 2000], [81, 25, 3000], [80.9, 25, 4000], [80.8, 25, 5000], [80.7, 25, 6000], [80, 25, 7000],
    [79.3, 25, 8000], [78.9, 25, 9000], [78.3, 25, 10000], [77.4, 25, 11000], [76.4, 25, 12000], [74.8, 25, 13000], [73.1, 25, 14000],
    [73.3, 20, -2000], [75.9, 20, -1000], [78.5, 20, 0], [79.4, 20, 1000], [80.6, 20, 2000], [81.8, 20, 3000], [82.8, 20, 4000], [83.8, 20, 5000], [83.7, 20, 6000],
    [83.3, 20, 7000], [82.8, 20, 8000], [82.3, 20, 9000], [81, 20, 10000], [80.6, 20, 11000], [80.2, 20, 12000], [79, 20, 13000], [77.4, 20, 14000],
    [73.5, 15, -2000], [76.1, 15, -1000], [78.7, 15, 0], [79.6, 15, 1000], [80.8, 15, 2000], [81.9, 15, 3000], [83, 15, 4000], [84, 15, 5000], [84.8, 15, 6000], [85.4, 15, 7000],
    [85.6, 15, 8000], [85.2, 15, 9000], [84.2, 15, 10000], [83.3, 15, 11000], [82.6, 15, 12000], [81.7, 15, 13000], [80.9, 15, 14000],
    [73.7, 10, -2000], [76.3, 10, -1000], [78.8, 10, 0], [79.8, 10, 1000], [81, 10, 2000], [82.1, 10, 3000], [83.1, 10, 4000], [84.2, 10, 5000], [85, 10, 6000], [85.6, 10, 7000],
    [86.2, 10, 8000], [86.7, 10, 9000], [86.8, 10, 10000], [85.9, 10, 11000], [85, 10, 12000], [84.1, 10, 13000], [83.2, 10, 14000],
    [73.9, 5, -2000], [76.5, 5, -1000], [79, 5, 0], [80, 5, 1000], [81.2, 5, 2000], [82.3, 5, 3000], [83.3, 5, 4000], [84.3, 5, 5000], [85.1, 5, 6000], [85.8, 5, 7000],
    [86.4, 5, 8000], [86.9, 5, 9000], [86.9, 5, 10000], [87.5, 5, 11000], [87.6, 5, 12000], [86.6, 5, 13000], [85.7, 5, 14000],
    [74, 0, -2000], [76.7, 0, -1000], [79.2, 0, 0], [80.2, 0, 1000], [81.3, 0, 2000], [82.5, 0, 3000], [83.5, 0, 4000], [84.5, 0, 5000], [85.3, 0, 6000], [85.9, 0, 7000],
    [86.5, 0, 8000], [87.1, 0, 9000], [87.1, 0, 10000], [87.7, 0, 11000], [89.4, 0, 12000], [89, 0, 13000], [88.2, 0, 14000],
    [74.4, -10, -2000], [77, -10, -1000], [79.6, -10, 0], [80.5, -10, 1000], [81.7, -10, 2000], [82.8, -10, 3000], [83.8, -10, 4000], [84.8, -10, 5000], [85.7, -10, 6000],
    [86.3, -10, 7000], [86.9, -10, 8000], [87.4, -10, 9000], [87.4, -10, 10000], [88, -10, 11000], [89.7, -10, 12000], [89.7, -10, 13000], [89.6, -10, 14000],
    [74.8, -20, -2000], [77.4, -20, -1000], [80, -20, 0], [80.9, -20, 1000], [82, -20, 2000], [83.1, -20, 3000], [84.2, -20, 4000], [85.2, -20, 5000], [86, -20, 6000],
    [86.6, -20, 7000], [87.2, -20, 8000], [87.8, -20, 9000], [87.8, -20, 10000], [88.4, -20, 11000], [90, -20, 12000], [90, -20, 13000], [90, -20, 14000],
    [75.1, -30, -2000], [77.8, -30, -1000], [80.3, -30, 0], [81.2, -30, 1000], [82.4, -30, 2000], [83.5, -30, 3000], [84.5, -30, 4000], [85.5, -30, 5000], [86.3, -30, 6000],
    [87, -30, 7000], [87.6, -30, 8000], [88.1, -30, 9000], [88.1, -30, 10000], [88.7, -30, 11000], [90.4, -30, 12000], [90.3, -30, 13000], [90.3, -30, 14000],
    [75.5, -40, -2000], [78.1, -40, -1000], [80.7, -40, 0], [81.6, -40, 1000], [82.7, -40, 2000], [83.8, -40, 3000], [84.8, -40, 4000], [85.8, -40, 5000], [86.7, -40, 6000],
    [87.3, -40, 7000], [87.9, -40, 8000], [88.4, -40, 9000], [88.4, -40, 10000], [89, -40, 11000], [90.7, -40, 12000], [90.7, -40, 13000], [90.6, -40, 14000],
    [75.8, -50, -2000], [78.5, -50, -1000], [81.1, -50, 0], [81.9, -50, 1000], [83, -50, 2000], [84.2, -50, 3000], [85.2, -50, 4000], [86.2, -50, 5000], [87, -50, 6000],
    [87.6, -50, 7000], [88.2, -50, 8000], [88.7, -50, 9000], [88.8, -50, 10000], [89.3, -50, 11000], [91.1, -50, 12000], [91.1, -50, 13000], [91, -50, 14000]
]);
B787EngineData.to_tpr_2 = new LerpLookupTable([
    [45, 75, -2000], [45, 75, -1000], [45, 75, 0], [45, 75, 1000], [45, 75, 2000], [45, 75, 3000], [45, 75, 4000], [45, 75, 5000], [44.7, 75, 6000], [43.2, 75, 7000],
    [41.7, 75, 8000], [40.2, 75, 9000], [38.6, 75, 10000], [37.1, 75, 11000], [35.5, 75, 12000], [33.6, 75, 13000], [31.7, 75, 14000],
    [45.4, 70, -2000], [45.7, 70, -1000], [45.8, 70, 0], [45, 70, 1000], [45, 70, 2000], [45, 70, 3000], [45, 70, 4000], [45, 70, 5000], [45, 70, 6000],
    [45, 70, 7000], [45, 70, 8000], [44.9, 70, 9000], [43.4, 70, 10000], [42, 70, 11000], [40.4, 70, 12000], [38.5, 70, 13000], [36.6, 70, 14000],
    [48.5, 65, -2000], [48.9, 65, -1000], [49.1, 65, 0], [48.3, 65, 1000], [47.7, 65, 2000], [47, 65, 3000], [46.4, 65, 4000], [45.6, 65, 5000], [45, 65, 6000],
    [45, 65, 7000], [45, 65, 8000], [45, 65, 9000], [45, 65, 10000], [45, 65, 11000], [45, 65, 12000], [43.4, 65, 13000], [41.5, 65, 14000],
    [51.6, 60, -2000], [52.1, 60, -1000], [52.4, 60, 0], [51.7, 60, 1000], [51.1, 60, 2000], [50.5, 60, 3000], [49.9, 60, 4000], [49.3, 60, 5000], [48.6, 60, 6000],
    [47.5, 60, 7000], [46.4, 60, 8000], [45.3, 60, 9000], [45, 60, 10000], [45, 60, 11000], [45, 60, 12000], [45, 60, 13000], [45, 60, 14000],
    [54.5, 55, -2000], [55.2, 55, -1000], [55.7, 55, 0], [55.1, 55, 1000], [54.5, 55, 2000], [54, 55, 3000], [53.5, 55, 4000], [52.9, 55, 5000], [52.2, 55, 6000],
    [51.2, 55, 7000], [50.1, 55, 8000], [49.1, 55, 9000], [48, 55, 10000], [47, 55, 11000], [45.9, 55, 12000], [45, 55, 13000], [45, 55, 14000],
    [57.3, 50, -2000], [58.1, 50, -1000], [58.8, 50, 0], [58.3, 50, 1000], [57.9, 50, 2000], [57.4, 50, 3000], [57, 50, 4000], [56.4, 50, 5000], [55.9, 50, 6000],
    [54.9, 50, 7000], [53.9, 50, 8000], [52.9, 50, 9000], [51.8, 50, 10000], [50.8, 50, 11000], [49.8, 50, 12000], [48.3, 50, 13000], [46.7, 50, 14000],
    [59.8, 45, -2000], [60.9, 45, -1000], [61.8, 45, 0], [61.4, 45, 1000], [61.1, 45, 2000], [60.7, 45, 3000], [60.4, 45, 4000], [60, 45, 5000], [59.5, 45, 6000],
    [58.5, 45, 7000], [57.6, 45, 8000], [56.6, 45, 9000], [55.6, 45, 10000], [54.7, 45, 11000], [53.7, 45, 12000], [52.1, 45, 13000], [50.6, 45, 14000],
    [62.4, 40, -2000], [63.5, 40, -1000], [64.5, 40, 0], [64.2, 40, 1000], [64.1, 40, 2000], [63.9, 40, 3000], [63.6, 40, 4000], [63.3, 40, 5000], [63, 40, 6000],
    [62.1, 40, 7000], [61.2, 40, 8000], [60.3, 40, 9000], [59.3, 40, 10000], [58.5, 40, 11000], [57.5, 40, 12000], [56, 40, 13000], [54.5, 40, 14000],
    [65, 35, -2000], [66.2, 35, -1000], [67.2, 35, 0], [66.9, 35, 1000], [66.9, 35, 2000], [66.7, 35, 3000], [66.7, 35, 4000], [66.5, 35, 5000], [66.3, 35, 6000],
    [65.6, 35, 7000], [64.8, 35, 8000], [64, 35, 9000], [63, 35, 10000], [62.2, 35, 11000], [61.3, 35, 12000], [59.8, 35, 13000], [58.4, 35, 14000],
    [65.7, 30, -2000], [68, 30, -1000], [70.1, 30, 0], [69.8, 30, 1000], [69.7, 30, 2000], [69.7, 30, 3000], [69.6, 30, 4000], [69.4, 30, 5000], [69.4, 30, 6000],
    [68.8, 30, 7000], [68.3, 30, 8000], [67.6, 30, 9000], [66.7, 30, 10000], [65.9, 30, 11000], [65, 30, 12000], [63.6, 30, 13000], [62.1, 30, 14000],
    [65.9, 25, -2000], [68.1, 25, -1000], [70.3, 25, 0], [71.1, 25, 1000], [72.1, 25, 2000], [72.6, 25, 3000], [72.5, 25, 4000], [72.4, 25, 5000], [72.3, 25, 6000],
    [71.7, 25, 7000], [71.2, 25, 8000], [70.8, 25, 9000], [70.3, 25, 10000], [69.5, 25, 11000], [68.7, 25, 12000], [67.3, 25, 13000], [65.9, 25, 14000],
    [66, 20, -2000], [68.3, 20, -1000], [70.4, 20, 0], [71.2, 20, 1000], [72.3, 20, 2000], [73.2, 20, 3000], [74, 20, 4000], [74.9, 20, 5000], [74.8, 20, 6000],
    [74.4, 20, 7000], [74.1, 20, 8000], [73.6, 20, 9000], [72.6, 20, 10000], [72.2, 20, 11000], [71.9, 20, 12000], [70.9, 20, 13000], [69.5, 20, 14000],
    [66.2, 15, -2000], [68.4, 15, -1000], [70.6, 15, 0], [71.4, 15, 1000], [72.4, 15, 2000], [73.3, 15, 3000], [74.2, 15, 4000], [75, 15, 5000], [75.7, 15, 6000],
    [76.2, 15, 7000], [76.3, 15, 8000], [76, 15, 9000], [75.2, 15, 10000], [74.4, 15, 11000], [73.9, 15, 12000], [73.2, 15, 13000], [72.5, 15, 14000],
    [66.3, 10, -2000], [68.6, 10, -1000], [70.8, 10, 0], [71.5, 10, 1000], [72.6, 10, 2000], [73.5, 10, 3000], [74.3, 10, 4000], [75.2, 10, 5000], [75.8, 10, 6000],
    [76.3, 10, 7000], [76.8, 10, 8000], [77.2, 10, 9000], [77.2, 10, 10000], [76.6, 10, 11000], [75.9, 10, 12000], [75.1, 10, 13000], [74.4, 10, 14000],
    [66.5, 5, -2000], [68.8, 5, -1000], [70.9, 5, 0], [71.7, 5, 1000], [72.7, 5, 2000], [73.6, 5, 3000], [74.5, 5, 4000], [75.3, 5, 5000], [75.9, 5, 6000],
    [76.4, 5, 7000], [76.9, 5, 8000], [77.3, 5, 9000], [77.4, 5, 10000], [77.9, 5, 11000], [77.9, 5, 12000], [77.1, 5, 13000], [76.4, 5, 14000],
    [66.6, 0, -2000], [68.9, 0, -1000], [71.1, 0, 0], [71.9, 0, 1000], [72.8, 0, 2000], [73.8, 0, 3000], [74.6, 0, 4000], [75.4, 0, 5000], [76.1, 0, 6000],
    [76.6, 0, 7000], [77.1, 0, 8000], [77.5, 0, 9000], [77.5, 0, 10000], [78, 0, 11000], [79.3, 0, 12000], [79, 0, 13000], [78.3, 0, 14000],
    [67, -10, -2000], [69.2, -10, -1000], [71.4, -10, 0], [72.2, -10, 1000], [73.1, -10, 2000], [74, -10, 3000], [74.9, -10, 4000], [75.7, -10, 5000], [76.4, -10, 6000],
    [76.8, -10, 7000], [77.3, -10, 8000], [77.8, -10, 9000], [77.8, -10, 10000], [78.3, -10, 11000], [79.6, -10, 12000], [79.5, -10, 13000], [79.5, -10, 14000],
    [67.3, -20, -2000], [69.5, -20, -1000], [71.7, -20, 0], [72.5, -20, 1000], [73.4, -20, 2000], [74.3, -20, 3000], [75.2, -20, 4000], [76, -20, 5000], [76.6, -20, 6000],
    [77.1, -20, 7000], [77.6, -20, 8000], [78, -20, 9000], [78.1, -20, 10000], [78.5, -20, 11000], [79.8, -20, 12000], [79.8, -20, 13000], [79.8, -20, 14000],
    [67.6, -30, -2000], [69.8, -30, -1000], [72, -30, 0], [72.8, -30, 1000], [73.7, -30, 2000], [74.6, -30, 3000], [75.4, -30, 4000], [76.2, -30, 5000], [76.9, -30, 6000],
    [77.4, -30, 7000], [77.9, -30, 8000], [78.3, -30, 9000], [78.3, -30, 10000], [78.8, -30, 11000], [80.1, -30, 12000], [80.1, -30, 13000], [80, -30, 14000],
    [67.9, -40, -2000], [70.1, -40, -1000], [72.3, -40, 0], [73, -40, 1000], [73.9, -40, 2000], [74.9, -40, 3000], [75.7, -40, 4000], [76.5, -40, 5000], [77.2, -40, 6000],
    [77.7, -40, 7000], [78.1, -40, 8000], [78.5, -40, 9000], [78.6, -40, 10000], [79, -40, 11000], [80.3, -40, 12000], [80.3, -40, 13000], [80.3, -40, 14000],
    [68.2, -50, -2000], [70.4, -50, -1000], [72.6, -50, 0], [73.3, -50, 1000], [74.2, -50, 2000], [75.2, -50, 3000], [76, -50, 4000], [76.8, -50, 5000], [77.4, -50, 6000],
    [77.9, -50, 7000], [78.4, -50, 8000], [78.8, -50, 9000], [78.8, -50, 10000], [79.3, -50, 11000], [80.6, -50, 12000], [80.6, -50, 13000], [80.6, -50, 14000]
]);
B787EngineData.ga_tpr_max = new LerpLookupTable([
    [63.8, 60, -2000], [64.6, 60, -1000], [65.1, 60, 0], [64.3, 60, 1000], [63.7, 60, 2000], [63, 60, 3000], [62.3, 60, 4000], [61.6, 60, 5000], [60.8, 60, 6000],
    [59.5, 60, 7000], [58.2, 60, 8000], [57, 60, 9000], [55.8, 60, 10000], [54.5, 60, 11000], [53.1, 60, 12000], [51.3, 60, 13000], [49.5, 60, 14000],
    [67.1, 55, -2000], [68.1, 55, -1000], [68.9, 55, 0], [68.3, 55, 1000], [67.8, 55, 2000], [67.2, 55, 3000], [66.6, 55, 4000], [65.9, 55, 5000], [65.2, 55, 6000],
    [63.9, 55, 7000], [62.7, 55, 8000], [61.6, 55, 9000], [60.4, 55, 10000], [59.1, 55, 11000], [57.8, 55, 12000], [56, 55, 13000], [54.2, 55, 14000],
    [70.6, 50, -2000], [71.6, 50, -1000], [72.7, 50, 0], [72.1, 50, 1000], [71.8, 50, 2000], [71.3, 50, 3000], [70.8, 50, 4000], [70.3, 50, 5000], [69.6, 50, 6000],
    [68.4, 50, 7000], [67.2, 50, 8000], [66.2, 50, 9000], [65, 50, 10000], [63.8, 50, 11000], [62.5, 50, 12000], [60.7, 50, 13000], [58.9, 50, 14000],
    [74, 45, -2000], [75.3, 45, -1000], [76.4, 45, 0], [76, 45, 1000], [75.7, 45, 2000], [75.4, 45, 3000], [75, 45, 4000], [74.6, 45, 5000], [74, 45, 6000],
    [72.9, 45, 7000], [71.8, 45, 8000], [70.7, 45, 9000], [69.6, 45, 10000], [68.5, 45, 11000], [67.3, 45, 12000], [65.5, 45, 13000], [63.7, 45, 14000],
    [77.4, 40, -2000], [78.8, 40, -1000], [80.1, 40, 0], [79.7, 40, 1000], [79.6, 40, 2000], [79.4, 40, 3000], [79.2, 40, 4000], [78.8, 40, 5000], [78.4, 40, 6000],
    [77.7, 40, 7000], [76.6, 40, 8000], [75.4, 40, 9000], [74.2, 40, 10000], [73.1, 40, 11000], [72, 40, 12000], [70.2, 40, 13000], [68.4, 40, 14000],
    [79.1, 35, -2000], [81.9, 35, -1000], [83.9, 35, 0], [83.5, 35, 1000], [83.4, 35, 2000], [83.4, 35, 3000], [83.2, 35, 4000], [83, 35, 5000], [82.8, 35, 6000],
    [82.5, 35, 7000], [81.7, 35, 8000], [80.6, 35, 9000], [79.1, 35, 10000], [78, 35, 11000], [76.7, 35, 12000], [74.9, 35, 13000], [73.1, 35, 14000],
    [79.3, 30, -2000], [82.1, 30, -1000], [85, 30, 0], [86.2, 30, 1000], [87.6, 30, 2000], [87.5, 30, 3000], [87.4, 30, 4000], [87.3, 30, 5000], [87.2, 30, 6000],
    [86.3, 30, 7000], [85.8, 30, 8000], [85.5, 30, 9000], [84.1, 30, 10000], [83.1, 30, 11000], [81.9, 30, 12000], [79.9, 30, 13000], [78, 30, 14000],
    [79.5, 25, -2000], [82.4, 25, -1000], [85.2, 25, 0], [86.4, 25, 1000], [88, 25, 2000], [89.5, 25, 3000], [91.1, 25, 4000], [91.7, 25, 5000], [91.6, 25, 6000],
    [90.9, 25, 7000], [90, 25, 8000], [89, 25, 9000], [88.2, 25, 10000], [87.5, 25, 11000], [87.1, 25, 12000], [85.1, 25, 13000], [83.2, 25, 14000],
    [79.7, 20, -2000], [82.6, 20, -1000], [85.5, 20, 0], [86.6, 20, 1000], [88.2, 20, 2000], [89.7, 20, 3000], [91.4, 20, 4000], [93, 20, 5000], [94.5, 20, 6000],
    [95.1, 20, 7000], [94.4, 20, 8000], [93.8, 20, 9000], [93.1, 20, 10000], [91.4, 20, 11000], [90.3, 20, 12000], [89.2, 20, 13000], [88, 20, 14000],
    [79.9, 15, -2000], [82.8, 15, -1000], [85.7, 15, 0], [86.9, 15, 1000], [88.4, 15, 2000], [90, 15, 3000], [91.6, 15, 4000], [93.3, 15, 5000], [94.8, 15, 6000],
    [95.6, 15, 7000], [96.4, 15, 8000], [97.1, 15, 9000], [96.5, 15, 10000], [95.4, 15, 11000], [94, 15, 12000], [92.6, 15, 13000], [91.3, 15, 14000],
    [80.1, 10, -2000], [83, 10, -1000], [85.9, 10, 0], [87.1, 10, 1000], [88.7, 10, 2000], [90.2, 10, 3000], [91.9, 10, 4000], [93.5, 10, 5000], [95, 10, 6000],
    [95.8, 10, 7000], [96.6, 10, 8000], [97.3, 10, 9000], [97.4, 10, 10000], [98.1, 10, 11000], [97.4, 10, 12000], [96.2, 10, 13000], [94.8, 10, 14000],
    [80.3, 5, -2000], [83.2, 5, -1000], [86.1, 5, 0], [87.3, 5, 1000], [88.9, 5, 2000], [90.4, 5, 3000], [92.1, 5, 4000], [93.8, 5, 5000], [95.3, 5, 6000],
    [96.1, 5, 7000], [96.9, 5, 8000], [97.6, 5, 9000], [97.7, 5, 10000], [98.6, 5, 11000], [101.1, 5, 12000], [99.7, 5, 13000], [98.5, 5, 14000],
    [80.5, 0, -2000], [83.4, 0, -1000], [86.3, 0, 0], [87.5, 0, 1000], [89.1, 0, 2000], [90.7, 0, 3000], [92.3, 0, 4000], [94, 0, 5000], [95.5, 0, 6000],
    [96.3, 0, 7000], [97.1, 0, 8000], [97.8, 0, 9000], [97.9, 0, 10000], [98.8, 0, 11000], [101.6, 0, 12000], [101.5, 0, 13000], [101.5, 0, 14000],
    [80.9, -10, -2000], [83.9, -10, -1000], [86.8, -10, 0], [88, -10, 1000], [89.6, -10, 2000], [91.1, -10, 3000], [92.8, -10, 4000], [94.5, -10, 5000],
    [96, -10, 6000], [96.8, -10, 7000], [97.6, -10, 8000], [98.4, -10, 9000], [98.4, -10, 10000], [99.4, -10, 11000], [102.1, -10, 12000], [102.1, -10, 13000], [102.1, -10, 14000],
    [81.3, -20, -2000], [84.3, -20, -1000], [87.2, -20, 0], [88.4, -20, 1000], [90, -20, 2000], [91.6, -20, 3000], [93.3, -20, 4000], [95, -20, 5000],
    [96.5, -20, 6000], [97.3, -20, 7000], [98.1, -20, 8000], [98.9, -20, 9000], [98.9, -20, 10000], [99.9, -20, 11000], [102.6, -20, 12000], [102.6, -20, 13000],
    [102.6, -20, 14000],
    [81.7, -30, -2000], [84.7, -30, -1000], [87.7, -30, 0], [88.9, -30, 1000], [90.5, -30, 2000], [92.1, -30, 3000], [93.8, -30, 4000], [95.4, -30, 5000],
    [97, -30, 6000], [97.8, -30, 7000], [98.6, -30, 8000], [99.4, -30, 9000], [99.4, -30, 10000], [100.4, -30, 11000], [103.1, -30, 12000], [103.1, -30, 13000],
    [103.1, -30, 14000],
    [82.2, -40, -2000], [85.1, -40, -1000], [88.1, -40, 0], [89.3, -40, 1000], [90.9, -40, 2000], [92.5, -40, 3000], [94.2, -40, 4000], [95.9, -40, 5000],
    [97.5, -40, 6000], [98.3, -40, 7000], [99.1, -40, 8000], [99.9, -40, 9000], [100, -40, 10000], [100.9, -40, 11000], [103.7, -40, 12000], [103.7, -40, 13000],
    [103.6, -40, 14000],
    [82.6, -50, -2000], [85.6, -50, -1000], [88.6, -50, 0], [89.8, -50, 1000], [91.4, -50, 2000], [93, -50, 3000], [94.7, -50, 4000], [96.4, -50, 5000],
    [98, -50, 6000], [98.8, -50, 7000], [99.6, -50, 8000], [100.4, -50, 9000], [100.5, -50, 10000], [101.4, -50, 11000], [104.2, -50, 12000],
    [104.2, -50, 13000], [104.2, -50, 14000]
]);
B787EngineData.ga_n1_max = new LerpLookupTable([
    [86.6, 60, -2000], [87.1, 60, -1000], [87.4, 60, 0], [86.9, 60, 1000], [86.5, 60, 2000], [86.2, 60, 3000], [85.8, 60, 4000], [85.4, 60, 5000], [84.9, 60, 6000],
    [84.1, 60, 7000], [83.4, 60, 8000], [82.7, 60, 9000], [81.9, 60, 10000], [81, 60, 11000], [80.1, 60, 12000], [78.9, 60, 13000], [77.7, 60, 14000],
    [87.7, 55, -2000], [88.3, 55, -1000], [88.7, 55, 0], [88.3, 55, 1000], [88.1, 55, 2000], [87.8, 55, 3000], [87.5, 55, 4000], [87.1, 55, 5000], [86.7, 55, 6000], [86, 55, 7000],
    [85.4, 55, 8000], [84.7, 55, 9000], [84, 55, 10000], [83.3, 55, 11000], [82.5, 55, 12000], [81.4, 55, 13000], [80.3, 55, 14000],
    [88.8, 50, -2000], [89.3, 50, -1000], [89.8, 50, 0], [89.5, 50, 1000], [89.4, 50, 2000], [89.2, 50, 3000], [89, 50, 4000], [88.7, 50, 5000], [88.4, 50, 6000], [87.7, 50, 7000],
    [87.1, 50, 8000], [86.6, 50, 9000], [86, 50, 10000], [85.3, 50, 11000], [84.6, 50, 12000], [83.6, 50, 13000], [82.5, 50, 14000],
    [89.6, 45, -2000], [90.2, 45, -1000], [90.7, 45, 0], [90.5, 45, 1000], [90.4, 45, 2000], [90.3, 45, 3000], [90.1, 45, 4000], [89.9, 45, 5000], [89.7, 45, 6000],
    [89.2, 45, 7000], [88.7, 45, 8000], [88.2, 45, 9000], [87.7, 45, 10000], [87.1, 45, 11000], [86.5, 45, 12000], [85.6, 45, 13000], [84.6, 45, 14000],
    [90.4, 40, -2000], [91, 40, -1000], [91.6, 40, 0], [91.4, 40, 1000], [91.4, 40, 2000], [91.3, 40, 3000], [91.2, 40, 4000], [91.1, 40, 5000], [90.9, 40, 6000], [90.6, 40, 7000],
    [90.1, 40, 8000], [89.6, 40, 9000], [89.1, 40, 10000], [88.6, 40, 11000], [88.1, 40, 12000], [87.3, 40, 13000], [86.4, 40, 14000],
    [90.4, 35, -2000], [91.7, 35, -1000], [92.6, 35, 0], [92.4, 35, 1000], [92.4, 35, 2000], [92.3, 35, 3000], [92.3, 35, 4000], [92.2, 35, 5000], [92.1, 35, 6000],
    [91.9, 35, 7000], [91.6, 35, 8000], [91.1, 35, 9000], [90.5, 35, 10000], [90, 35, 11000], [89.4, 35, 12000], [88.6, 35, 13000], [87.9, 35, 14000],
    [89.8, 30, -2000], [91, 30, -1000], [92.3, 30, 0], [92.8, 30, 1000], [93.4, 30, 2000], [93.4, 30, 3000], [93.3, 30, 4000], [93.3, 30, 5000], [93.2, 30, 6000], [92.8, 30, 7000],
    [92.6, 30, 8000], [92.5, 30, 9000], [91.9, 30, 10000], [91.4, 30, 11000], [90.9, 30, 12000], [90.1, 30, 13000], [89.2, 30, 14000],
    [89.1, 25, -2000], [90.4, 25, -1000], [91.6, 25, 0], [92.1, 25, 1000], [92.8, 25, 2000], [93.4, 25, 3000], [94.2, 25, 4000], [94.5, 25, 5000], [94.4, 25, 6000],
    [94.1, 25, 7000], [93.7, 25, 8000], [93.2, 25, 9000], [92.9, 25, 10000], [92.6, 25, 11000], [92.4, 25, 12000], [91.6, 25, 13000], [90.7, 25, 14000],
    [88.5, 20, -2000], [89.7, 20, -1000], [90.9, 20, 0], [91.5, 20, 1000], [92.1, 20, 2000], [92.8, 20, 3000], [93.5, 20, 4000], [94.3, 20, 5000], [95, 20, 6000], [95.3, 20, 7000],
    [95, 20, 8000], [94.7, 20, 9000], [94.3, 20, 10000], [93.5, 20, 11000], [93, 20, 12000], [92.5, 20, 13000], [92, 20, 14000],
    [87.8, 15, -2000], [89, 15, -1000], [90.3, 15, 0], [90.8, 15, 1000], [91.4, 15, 2000], [92.1, 15, 3000], [92.8, 15, 4000], [93.6, 15, 5000], [94.3, 15, 6000], [94.8, 15, 7000],
    [95.2, 15, 8000], [95.6, 15, 9000], [95.3, 15, 10000], [94.6, 15, 11000], [94, 15, 12000], [93.3, 15, 13000], [92.7, 15, 14000],
    [87.1, 10, -2000], [88.3, 10, -1000], [89.6, 10, 0], [90.1, 10, 1000], [90.7, 10, 2000], [91.4, 10, 3000], [92.1, 10, 4000], [92.9, 10, 5000], [93.6, 10, 6000],
    [94.1, 10, 7000], [94.5, 10, 8000], [94.9, 10, 9000], [95, 10, 10000], [95.3, 10, 11000], [95, 10, 12000], [94.3, 10, 13000], [93.5, 10, 14000],
    [86.4, 5, -2000], [87.7, 5, -1000], [88.9, 5, 0], [89.4, 5, 1000], [90, 5, 2000], [90.7, 5, 3000], [91.4, 5, 4000], [92.2, 5, 5000], [92.9, 5, 6000], [93.4, 5, 7000],
    [93.8, 5, 8000], [94.2, 5, 9000], [94.3, 5, 10000], [94.8, 5, 11000], [96.2, 5, 12000], [95.4, 5, 13000], [94.7, 5, 14000],
    [85.7, 0, -2000], [87, 0, -1000], [88.2, 0, 0], [88.6, 0, 1000], [89.3, 0, 2000], [89.9, 0, 3000], [90.7, 0, 4000], [91.5, 0, 5000], [92.2, 0, 6000], [92.7, 0, 7000],
    [93.1, 0, 8000], [93.5, 0, 9000], [93.6, 0, 10000], [94.1, 0, 11000], [95.7, 0, 12000], [95.7, 0, 13000], [95.6, 0, 14000],
    [84.3, -10, -2000], [85.5, -10, -1000], [86.7, -10, 0], [87.2, -10, 1000], [87.8, -10, 2000], [88.5, -10, 3000], [89.3, -10, 4000], [90, -10, 5000], [90.8, -10, 6000],
    [91.2, -10, 7000], [91.7, -10, 8000], [92.1, -10, 9000], [92.1, -10, 10000], [92.6, -10, 11000], [94.2, -10, 12000], [94.2, -10, 13000], [94.2, -10, 14000],
    [82.9, -20, -2000], [84.1, -20, -1000], [85.2, -20, 0], [85.7, -20, 1000], [86.3, -20, 2000], [87, -20, 3000], [87.8, -20, 4000], [88.5, -20, 5000], [89.3, -20, 6000],
    [89.8, -20, 7000], [90.2, -20, 8000], [90.6, -20, 9000], [90.6, -20, 10000], [91.1, -20, 11000], [92.7, -20, 12000], [92.7, -20, 13000], [92.7, -20, 14000],
    [81.4, -30, -2000], [82.5, -30, -1000], [83.7, -30, 0], [84.2, -30, 1000], [84.8, -30, 2000], [85.5, -30, 3000], [86.2, -30, 4000], [87, -30, 5000], [87.8, -30, 6000],
    [88.2, -30, 7000], [88.7, -30, 8000], [89, -30, 9000], [89.1, -30, 10000], [89.6, -30, 11000], [91.2, -30, 12000], [91.2, -30, 13000], [91.2, -30, 14000],
    [79.8, -40, -2000], [81, -40, -1000], [82.1, -40, 0], [82.6, -40, 1000], [83.2, -40, 2000], [83.9, -40, 3000], [84.6, -40, 4000], [85.4, -40, 5000], [86.2, -40, 6000],
    [86.6, -40, 7000], [87.1, -40, 8000], [87.5, -40, 9000], [87.5, -40, 10000], [88, -40, 11000], [89.6, -40, 12000], [89.6, -40, 13000], [89.6, -40, 14000],
    [78.3, -50, -2000], [79.4, -50, -1000], [80.5, -50, 0], [80.9, -50, 1000], [81.6, -50, 2000], [82.3, -50, 3000], [83, -50, 4000], [83.8, -50, 5000], [84.6, -50, 6000],
    [85, -50, 7000], [85.4, -50, 8000], [85.8, -50, 9000], [85.9, -50, 10000], [86.4, -50, 11000], [87.9, -50, 12000], [87.9, -50, 13000], [87.9, -50, 14000]
]);
B787EngineData.clb_tpr_max = new LerpLookupTable([
    [51.1, 60, 0], [51.7, 60, 5000], [53.7, 60, 10000], [59.9, 60, 15000], [61.9, 60, 20000], [64.6, 60, 25000], [67.4, 60, 30000], [74.1, 60, 35000], [71.9, 60, 40000],
    [70.9, 60, 43000], [58.2, 50, 0], [58.3, 50, 5000], [56.9, 50, 10000], [59.9, 50, 15000], [61.9, 50, 20000], [64.6, 50, 25000], [67.4, 50, 30000], [74.1, 50, 35000],
    [71.9, 50, 40000], [70.9, 50, 43000], [66.3, 40, 0], [66.5, 40, 5000], [64.6, 40, 10000], [66.1, 40, 15000], [63.2, 40, 20000], [64.6, 40, 25000], [67.4, 40, 30000],
    [74.1, 40, 35000], [71.9, 40, 40000], [70.9, 40, 43000], [67.8, 30, 0], [74.9, 30, 5000], [74.4, 30, 10000], [75.4, 30, 15000], [72.1, 30, 20000], [70.2, 30, 25000],
    [68.6, 30, 30000], [74.1, 30, 35000], [71.9, 30, 40000], [70.9, 30, 43000], [68.1, 20, 0], [75.3, 20, 5000], [80.2, 20, 10000], [85.3, 20, 15000], [82.6, 20, 20000],
    [80.5, 20, 25000], [78.4, 20, 30000], [76.6, 20, 35000], [72.4, 20, 40000], [71.4, 20, 43000], [68.3, 15, 0], [75.5, 15, 5000], [80.4, 15, 10000], [87.4, 15, 15000],
    [89.2, 15, 20000], [86.1, 15, 25000], [84.2, 15, 30000], [80.7, 15, 35000], [76.8, 15, 40000], [75.9, 15, 43000], [68.5, 10, 0], [75.7, 10, 5000], [80.6, 10, 10000],
    [87.6, 10, 15000], [92.8, 10, 20000], [91.5, 10, 25000], [89.9, 10, 30000], [85.2, 10, 35000], [81.1, 10, 40000], [80.4, 10, 43000], [68.7, 5, 0], [75.9, 5, 5000],
    [80.8, 5, 10000], [87.8, 5, 15000], [93.8, 5, 20000], [95.5, 5, 25000], [95.3, 5, 30000], [90.4, 5, 35000], [86.8, 5, 40000], [86.4, 5, 43000],
    [68.8, 0, 0], [76, 0, 5000], [81, 0, 10000], [88, 0, 15000], [94, 0, 20000], [97.2, 0, 25000], [99.6, 0, 30000], [95.8, 0, 35000], [92.8, 0, 40000], [92.6, 0, 43000],
    [69, -5, 0], [76.2, -5, 5000], [81.2, -5, 10000], [88.2, -5, 15000], [94.2, -5, 20000], [97.4, -5, 25000], [101.8, -5, 30000], [102.3, -5, 35000], [98.7, -5, 40000],
    [98.7, -5, 43000], [69.2, -10, 0], [76.4, -10, 5000], [81.4, -10, 10000], [88.5, -10, 15000], [94.4, -10, 20000], [97.6, -10, 25000], [102, -10, 30000], [106.3, -10, 35000],
    [103.9, -10, 40000], [104, -10, 43000], [69.3, -15, 0], [76.6, -15, 5000], [81.6, -15, 10000], [88.7, -15, 15000], [94.7, -15, 20000], [97.9, -15, 25000], [102.2, -15, 30000],
    [107.5, -15, 35000], [107, -15, 40000], [107.1, -15, 43000], [69.5, -20, 0], [76.8, -20, 5000], [81.8, -20, 10000], [88.9, -20, 15000], [94.9, -20, 20000], [98.1, -20, 25000],
    [102.5, -20, 30000], [107.7, -20, 35000], [107.2, -20, 40000], [107.3, -20, 43000], [69.7, -25, 0], [77, -25, 5000], [82, -25, 10000], [89.1, -25, 15000], [95.1, -25, 20000],
    [98.3, -25, 25000], [102.7, -25, 30000], [108, -25, 35000], [107.5, -25, 40000], [107.6, -25, 43000], [69.9, -30, 0], [77.2, -30, 5000], [82.2, -30, 10000], [89.3, -30, 15000],
    [95.4, -30, 20000], [98.6, -30, 25000], [103, -30, 30000], [108.2, -30, 35000], [107.7, -30, 40000], [107.8, -30, 43000], [70, -35, 0], [77.4, -35, 5000], [82.4, -35, 10000],
    [89.5, -35, 15000], [95.6, -35, 20000], [98.8, -35, 25000], [103.2, -35, 30000], [108.5, -35, 35000], [108, -35, 40000], [108.1, -35, 43000], [70.2, -40, 0], [77.6, -40, 5000],
    [82.6, -40, 10000], [89.7, -40, 15000], [95.8, -40, 20000], [99, -40, 25000], [103.4, -40, 30000], [108.7, -40, 35000], [108.2, -40, 40000], [108.3, -40, 43000]
]);
B787EngineData.clb_n1_max = new LerpLookupTable([
    [79.9, 60, 0], [80.6, 60, 5000], [82.3, 60, 10000], [86.5, 60, 15000], [87.8, 60, 20000], [89.4, 60, 25000], [91.2, 60, 30000], [94.5, 60, 35000], [93.5, 60, 40000], [93.1, 60, 43000],
    [83.2, 50, 0], [83.5, 50, 5000], [83, 50, 10000], [85.2, 50, 15000], [86.5, 50, 20000], [88.1, 50, 25000], [89.8, 50, 30000], [93, 50, 35000], [92.1, 50, 40000], [91.7, 50, 43000],
    [86.2, 40, 0], [86.5, 40, 5000], [85.9, 40, 10000], [87, 40, 15000], [85.8, 40, 20000], [86.7, 40, 25000], [88.4, 40, 30000], [91.6, 40, 35000], [90.7, 40, 40000], [90.2, 40, 43000],
    [85.5, 30, 0], [88.9, 30, 5000], [89, 30, 10000], [89.8, 30, 15000], [88.5, 30, 20000], [87.9, 30, 25000], [87.5, 30, 30000], [90.1, 30, 35000], [89.2, 30, 40000], [88.8, 30, 43000],
    [84.2, 20, 0], [87.6, 20, 5000], [89.9, 20, 10000], [92.4, 20, 15000], [91.3, 20, 20000], [90.7, 20, 25000], [90.1, 20, 30000], [89.6, 20, 35000], [87.9, 20, 40000], [87.5, 20, 43000],
    [83.6, 15, 0], [86.9, 15, 5000], [89.3, 15, 10000], [92.5, 15, 15000], [93.2, 15, 20000], [92.2, 15, 25000], [91.7, 15, 30000], [90.4, 15, 35000], [88.9, 15, 40000], [88.6, 15, 43000],
    [83, 10, 0], [86.2, 10, 5000], [88.6, 10, 10000], [91.8, 10, 15000], [94.1, 10, 20000], [93.6, 10, 25000], [93.2, 10, 30000], [91.5, 10, 35000], [89.8, 10, 40000], [89.6, 10, 43000],
    [82.3, 5, 0], [85.6, 5, 5000], [87.9, 5, 10000], [91, 5, 15000], [93.7, 5, 20000], [94.7, 5, 25000], [94.9, 5, 30000], [92.8, 5, 35000], [91.3, 5, 40000], [91.1, 5, 43000],
    [81.6, 0, 0], [84.9, 0, 5000], [87.2, 0, 10000], [90.3, 0, 15000], [93, 0, 20000], [94.7, 0, 25000], [96.3, 0, 30000], [94.5, 0, 35000], [93.1, 0, 40000], [93, 0, 43000],
    [81, -5, 0], [84.2, -5, 5000], [86.4, -5, 10000], [89.6, -5, 15000], [92.2, -5, 20000], [94, -5, 25000], [96.5, -5, 30000], [96.9, -5, 35000], [95, -5, 40000], [95.1, -5, 43000],
    [80.3, -10, 0], [83.4, -10, 5000], [85.7, -10, 10000], [88.8, -10, 15000], [91.5, -10, 20000], [93.2, -10, 25000], [95.8, -10, 30000], [98.2, -10, 35000], [96.9, -10, 40000], [96.9, -10, 43000],
    [79.6, -15, 0], [82.7, -15, 5000], [85, -15, 10000], [88, -15, 15000], [90.7, -15, 20000], [92.5, -15, 25000], [95, -15, 30000], [97.8, -15, 35000], [97.6, -15, 40000], [97.6, -15, 43000],
    [78.9, -20, 0], [82, -20, 5000], [84.2, -20, 10000], [87.3, -20, 15000], [89.9, -20, 20000], [91.7, -20, 25000], [94.2, -20, 30000], [97, -20, 35000], [96.7, -20, 40000], [96.8, -20, 43000],
    [78.2, -25, 0], [81.2, -25, 5000], [83.5, -25, 10000], [86.5, -25, 15000], [89.2, -25, 20000], [90.9, -25, 25000], [93.4, -25, 30000], [96.1, -25, 35000], [95.9, -25, 40000], [95.9, -25, 43000],
    [77.5, -30, 0], [80.5, -30, 5000], [82.7, -30, 10000], [85.7, -30, 15000], [88.4, -30, 20000], [90.1, -30, 25000], [92.6, -30, 30000], [95.3, -30, 35000], [95.1, -30, 40000], [95.1, -30, 43000],
    [76.7, -35, 0], [79.7, -35, 5000], [81.9, -35, 10000], [84.9, -35, 15000], [87.6, -35, 20000], [89.3, -35, 25000], [91.7, -35, 30000], [94.4, -35, 35000], [94.2, -35, 40000], [94.2, -35, 43000],
    [76, -40, 0], [79, -40, 5000], [81.1, -40, 10000], [84.1, -40, 15000], [86.8, -40, 20000], [88.4, -40, 25000], [90.9, -40, 30000], [93.5, -40, 35000], [93.3, -40, 40000], [93.4, -40, 43000],
]);
B787EngineData.cru_n1_max = new LerpLookupTable([
    [87.4, 25, 25000], [87.1, 25, 27000], [87.1, 25, 29000], [87.1, 25, 31000], [87.2, 25, 33000], [87.6, 25, 35000], [87.4, 25, 37000],
    [86.9, 25, 39000], [86.6, 25, 41000], [86.3, 25, 43000], [88.7, 20, 25000], [88.4, 20, 27000], [88.3, 20, 29000], [88.2, 20, 31000],
    [88.1, 20, 33000], [87.8, 20, 35000], [86.9, 20, 37000], [86.4, 20, 39000], [86.1, 20, 41000], [85.8, 20, 43000], [89.9, 15, 25000],
    [89.5, 15, 27000], [89.5, 15, 29000], [89.4, 15, 31000], [89, 15, 33000], [88.6, 15, 35000], [87.7, 15, 37000], [87.3, 15, 39000],
    [87, 15, 41000], [86.8, 15, 43000], [91, 10, 25000], [90.6, 10, 27000], [90.7, 10, 29000], [90.6, 10, 31000], [90.1, 10, 33000], [89.3, 10, 35000],
    [88.4, 10, 37000], [88, 10, 39000], [87.9, 10, 41000], [87.7, 10, 43000], [91.5, 5, 25000], [91.5, 5, 27000], [91.6, 5, 29000], [91.8, 5, 31000],
    [91.2, 5, 33000], [90.3, 5, 35000], [89.4, 5, 37000], [89.1, 5, 39000], [89, 5, 41000], [88.9, 5, 43000], [91.3, 0, 25000], [91.7, 0, 27000],
    [92.1, 0, 29000], [92.8, 0, 31000], [92.7, 0, 33000], [91.3, 0, 35000], [90.4, 0, 37000], [90.3, 0, 39000], [90.3, 0, 41000], [90.2, 0, 43000],
    [90.5, -5, 25000], [91, -5, 27000], [91.8, -5, 29000], [93.1, -5, 31000], [93.7, -5, 33000], [93, -5, 35000], [91.5, -5, 37000], [91.5, -5, 39000],
    [91.6, -5, 41000], [91.6, -5, 43000], [89.7, -10, 25000], [90.2, -10, 27000], [91, -10, 29000], [92.4, -10, 31000], [93.5, -10, 33000], [93.8, -10, 35000],
    [92.7, -10, 37000], [92.8, -10, 39000], [92.8, -10, 41000], [92.8, -10, 43000], [89, -15, 25000], [89.4, -15, 27000], [90.3, -15, 29000], [91.6, -15, 31000],
    [92.7, -15, 33000], [93.4, -15, 35000], [93.2, -15, 37000], [93.2, -15, 39000], [93.2, -15, 41000], [93.2, -15, 43000], [88.2, -20, 25000],
    [88.7, -20, 27000], [89.5, -20, 29000], [90.8, -20, 31000], [91.9, -20, 33000], [92.6, -20, 35000], [92.4, -20, 37000], [92.4, -20, 39000],
    [92.4, -20, 41000], [92.4, -20, 43000], [87.4, -25, 25000], [87.9, -25, 27000], [88.7, -25, 29000], [90, -25, 31000], [91.1, -25, 33000], [91.8, -25, 35000],
    [91.6, -25, 37000], [91.6, -25, 39000], [91.6, -25, 41000], [91.6, -25, 43000], [86.6, -30, 25000], [87.1, -30, 27000], [87.9, -30, 29000],
    [89.2, -30, 31000], [90.3, -30, 33000], [90.9, -30, 35000], [90.7, -30, 37000], [90.7, -30, 39000], [90.8, -30, 41000], [90.8, -30, 43000],
    [85.8, -35, 25000], [86.2, -35, 27000], [87.1, -35, 29000], [88.4, -35, 31000], [89.4, -35, 33000], [90.1, -35, 35000], [89.9, -35, 37000],
    [89.9, -35, 39000], [89.9, -35, 41000], [89.9, -35, 43000]
]);
B787EngineData.max_con_n1 = new LerpLookupTable([
    [89.3, 30, 5000], [90, 30, 10000], [90.6, 30, 12000], [90.2, 30, 14000], [89.8, 30, 16000], [90, 30, 18000], [90.6, 30, 20000], [90.1, 30, 22000],
    [89.8, 30, 24000], [89.7, 30, 25000], [89.7, 30, 27000], [89.7, 30, 29000], [89.3, 30, 31000], [88.5, 30, 33000], [87.6, 30, 35000], [86.4, 30, 37000],
    [88.7, 25, 5000], [90.9, 25, 10000], [91.6, 25, 12000], [91.4, 25, 14000], [90.9, 25, 16000], [90.8, 25, 18000], [91.5, 25, 20000], [91.1, 25, 22000],
    [90.9, 25, 24000], [90.9, 25, 25000], [91.1, 25, 27000], [91.1, 25, 29000], [90.7, 25, 31000], [89.9, 25, 33000], [89.1, 25, 35000], [87.9, 25, 37000],
    [88, 20, 5000], [90.6, 20, 10000], [92.3, 20, 12000], [92.1, 20, 14000], [92.2, 20, 16000], [92.2, 20, 18000], [92.5, 20, 20000], [92.1, 20, 22000],
    [91.9, 20, 24000], [91.9, 20, 25000], [92.2, 20, 27000], [92.4, 20, 29000], [92, 20, 31000], [91.2, 20, 33000], [90.5, 20, 35000], [89.1, 20, 37000],
    [87.3, 15, 5000], [89.9, 15, 10000], [91.6, 15, 12000], [91.9, 15, 14000], [92.4, 15, 16000], [93.1, 15, 18000], [93.6, 15, 20000], [93.4, 15, 22000],
    [93.1, 15, 24000], [93, 15, 25000], [93.3, 15, 27000], [93.5, 15, 29000], [93.2, 15, 31000], [92.3, 15, 33000], [91.6, 15, 35000], [90.1, 15, 37000],
    [86.7, 10, 5000], [89.2, 10, 10000], [90.9, 10, 12000], [91.1, 10, 14000], [91.7, 10, 16000], [93, 10, 18000], [95.1, 10, 20000], [94.7, 10, 22000],
    [94.7, 10, 24000], [95, 10, 25000], [95, 10, 27000], [94.9, 10, 29000], [94.5, 10, 31000], [93.3, 10, 33000], [92.6, 10, 35000], [91.1, 10, 37000],
    [86, 5, 5000], [88.5, 5, 10000], [90.2, 5, 12000], [90.4, 5, 14000], [91, 5, 16000], [92.2, 5, 18000], [94.3, 5, 20000], [94.8, 5, 22000], [95.3, 5, 24000],
    [95.6, 5, 25000], [96.3, 5, 27000], [96.5, 5, 29000], [96, 5, 31000], [94.7, 5, 33000], [93.8, 5, 35000], [92.1, 5, 37000],
    [85.3, 0, 5000], [87.8, 0, 10000], [89.4, 0, 12000], [89.7, 0, 14000], [90.3, 0, 16000], [91.5, 0, 18000], [93.6, 0, 20000], [94.1, 0, 22000],
    [94.6, 0, 24000], [95.1, 0, 25000], [96.3, 0, 27000], [97.3, 0, 29000], [97.2, 0, 31000], [96.1, 0, 33000], [95.3, 0, 35000], [93.3, 0, 37000],
    [84.5, -5, 5000], [87.1, -5, 10000], [88.7, -5, 12000], [88.9, -5, 14000], [89.5, -5, 16000], [90.8, -5, 18000], [92.9, -5, 20000], [93.3, -5, 22000],
    [93.8, -5, 24000], [94.3, -5, 25000], [95.5, -5, 27000], [96.5, -5, 29000], [97.1, -5, 31000], [96.8, -5, 33000], [96.6, -5, 35000], [94.6, -5, 37000],
    [83.8, -10, 5000], [86.3, -10, 10000], [88, -10, 12000], [88.2, -10, 14000], [88.8, -10, 16000], [90, -10, 18000], [92.1, -10, 20000], [92.6, -10, 22000],
    [93.1, -10, 24000], [93.5, -10, 25000], [94.8, -10, 27000], [95.7, -10, 29000], [96.3, -10, 31000], [96, -10, 33000], [95.9, -10, 35000], [93.8, -10, 37000],
    [83.1, -15, 5000], [85.6, -15, 10000], [87.2, -15, 12000], [87.4, -15, 14000], [88, -15, 16000], [89.3, -15, 18000], [91.4, -15, 20000], [91.8, -15, 22000],
    [92.3, -15, 24000], [92.8, -15, 25000], [94, -15, 27000], [95, -15, 29000], [95.6, -15, 31000], [95.2, -15, 33000], [95.1, -15, 35000], [93, -15, 37000],
    [82.4, -20, 5000], [84.9, -20, 10000], [86.4, -20, 12000], [86.7, -20, 14000], [87.2, -20, 16000], [88.5, -20, 18000], [90.6, -20, 20000], [91, -20, 22000],
    [91.5, -20, 24000], [92, -20, 25000], [93.2, -20, 27000], [94.2, -20, 29000], [94.7, -20, 31000], [94.4, -20, 33000], [94.3, -20, 35000], [92.2, -20, 37000],
    [81.6, -25, 5000], [84.1, -25, 10000], [85.7, -25, 12000], [85.9, -25, 14000], [86.4, -25, 16000], [87.7, -25, 18000], [89.8, -25, 20000], [90.2, -25, 22000],
    [90.7, -25, 24000], [91.2, -25, 25000], [92.4, -25, 27000], [93.4, -25, 29000], [93.9, -25, 31000], [93.6, -25, 33000], [93.5, -25, 35000], [91.4, -25, 37000],
    [80.9, -30, 5000], [83.3, -30, 10000], [84.9, -30, 12000], [85.1, -30, 14000], [85.6, -30, 16000], [86.9, -30, 18000], [89, -30, 20000], [89.4, -30, 22000],
    [89.9, -30, 24000], [90.4, -30, 25000], [91.6, -30, 27000], [92.5, -30, 29000], [93.1, -30, 31000], [92.8, -30, 33000], [92.7, -30, 35000], [90.6, -30, 37000],
    [80.1, -35, 5000], [82.5, -35, 10000], [84.1, -35, 12000], [84.3, -35, 14000], [84.8, -35, 16000], [86.1, -35, 18000], [88.2, -35, 20000], [88.6, -35, 22000],
    [89.1, -35, 24000], [89.5, -35, 25000], [90.8, -35, 27000], [91.7, -35, 29000], [92.3, -35, 31000], [92, -35, 33000], [91.8, -35, 35000], [89.8, -35, 37000],
    [79.3, -40, 5000], [81.7, -40, 10000], [83.3, -40, 12000], [83.5, -40, 14000], [84, -40, 16000], [85.3, -40, 18000], [87.4, -40, 20000], [87.8, -40, 22000],
    [88.3, -40, 24000], [88.7, -40, 25000], [89.9, -40, 27000], [90.8, -40, 29000], [91.4, -40, 31000], [91.1, -40, 33000], [91, -40, 35000], [88.9, -40, 37000]
]);
B787EngineData.lrc_mach = new LerpLookupTable([
    // New data, this is for the 787-10 from the respective FCOM.
    // At weight 617294/280t:
    [0.825, 617294.3, 25000], [0.855, 617294.3, 27000], [0.858, 617294.3, 29000], [0.854, 617294.3, 31000], [0.847, 617294.3, 33000],
    [.843, 617294.3, 35000], [.833, 617294.3, 37000], [.815, 617294.3, 39000], [.801, 617294.3, 41000], [.789, 617294.3, 43000],
    // At weight 573201/260t:
    [0.789, 573201.2, 25000], [0.832, 573201.2, 27000], [0.857, 573201.2, 29000], [0.857, 573201.2, 31000], [0.853, 573201.2, 33000],
    [0.845, 573201.2, 35000], [.833, 573201.2, 37000], [.815, 573201.2, 39000], [.801, 573201.2, 41000], [.789, 573201.2, 43000],
    // At weight 529108/240t:
    [0.758, 529108.8, 25000], [0.792, 529108.8, 27000], [0.836, 529108.8, 29000], [0.858, 529108.8, 31000], [0.857, 529108.8, 33000],
    [0.852, 529108.8, 35000], [0.843, 529108.8, 37000], [0.837, 529108.8, 39000], [0.829, 529108.8, 41000], [0.814, 529108.8, 43000],
    // At weight 485016/220t:
    [0.731, 485016.4, 25000], [0.759, 485016.4, 27000], [0.794, 485016.4, 29000], [0.838, 485016.4, 31000], [0.858, 485016.4, 33000],
    [0.856, 485016.4, 35000], [0.851, 485016.4, 37000], [0.844, 485016.4, 39000], [0.834, 485016.4, 41000], [0.824, 485016.4, 43000],
    // At weight 440924/200t:
    [0.704, 440924, 25000], [0.729, 440924, 27000], [0.757, 440924, 29000], [0.792, 440924, 31000], [0.837, 440924, 33000],
    [0.858, 440924, 35000], [0.856, 440924, 37000], [0.851, 440924, 39000], [0.842, 440924, 41000], [0.835, 440924, 43000],
    // At weight 396831/180t:
    [0.676, 396831.6, 25000], [0.700, 396831.6, 27000], [0.725, 396831.6, 29000], [0.752, 396831.6, 31000], [0.786, 396831.6, 33000],
    [0.832, 396831.6, 35000], [0.858, 396831.6, 37000], [0.857, 396831.6, 39000], [0.852, 396831.6, 41000], [.845, 396831.6, 43000],
    // At weight 352739/160t:
    [0.644, 352739.2, 25000], [0.668, 352739.2, 27000], [0.692, 352739.2, 29000], [0.717, 352739.2, 31000], [0.744, 352739.2, 33000],
    [0.775, 352739.2, 35000], [0.820, 352739.2, 37000], [0.855, 352739.2, 39000], [0.857, 352739.2, 41000], [0.854, 352739.2, 43000],
    // At weight 308646/140t:
    [0.612, 308646.8, 25000], [0.633, 308646.8, 27000], [0.656, 308646.8, 29000], [0.681, 308646.8, 31000], [0.706, 308646.8, 33000],
    [0.733, 308646.8, 35000], [0.763, 308646.8, 37000], [0.802, 308646.8, 39000], [0.847, 308646.8, 41000], [0.853, 308646.8, 43000],
    // At weight 264554/120t:
    [0.581, 264554.4, 25000], [0.598, 264554.4, 27000], [0.618, 264554.4, 29000], [0.639, 264554.4, 31000], [0.664, 264554.4, 33000],
    [0.690, 264554.4, 35000], [0.716, 264554.4, 37000], [0.744, 264554.4, 39000], [0.775, 264554.4, 41000], [0.818, 264554.4, 43000]
]);
/** Output: Opt Altitude in Ft; Term 1: Weight in LBS */
B787EngineData.alt_opt = new LerpLookupTable([
    [31800, 573201.2],
    [32600, 551155],
    [33500, 529108.8],
    [34400, 507062.6],
    [35300, 485016.4],
    [36300, 462970.2],
    [37300, 440924],
    [38400, 418877.8],
    [39500, 396831.6],
    [40700, 374785.4],
    [41900, 352739.2],
    [43100, 330693],
    [43100, 308646.8],
    [43100, 286600.6],
    [43100, 264554.4]
]);
/** Output: Max Altitude in Ft; Term 1: Weight in LBS; Term 2: ISA Tem Deviation in C */
B787EngineData.alt_max = new LerpLookupTable([
    [34700, 573201.2, -100], [34700, 573201.2, 10], [34400, 573201.2, 15], [32700, 573201.2, 20],
    [35600, 551155, -100], [35600, 551155, 10], [35300, 551155, 15], [33800, 551155, 20],
    [36400, 529108.8, -100], [36400, 529108.8, 10], [36000, 529108.8, 15], [34800, 529108.8, 20],
    [37300, 507062.6, -100], [37300, 507062.6, 10], [36800, 507062.6, 15], [35800, 507062.6, 20],
    [38200, 485016.4, -100], [38200, 485016.4, 10], [37700, 485016.4, 15], [36500, 485016.4, 20],
    [39200, 462970.2, -100], [39200, 462970.2, 10], [38700, 462970.2, 15], [37500, 462970.2, 20],
    [40200, 440924, -100], [40200, 440924, 10], [39600, 440924, 15], [38400, 440924, 20],
    [41300, 418877.8, -100], [41300, 418877.8, 10], [40600, 418877.8, 15], [39300, 418877.8, 20],
    [42300, 396831.6, -100], [42300, 396831.6, 10], [41600, 396831.6, 15], [40200, 396831.6, 20],
    [43100, 374785.4, -100], [43100, 374785.4, 10], [42700, 374785.4, 15], [41100, 374785.4, 20],
    [43100, 352739.2, -100], [43100, 352739.2, 10], [43100, 352739.2, 15], [42100, 352739.2, 20],
    [43100, 330693, -100], [43100, 330693, 10], [43100, 330693, 15], [43100, 330693, 20],
    [43100, 308646.8, -100], [43100, 308646.8, 10], [43100, 308646.8, 15], [43100, 308646.8, 20],
    [43100, 286600.6, -100], [43100, 286600.6, 10], [43100, 286600.6, 15], [43100, 286600.6, 20],
    [43100, 264554.4, -100], [43100, 264554.4, 10], [43100, 264554.4, 15], [43100, 264554.4, 20]
]);
B787EngineData.n1_tpr_lookup = new LerpLookupTable([
    [1.015, -30, -2000, 90], [1.06, -30, 0, 90], [1.105, -30, 5000, 90], [1.124, -30, 10000, 90], [1.129, -30, 11000, 90], [1.14, -30, 12000, 90], [1.139, -30, 13000, 90],
    [1.139, -30, 14000, 90], [1.079, -30, 20000, 90], [1.094, -30, 25000, 90], [1.112, -30, 30000, 90], [1.135, -30, 35000, 90], [1.132, -30, 40000, 90], [1.134, -30, 43000, 90],
    [1.015, -30, -2000, 65], [1.06, -30, 0, 65], [1.105, -30, 5000, 65], [1.124, -30, 10000, 65], [1.129, -30, 11000, 65], [1.14, -30, 12000, 65], [1.139, -30, 13000, 65],
    [1.139, -30, 14000, 65], [1.079, -30, 20000, 65], [1.094, -30, 25000, 65], [1.112, -30, 30000, 65], [1.135, -30, 35000, 65], [1.132, -30, 40000, 65], [1.134, -30, 43000, 65],
    [0.338, -30, -2000, 25], [0.353, -30, 0, 25], [0.368, -30, 5000, 25], [0.375, -30, 10000, 25], [0.376, -30, 11000, 25], [0.38, -30, 12000, 25], [0.38, -30, 13000, 25],
    [0.38, -30, 14000, 25], [0.36, -30, 20000, 25], [0.365, -30, 25000, 25], [0.371, -30, 30000, 25], [0.378, -30, 35000, 25], [0.377, -30, 40000, 25], [0.378, -30, 43000, 25],
    [0.238, -30, -2000, 0], [0.253, -30, 0, 0], [0.268, -30, 5000, 0], [0.275, -30, 10000, 0], [0.276, -30, 11000, 0], [0.28, -30, 12000, 0], [0.28, -30, 13000, 0],
    [0.28, -30, 14000, 0], [0.26, -30, 20000, 0], [0.265, -30, 25000, 0], [0.271, -30, 30000, 0], [0.278, -30, 35000, 0], [0.277, -30, 40000, 0], [0.278, -30, 43000, 0],
    [0.971, -10, -2000, 90], [1.014, -10, 0, 90], [1.057, -10, 5000, 90], [1.077, -10, 10000, 90], [1.079, -10, 11000, 90], [1.091, -10, 12000, 90], [1.091, -10, 13000, 90],
    [1.09, -10, 14000, 90], [1.032, -10, 20000, 90], [1.047, -10, 25000, 90], [1.065, -10, 30000, 90], [1.082, -10, 35000, 90], [1.072, -10, 40000, 90], [1.073, -10, 43000, 90],
    [0.971, -10, -2000, 65], [1.014, -10, 0, 65], [1.057, -10, 5000, 65], [1.077, -10, 10000, 65], [1.079, -10, 11000, 65], [1.091, -10, 12000, 65], [1.091, -10, 13000, 65],
    [1.09, -10, 14000, 65], [1.032, -10, 20000, 65], [1.047, -10, 25000, 65], [1.065, -10, 30000, 65], [1.082, -10, 35000, 65], [1.072, -10, 40000, 65], [1.073, -10, 43000, 65],
    [0.324, -10, -2000, 25], [0.338, -10, 0, 25], [0.352, -10, 5000, 25], [0.359, -10, 10000, 25], [0.36, -10, 11000, 25], [0.364, -10, 12000, 25], [0.364, -10, 13000, 25],
    [0.363, -10, 14000, 25], [0.344, -10, 20000, 25], [0.349, -10, 25000, 25], [0.355, -10, 30000, 25], [0.361, -10, 35000, 25], [0.357, -10, 40000, 25], [0.358, -10, 43000, 25],
    [0.224, -10, -2000, 0], [0.238, -10, 0, 0], [0.252, -10, 5000, 0], [0.259, -10, 10000, 0], [0.26, -10, 11000, 0], [0.264, -10, 12000, 0], [0.264, -10, 13000, 0],
    [0.263, -10, 14000, 0], [0.244, -10, 20000, 0], [0.249, -10, 25000, 0], [0.255, -10, 30000, 0], [0.261, -10, 35000, 0], [0.257, -10, 40000, 0], [0.258, -10, 43000, 0],
    [0.949, 0, -2000, 90], [0.991, 0, 0, 90], [1.036, 0, 5000, 90], [1.053, 0, 10000, 90], [1.058, 0, 11000, 90], [1.07, 0, 12000, 90], [1.067, 0, 13000, 90], [1.06, 0, 14000, 90],
    [1.011, 0, 20000, 90], [1.026, 0, 25000, 90], [1.034, 0, 30000, 90], [1.014, 0, 35000, 90], [0.997, 0, 40000, 90], [0.996, 0, 43000, 90],
    [0.949, 0, -2000, 65], [0.991, 0, 0, 65], [1.036, 0, 5000, 65], [1.053, 0, 10000, 65], [1.058, 0, 11000, 65], [1.07, 0, 12000, 65], [1.067, 0, 13000, 65],
    [1.06, 0, 14000, 65], [1.011, 0, 20000, 65], [1.026, 0, 25000, 65], [1.034, 0, 30000, 65], [1.014, 0, 35000, 65], [0.997, 0, 40000, 65], [0.996, 0, 43000, 65],
    [0.316, 0, -2000, 25], [0.33, 0, 0, 25], [0.345, 0, 5000, 25], [0.351, 0, 10000, 25], [0.353, 0, 11000, 25], [0.357, 0, 12000, 25], [0.356, 0, 13000, 25],
    [0.353, 0, 14000, 25], [0.337, 0, 20000, 25], [0.342, 0, 25000, 25], [0.345, 0, 30000, 25], [0.338, 0, 35000, 25], [0.332, 0, 40000, 25], [0.332, 0, 43000, 25],
    [0.216, 0, -2000, 0], [0.23, 0, 0, 0], [0.245, 0, 5000, 0], [0.251, 0, 10000, 0], [0.253, 0, 11000, 0], [0.257, 0, 12000, 0], [0.256, 0, 13000, 0], [0.253, 0, 14000, 0],
    [0.237, 0, 20000, 0], [0.242, 0, 25000, 0], [0.245, 0, 30000, 0], [0.238, 0, 35000, 0], [0.232, 0, 40000, 0], [0.232, 0, 43000, 0],
    [0.92, 15, -2000, 90], [0.96, 15, 0, 90], [1.003, 15, 5000, 90], [1.005, 15, 10000, 90], [0.998, 15, 11000, 90], [0.991, 15, 12000, 90], [0.985, 15, 13000, 90],
    [0.977, 15, 14000, 90], [0.957, 15, 20000, 90], [0.934, 15, 25000, 90], [0.918, 15, 30000, 90], [0.893, 15, 35000, 90], [0.864, 15, 40000, 90], [0.857, 15, 43000, 90],
    [0.92, 15, -2000, 65], [0.96, 15, 0, 65], [1.003, 15, 5000, 65], [1.005, 15, 10000, 65], [0.998, 15, 11000, 65], [0.991, 15, 12000, 65], [0.985, 15, 13000, 65],
    [0.977, 15, 14000, 65], [0.957, 15, 20000, 65], [0.934, 15, 25000, 65], [0.918, 15, 30000, 65], [0.893, 15, 35000, 65], [0.864, 15, 40000, 65], [0.857, 15, 43000, 65],
    [0.307, 15, -2000, 25], [0.32, 15, 0, 25], [0.334, 15, 5000, 25], [0.335, 15, 10000, 25], [0.333, 15, 11000, 25], [0.33, 15, 12000, 25], [0.328, 15, 13000, 25],
    [0.326, 15, 14000, 25], [0.319, 15, 20000, 25], [0.311, 15, 25000, 25], [0.306, 15, 30000, 25], [0.298, 15, 35000, 25], [0.288, 15, 40000, 25], [0.286, 15, 43000, 25],
    [0.207, 15, -2000, 0], [0.22, 15, 0, 0], [0.234, 15, 5000, 0], [0.235, 15, 10000, 0], [0.233, 15, 11000, 0], [0.23, 15, 12000, 0], [0.228, 15, 13000, 0],
    [0.226, 15, 14000, 0], [0.219, 15, 20000, 0], [0.211, 15, 25000, 0], [0.206, 15, 30000, 0], [0.198, 15, 35000, 0], [0.188, 15, 40000, 0], [0.186, 15, 43000, 0],
    [0.893, 30, -2000, 90], [0.932, 30, 0, 90], [0.925, 30, 5000, 90], [0.9, 30, 10000, 90], [0.893, 30, 11000, 90], [0.884, 30, 12000, 90], [0.872, 30, 13000, 90],
    [0.858, 30, 14000, 90], [0.815, 30, 20000, 90], [0.799, 30, 25000, 90], [0.784, 30, 30000, 90], [0.822, 30, 35000, 90], [0.806, 30, 40000, 90], [0.798, 30, 43000, 90],
    [0.893, 30, -2000, 65], [0.932, 30, 0, 65], [0.925, 30, 5000, 65], [0.9, 30, 10000, 65], [0.893, 30, 11000, 65], [0.884, 30, 12000, 65], [0.872, 30, 13000, 65],
    [0.858, 30, 14000, 65], [0.815, 30, 20000, 65], [0.799, 30, 25000, 65], [0.784, 30, 30000, 65], [0.822, 30, 35000, 65], [0.806, 30, 40000, 65], [0.798, 30, 43000, 65],
    [0.298, 30, -2000, 25], [0.311, 30, 0, 25], [0.308, 30, 5000, 25], [0.3, 30, 10000, 25], [0.298, 30, 11000, 25], [0.295, 30, 12000, 25], [0.291, 30, 13000, 25],
    [0.286, 30, 14000, 25], [0.272, 30, 20000, 25], [0.266, 30, 25000, 25], [0.261, 30, 30000, 25], [0.274, 30, 35000, 25], [0.269, 30, 40000, 25], [0.266, 30, 43000, 25],
    [0.198, 30, -2000, 0], [0.211, 30, 0, 0], [0.208, 30, 5000, 0], [0.2, 30, 10000, 0], [0.198, 30, 11000, 0], [0.195, 30, 12000, 0], [0.191, 30, 13000, 0],
    [0.186, 30, 14000, 0], [0.172, 30, 20000, 0], [0.166, 30, 25000, 0], [0.161, 30, 30000, 0], [0.174, 30, 35000, 0], [0.169, 30, 40000, 0], [0.166, 30, 43000, 0]
]);

/** B787 Performance Math Utility Class. */
class B787PerformanceMath extends BoeingPerformanceDataProvider {
    /** @inheritDoc */
    get operatingEmptyWeight() {
        return 298700; // 135,488 kg
    }
    /** @inheritDoc */
    get maxZeroFuelWeight() {
        return 425000; // 192,777 kg
    }
    /** @inheritDoc */
    get maxGrossWeight() {
        return 557000; // 252,651 kg
    }
    /** @inheritDoc */
    get maxReserveFuel() {
        return Number.MAX_SAFE_INTEGER; // TODO Replace with actual value
    }
    /** @inheritDoc */
    get fuelFreezeTemp() {
        return -37;
    }
    /** @inheritDoc */
    get minCenterOfGravity() {
        return 6;
    }
    /** @inheritDoc */
    get maxCenterOfGravity() {
        return 39.5;
    }
    /** @inheritdoc */
    getAircraftFlightModel() {
        return {
            wing_span: 197.33,
            wing_area: 4058,
            //From the lift_coef_aoa_table: the value at aoa_0.
            cl_cd: [[0.317, 0.028], [0.5282, 0.0447], [0.5714, 0.526], [0.6147, 0.0620], [0.6580, 0.0729],
                [0.6801, 0.0788], [0.6952, 0.0830], [0.7173, 0.0898], [0.7109, 0.1041], [0.7284, 0.1280], [1.516, 0.28885]],
            induced_drag_scalar: 1.3,
            oswald_efficiency_factor: 0.73,
            inlet_area: 68.4,
            low_idle_n1: 20,
            mach_influence_on_n1: 10,
            static_thrust: 78500,
            ThrustSpecificFuelConsumption: 0.265,
            /** Output: Thrust scalar; Term 1: Mach; Term 2: CN1 */
            n1_and_mach_on_thrust_table: new LerpLookupTable([
                [0, 0, 0], [0, 0.4, 0], [0, 0.8, 0], [0, 0.9, 0],
                [0.0705, 0, 20], [0, 0.4, 20], [0.0705, 0.8, 20], [0.0705, 0.9, 20],
                [0.087562, 0, 26], [0, 0.4, 26], [0.221344, 0.8, 26], [0.225566, 0.9, 26],
                [0.265, 0, 50], [0.29, 0.4, 50], [0.315, 0.8, 50], [0.315, 0.9, 50],
                [0.43, 0, 65], [0.44, 0.4, 65], [0.45, 0.8, 65], [0.45, 0.9, 65],
                [0.68, 0, 80], [0.715, 0.4, 80], [0.75, 0.8, 80], [0.76, 0.9, 80],
                [0.82, 0, 85], [0.86, 0.4, 85], [0.9, 0.8, 85], [0.91, 0.9, 85],
                [0.98, 0, 90], [1.02, 0.4, 90], [1.06, 0.8, 90], [1.11, 0.9, 90],
                [1.1, 0, 95], [1.165, 0.4, 95], [1.23, 0.8, 95], [1.24, 0.9, 95],
                [1.18, 0, 100], [1.25, 0.4, 100], [1.32, 0.8, 100], [1.32, 0.9, 100],
                [1.25, 0, 105], [1.335, 0.4, 105], [1.42, 0.8, 105], [1.42, 0.9, 105],
                [1.3, 0, 110], [1.395, 0.4, 110], [1.49, 0.8, 110], [1.49, 0.9, 110]
            ]),
            /** Output: CN1; Term 1: Mach; Term 2: Thrust Scalar */
            thrust_and_mach_on_n1_table: new LerpLookupTable([
                [0, 0, 0], [0, 0.4, 0], [0, 0.8, 0], [0, 0.9, 0],
                [20, 0, 0.0705], [20, 0.4, 0], [20, 0.8, 0.0705], [20, 0.9, 0.0705],
                [26, 0, 0.087562], [26, 0.4, 0], [26, 0.8, 0.221344], [26, 0.9, 0.225566],
                [50, 0, 0.265], [50, 0.4, 0.29], [50, 0.8, 0.315], [50, 0.9, 0.315],
                [65, 0, 0.43], [65, 0.4, 0.44], [65, 0.8, 0.45], [65, 0.9, 0.45],
                [80, 0, 0.68], [80, 0.4, 0.715], [80, 0.8, 0.75], [80, 0.9, 0.76],
                [85, 0, 0.82], [85, 0.4, 0.86], [85, 0.8, 0.9], [85, 0.9, 0.91],
                [90, 0, 0.98], [90, 0.4, 1.02], [90, 0.8, 1.06], [90, 0.9, 1.11],
                [95, 0, 1.1], [95, 0.4, 1.165], [95, 0.8, 1.23], [95, 0.9, 1.24],
                [100, 0, 1.18], [100, 0.4, 1.25], [100, 0.8, 1.32], [100, 0.9, 1.32],
                [105, 0, 1.25], [105, 0.4, 1.335], [105, 0.8, 1.42], [105, 0.9, 1.42],
                [110, 0, 1.3], [110, 0.4, 1.395], [110, 0.8, 1.49], [110, 0.9, 1.49]
            ]),
            corrected_airflow_table: new LerpLookupTable([
                // updated 2/22/23 CWB
                [0, 0, 0], [0, 0, 0.9],
                [0.1, 20, 0], [5, 20, 0.9],
                [1, 40, 0], [7.3, 40, 0.9],
                [3, 60, 0], [8.75, 60, 0.9],
                [4, 70, 0], [9.7, 70, 0.9],
                [5, 75, 0], [10.5, 75, 0.9],
                [8, 80, 0], [12, 80, 0.9],
                [11.5, 85, 0], [14.75, 85, 0.9],
                [15, 90, 0], [18, 90, 0.9],
                [17, 95, 0], [21, 95, 0.9],
                [19, 100, 0], [23, 100, 0.9],
                [21, 105, 0], [24.75, 105, 0.9],
                [23, 110, 0], [26.25, 110, 0.9]
            ])
        };
    }
}

/* eslint-disable max-len */
/**
 * A provider of Boeing 787-10 reference airspeeds.
 */
class B787SpeedData extends AbstractBoeingSpeedProvider {
    /**
     * Creates a new instance of B787SpeedData.
     * @param bus The event bus.
     * @param engineDataProvider A provider of airplane engine data.
     */
    constructor(bus, engineDataProvider) {
        super(engineDataProvider);
        this.bus = bus;
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.pressureAlt.setConsumer(this.bus.getSubscriber().on('pressure_alt'));
    }
    /** @inheritdoc */
    getFlapManeuverSpeed(flapPos, weight, pressureAlt) {
        return B787SpeedData.flap_maneuver_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVrefSpeed(flapPos, weight, pressureAlt) {
        if (flapPos === 20) {
            // We don't have pressure alt corrected data for 10k... do a dirty and use the difference between maneuver speeds
            const vRef14k = B787SpeedData.vref14k.get(weight, flapPos);
            const maneuver14k = this.getFlapManeuverSpeed(flapPos, weight, 14000);
            const maneuver = this.getFlapManeuverSpeed(flapPos, weight, pressureAlt);
            return vRef14k + (maneuver - maneuver14k);
        }
        if (flapPos === 25 || flapPos === 30) {
            // the flap maneuver speeds for 25 and 30 are vref, and corrected for pressure alt
            return this.getFlapManeuverSpeed(flapPos, weight, pressureAlt);
        }
        throw new Error('20, 25, 30 are the only valid 787 VREF flap positions');
    }
    /** @inheritdoc */
    getHoldingSpeed(flapPos, weight, pressureAlt) {
        return B787SpeedData.holding_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVmo(pressureAlt) {
        // The 787's official Type Certificate Data Sheet contains these speed limits: VMO/MMO 350KEAS / 360KIAS / 0.90M
        return Math.min(360, BoeingAeroMath.easToCas(B787SpeedData.vmo, pressureAlt !== null && pressureAlt !== void 0 ? pressureAlt : this.pressureAlt.get()));
    }
    /** @inheritdoc */
    getMmo() {
        return B787SpeedData.mmo;
    }
    /** @inheritdoc */
    getGearLimitSpeed() {
        return B787SpeedData.vle;
    }
}
/** Maximum Speed Limit Mach Number */
B787SpeedData.mmo = 0.9;
/** Maximum Speed Limit KEAS */
B787SpeedData.vmo = 350;
/** Landing Gear Placard Speed KIAS */
B787SpeedData.vle = 270;
/** Flap Maneuver Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B787SpeedData.flap_maneuver_speeds = new LerpLookupTable([
    [258, 573202, 0, 0], [238, 573202, 1, 0], [208, 573202, 5, 0], [198, 573202, 10, 0], [193, 573202, 15, 0], [193, 573202, 17, 0], [193, 573202, 18, 0], [187, 573202, 20, 0], [179, 573202, 25, 0], [174, 573202, 30, 0],
    [258, 551156, 0, 0], [238, 551156, 1, 0], [208, 551156, 5, 0], [198, 551156, 10, 0], [193, 551156, 15, 0], [193, 551156, 17, 0], [193, 551156, 18, 0], [185, 551156, 20, 0], [175, 551156, 25, 0], [170, 551156, 30, 0],
    [258, 529110, 0, 0], [237, 529110, 1, 0], [208, 529110, 5, 0], [195, 529110, 10, 0], [190, 529110, 15, 0], [190, 529110, 17, 0], [190, 529110, 18, 0], [182, 529110, 20, 0], [172, 529110, 25, 0], [167, 529110, 30, 0],
    [253, 507064, 0, 0], [233, 507064, 1, 0], [206, 507064, 5, 0], [192, 507064, 10, 0], [187, 507064, 15, 0], [187, 507064, 17, 0], [187, 507064, 18, 0], [178, 507064, 20, 0], [168, 507064, 25, 0], [163, 507064, 30, 0],
    [246, 485017, 0, 0], [227, 485017, 1, 0], [203, 485017, 5, 0], [188, 485017, 10, 0], [183, 485017, 15, 0], [183, 485017, 17, 0], [183, 485017, 18, 0], [174, 485017, 20, 0], [164, 485017, 25, 0], [159, 485017, 30, 0],
    [238, 462971, 0, 0], [222, 462971, 1, 0], [199, 462971, 5, 0], [184, 462971, 10, 0], [179, 462971, 15, 0], [179, 462971, 17, 0], [179, 462971, 18, 0], [171, 462971, 20, 0], [160, 462971, 25, 0], [155, 462971, 30, 0],
    [234, 440925, 0, 0], [217, 440925, 1, 0], [195, 440925, 5, 0], [180, 440925, 10, 0], [175, 440925, 15, 0], [175, 440925, 17, 0], [175, 440925, 18, 0], [167, 440925, 20, 0], [157, 440925, 25, 0], [152, 440925, 30, 0],
    [233, 418879, 0, 0], [211, 418879, 1, 0], [191, 418879, 5, 0], [176, 418879, 10, 0], [171, 418879, 15, 0], [171, 418879, 17, 0], [171, 418879, 18, 0], [165, 418879, 20, 0], [155, 418879, 25, 0], [150, 418879, 30, 0],
    [227, 396832, 0, 0], [206, 396832, 1, 0], [187, 396832, 5, 0], [172, 396832, 10, 0], [167, 396832, 15, 0], [167, 396832, 17, 0], [167, 396832, 18, 0], [161, 396832, 20, 0], [150, 396832, 25, 0], [146, 396832, 30, 0],
    [223, 374786, 0, 0], [200, 374786, 1, 0], [183, 374786, 5, 0], [168, 374786, 10, 0], [163, 374786, 15, 0], [163, 374786, 17, 0], [163, 374786, 18, 0], [157, 374786, 20, 0], [146, 374786, 25, 0], [141, 374786, 30, 0],
    [218, 352740, 0, 0], [194, 352740, 1, 0], [179, 352740, 5, 0], [164, 352740, 10, 0], [158, 352740, 15, 0], [158, 352740, 17, 0], [158, 352740, 18, 0], [152, 352740, 20, 0], [141, 352740, 25, 0], [137, 352740, 30, 0],
    [214, 330694, 0, 0], [189, 330694, 1, 0], [174, 330694, 5, 0], [159, 330694, 10, 0], [154, 330694, 15, 0], [154, 330694, 17, 0], [154, 330694, 18, 0], [148, 330694, 20, 0], [137, 330694, 25, 0], [132, 330694, 30, 0],
    [209, 308647, 0, 0], [184, 308647, 1, 0], [170, 308647, 5, 0], [154, 308647, 10, 0], [149, 308647, 15, 0], [149, 308647, 17, 0], [149, 308647, 18, 0], [143, 308647, 20, 0], [132, 308647, 25, 0], [128, 308647, 30, 0],
    [206, 286601, 0, 0], [180, 286601, 1, 0], [166, 286601, 5, 0], [150, 286601, 10, 0], [145, 286601, 15, 0], [145, 286601, 17, 0], [145, 286601, 18, 0], [139, 286601, 20, 0], [127, 286601, 25, 0], [124, 286601, 30, 0],
    [202, 264555, 0, 0], [177, 264555, 1, 0], [162, 264555, 5, 0], [147, 264555, 10, 0], [142, 264555, 15, 0], [142, 264555, 17, 0], [142, 264555, 18, 0], [135, 264555, 20, 0], [122, 264555, 25, 0], [121, 264555, 30, 0],
    [258, 573202, 0, 10000], [238, 573202, 1, 10000], [208, 573202, 5, 10000], [200, 573202, 10, 10000], [194, 573202, 15, 10000], [194, 573202, 17, 10000], [194, 573202, 18, 10000], [188, 573202, 20, 10000], [182, 573202, 25, 10000], [175, 573202, 30, 10000],
    [258, 551156, 0, 10000], [238, 551156, 1, 10000], [208, 551156, 5, 10000], [200, 551156, 10, 10000], [194, 551156, 15, 10000], [194, 551156, 17, 10000], [194, 551156, 18, 10000], [187, 551156, 20, 10000], [178, 551156, 25, 10000], [172, 551156, 30, 10000],
    [258, 529110, 0, 10000], [238, 529110, 1, 10000], [208, 529110, 5, 10000], [197, 529110, 10, 10000], [192, 529110, 15, 10000], [192, 529110, 17, 10000], [192, 529110, 18, 10000], [183, 529110, 20, 10000], [174, 529110, 25, 10000], [168, 529110, 30, 10000],
    [253, 507064, 0, 10000], [234, 507064, 1, 10000], [207, 507064, 5, 10000], [193, 507064, 10, 10000], [188, 507064, 15, 10000], [188, 507064, 17, 10000], [188, 507064, 18, 10000], [179, 507064, 20, 10000], [170, 507064, 25, 10000], [164, 507064, 30, 10000],
    [246, 485017, 0, 10000], [229, 485017, 1, 10000], [204, 485017, 5, 10000], [189, 485017, 10, 10000], [184, 485017, 15, 10000], [184, 485017, 17, 10000], [184, 485017, 18, 10000], [176, 485017, 20, 10000], [166, 485017, 25, 10000], [161, 485017, 30, 10000],
    [238, 462971, 0, 10000], [224, 462971, 1, 10000], [200, 462971, 5, 10000], [185, 462971, 10, 10000], [180, 462971, 15, 10000], [180, 462971, 17, 10000], [180, 462971, 18, 10000], [172, 462971, 20, 10000], [162, 462971, 25, 10000], [157, 462971, 30, 10000],
    [234, 440925, 0, 10000], [218, 440925, 1, 10000], [196, 440925, 5, 10000], [181, 440925, 10, 10000], [176, 440925, 15, 10000], [176, 440925, 17, 10000], [176, 440925, 18, 10000], [169, 440925, 20, 10000], [159, 440925, 25, 10000], [153, 440925, 30, 10000],
    [233, 418879, 0, 10000], [213, 418879, 1, 10000], [192, 418879, 5, 10000], [177, 418879, 10, 10000], [172, 418879, 15, 10000], [172, 418879, 17, 10000], [172, 418879, 18, 10000], [166, 418879, 20, 10000], [156, 418879, 25, 10000], [151, 418879, 30, 10000],
    [228, 396832, 0, 10000], [207, 396832, 1, 10000], [188, 396832, 5, 10000], [173, 396832, 10, 10000], [168, 396832, 15, 10000], [168, 396832, 17, 10000], [168, 396832, 18, 10000], [162, 396832, 20, 10000], [152, 396832, 25, 10000], [147, 396832, 30, 10000],
    [224, 374786, 0, 10000], [201, 374786, 1, 10000], [184, 374786, 5, 10000], [169, 374786, 10, 10000], [164, 374786, 15, 10000], [164, 374786, 17, 10000], [164, 374786, 18, 10000], [158, 374786, 20, 10000], [147, 374786, 25, 10000], [142, 374786, 30, 10000],
    [219, 352740, 0, 10000], [195, 352740, 1, 10000], [179, 352740, 5, 10000], [164, 352740, 10, 10000], [159, 352740, 15, 10000], [159, 352740, 17, 10000], [159, 352740, 18, 10000], [153, 352740, 20, 10000], [142, 352740, 25, 10000], [138, 352740, 30, 10000],
    [215, 330694, 0, 10000], [189, 330694, 1, 10000], [175, 330694, 5, 10000], [160, 330694, 10, 10000], [155, 330694, 15, 10000], [155, 330694, 17, 10000], [155, 330694, 18, 10000], [148, 330694, 20, 10000], [137, 330694, 25, 10000], [133, 330694, 30, 10000],
    [210, 308647, 0, 10000], [184, 308647, 1, 10000], [170, 308647, 5, 10000], [155, 308647, 10, 10000], [150, 308647, 15, 10000], [150, 308647, 17, 10000], [150, 308647, 18, 10000], [144, 308647, 20, 10000], [132, 308647, 25, 10000], [128, 308647, 30, 10000],
    [206, 286601, 0, 10000], [180, 286601, 1, 10000], [166, 286601, 5, 10000], [151, 286601, 10, 10000], [146, 286601, 15, 10000], [146, 286601, 17, 10000], [146, 286601, 18, 10000], [139, 286601, 20, 10000], [127, 286601, 25, 10000], [124, 286601, 30, 10000],
    [202, 264555, 0, 10000], [177, 264555, 1, 10000], [163, 264555, 5, 10000], [147, 264555, 10, 10000], [142, 264555, 15, 10000], [142, 264555, 17, 10000], [142, 264555, 18, 10000], [135, 264555, 20, 10000], [122, 264555, 25, 10000], [121, 264555, 30, 10000],
    [260, 573202, 0, 20000], [239, 573202, 1, 20000], [209, 573202, 5, 20000], [202, 573202, 10, 20000], [194, 573202, 15, 20000], [194, 573202, 17, 20000], [194, 573202, 18, 20000], [189, 573202, 20, 20000], [185, 573202, 25, 20000], [177, 573202, 30, 20000],
    [259, 551156, 0, 20000], [239, 551156, 1, 20000], [209, 551156, 5, 20000], [202, 551156, 10, 20000], [194, 551156, 15, 20000], [194, 551156, 17, 20000], [194, 551156, 18, 20000], [189, 551156, 20, 20000], [181, 551156, 25, 20000], [174, 551156, 30, 20000],
    [259, 529110, 0, 20000], [239, 529110, 1, 20000], [209, 529110, 5, 20000], [199, 529110, 10, 20000], [193, 529110, 15, 20000], [193, 529110, 17, 20000], [193, 529110, 18, 20000], [185, 529110, 20, 20000], [177, 529110, 25, 20000], [170, 529110, 30, 20000],
    [254, 507064, 0, 20000], [237, 507064, 1, 20000], [209, 507064, 5, 20000], [195, 507064, 10, 20000], [190, 507064, 15, 20000], [190, 507064, 17, 20000], [190, 507064, 18, 20000], [181, 507064, 20, 20000], [173, 507064, 25, 20000], [166, 507064, 30, 20000],
    [247, 485017, 0, 20000], [232, 485017, 1, 20000], [206, 485017, 5, 20000], [191, 485017, 10, 20000], [186, 485017, 15, 20000], [186, 485017, 17, 20000], [186, 485017, 18, 20000], [177, 485017, 20, 20000], [169, 485017, 25, 20000], [162, 485017, 30, 20000],
    [239, 462971, 0, 20000], [227, 462971, 1, 20000], [202, 462971, 5, 20000], [187, 462971, 10, 20000], [182, 462971, 15, 20000], [182, 462971, 17, 20000], [182, 462971, 18, 20000], [174, 462971, 20, 20000], [165, 462971, 25, 20000], [158, 462971, 30, 20000],
    [234, 440925, 0, 20000], [221, 440925, 1, 20000], [198, 440925, 5, 20000], [183, 440925, 10, 20000], [178, 440925, 15, 20000], [178, 440925, 17, 20000], [178, 440925, 18, 20000], [170, 440925, 20, 20000], [161, 440925, 25, 20000], [155, 440925, 30, 20000],
    [234, 418879, 0, 20000], [215, 418879, 1, 20000], [194, 418879, 5, 20000], [179, 418879, 10, 20000], [174, 418879, 15, 20000], [174, 418879, 17, 20000], [174, 418879, 18, 20000], [168, 418879, 20, 20000], [159, 418879, 25, 20000], [152, 418879, 30, 20000],
    [229, 396832, 0, 20000], [209, 396832, 1, 20000], [190, 396832, 5, 20000], [175, 396832, 10, 20000], [170, 396832, 15, 20000], [170, 396832, 17, 20000], [170, 396832, 18, 20000], [164, 396832, 20, 20000], [154, 396832, 25, 20000], [148, 396832, 30, 20000],
    [225, 374786, 0, 20000], [203, 374786, 1, 20000], [185, 374786, 5, 20000], [170, 374786, 10, 20000], [165, 374786, 15, 20000], [165, 374786, 17, 20000], [165, 374786, 18, 20000], [159, 374786, 20, 20000], [149, 374786, 25, 20000], [144, 374786, 30, 20000],
    [220, 352740, 0, 20000], [196, 352740, 1, 20000], [181, 352740, 5, 20000], [166, 352740, 10, 20000], [161, 352740, 15, 20000], [161, 352740, 17, 20000], [161, 352740, 18, 20000], [155, 352740, 20, 20000], [144, 352740, 25, 20000], [139, 352740, 30, 20000],
    [216, 330694, 0, 20000], [191, 330694, 1, 20000], [176, 330694, 5, 20000], [161, 330694, 10, 20000], [156, 330694, 15, 20000], [156, 330694, 17, 20000], [156, 330694, 18, 20000], [150, 330694, 20, 20000], [139, 330694, 25, 20000], [134, 330694, 30, 20000],
    [211, 308647, 0, 20000], [186, 308647, 1, 20000], [171, 308647, 5, 20000], [156, 308647, 10, 20000], [151, 308647, 15, 20000], [151, 308647, 17, 20000], [151, 308647, 18, 20000], [145, 308647, 20, 20000], [134, 308647, 25, 20000], [129, 308647, 30, 20000],
    [207, 286601, 0, 20000], [181, 286601, 1, 20000], [167, 286601, 5, 20000], [152, 286601, 10, 20000], [146, 286601, 15, 20000], [146, 286601, 17, 20000], [146, 286601, 18, 20000], [140, 286601, 20, 20000], [128, 286601, 25, 20000], [125, 286601, 30, 20000],
    [203, 264555, 0, 20000], [177, 264555, 1, 20000], [163, 264555, 5, 20000], [148, 264555, 10, 20000], [143, 264555, 15, 20000], [143, 264555, 17, 20000], [143, 264555, 18, 20000], [136, 264555, 20, 20000], [123, 264555, 25, 20000], [122, 264555, 30, 20000],
]);
/** Holding Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B787SpeedData.holding_speeds = new LerpLookupTable([
    [258, 617295, 0, 1500], [258, 617295, 0, 5000], [258, 617295, 0, 10000], [260, 617295, 0, 15000], [277, 617295, 0, 20000], [290, 617295, 0, 25000], [294, 617295, 0, 30000],
    [258, 573202, 0, 1500], [258, 573202, 0, 5000], [258, 573202, 0, 10000], [259, 573202, 0, 15000], [260, 573202, 0, 20000], [279, 573202, 0, 25000], [282, 573202, 0, 30000], [287, 573202, 0, 35000],
    [258, 529110, 0, 1500], [258, 529110, 0, 5000], [258, 529110, 0, 10000], [258, 529110, 0, 15000], [259, 529110, 0, 20000], [263, 529110, 0, 25000], [270, 529110, 0, 30000], [275, 529110, 0, 35000],
    [246, 485017, 0, 1500], [246, 485017, 0, 5000], [246, 485017, 0, 10000], [246, 485017, 0, 15000], [247, 485017, 0, 20000], [247, 485017, 0, 25000], [258, 485017, 0, 30000], [262, 485017, 0, 35000],
    [234, 440925, 0, 1500], [234, 440925, 0, 5000], [234, 440925, 0, 10000], [234, 440925, 0, 15000], [234, 440925, 0, 20000], [234, 440925, 0, 25000], [244, 440925, 0, 30000], [248, 440925, 0, 35000], [253, 440925, 0, 40000],
    [227, 396832, 0, 1500], [227, 396832, 0, 5000], [228, 396832, 0, 10000], [229, 396832, 0, 15000], [229, 396832, 0, 20000], [230, 396832, 0, 25000], [230, 396832, 0, 30000], [235, 396832, 0, 35000], [238, 396832, 0, 40000], [239, 396832, 0, 41000],
    [218, 352740, 0, 1500], [219, 352740, 0, 5000], [219, 352740, 0, 10000], [220, 352740, 0, 15000], [220, 352740, 0, 20000], [221, 352740, 0, 25000], [221, 352740, 0, 30000], [221, 352740, 0, 35000], [223, 352740, 0, 40000], [224, 352740, 0, 41000],
    [209, 308647, 0, 1500], [210, 308647, 0, 5000], [210, 308647, 0, 10000], [210, 308647, 0, 15000], [211, 308647, 0, 20000], [211, 308647, 0, 25000], [211, 308647, 0, 30000], [211, 308647, 0, 35000], [211, 308647, 0, 40000], [211, 308647, 0, 41000],
    [202, 264555, 0, 1500], [202, 264555, 0, 5000], [202, 264555, 0, 10000], [203, 264555, 0, 15000], [203, 264555, 0, 20000], [203, 264555, 0, 25000], [203, 264555, 0, 30000], [203, 264555, 0, 35000], [203, 264555, 0, 40000], [203, 264555, 0, 41000],
    [238, 617294, 1, 1500], [238, 617294, 1, 5000], [238, 617294, 1, 10000], [238, 617294, 1, 15000], [239, 617294, 1, 20000],
    [238, 573202, 1, 1500], [238, 573202, 1, 5000], [238, 573202, 1, 10000], [238, 573202, 1, 15000], [239, 573202, 1, 20000],
    [237, 529109, 1, 1500], [237, 529109, 1, 5000], [238, 529109, 1, 10000], [238, 529109, 1, 15000], [239, 529109, 1, 20000],
    [228, 485017, 1, 1500], [228, 485017, 1, 5000], [229, 485017, 1, 10000], [230, 485017, 1, 15000], [232, 485017, 1, 20000],
    [217, 440925, 1, 1500], [217, 440925, 1, 5000], [218, 440925, 1, 10000], [219, 440925, 1, 15000], [221, 440925, 1, 20000],
    [206, 396832, 1, 1500], [206, 396832, 1, 5000], [207, 396832, 1, 10000], [208, 396832, 1, 15000], [209, 396832, 1, 20000],
    [194, 352740, 1, 1500], [194, 352740, 1, 5000], [195, 352740, 1, 10000], [195, 352740, 1, 15000], [196, 352740, 1, 20000],
    [184, 308647, 1, 1500], [184, 308647, 1, 5000], [184, 308647, 1, 10000], [185, 308647, 1, 15000], [186, 308647, 1, 20000],
    [177, 264555, 1, 1500], [177, 264555, 1, 5000], [177, 264555, 1, 10000], [177, 264555, 1, 15000], [177, 264555, 1, 20000],
]);
/** Vref data for Zp=14000 ft, speed [kcas], weight [lb], flap position => lookup key = (weight, flap) */
B787SpeedData.vref14k = new LerpLookupTable([
    [176, 573202, 30], [183, 573202, 25], [183, 573202, 20],
    [172, 551156, 30], [79, 551156, 25], [179, 551156, 20],
    [169, 529110, 30], [175, 529110, 25], [175, 529110, 20],
    [165, 507064, 30], [171, 507064, 25], [171, 507064, 20],
    [161, 485017, 30], [167, 485017, 25], [167, 485017, 20],
    [157, 462971, 30], [163, 462971, 25], [163, 462971, 20],
    [154, 440925, 30], [160, 440925, 25], [160, 440925, 20],
    [152, 418879, 30], [157, 418879, 25], [157, 418879, 20],
    [147, 396832, 30], [153, 396832, 25], [153, 396832, 20],
    [143, 374786, 30], [148, 374786, 25], [148, 374786, 20],
    [138, 352740, 30], [143, 352740, 25], [143, 352740, 20],
    [134, 330694, 30], [138, 330694, 25], [138, 330694, 20],
    [129, 308647, 30], [133, 308647, 25], [133, 308647, 20],
    [125, 286601, 30], [128, 286601, 25], [128, 286601, 20],
    [121, 264555, 30], [122, 264555, 25], [122, 264555, 20],
]);

/**
 * A Boeing 787 air data reference system (ADRS).
 */
class B787Adrs {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param sourceSelectSide The system source select side that determines which AIR DATA/ATT selector knob controls
     * this system's selection logic.
     */
    constructor(bus, sourceSelectSide) {
        this.bus = bus;
        this.sourceSelectSide = sourceSelectSide;
        // index 1: primary ADCs (1-3 combined)
        // index 2: backup airspeed system
        // index 3: backup altitude system
        // index 4: ISFD air data system
        this.airspeedCandidates = SetSubject.create([1, 2, 4]);
        this.altitudeCandidates = SetSubject.create([1, 3, 4]);
        this.airspeedSelector = new AdcSystemSelector(1, this.bus, this.airspeedCandidates, [1, 2, 4], 'airspeed-only');
        this.altitudeSelector = new AdcSystemSelector(2, this.bus, this.altitudeCandidates, [1, 3, 4], 'altitude-only');
        this.isInit = false;
    }
    /**
     * Initializes this system. Once initialized, this system will automatically select the best ADCs for airspeed and
     * altitude data among its candidates.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.bus.getSubscriber()
            .on(`b78_air_data_att_source_knob_state_${this.sourceSelectSide === 'right' ? 2 : 1}`)
            .handle(state => {
            if (state === AirDataAttSourceKnobState.Alternate) {
                this.airspeedCandidates.toggle(1, false);
                this.altitudeCandidates.toggle(1, false);
            }
            else {
                this.airspeedCandidates.toggle(1, true);
                this.altitudeCandidates.toggle(1, true);
            }
        });
        this.airspeedSelector.init();
        this.altitudeSelector.init();
    }
}

/**
 * A Boeing 787 backup airspeed system. Provides backup airspeed data from angle-of-attack and inertial inputs.
 */
class B787BackupAirspeedSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of B787BackupAirspeedSystem.
     * @param index The index of the system.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this system derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, airspeedIndicatorIndex, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.airspeedIndicatorIndex = airspeedIndicatorIndex;
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_ias_${this.index}`]: `ias_${this.airspeedIndicatorIndex}`,
            [`adc_tas_${this.index}`]: `tas_${this.airspeedIndicatorIndex}`,
            [`adc_mach_to_kias_factor_${this.index}`]: `mach_to_kias_factor_${this.airspeedIndicatorIndex}`,
            [`adc_mach_number_${this.index}`]: 'mach_number'
        };
        this.invalidDataTopics = {
            [`adc_indicated_alt_${this.index}`]: 0,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: 1013.2,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: 16212,
            [`adc_altimeter_baro_is_std_${this.index}`]: false,
            [`adc_pressure_alt_${this.index}`]: 0,
            [`adc_vertical_speed_${this.index}`]: 0,
            [`adc_ambient_density_${this.index}`]: 0,
            [`adc_ambient_temp_c_${this.index}`]: 0,
            [`adc_ambient_pressure_inhg_${this.index}`]: 0,
            [`adc_isa_temp_c_${this.index}`]: 0,
            [`adc_ram_air_temp_c_${this.index}`]: 0
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.isInertialDataValid = ConsumerSubject.create(null, true);
        this.aoaSystemState1 = ConsumerSubject.create(null, undefined);
        this.aoaSystemState2 = ConsumerSubject.create(null, undefined);
        this.scheduleUpdateFailedState = () => { this.needUpdateFailedState = true; };
        this.needUpdateFailedState = true;
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, true, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, false, false, false);
        const sub = bus.getSubscriber();
        this.isInertialDataValid.setConsumer(sub.on('irs_selector_inertial_data_valid_1'));
        this.aoaSystemState1.setConsumer(sub.on('aoa_state_1'));
        this.aoaSystemState2.setConsumer(sub.on('aoa_state_2'));
        this.isInertialDataValid.sub(this.scheduleUpdateFailedState);
        this.aoaSystemState1.sub(this.scheduleUpdateFailedState);
        this.aoaSystemState2.sub(this.scheduleUpdateFailedState);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing airspeed data on the event bus.
     */
    startDataPublish() {
        // Publish default values for all non-airspeed topics.
        for (const topic in this.invalidDataTopics) {
            this.publisher.pub(topic, this.invalidDataTopics[topic], false, true);
        }
        for (const topic in this.dataSourceTopicMap) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.needUpdateFailedState = true;
            }
            else {
                this.setState(AvionicsSystemState.Off);
                this.needUpdateFailedState = false;
            }
        }
        else {
            this.needUpdateFailedState = false;
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(this.scheduleUpdateFailedState, this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.speedDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.speedDataValidTopic, false, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        var _a, _b;
        super.onUpdate();
        if (this.isPowerValid && this.needUpdateFailedState) {
            const aoaSystemState1 = (_a = this.aoaSystemState1.get()) === null || _a === void 0 ? void 0 : _a.current;
            const aoaSystemState2 = (_b = this.aoaSystemState2.get()) === null || _b === void 0 ? void 0 : _b.current;
            if (((aoaSystemState1 === undefined || aoaSystemState1 === AvionicsSystemState.On)
                || (aoaSystemState2 === undefined || aoaSystemState2 === AvionicsSystemState.On))
                && this.isInertialDataValid.get()) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Failed);
            }
            this.needUpdateFailedState = false;
        }
    }
}

/**
 * A Boeing 787 backup altitude system. Provides backup altitude data from GPS inputs.
 */
class B787BackupAltitudeSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of B787BackupAltitudeSystem.
     * @param index The index of the system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_vertical_speed_${this.index}`]: 'vertical_speed'
        };
        this.altitudeTopics = [
            `adc_indicated_alt_${this.index}`,
            `adc_pressure_alt_${this.index}`
        ];
        this.invalidDataTopics = {
            [`adc_ias_${this.index}`]: 0,
            [`adc_tas_${this.index}`]: 0,
            [`adc_mach_to_kias_factor_${this.index}`]: UnitType.MPS.convertTo(AeroMath.SOUND_SPEED_SEA_LEVEL_ISA, UnitType.KNOT),
            [`adc_mach_number_${this.index}`]: 0,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: 1013.2,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: 16212,
            [`adc_altimeter_baro_is_std_${this.index}`]: false,
            [`adc_ambient_density_${this.index}`]: 0,
            [`adc_ambient_temp_c_${this.index}`]: 0,
            [`adc_ambient_pressure_inhg_${this.index}`]: 0,
            [`adc_isa_temp_c_${this.index}`]: 0,
            [`adc_ram_air_temp_c_${this.index}`]: 0
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.gpsReceiverSystemState1 = ConsumerSubject.create(null, undefined);
        this.gpsReceiverSystemState2 = ConsumerSubject.create(null, undefined);
        this.scheduleUpdateFailedState = () => { this.needUpdateFailedState = true; };
        this.needUpdateFailedState = true;
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, false, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, true, false, false);
        const sub = bus.getSubscriber();
        this.gpsReceiverSystemState1.setConsumer(sub.on('gps_rec_state_1'));
        this.gpsReceiverSystemState2.setConsumer(sub.on('gps_rec_state_2'));
        this.gpsReceiverSystemState1.sub(this.scheduleUpdateFailedState);
        this.gpsReceiverSystemState2.sub(this.scheduleUpdateFailedState);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing altitude data on the event bus.
     */
    startDataPublish() {
        // Publish default values for all non-altitude topics.
        for (const topic in this.invalidDataTopics) {
            this.publisher.pub(topic, this.invalidDataTopics[topic], false, true);
        }
        for (const topic in this.dataSourceTopicMap) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        for (const topic of this.altitudeTopics) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap || this.altitudeTopics.includes(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        if (topic in this.dataSourceTopicMap) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, true);
            }, paused));
        }
        else {
            this.dataSubs.push(this.dataSourceSubscriber.on('gps-position').handle(lla => {
                this.publisher.pub(topic, UnitType.METER.convertTo(lla.alt, UnitType.FOOT), false, true);
            }, paused));
        }
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.needUpdateFailedState = true;
            }
            else {
                this.setState(AvionicsSystemState.Off);
                this.needUpdateFailedState = false;
            }
        }
        else {
            this.needUpdateFailedState = false;
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(this.scheduleUpdateFailedState, this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.altitudeDataValidTopic, false, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        var _a, _b;
        super.onUpdate();
        if (this.isPowerValid && this.needUpdateFailedState) {
            const gpsReceiverSystemState1 = (_a = this.gpsReceiverSystemState1.get()) === null || _a === void 0 ? void 0 : _a.current;
            const gpsReceiverSystemState2 = (_b = this.gpsReceiverSystemState2.get()) === null || _b === void 0 ? void 0 : _b.current;
            if ((gpsReceiverSystemState1 === undefined || gpsReceiverSystemState1 === AvionicsSystemState.On)
                || (gpsReceiverSystemState2 === undefined || gpsReceiverSystemState2 === AvionicsSystemState.On)) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Failed);
            }
            this.needUpdateFailedState = false;
        }
    }
}

/**
 * A TCAS II implementation for the B787.
 */
class B787TCAS extends BoeingTCAS {
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/// <reference types="@microsoft/msfs-types/js/radionav" />
/**
 * A common instrument for the B787-10 displays.
 */
class WTB78xFsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        this.instrument = instrument;
        this.config = config;
        this.isInstrumentPowered = false;
        this.isPowerValid = false;
        this.isPowered = undefined;
        this.bus = new EventBus();
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.hEventPublisher = new HEventPublisher(this.bus);
        this.flightPathCalculator = new FlightPathCalculator(this.facLoader, {
            defaultClimbRate: 2000,
            defaultSpeed: 180,
            bankAngle: BoeingFlightPathUtils.flightPathBankAngleTable,
            holdBankAngle: null,
            courseReversalBankAngle: null,
            turnAnticipationBankAngle: null,
            maxBankAngle: 25,
            airplaneSpeedMode: FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
        }, this.bus);
        this.flightPlanner = FlightPlanner.getPlanner(this.bus, this.flightPathCalculator, BoeingFmsUtils.buildBoeingLegName);
        this.perfPlanRepository = new PerformancePlanRepository(this.flightPlanner, this.bus);
        this.activeRoutePerformancePlan = this.perfPlanRepository.getActivePlan();
        this.performanceMath = new B787PerformanceMath();
        this.pathPerformanceProvider = new DefaultBoeingPathPerformanceProvider(this.performanceMath);
        this.engineDataProvider = new B787EngineData(this.bus, this.performanceMath);
        this.speedData = new B787SpeedData(this.bus, this.engineDataProvider);
        /** Handles wind and temperature entries and propagation for climb, cruise, and descent */
        this.windPlanner = new InterpolatingWindPlanner(this.bus, this.flightPlanner, {
            numberOfClimbAltitudes: 9,
            numberOfDescentAltitudes: 9,
            numberOfLegAltitudes: 4,
        });
        this.verticalPathCalculator = new BoeingPathCalculator(this.bus, this.flightPlanner, BoeingFlightPlans.ACT_RTE_PLAN_INDEX, this.pathPerformanceProvider, this.engineDataProvider, this.speedData, this.perfPlanRepository, this.windPlanner, this.getVerticalPathCalculatorOptions());
        this.activeRoutePredictor = new BoeingFlightPlanPredictionsProvider(this.bus, 1, BoeingFlightPlans.ACT_RTE_PLAN_INDEX, 1000, this.flightPlanner, this.windPlanner, this.verticalPathCalculator, this.perfPlanRepository, this.pathPerformanceProvider, this.facLoader);
        this.backplane = new InstrumentBackplane();
        this.clock = new Clock(this.bus);
        this.baseInstrumentPublisher = new BaseInstrumentPublisher(this.instrument, this.bus);
        this.ambientPublisher = new AmbientPublisher(this.bus);
        this.gnssPublisher = new GNSSPublisher(this.bus);
        this.adcPublisher = new AdcPublisher(this.bus);
        this.ahrsPublisher = new AhrsPublisher(this.bus);
        this.boeingApPublisher = new BoeingAPSimVarPublisher(this.bus);
        this.lNavPublisher = new LNavSimVarPublisher(this.bus);
        this.lNavDataPublisher = new BoeingLNavDataSimVarPublisher(this.bus);
        this.vNavPublisher = new VNavSimVarPublisher(this.bus);
        this.boeingVNavPublisher = new BoeingVNavSimVarPublisher(this.bus);
        this.navComSimVarPublisher = new NavComSimVarPublisher(this.bus);
        this.cockpitVarsPublisher = new CockpitVarsPublisher(this.bus);
        this.electricalPublisher = new ElectricalPublisher(this.bus);
        this.eisPublisher = new EISPublisher(this.bus);
        this.trafficInstrument = new TrafficInstrument(this.bus, { realTimeUpdateFreq: 2, simTimeUpdateFreq: 1, contactDeprecateTime: 10 });
        this.weightAndBalancePublisher = new WeightBalanceSimvarPublisher(this.bus);
        this.fuelSystemPublisher = new FuelSystemSimVarPublisher(this.bus);
        this.tcas = new B787TCAS(this.bus, this.trafficInstrument, 40, 2, 1);
        this.gameUnitsPublisher = new BoeingGameUnitsPublisher(this.bus);
        this.xpdrInstrument = new XPDRInstrument(this.bus);
        this.brakesPublisher = new BrakeSimvarPublisher(this.bus);
        this.timerPublisher = new FlightTimerPublisher(this.bus, 2);
        this.aiPilotPublisher = new AiPilotPublisher(this.bus);
        this.fmsOperatingPhasePublisher = new FmsOperatingPhasePublisher(this.bus);
        this.irsSystemGroupStatusPublisher = new IrsSystemGroupStatusPublisher(this.bus, 2);
        // TODO check placard speeds are correct for -9 (from flight_model.cfg)
        // -9 is 260, 240, 230, *220*, *215*, 215, 210, 190, 180
        this.flapConfig = {
            flap_positions: [
                { label: 0, flapAngle: 0, slatAngle: 0, speedLimit: Infinity },
                { label: 1, flapAngle: 0, slatAngle: 15, speedLimit: 260 },
                { label: 5, flapAngle: 5, slatAngle: 15.572958, speedLimit: 240 },
                { label: 10, flapAngle: 10, slatAngle: 16.145916, speedLimit: 230 },
                { label: 15, flapAngle: 15, slatAngle: 16.718873, speedLimit: 225 },
                { label: 17, flapAngle: 17, slatAngle: 17.291831, speedLimit: 220 },
                { label: 18, flapAngle: 18, slatAngle: 17.864789, speedLimit: 215 },
                { label: 20, flapAngle: 20, slatAngle: 18.437747, speedLimit: 210 },
                { label: 25, flapAngle: 20, slatAngle: 31, speedLimit: 190 },
                { label: 30, flapAngle: 30, slatAngle: 31.572958, speedLimit: 180 },
            ],
            speed_data: this.speedData,
        };
        this.flapComputer = new FlapComputer(this.bus, this.flapConfig);
        /** Videos show the radio altimeter at about [-8, -4] on the ground,
         * the RADIO HEIGHT simvar is about +13 feet(+15 feet in -10), so we use offset of -19(-21 in -10). */
        this.radioAltimeterOffset = -21;
        this.apInstrument = new AutopilotInstrument(this.bus);
        this.apRadioNavInstrument = new APRadioNavInstrument(this.bus);
        this.systems = [];
        this.sourceSelectSide = this.getSourceSelectSide();
        this.adrs = new B787Adrs(this.bus, this.sourceSelectSide);
        this.irsSystemSelector = new IrsSystemSelector(1, this.bus, [1, 2], [1, 2]);
        /** Whether this instrument has started updating. */
        this.haveUpdatesStarted = false;
        this.backplane.addInstrument(InstrumentBackplaneNames.Clock, this.clock);
        this.backplane.addInstrument(InstrumentBackplaneNames.Autopilot, this.apInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.AutopilotRadioNav, this.apRadioNavInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Traffic, this.trafficInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Xpdr, this.xpdrInstrument);
        this.backplane.addPublisher(InstrumentBackplaneNames.Base, this.baseInstrumentPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ambient, this.ambientPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Brakes, this.brakesPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.HEvents, this.hEventPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Adc, this.adcPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ahrs, this.ahrsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Gnss, this.gnssPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingAutopilot, this.boeingApPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNav, this.lNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNavData, this.lNavDataPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.VNav, this.vNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingVNav, this.boeingVNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.NavCom, this.navComSimVarPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.CockpitVars, this.cockpitVarsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Electrical, this.electricalPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Eis, this.eisPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.WeightAndBalance, this.weightAndBalancePublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Units, this.gameUnitsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.FuelSystem, this.fuelSystemPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Timer, this.timerPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ai, this.aiPilotPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.FmsOperatingPhase, this.fmsOperatingPhasePublisher);
        this.tcas.init();
        // force enable animations
        document.documentElement.classList.add('animationsEnabled');
        // Wait until game has entered briefing or in-game mode before initializing the avionics status client. This
        // ensures that we do not publish any statuses based on erroneous power states.
        Wait.awaitSubscribable(GameStateProvider.get(), gameState => gameState === GameState.briefing || gameState === GameState.ingame, true).then(async () => {
            this.isPowerValid = true;
            // Wait until updates have started before initializing the power state because instrument power is not
            // initialized until the first update.
            await Wait.awaitCondition(() => this.haveUpdatesStarted);
            if (this.isPowered === undefined) {
                this.isPowered = this.isInstrumentPowered;
                this.onPowerChanged(this.isPowered, undefined);
            }
        });
    }
    /**
     * Gets configuration options for the vertical path calculator.
     * @returns Configuration options for the vertical path calculator.
     */
    getVerticalPathCalculatorOptions() {
        return undefined;
    }
    /**
     * Whether to locally calculate predictions
     *
     * @returns a boolean
     */
    getLocallyCalculatePredictions() {
        return false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSoundEnd(soundEventId) {
        // noop
    }
    /** @inheritdoc */
    Update() {
        this.haveUpdatesStarted = true;
        this.backplane.onUpdate();
        this.updateSystems();
    }
    /**
     * Updates this instrument's systems.
     */
    updateSystems() {
        for (let i = 0; i < this.systems.length; i++) {
            this.systems[i].onUpdate();
        }
    }
    /**
     * Creates this instrument's avionics systems. This method should be called after `this.iauIndex` has been defined.
     */
    createSystems() {
        // TODO the B787 doesn't have a magnetometer
        const magnetometers = [new MagnetometerSystem(1, this.bus, 'elec_master_battery')];
        // In reality, there are three independent ADCs (pitot-static systems with their own air data modules). However,
        // since we are not fully modeling the electrical system and the sim doesn't model independent ADC failures for
        // other reasons, we will combine all three ADCs into one system (index 1).
        const adcSystems = [
            new AdcSystem(1, this.bus, 1, 1, 'elec_circuit_on_96'),
            new B787BackupAirspeedSystem(2, this.bus, 1, 'elec_circuit_on_95'),
            new B787BackupAltitudeSystem(3, this.bus, 'elec_circuit_on_95'),
            new AdcSystem(4, this.bus, 2, 2, 'elec_circuit_on_99'), // ISFD air data
        ];
        const raSystems = this.config.sensors.radarAltimeterDefinitions.slice(1, this.config.sensors.radarAltimeterCount + 1).map((def, index) => {
            return new RASystem(index + 1, this.bus, this.radioAltimeterOffset, def.electricity);
        });
        const gpsSystems = [1, 2].map(index => new GpsReceiverSystem(index, this.bus, new GPSSatComputer(index, this.bus, 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/Data/gps_ephemeris.json', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/Data/gps_sbas.json', 5000, [], this.instrument.instrumentIndex === 3 ? 'primary' : 'replica')));
        const irsAlignTimeSetting = BoeingMsfsUserSettings.getManager(this.bus).getSetting('boeingMsfsIrsAlignTime');
        const irsAttitudeAndRealignDuration = irsAlignTimeSetting.map(setting => setting === BoeingIrsAlignTimeMode.Instant ? 0 : undefined);
        const irsFullAlignDuration = irsAlignTimeSetting.map(setting => {
            switch (setting) {
                case BoeingIrsAlignTimeMode.Instant:
                    return 0;
                case BoeingIrsAlignTimeMode.Realistic:
                    return undefined;
                default:
                    return 60000;
            }
        });
        const irsSystems = [1, 2].map(index => {
            const modeSetting = ConsumerSubject.create(this.bus.getSubscriber().on(`b78_irs_knob_state_${index}`), IrsKnobState.On)
                .map(state => state === IrsKnobState.Off ? IrsSystemOperatingModeSetting.Off : IrsSystemOperatingModeSetting.Navigation);
            return new IrsSystem(index, this.bus, 1, 1, true, modeSetting, `elec_circuit_on_${96 + index}`, [1, 2], irsAttitudeAndRealignDuration, irsFullAlignDuration, irsAttitudeAndRealignDuration);
        });
        this.gpsReceiverSelector = new GpsReceiverSelector(this.bus, Array.from({ length: this.config.sensors.gpsCount }, (v, index) => index + 1), 1 // Math.min(this.iauIndex, this.config.sensors.gpsCount)
        );
        this.gpsReceiverSelector.init();
        // One FMS geo-positioning system for each PFD (technically IAU)
        const fmsPosSystems = [0].map(index => {
            return new FmsPositionSystem(index + 1, this.bus, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.gpsReceiverSelector.selectedIndex, 1, // pfdSettingManager.getSetting('pfdAdcIndex'),
            1);
        });
        this.systems.push(...magnetometers, ...adcSystems, ...raSystems, ...gpsSystems, ...irsSystems, ...fmsPosSystems, new AoaSystem(1, this.bus, 'elec_master_battery'), new MarkerBeaconSystem(1, this.bus, 'elec_master_battery'));
        this.adrs.init();
        this.irsSystemSelector.init();
        this.activeRoutePredictor.init(this.getLocallyCalculatePredictions());
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        this.hEventPublisher.dispatchHEvent(args[0]);
    }
    /**
     * Attempt to run onFlightStart in case the instrument was reloaded.
     */
    tryRunOnFlightStart() {
        // Only try to start if ingame during the constructor.
        // If not ingame, then user will get a briefing and will eventually trigger onFlightStart.
        if (GameStateProvider.get().get() === GameState.ingame) {
            this.onFlightStart();
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        SimVar.SetSimVarValue('L:WT_Flight_Started', SimVarValueType.Bool, true);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onGameStateChanged(oldState, newState) {
        // TODO
    }
    /**
     * A callback which is executed when this instrument transitions from a power-off to power-on state.
     */
    onPowerOn() {
        this.isInstrumentPowered = true;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = true;
            if (old !== true) {
                this.onPowerChanged(true, old);
            }
        }
    }
    /**
     * A callback which is executed when this instrument transitions from a power-on to power-off state.
     */
    onPowerOff() {
        this.isInstrumentPowered = false;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = false;
            if (old !== false) {
                this.onPowerChanged(false, old);
            }
        }
    }
    /**
     * Responds to when this instrument's power state changes.
     * @param current The current power state.
     * @param previous The previous power state, or `undefined` if the previous state was invalid.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPowerChanged(current, previous) {
        //
    }
}

/**
 * Publisher for {@link B787EfbLVarEvents}
 */
class B787EfbLVarPublisher extends SimVarPublisher {
    /** @inheritDoc */
    constructor(bus) {
        super(new Map([
            ['b787efb_power', { name: 'L:WT_EFB_POWER', type: SimVarValueType.Bool }],
        ]), bus);
        this.bus = bus;
    }
}

/** The B787PerformancePage component. */
class B787PerformancePage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.gameUnitsMetric = ConsumerSubject.create(this.props.bus.getSubscriber().on('game_units_metric'), false);
        this.unit = this.gameUnitsMetric.map((isMetric) => {
            return isMetric ? UnitType.KILOGRAM : UnitType.POUND;
        });
        this.unitString = this.gameUnitsMetric.map((isMetric) => {
            return BoeingUnitUtils.getUnitString(isMetric ? UnitType.KILOGRAM : UnitType.POUND);
        });
        this.atmTextFieldRef = FSComponent.createRef();
        this.windTextFieldRef = FSComponent.createRef();
        this.rwyDropdownRef = FSComponent.createRef();
        this.ArptDropdownRef = FSComponent.createRef();
        this.oatFieldRef = FSComponent.createRef();
        this.progressBarRef = FSComponent.createRef();
        
        this.qnhFieldRef = FSComponent.createRef();
        this.towFieldRef = FSComponent.createRef();
        this.zfwFieldRef = FSComponent.createRef();
        this.cgFieldRef = FSComponent.createRef();
        this.RTGBoxRef = FSComponent.createRef();
        this.ConditionBoxRef = FSComponent.createRef();
        this.FLAPRef = FSComponent.createRef();
        this.AIRef = FSComponent.createRef();
        this.IMCLBRef = FSComponent.createRef();
        this.RWYRef = FSComponent.createRef();
        this.ARPTRef = FSComponent.createRef();
        this.sendOutputButtonRef = FSComponent.createRef();
        this.OutputPageRef = FSComponent.createRef();
        this.bus = new EventBus();
        this.takeoffCalculator = this.props.takeoffCalculator;
        this.runwayList = ArraySubject.create([]);
        this.arptList = ArraySubject.create([]);
        this.aprtName = Subject.create('');
        this.GettingData = Subject.create(null);
        this.pickedRunway = Subject.create(null);
        this.pickedRunwayCondition = Subject.create(null);
        this.pickedOat = Subject.create(null);
        this.pickedTow2 = Subject.create(null);
        this.runwayCondition = Subject.create(null);
        /** QNH in hPa, or null if none. */
        this.pickedQnh = NumberUnitSubject.create(new NumberUnit(0, UnitType.HPA));
        this.typedQnhUnit = Subject.create(UnitType.HPA);
        this.pickedWind = Subject.create(null);
       
        this.pickedTow = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.pickedAtm = Subject.create(null);
        this.pickedZfwKg = Subject.create(null);
        this.pickedCg = Subject.create(null);
        this.pickedFlaps = Subject.create(null);
        this.pickedRtg = Subject.create(null);
        this.pickAiConfig = Subject.create(null);
        this.pickedImClb = Subject.create(null);
        this.atmResults = Subject.create(undefined);
        this.fullResults = Subject.create(undefined);
        this.rtgList = ArraySubject.create([
            EFBTakeoffThrustMode.OPTIMUM,
            EFBTakeoffThrustMode.TO,
            EFBTakeoffThrustMode.TO1,
            EFBTakeoffThrustMode.TO2,
            EFBTakeoffThrustMode.WINDSHEAR,
            EFBTakeoffThrustMode.EXIT,
        ]);
        this.flapList = ArraySubject.create([OptimumRequest.OPTIMUM, 5, 10, 15, 17, 18, 20,OptimumRequest.EXIT]);
        this.aiList = ArraySubject.create([EFBAntiIceSetting.OFF, EFBAntiIceSetting.ENGINE, EFBAntiIceSetting.ENGINE_AUTO,EFBAntiIceSetting.EXIT]);
        this.imClbList = ArraySubject.create(['OPTIMUM', 'NONE', 'EXIT']);
        this.intxList = ArraySubject.create([]);
        this.flapsValue = Subject.create('0');
        this.accelHtValue = Subject.create('0');
        this.rwyValue = Subject.create('0');
        /** Takeoff weight value in the results area. */
        this.togwResultText = Subject.create('0');
        this.takeoffThrustValue = Subject.create('0');
        this.selTempValue = Subject.create('0');
        // FIXME rename (rename css class as well)
        /** Result not available message. */
        this.runwayInformationValue = Subject.create('');
        this.v1SpeedValue = Subject.create('0');
        this.v2SpeedValue = Subject.create('0');
        this.vrSpeedValue = Subject.create('0');
        this.vRefSpeedValue = Subject.create('0');
        this.efbThrustModeText = Subject.create(null);
        this.isResultPerfCalculation = Subject.create(false);
        this.isResultAvailable = Subject.create(false);
        this.condList = ArraySubject.create([
            EfbRunwayCondition.DRY,
            EfbRunwayCondition.WET,
            EfbRunwayCondition.STNDNG_WTR,
            EfbRunwayCondition.SLUSH,
            EfbRunwayCondition.CMPCT_SNOW,
            EfbRunwayCondition.DRY_SNOW,
            // EfbRunwayCondition.WET_SNOW,
            EfbRunwayCondition.ICE,
            EfbRunwayCondition.GOOD,
            EfbRunwayCondition.MEDIUM,
            EfbRunwayCondition.POOR,
            EfbRunwayCondition.EXIT,
        ]);
        this.selTempTextAreaRef = FSComponent.createRef();
        this.nameAndEngineRef = FSComponent.createRef();
        this.v1TextAreaValueRef = FSComponent.createRef();
        this.vrTextAreaValueRef = FSComponent.createRef();
        this.v2TextAreaValueRef = FSComponent.createRef();
        this.vrefTextAreaValueRef = FSComponent.createRef();
        this.activeSetting = Subject.create(textAreaSetting.Atm);
        this.isFullSettingActive = this.activeSetting.map(x => x === textAreaSetting.Full);
        this.isAtmSettingActive = this.activeSetting.map(x => x === textAreaSetting.Atm);
        this.isAtmSettingDisabled = this.atmResults.map(x => x === undefined);
        this.textAreaSettingRef = FSComponent.createRef();
        this.textAreaSettingButtonsRefs = FSComponent.createRef();
        this.textAreaSetting = this.activeSetting.map((method) => method === textAreaSetting.Atm ? 'ATM' : 'FULL');
        this.textAreaContentsRef = FSComponent.createRef();
        this.calculationAllowed = MappedSubject.create(
            (inputs) => inputs.every((v) => v !== null), 
            this.pickedQnh, 
            this.pickedOat, 
            this.pickedWind, 
            this.pickedFlaps, 
            this.pickedRtg, 
            this.pickAiConfig, 
            this.pickedRunway, 
            this.pickedRunwayCondition, 
            this.pickedImClb, 
            this.pickedAtm,
            this.pickedTow2,
            
           
        );
        
                this.sendDataDisabled = Subject.create(true);
        // RTOW requirements are a subset of perf requirements so we can always calculate when RTOW is possible
        
        this.calcDataDisabled = this.calculationAllowed.map((v) => !v);
        this.arptListGreenOutline = Subject.create(false);
        this.OATGreenOutline = Subject.create(false);
        this.QNHGreenOutline = Subject.create(false);
        this.TOWGreenOutline = Subject.create(false);
        this.ZFWGreenOutline = Subject.create(false);
        this.rwyListGreenOutline = Subject.create(false);
        this.isProgressBarVisible = Subject.create(false);
        this.flightButtonDisabled = Subject.create(false);
        this.arptinfobuttondisabled = Subject.create(true);
        this.MELinfobuttondisabled = Subject.create(true);
        this.RwyDisabled = Subject.create(true);
        this.RwyArrow = Subject.create(false);
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        this.props.visible.sub((visible) => {
            this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
        }, true);
        this.subscriptions = [
            this.DetectInput.call(this, this.aprtName, 'ARPT'),
            this.DetectInput.call(this, this.pickedRunway, 'RWY'),
            this.DetectInput.call(this, this.pickedOat, 'OAT'),
            this.DetectInput.call(this, this.pickedQnh, 'QNH'),
            this.DetectInput.call(this, this.pickedTow, 'TOW'),
            this.DetectInput.call(this, this.pickedZfwKg, 'ZFW'),
 
        ];
        this.props.store.flightInitializationDataAcceptedEvent.on(this.initializeData.bind(this));
        this.props.store.GreenOutlineHandler.on(this.GreenOutline.bind(this));
        this.unit.sub(() => this.handleGameUnitsChanged());
        this.unitString.sub(() => this.handleGameUnitsChanged());
        this.isResultAvailable.sub(this.showDataInTextArea.bind(this));
        this.activeSetting.sub(this.showDataInTextArea.bind(this));
        // default ATM to MAX here. subject is a number so can't use valueOnStartup on the field
        this.atmTextFieldRef.instance.typeValue('MAX');
    }
    handleInputDetection(inputType, newValue) {
        if (newValue) {
            
            
            const inputs = {
                'ARPT': this.arptListGreenOutline, 'RWY': this.rwyListGreenOutline, 'OAT': this.OATGreenOutline, 'QNH': this.QNHGreenOutline, 'TOW': this.TOWGreenOutline,'ZFW': this.ZFWGreenOutline
            };
            const Picked = {
                'ARPT': this.aprtName, 'RWY': this.pickedRunway, 'OAT': this.pickedOat, 'QNH': this.pickedQnh, 'TOW': this.pickedTow,'ZFW': this.pickedZfwKg
            };
            for (const key in inputs) {
                if (key == inputType) {
                    const DataCheck = this.GettingData.get();
                    if (DataCheck== false){
                        inputs[key].set(false);
                    }
                   
                      
                    
                  
                }
            }
        }
    }
    DetectInput(input, inputType) {
        return input.sub(this.handleInputDetection.bind(this, inputType), true);
    }


    /**
     * Handles the user pressing the CALC button
     */
    handleCalculateButton() {
        
        if (this.calculationAllowed.get()) {
            // clear the textfield and show the text area if its possible
            this.runwayInformationValue.set('');
            this.hideDataInTextArea();
        const toRunway = this.pickedRunway.get();
        
        const toRunwayCondition = this.pickedRunwayCondition.get();
        const toWind = this.pickedWind.get();
        const toOat = this.pickedOat.get();
        const toQnh = this.pickedQnh.get().asUnit(UnitType.HPA);
        const toTow = this.pickedTow.get().asUnit(UnitType.POUND);
        const toAtm = this.pickedAtm.get();
        const toFlaps = this.pickedFlaps.get();
        const toRtg = this.pickedRtg.get();
        const toAi = this.pickAiConfig.get();
        const toImClb = this.pickedImClb.get();
        this.disableEverything(); // After reading the fields, because we need to fetch the field state for the tow field unaltered!
        // TODO ugggh annoying to validate these again
        if (toRunway === null || toRunwayCondition === null || toWind === null || toOat === null || toQnh === null
            || toAtm === null || toFlaps === null || toRtg === null || toAi === null || toImClb === null) {
            return;
        }
        const runwayMagneticCourse = MagVar.trueToMagnetic(toRunway.course, toRunway.latitude, toRunway.longitude);
        // Make the progress bar ready and call the calculation:
        this.progressBarRef.instance.resetProgressBar();
        this.isProgressBarVisible.set(true);
        this.simulateProgressBar().then(() => {
            const results = this.takeoffCalculator.getTakeoffPerformanceData(toRunway, toRunwayCondition, Number.isFinite(toWind.direction) ? toWind.direction : runwayMagneticCourse, toWind.speed, toOat, toQnh, toRtg, toAtm, toFlaps, toAi, toTow);
            const atmResult = results.find(result => result.resultMode === EFBTakeoffCalculationMode.ATM);
            const fullResult = results.find(result => result.resultMode === EFBTakeoffCalculationMode.FULL);
            this.atmResults.set(atmResult);
            this.fullResults.set(fullResult);
            if (atmResult !== undefined) {
            this.isResultPerfCalculation.set(true);
                            this.activeSetting.set(textAreaSetting.Atm);
                this.displayResults(atmResult);
            }
            else if (fullResult) {
                this.isResultPerfCalculation.set(true);
                this.activeSetting.set(textAreaSetting.Full);
                this.displayResults(fullResult);
            }
        else {
        // At this point, results should only contain a RTOW result:
                const rtowResult = results.find(result => result.resultMode === EFBTakeoffCalculationMode.RTOW);
                if (rtowResult !== undefined) {
                    this.isResultPerfCalculation.set(false);
                this.displayResults(rtowResult);
                }
            }
        });
    }
}
    /**
     * Displays calculation results in the bottom section
     *
     * @param calculatedData the calculated data
     */
    displayResults(calculatedData) {
        if (calculatedData) {
        var _a;
        const toRunway = this.pickedRunway.get();
        const toRtg = this.pickedRtg.get();
        const toOat = this.pickedOat.get();
        if (toRunway === null || toRtg === null || toOat === null) {
            return;
        }
        const { isPossible, maxTakeoffWeightOut, thrustRatingOut, flapSettingOut, assumedTemperatureOut, v1Out, vrOut, v2Out, } = calculatedData;
        if (!isPossible) {
            // if the calc is not possible it will report it in the inforamtion field
            this.hideDataInTextArea();
            if (this.activeSetting.get() === textAreaSetting.Atm && calculatedData.resultMode !== EFBTakeoffCalculationMode.RTOW) {
                this.runwayInformationValue.set('No valid assumed temp found for these conditions. No assumed temp allowed.');
            }
            else {
                this.runwayInformationValue.set('No takeoff allowed. Planned weight exceeds max allowable weight of ' + Math.trunc(UnitType.POUND.convertTo(maxTakeoffWeightOut, this.unit.get())) + ' ' + this.unitString.get() + '.');
            }
            this.sendDataDisabled.set(true);
            this.textAreaSettingRef.instance.classList.remove('hidden');
        }
        else {
            this.runwayInformationValue.set('');
            this.sendDataDisabled.set(false);
            const accelAlt = UnitType.FOOT.convertFrom(toRunway.elevation, UnitType.METER) + this.props.activePerformancePlan.takeoffAccelerationHeight.get();
            this.accelHtValue.set(`${Math.round(accelAlt)} ft MSL`);
            this.props.activePerformancePlan.takeoffFlaps.get();
            if (this.pickedFlaps !== null) {
                if (this.pickedFlaps.get() === OptimumRequest.OPTIMUM) {
                    this.flapsValue.set(flapSettingOut + '');
                }
                else {
                    this.flapsValue.set(this.pickedFlaps.get() + '');
                }
            }
            // truncate so the RTOW calculation result can always get a result when entered back into the calculator
            this.togwResultText.set(`${Math.trunc(UnitType.POUND.convertTo(maxTakeoffWeightOut, this.unit.get()))} ${this.unitString.get()}`);
            // set the button on the right menu bar
            this.progressBarRef.instance.setBarInfo((_a = this.pickedRunway.get()) === null || _a === void 0 ? void 0 : _a.designation, this.togwResultText.get());
            this.v1SpeedValue.set(v1Out !== undefined ? (v1Out + ' KT') : '');
            this.v2SpeedValue.set(v2Out !== undefined ? (v2Out + ' KT') : '');
            this.vrSpeedValue.set(vrOut !== undefined ? (vrOut + ' KT') : '');
            if (assumedTemperatureOut !== 0) {
                this.selTempValue.set(assumedTemperatureOut + ' C');
            }
            //default value for the QNH if nothing is entered
            const qnh = this.pickedQnh.get().asUnit(UnitType.HPA);
            const qnhValue = Number.isFinite(qnh) ? qnh : 1013.25;
            const pressureAlt = UnitType.FOOT.convertFrom(toRunway.elevation + AeroMath.baroPressureAltitudeOffset(qnhValue), UnitType.METER);
            this.rwyValue.set(toRunway.designation);
            this.vRefSpeedValue.set(Math.round(this.props.speedDataProvider.getVrefSpeed(30, maxTakeoffWeightOut, pressureAlt)) + ' KT');
            let thrustRating;
            switch (thrustRatingOut) {
                default:
                case EFBTakeoffThrustMode.TO:
                    thrustRating = TakeoffThrustMode.TO;
                    break;
                case EFBTakeoffThrustMode.TO1:
                    thrustRating = TakeoffThrustMode.TO1;
                    break;
                case EFBTakeoffThrustMode.TO2:
                    thrustRating = TakeoffThrustMode.TO2;
                    break;
            }
            if (this.pickedRtg !== null) {
                switch (toRtg) {
                    case EFBTakeoffThrustMode.OPTIMUM:
                        this.setRtg(thrustRating, toOat, assumedTemperatureOut, toRunway);
                        break;
                    case EFBTakeoffThrustMode.TO:
                        this.setRtg(TakeoffThrustMode.TO, toOat, assumedTemperatureOut, toRunway);
                        break;
                    case EFBTakeoffThrustMode.TO1:
                        this.setRtg(TakeoffThrustMode.TO1, toOat, assumedTemperatureOut, toRunway);
                        break;
                    case EFBTakeoffThrustMode.TO2:
                        this.setRtg(TakeoffThrustMode.TO2, toOat, assumedTemperatureOut, toRunway);
                        break;
                }
            }
            this.isResultAvailable.set(true);
        }
        }
        else {
           
           
            this.hideDataInTextArea();
            
            this.sendDataDisabled.set(true);
           this.textAreaSettingRef.instance.classList.remove('hidden');
          //      this.runwayInformationValue.set('');
                
              
               this.isResultAvailable.set(false);
            
        }
    }
    /**
     * Simulates the progress bar filling up, and resolves when complete.
     */
    simulateProgressBar() {
        return new Promise((resolve) => {
            for (let i = 0; i <= 11; i++) {
                setTimeout(() => {
                    if (i <= 10) {
                        this.progressBarRef.instance.update(i * 10);
                    }
                    if (i === 11) {
                        resolve();
                    }
                }, 200 * i);
            }
        });
    }
    /**
     * Handles the user pressing the CALC button
     */
    sendPerfDataToFMC() {
        const togw = this.pickedTow.get().asUnit(UnitType.POUND);
        if (togw === null) {
            return;
        }
        const calculatedData = this.activeSetting.get() === textAreaSetting.Full ? this.fullResults.get() : this.atmResults.get();
        if (calculatedData === undefined) {
            return;
        }
        const { isPossible, thrustRatingOut, flapSettingOut, assumedTemperatureOut, v1Out, vrOut, v2Out } = calculatedData;
        let thrustRating;
        switch (thrustRatingOut) {
            default:
            case EFBTakeoffThrustMode.TO:
                thrustRating = TakeoffThrustMode.TO;
                break;
            case EFBTakeoffThrustMode.TO1:
                thrustRating = TakeoffThrustMode.TO1;
                break;
            case EFBTakeoffThrustMode.TO2:
                thrustRating = TakeoffThrustMode.TO2;
                break;
        }
        if (isPossible) {
            this.props.communicationsManager.sendTakeoffDataUplinkToFmc({
                v1: v1Out,
                vr: vrOut,
                v2: v2Out,
                togw,
                thrustRating,
                assumedTemperature: assumedTemperatureOut,
                flapSetting: flapSettingOut,
            });
        }
    }
    /**
     * Will disable eveything and take away green outline while the progess bar fills up.
     */
    DisableDropDownBoxes(value) {
        this.RTGBoxRef.instance.SetDefault();
        this.pickedRtg.set(null);
        this.FLAPRef.instance.SetDefault();
        this.pickedFlaps.set(null);
        this.AIRef.instance.SetDefault();
        this.pickAiConfig.set(null);
        this.IMCLBRef.instance.SetDefault();
        this.pickedImClb.set(null);
        this.ConditionBoxRef.instance.SetDefault();
        this.pickedRunwayCondition.set(null);
        this.windTextFieldRef.instance.typeValue(null);
        this.cgFieldRef.instance.typeValue(null); 
        this.isProgressBarVisible.set(false);
        this.displayResults()
if ( this.OATGreenOutline.Get() == false) {
    this.oatFieldRef.instance.typeValue(null); 
}
if ( this.QNHGreenOutline.Get() == false) {
    this.qnhFieldRef.instance.typeValue(null); 
}
if ( this.TOWGreenOutline.Get() == false) {
    this.towFieldRef.instance.typeValue(null); 
}
if ( this.ZFWGreenOutline.Get() == false) {
    this.zfwFieldRef.instance.typeValue(null); 
}
      

    }

    disableEverything(value) {
        
        if (value == true){
        this.arptinfobuttondisabled.set(true);  
            this.RTGBoxRef.instance.SetDefault();
        this.pickedRtg.set(null);

       this.ConditionBoxRef.instance.SetDefault();
       this.pickedRunwayCondition.set(null);
        
        this.FLAPRef.instance.SetDefault();
        this.pickedFlaps.set(null);

        this.AIRef.instance.SetDefault();
        this.pickAiConfig.set(null);
        this.runwayList.clear();
        this.IMCLBRef.instance.SetDefault();
        this.pickedImClb.set(null);
        this.ArptDropdownRef.instance.SetDefault();
        this.rwyDropdownRef.instance.SetDefault();
    
      this.windTextFieldRef.instance.typeValue(null);
      
      this.oatFieldRef.instance.typeValue(null); 
      this.qnhFieldRef.instance.typeValue(null); 
      this.towFieldRef.instance.typeValue(null); 
      this.pickedWind.set(null)
      this.pickedOat.set(null)
      this.pickedTow2.set(null)
      this.zfwFieldRef.instance.typeValue(null); 
      this.cgFieldRef.instance.typeValue(null); 
      this.isProgressBarVisible.set(false);
      
     this.displayResults()
        }

        
        
        this.arptListGreenOutline.set(false);
        this.rwyListGreenOutline.set(false);
        this.OATGreenOutline.set(false);
        this.QNHGreenOutline.set(false);
        this.TOWGreenOutline.set(false);
        this.ZFWGreenOutline.set(false);
      this.windTextFieldRef.instance.setTextFieldToInactive();
        this.oatFieldRef.instance.setTextFieldToInactive();
        this.qnhFieldRef.instance.setTextFieldToInactive();
        this.towFieldRef.instance.setTextFieldToInactive();
       this.zfwFieldRef.instance.setTextFieldToInactive();
       this.cgFieldRef.instance.setTextFieldToInactive();

    }
    /**
     * Sets the RTG in the display area to the right settings
     * @param thrustRatingMode The mode
     * @param toOat The temp
     * @param assumedTemp Assumed temperature from the calculation or 0 if none.
     * @param toRunway The runway taking off from
     */
    setRtg(thrustRatingMode, toOat, assumedTemp, toRunway) {
        const useAssumedTemp = assumedTemp !== 0 && assumedTemp > toOat;
        const temperature = useAssumedTemp ? assumedTemp : toOat;
        const qnh = this.pickedQnh.get().asUnit(UnitType.HPA);
        const pressureAlt = Number.isFinite(qnh) ? UnitType.FOOT.convertFrom(toRunway.elevation - AeroMath.baroPressureAltitudeOffset(qnh), UnitType.METER) : null;
        const thrustModeText = useAssumedTemp ? `D-${thrustRatingMode}` : thrustRatingMode;
        if (thrustRatingMode === TakeoffThrustMode.TO) {
            this.efbThrustModeText.set(thrustModeText);
            if (pressureAlt !== null) {
                this.takeoffThrustValue.set(this.props.engineDataProvider.getToMaxTpr(pressureAlt, temperature).toFixed(1));
            }
        }
        else if (thrustRatingMode === TakeoffThrustMode.TO1) {
            this.efbThrustModeText.set(thrustModeText);
            if (pressureAlt !== null) {
                this.takeoffThrustValue.set(this.props.engineDataProvider.getTo1Tpr(pressureAlt, temperature).toFixed(1));
            }
        }
        else if (thrustRatingMode === TakeoffThrustMode.TO2) {
            this.efbThrustModeText.set(thrustModeText);
            if (pressureAlt !== null) {
                this.takeoffThrustValue.set(this.props.engineDataProvider.getTo2Tpr(pressureAlt, temperature).toFixed(1));
            }
        }
    }
    /** Shows data in the results area */
    showDataInTextArea() {
        const isResultAvailable = this.isResultAvailable.get();
        this.textAreaContentsRef.instance.classList.toggle('hidden', !isResultAvailable);
        this.nameAndEngineRef.instance.classList.toggle('hidden', !isResultAvailable);
        const isRtowCalc = !this.isResultPerfCalculation.get();
        this.selTempTextAreaRef.instance.classList.toggle('hidden', isRtowCalc || this.activeSetting.get() !== textAreaSetting.Atm);
        this.textAreaSettingRef.instance.classList.toggle('hidden', isRtowCalc);
        this.textAreaSettingButtonsRefs.instance.classList.toggle('hidden', isRtowCalc || this.atmResults.get() === null);
        this.v1TextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
        this.vrTextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
        this.v2TextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
        this.vrefTextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
    }
    /**
     * Hides data in the results area
     */
    hideDataInTextArea() {
        this.isResultPerfCalculation.set(false);
        this.isResultAvailable.set(false);
        this.textAreaContentsRef.instance.classList.add('hidden');
        this.nameAndEngineRef.instance.classList.add('hidden');
        this.selTempTextAreaRef.instance.classList.add('hidden');
        this.v1TextAreaValueRef.instance.classList.add('hidden');
        this.vrTextAreaValueRef.instance.classList.add('hidden');
        this.v2TextAreaValueRef.instance.classList.add('hidden');
        this.vrefTextAreaValueRef.instance.classList.add('hidden');
        this.textAreaSettingRef.instance.classList.add('hidden');
        this.textAreaSettingButtonsRefs.instance.classList.add('hidden');
    }
    /**
     * Handles when a new airport is selected and runways change.
     */
    initializeData() {
        var _a;
        const unit = this.unit.get();
        //clear lists so no dupes show up
        this.runwayList.clear();
        this.arptList.clear();
        const listOfRunways = this.props.store.availableTakeoffRunways.get();
       
        
       

        this.runwayList.set(listOfRunways);
        if (this.props.store.airportOrigin.get() !== '') {
        //    this.aprtName.set(this.props.store.airportOrigin.get().substring(6));
            this.ArptDropdownRef.instance.pickItem(this.props.store.airportOrigin.get().substring(6));
        }
        else {
            this.aprtName.set('ARPT SEARCH');
        }
        const takeoffRunway = this.props.store.takeoffRunway.get();
        takeoffRunway !== null && this.rwyDropdownRef.instance.pickItem(takeoffRunway);
        const takeoffOat = this.props.store.takeoffOatCelsius.get();
        takeoffOat !== null && this.oatFieldRef.instance.typeValue(takeoffOat.toFixed(0));
        const takeoffWind = this.props.store.takeoffWind.get();
        if (takeoffWind) {
            const direction = (takeoffWind.direction.toFixed(0) === '0' ? '360' : takeoffWind.direction.toFixed(0)).padStart(3, '0');
            this.windTextFieldRef.instance.typeValue(direction + '/' + takeoffWind.speed.toFixed(0));
        }
        const takeoffQnh = this.props.store.takeoffQnhHpa.get();
        if (takeoffQnh !== null) {
            if (this.gameUnitsMetric.get()) {
                if (takeoffQnh < 1000) {
                    //show one deciml point
                    takeoffQnh !== null && this.qnhFieldRef.instance.typeValue(takeoffQnh.toFixed(1));
                }
                else {
                    //show none if above or equal to 1000
                    //this.qnhFieldRef.instance.typeValue(pickedQnh.number.toFixed(0).toString());
                    takeoffQnh !== null && this.qnhFieldRef.instance.typeValue(takeoffQnh.toFixed(0));
                }
            }
            else {
                takeoffQnh !== null && this.qnhFieldRef.instance.typeValue(UnitType.IN_HG.convertFrom(takeoffQnh, UnitType.HPA).toFixed(2));
            }
        }
        const takeoffWeightLbs = this.props.store.takeoffGwLbs.get();
        takeoffWeightLbs !== null && this.towFieldRef.instance.typeValue(unit.convertFrom(takeoffWeightLbs, UnitType.POUND).toFixed(0));
        const zeroFuelWeightKg = this.props.store.takeoffZfwKg.get();
        zeroFuelWeightKg !== null && this.zfwFieldRef.instance.typeValue(unit.convertFrom(zeroFuelWeightKg, UnitType.KILOGRAM).toFixed(0));
        const centerOfGravity = this.props.store.takeoffCg.get();
        centerOfGravity !== null && this.cgFieldRef.instance.typeValue(centerOfGravity.toFixed(0));
        this.runwayCondition.set(this.props.store.takeoffRunwayCondition.get());
        this.pickedQnh.set((_a = this.props.store.takeoffQnhHpa.get()) !== null && _a !== void 0 ? _a : NaN, UnitType.HPA);
        this.pickedTow.set(takeoffWeightLbs === null ? 0 : takeoffWeightLbs, UnitType.POUND);
        this.pickedZfwKg.set(zeroFuelWeightKg);
        this.pickedCg.set(centerOfGravity);
    }
    /** Updates fields when game units change. */
    handleGameUnitsChanged() {
        var _a;
        const weightUnit = this.unit.get();
        const pickedZfwKg = this.pickedZfwKg.get();
        pickedZfwKg !== null && this.zfwFieldRef.instance.typeValue(weightUnit.convertFrom(pickedZfwKg, UnitType.KILOGRAM).toFixed(0));
        const pickedTow = this.pickedTow.get();
        
     //   pickedTow !== null && this.towFieldRef.instance.typeValue(pickedTow.asUnit(weightUnit).toFixed(0));
        // Redisplay results
        const activeAtmFullSetting = this.activeSetting.get();
        const atmResults = this.atmResults.get();
        const fullResults = this.fullResults.get();
        if (activeAtmFullSetting === textAreaSetting.Atm && atmResults) {
            this.displayResults(atmResults);
        }
        else if (activeAtmFullSetting === textAreaSetting.Full && fullResults) {
            this.displayResults(fullResults);
        }
        //update the text in the progress bar
        this.progressBarRef.instance.setBarInfo((_a = this.pickedRunway.get()) === null || _a === void 0 ? void 0 : _a.designation, this.togwResultText.get());
    }
    /**
     * Handler when any top menu button is clicked.(NORMAL, RESET, NON-NORMAL)
     * @param menu The menu button that was clicked.
     */
    onMenuButtonClicked(menu) {
        if (menu === textAreaSetting.Atm) {
            const atmResults = this.atmResults.get();
            if (atmResults) {
            this.activeSetting.set(textAreaSetting.Atm);
                            this.displayResults(atmResults);
            }
        }
        if (menu === textAreaSetting.Full) {
                        const fullResults = this.fullResults.get();
            if (fullResults) {
                this.activeSetting.set(textAreaSetting.Full);
                this.displayResults(fullResults);
            }
        }
    }
   
    async GreenOutline(data) {
        
        if (data) {
            
            this.GettingData.set(true);
            this.arptListGreenOutline.set(data.airportOrigin !== undefined);
            if (data.airportOrigin !== undefined){
                
                this.RwyDisabled.set(false);
                this.RwyArrow.set(true);
            }
            this.rwyListGreenOutline.set(data.availableTakeoffRunways !== undefined);
            this.OATGreenOutline.set(data.oatCelsius !== undefined);
            this.QNHGreenOutline.set(data.qnhHpa !== undefined);
            this.TOWGreenOutline.set(data.gwLbs !== undefined);
            this.ZFWGreenOutline.set(data.zfwLbs !== undefined);
            this.flightButtonDisabled.set(false);
            this.arptinfobuttondisabled.set(false);
            setTimeout(() => {
                this.GettingData.set(false);
            }, 10); 
            this.DisableDropDownBoxes();

        }
        else {
           
            this.disableEverything(true)
        }
         
            
           
       
    }
    async CloseFlight() {
        
       this.flightButtonDisabled.set(false);
            this.flightButtonText.set('INITIALIZE FLIGHT');
        this.props.store. ResetFlightDataEFB()
       
    }
   
    async CopyFMCDATA() {
        this.flightButtonDisabled.set(true);
       
        this.props.communicationsManager.requestFlightInitializationData().then((data) => {
           
            this.GettingData.set(true);
            this.arptListGreenOutline.set(data.airportOrigin !== undefined);
            if (data.airportOrigin !== undefined){
                
                this.RwyDisabled.set(false);
                this.RwyArrow.set(true);
            }
            this.rwyListGreenOutline.set(data.availableTakeoffRunways !== undefined);
            this.OATGreenOutline.set(data.oatCelsius !== undefined);
            this.QNHGreenOutline.set(data.qnhHpa !== undefined);
            this.TOWGreenOutline.set(data.gwLbs !== undefined);
            this.ZFWGreenOutline.set(data.zfwLbs !== undefined);
            this.flightButtonDisabled.set(false);
            this.arptinfobuttondisabled.set(false);
            this.props.store.acceptFlightInitializationData(data,false);
            setTimeout(() => {
                this.GettingData.set(false);
            }, 10); 
            
        }).catch(() => {
            
          this.flightButtonDisabled.set(false);
        });
    }
    async CloseFlight() {
        
       this.flightButtonDisabled.set(false);
       this.flightButtonText.set('INITIALIZE FLIGHT');
        this.props.store. ResetFlightDataEFB()
       
   }
   
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef },
            FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PERFORMANCE-TAKEOFF"),
            FSComponent.buildComponent("div", { class: 'efb-left-side' },
               
           //FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => this.onPageSelect(EfbPages.PerformanceARPTINFO),isDisabled: false},
                
           FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => {this.props.onPageSelect(EfbPages.PerformanceARPTINFO);LastEFBPg = "Performance"; },isDisabled: this.arptinfobuttondisabled },
                    
                    FSComponent.buildComponent("span", null, "ARPT"),
                    FSComponent.buildComponent("span", null, "INFO")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "ADD"),
                    FSComponent.buildComponent("span", null, "ARPT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "NOTAMS")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "SHOW"),
                    FSComponent.buildComponent("span", null, "KYBD")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "WT AND"),
                    FSComponent.buildComponent("span", null, "BALANCE")),
              //  FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => {this.props.onPageSelect(EfbPages.LandingPerformancePG);LastEFBPg = "Performance"; },},
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "SHOW"),
                    FSComponent.buildComponent("span", null, "LANDING")),
                FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.CopyFMCDATA.bind(this), isDisabled: this.flightButtonDisabled },
                    FSComponent.buildComponent("span", null, "COPY"),
                    FSComponent.buildComponent("span", null, "FMC DATA")),
                FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.sendPerfDataToFMC.bind(this), isDisabled: this.sendDataDisabled },
                    FSComponent.buildComponent("span", null, "SEND"),
                    FSComponent.buildComponent("span", null, "OUTPUT"))),
            FSComponent.buildComponent("div", { class: 'efb-right-side' },
                FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.handleCalculateButton.bind(this), isDisabled: this.calcDataDisabled },
                    FSComponent.buildComponent("span", null, "CALC")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "SHOW"),
                    FSComponent.buildComponent("span", null, "ALL ENGINE")),
             FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => {this.props.onPageSelect(EfbPages.PerformanceMEL);LastEFBPg = "Performance"; },isDisabled: this.MELinfobuttondisabled },
                    FSComponent.buildComponent("span", null, "MEL")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "CDL")),
                    
                FSComponent.buildComponent(BoeingEfbProgressBar, { ref: this.progressBarRef, isHidden: this.isProgressBarVisible })),
            FSComponent.buildComponent("div", { class: 'efb-middle' },
                FSComponent.buildComponent("div", { class: 'efb-middle-top-left-title' }, "GENX-1B76"),
                FSComponent.buildComponent("div", { class: 'efb-middle-top-right-box' },
                    FSComponent.buildComponent("div", { class: 'right-side-dropdowns' },
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { ref: this.RTGBoxRef,dropdownItems: this.rtgList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'RTG', isNameOnLeftSide: false, dropDownDefaultName: 'THRUST RTG', onItemSelected: (thrustRTG) => this.pickedRtg.set(thrustRTG) }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.atmTextFieldRef, buttonName: 'ATM', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: false, onValueChanged: (value) => {
                                this.pickedAtm.set(value);
                            } }),
                        FSComponent.buildComponent("div", { class: 'right-side-making-space' }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { ref: this.FLAPRef,dropdownItems: this.flapList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'FLAP', isNameOnLeftSide: false, dropDownDefaultName: 'FLAP CONFIG', onItemSelected: (flap) => this.pickedFlaps.set(flap) }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { ref: this.AIRef,dropdownItems: this.aiList, dropdownItemFormatter: EfbFormatters.EngineAntiIceSettingFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'A/I', isNameOnLeftSide: false, dropDownDefaultName: 'A/I CONFIG', onItemSelected: (aiConfig) => this.pickAiConfig.set(aiConfig) }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { ref: this.IMCLBRef,dropdownItems: this.imClbList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'ImCLB', isNameOnLeftSide: false, dropDownDefaultName: 'NONE', onItemSelected: (imClb) => this.pickedImClb.set(imClb), isDisabled: false, isDropDownDisabled: false }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-top-left-box' },
                    FSComponent.buildComponent("div", { class: 'left-side-dropdowns' },
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { ref:  this.ArptDropdownRef ,dropdownItems: this.arptList, dropdownItemFormatter: RawFormatter, hasGreenOutline: this.arptListGreenOutline, hasArrow: false, dropdownButtonName: 'ARPT', isNameOnLeftSide: true, dropDownDefaultName: 'ARPT SEARCH', onFmcLoadedName: this.aprtName, isDropDownDisabled: true }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { ref: this.rwyDropdownRef, dropdownItems: this.runwayList, dropdownItemFormatter: EfbFormatters.RunwayFormatter, hasGreenOutline: this.rwyListGreenOutline, hasArrow: this.RwyArrow, dropdownButtonName: 'RWY', isNameOnLeftSide: true, isDisabled: this.RwyDisabled,dropDownDefaultName: 'RUNWAYS', onItemSelected: (runway) => {
                            this.pickedRunway.set(runway); this.props.store.takeoffRunway.set(runway);this.props.store.FlightDataUpdate.notify(this, undefined);
                        } }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { dropdownItems: this.intxList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: false, dropdownButtonName: 'INTX', isNameOnLeftSide: true, dropDownDefaultName: 'NO INTX', isDisabled: true, isDropDownDisabled: true }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, {ref: this.ConditionBoxRef, dropdownItems: this.condList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'COND', isNameOnLeftSide: true, dropDownDefaultName: 'CONDITION', onItemSelected: (item) => {this.pickedRunwayCondition.set(item);
                            }, }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.windTextFieldRef, buttonName: 'WIND', isNameOnLeftSide: true, hasBottomText: true, enableKeyboard: true, validator: EfbFormatters.WindParser, bottomTextFormatter: EfbFormatters.WindFormatter(this.props.store.takeoffRunway), onlyNumberEntry: true, onValueChanged: (value) => {
                                this.pickedWind.set(value);
                            }, unitForTextField: 'KT', allowTforWind: true }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.oatFieldRef, buttonName: 'OAT', isNameOnLeftSide: true, hasBottomText: true, enableKeyboard: true,hasGreenOutline: this.OATGreenOutline, valueOnStartUp: this.pickedOat, validator: EfbFormatters.NumberParser, bottomTextFormatter: EfbFormatters.FahrenheitTemperatureFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                this.pickedOat.set(value);
                            }, unitForTextField: 'C' }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.qnhFieldRef, buttonName: 'QNH', isNameOnLeftSide: true, hasBottomText: true, enableKeyboard: true,hasGreenOutline: this.QNHGreenOutline, validator: EfbFormatters.PressureParser, textFieldFormatter: EfbFormatters.FieldPressureFormatter, bottomTextFormatter: EfbFormatters.BottomTextPressureFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                const unit = (value >= 28 && value <= 31) ? UnitType.IN_HG : UnitType.HPA;
                                this.typedQnhUnit.set(unit);
                                this.pickedQnh.set(value, unit);
                            }, unitForTextField: this.typedQnhUnit.map((unit) => unit === UnitType.HPA ? 'HPa' : 'IN HG') }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-1st-middle-box' },
                    FSComponent.buildComponent("div", { class: 'left-textfield-middle' },
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.towFieldRef, buttonName: 'TOW:', isNameOnLeftSide: true, hasBottomText: false, enableKeyboard: true,hasGreenOutline: this.TOWGreenOutline, validator: EfbFormatters.TowParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                if (this.gameUnitsMetric.get()) {
                                    this.pickedTow.set(value, UnitType.KILOGRAM);
                                    this.pickedTow2.set("Set");
                                }
                                else {
                                    this.pickedTow.set(value, UnitType.POUND);
                                }
                            }, unitForTextField: this.unitString })),
                    FSComponent.buildComponent("div", { class: 'right-textfield-middle' },
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.zfwFieldRef, buttonName: 'ZFW:', isNameOnLeftSide: true, hasBottomText: false, enableKeyboard: true,hasGreenOutline: this.ZFWGreenOutline, validator: EfbFormatters.NumberParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                if (this.gameUnitsMetric.get()) {
                                    //if the game is in metric then keep the same
                                    this.pickedZfwKg.set(value);
                                }
                                else {
                                    //if in us system (LB) then convert to lb
                                    const data = Number(UnitType.POUND.convertTo(value, UnitType.KILOGRAM).toFixed());
                                    this.pickedZfwKg.set(data);
                                }
                            }, unitForTextField: this.unitString }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box' },
                    FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box-name-and-engine hidden', ref: this.nameAndEngineRef }, "787-10/GENX-1B76"),
                    FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box-setting-buttons hidden', ref: this.textAreaSettingButtonsRefs },
                        FSComponent.buildComponent(BoeingEfbButton, { selected: this.isFullSettingActive, onClick: () => this.onMenuButtonClicked(textAreaSetting.Full) },
                            FSComponent.buildComponent("span", null, "FULL")),
                        FSComponent.buildComponent(BoeingEfbButton, { selected: this.isAtmSettingActive, isDisabled: this.isAtmSettingDisabled, onClick: () => this.onMenuButtonClicked(textAreaSetting.Atm) },
                            FSComponent.buildComponent("span", null, "ATM"))),
                    FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box-cg' },
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.cgFieldRef, buttonName: 'CG(%): ', isNameOnLeftSide: true, hasBottomText: false, width: 60, enableKeyboard: true, validator: EfbFormatters.NumberParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                this.pickedCg.set(value);
                            } }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-3st-middle-box' },
                    FSComponent.buildComponent("div", { class: 'efb-middle-3st-middle-box-contents hidden', ref: this.textAreaContentsRef },
                        FSComponent.buildComponent("div", { class: 'efb-text-area-flaps' },
                            "FLAP",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-flaps-value efb-result-value' }, this.flapsValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-accel-ht' },
                            "ACCEL HT",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-accel-ht-value efb-result-value' }, this.accelHtValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-rwy-intx' },
                            "RWY/INTX",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-rwy-intx-value efb-result-value' }, this.rwyValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-togw' },
                            "TOGW",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-togw-value efb-result-value' }, this.togwResultText)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-thrust-rating' },
                            this.efbThrustModeText,
                            FSComponent.buildComponent("div", { class: 'efb-text-area-thrust-rating-value efb-result-value' }, this.takeoffThrustValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-sel-temp', ref: this.selTempTextAreaRef },
                            "SEL TEMP",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-sel-temp-value efb-result-value' }, this.selTempValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-v1-speed' },
                            "V1",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-v-speed-value hidden efb-result-value', ref: this.v1TextAreaValueRef }, this.v1SpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-vr-speed' },
                            "VR",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-v-speed-value hidden efb-result-value', ref: this.vrTextAreaValueRef }, this.vrSpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-v2-speed' },
                            "V2",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-v-speed-value hidden efb-result-value', ref: this.v2TextAreaValueRef }, this.v2SpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-vref' },
                            "Vref30",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-vref-speed-value hidden efb-result-value', ref: this.vrefTextAreaValueRef }, this.vRefSpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-big-setting-text hidden', ref: this.textAreaSettingRef }, this.textAreaSetting)),
                    FSComponent.buildComponent("div", { class: 'efb-text-area-runway-information' },
                        FSComponent.buildComponent("div", { class: 'efb-text-area-runway-information-value' }, this.runwayInformationValue))
                        
                    )
                        ,
                        

                    )));
                    }












   
   
}

/**
 * A component that represents a 787 Systems Page.
 */
var B78DoorStatus;
(function (B78DoorStatus) {
    B78DoorStatus[B78DoorStatus["BLANK"] = 0] = "BLANK";
    B78DoorStatus[B78DoorStatus["OPEN"] = 1] = "OPEN";
    B78DoorStatus[B78DoorStatus["MANUAL"] = 2] = "MANUAL";
    B78DoorStatus[B78DoorStatus["AUTO"] = 3] = "AUTO";
})(B78DoorStatus || (B78DoorStatus = {}));


/* eslint-disable @typescript-eslint/no-unused-vars */
/** A DisplayPaneView component */
class DisplayPaneView extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._title = Subject.create('');
        /** The title of this display pane view. */
        this.title = this._title;
    }
    /**
     * Called when this view is made visible.
     * @param size The size of this view's parent pane.
     * @param width The width of this view's parent pane, in pixels.
     * @param height The height of this view's parent pane, in pixels.
     */
    onResume(size, width, height) {
        // noop
    }
    /**
     * Called when this view is hidden.
     */
    onPause() {
        // noop
    }
    /**
     * Called when this view's parent pane is resized while this view is visible.
     * @param size The size of this view's parent pane.
     * @param width The width of this view's parent pane, in pixels.
     * @param height The height of this view's parent pane, in pixels.
     */
    onResize(size, width, height) {
        // noop
    }
    /**
     * Called every update cycle.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    onUpdate(time) {
        // noop
    }
    /**
     * Called when a display pane view event is received by this view.
     * @param event The event.
     */
    onEvent(event) {
        // noop
    }
}

class B787DoorsPageE extends DisplayPaneView {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.doorSub = this.props.bus.getSubscriber();
        this.engineSub = this.props.bus.getSubscriber();
        this.engine1N1 = ConsumerValue.create(this.engineSub.on('n1_1').whenChanged().withPrecision(1), 0);
        this.entry1LStatus = ConsumerSubject.create(this.doorSub.on('entry_1l_status').whenChanged(), this.getInitialDoorValue());
        this.entry1RStatus = ConsumerSubject.create(this.doorSub.on('entry_1r_status').whenChanged(), this.getInitialDoorValue());
        this.entry2LStatus = ConsumerSubject.create(this.doorSub.on('entry_2l_status').whenChanged(), this.getInitialDoorValue());
        this.entry2RStatus = ConsumerSubject.create(this.doorSub.on('entry_2r_status').whenChanged(), this.getInitialDoorValue());
        this.entry3LStatus = ConsumerSubject.create(this.doorSub.on('entry_3l_status').whenChanged(), this.getInitialDoorValue());
        this.entry3RStatus = ConsumerSubject.create(this.doorSub.on('entry_3r_status').whenChanged(), this.getInitialDoorValue());
        this.entry4LStatus = ConsumerSubject.create(this.doorSub.on('entry_4l_status').whenChanged(), this.getInitialDoorValue());
        this.entry4RStatus = ConsumerSubject.create(this.doorSub.on('entry_4r_status').whenChanged(), this.getInitialDoorValue());
        this.fwdCargoStatus = ConsumerSubject.create(this.doorSub.on('fwd_cargo_status').whenChanged(), B78DoorStatus.BLANK);
        this.aftCargoStatus = ConsumerSubject.create(this.doorSub.on('aft_cargo_status').whenChanged(), B78DoorStatus.BLANK);
        this.bulkCargoStatus = ConsumerSubject.create(this.doorSub.on('bulk_cargo_status').whenChanged(), B78DoorStatus.BLANK);
        this.refuelDoorStatus = ConsumerSubject.create(this.doorSub.on('refuel_door_status').whenChanged(), B78DoorStatus.BLANK);
        this.lavatoryRef = FSComponent.createRef();
        this.entry1LRef = FSComponent.createRef();
        this.entry1RRef = FSComponent.createRef();
        this.entry2LRef = FSComponent.createRef();
        this.entry2RRef = FSComponent.createRef();
        this.entry3LRef = FSComponent.createRef();
        this.entry3RRef = FSComponent.createRef();
        this.entry4LRef = FSComponent.createRef();
        this.entry4RRef = FSComponent.createRef();
        this.fwdCargoRef = FSComponent.createRef();
        this.aftCargoRef = FSComponent.createRef();
        this.bulkCargoRef = FSComponent.createRef();
        this.refuelDoorRef = FSComponent.createRef();
        this.subs = [];
        this.DoorButtonDisabled = Subject.create(false);
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        this.props.visible.sub((visible) => {
            this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
        }, true);
        this.subs.push(this.doorSub.on('lavatory_occupied').whenChanged().handle(this.updateLavatoryOccupancy.bind(this)));
        this.subs.push(this.entry1LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry1LRef), true));
        this.subs.push(this.entry1RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry1RRef), true));
        this.subs.push(this.entry2LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry2LRef), true));
        this.subs.push(this.entry2RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry2RRef), true));
        this.subs.push(this.entry3LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry3LRef), true));
        this.subs.push(this.entry3RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry3RRef), true));
        this.subs.push(this.entry4LStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry4LRef), true));
        this.subs.push(this.entry4RStatus.sub(v => this.updateEntryDoorDisplay(v, this.entry4RRef), true));
        this.subs.push(this.fwdCargoStatus.sub(v => this.updateOtherDoorDisplay(v, this.fwdCargoRef), true));
        this.subs.push(this.aftCargoStatus.sub(v => this.updateOtherDoorDisplay(v, this.aftCargoRef), true));
        this.subs.push(this.bulkCargoStatus.sub(v => this.updateOtherDoorDisplay(v, this.bulkCargoRef), true));
        this.subs.push(this.refuelDoorStatus.sub(v => this.updateRefuelDoorDisplay(v, this.refuelDoorRef), true));
        /** const isAircraftOnGround = !!SimVar.GetSimVarValue('SIM ON GROUND', SimVarValueType.Bool);
        if (isAircraftOnGround) {
            this.DoorButtonDisabled.set(false);
        }
        else {
            this.DoorButtonDisabled.set(true);
        }*/
    }
    /** @inheritDoc */
    onSuspend() {
        super.onSuspend();
        this.subs.forEach(sub => sub.pause());
    }
    /** @inheritDoc */
    onResume() {
        super.onResume();
        this.subs.forEach(sub => sub.resume(true));
    }
    /**
     * Updates lavatory occupancy display
     * @param isOccupied whether the lavatory is occupied
     * @private
     */
    updateLavatoryOccupancy(isOccupied) {
        this.lavatoryRef.instance.classList.toggle('occupied', isOccupied);
        this.lavatoryRef.instance.textContent = isOccupied ? 'LAV OCCUPIED' : 'LAV VACANT';
    }
    /**
     * Returns initial door value for the current engine conditions. Used on page init.
     * @returns B78DoorStatus
     */
    getInitialDoorValue() {
        return this.engine1N1.get() > 1 ? B78DoorStatus.AUTO : B78DoorStatus.MANUAL;
    }
    /**
     * Updates Entry door status display (with randomized delay on closing doors)
     * @param doorStatus the new door status
     * @param door the door div reference to update
     * @param force whether to force immediate change (skip the random timeout)
     * @private
     */
    updateEntryDoorDisplay(doorStatus, door, force = false) {
        switch (doorStatus) {
            case B78DoorStatus.OPEN:
                door.instance.classList.add('entry-door-unlocked');
                door.instance.classList.remove('entry-door-closed', 'entry-door-auto', 'entry-door-manual');
                door.instance.textContent = '';
                break;
            case B78DoorStatus.AUTO:
                setTimeout(() => {
                    door.instance.classList.remove('entry-door-unlocked', 'entry-door-manual');
                    door.instance.classList.add('entry-door-closed', 'entry-door-auto');
                    door.instance.textContent = 'A';
                }, force ? 0 : Math.random() * 5000);
                break;
            case B78DoorStatus.MANUAL:
                setTimeout(() => {
                    door.instance.classList.remove('entry-door-unlocked', 'entry-door-auto');
                    door.instance.classList.add('entry-door-closed', 'entry-door-manual');
                    door.instance.textContent = 'M';
                }, force ? 0 : Math.random() * 5000);
                break;
        }
    }
    /**
     * Updates other (cargo/e-bay etc.) door status display
     * @param doorStatus the new door status
     * @param door the door div reference to update
     * @private
     */
    updateOtherDoorDisplay(doorStatus, door) {
        switch (doorStatus) {
            case B78DoorStatus.BLANK:
                door.instance.classList.add('other-door-closed');
                door.instance.classList.remove('door-not-locked');
                break;
            case B78DoorStatus.OPEN:
                door.instance.classList.remove('other-door-closed');
                door.instance.classList.add('door-not-locked');
                break;
        }
    }
    /**
     * Updates refueling panel status display
     * @param doorStatus the new door status
     * @param door the door div reference to update
     * @private
     */
    updateRefuelDoorDisplay(doorStatus, door) {
        switch (doorStatus) {
            case B78DoorStatus.BLANK:
                door.instance.classList.add('other-door-closed');
                door.instance.classList.remove('door-refuel-unlocked');
                break;
            case B78DoorStatus.OPEN:
                door.instance.classList.remove('other-door-closed');
                door.instance.classList.add('door-refuel-unlocked');
                break;
        }
    }
    async SimVarDoorSet(index) {
        const isON = SimVar.GetSimVarValue(`A:INTERACTIVE POINT OPEN:${index}`, SimVarValueType.Percent);
        switch (isON) {
            case 100:
                SimVar.SetSimVarValue(`K:TOGGLE_AIRCRAFT_EXIT`, SimVarValueType.Enum, index);
                break;
            default:
                SimVar.SetSimVarValue(`K:TOGGLE_AIRCRAFT_EXIT`, SimVarValueType.Enum, index);
                break;
        }
    }
    async SimVarDoorCommand(index) {
        this.SimVarDoorSet(index);
    }
    //There are CSS classes at the bottom to toggle for a given door state.
    //For the entry doors, toggle "entry-door-closed-auto" and "entry-door-unlocked"
    //For the cargo doors & e-bay access, toggle "door-not-locked" and "other-door-closed"
    //For the refuel panel, toggle "door-refuel-unlocked" and "other-door-closed"
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page2' }, "DOORS"),
        FSComponent.buildComponent("div", { class: "doors-page-container" },
            FSComponent.buildComponent("svg", { width: "954", height: "1375" },
            FSComponent.buildComponent("path", { d: "M 249 585 c 9 -26 14 -56 0 -93 l -70 0 c -16 29 -11 57 -2 93 l 6 0 l 15 27 l 51 -27", fill: BoeingColors.darkGray, stroke: BoeingColors.cyan, "stroke-width": "5px" }),
            FSComponent.buildComponent("path", { d: "M 249 586 l -66 0", stroke: BoeingColors.cyan, "stroke-width": "3px" }),
            FSComponent.buildComponent("path", { d: "M 705 585 c -9 -26 -14 -56 0 -93 l 70 0 c 16 29 11 57 2 93 l -6 0 l -17 27 z", fill: BoeingColors.darkGray, stroke: BoeingColors.cyan, "stroke-width": "5px" }),
            FSComponent.buildComponent("path", { d: "M 771 586 l -66 0", stroke: BoeingColors.cyan, "stroke-width": "3px" }),
            FSComponent.buildComponent("path", { d: "M 409 478 c -1.256 8.294 -4.184 14.532 -11.611 18.48 l -397.389 217.52 l 0 132 l 266 -33 l 422 0 l 266 33 l 0 -132 l -394.829 -216.859 c -6.897 -4.492 -10.44 -10.856 -11.171 -19.141 z", fill: BoeingColors.darkGray, stroke: BoeingColors.cyan, "stroke-width": "5px" }),
            FSComponent.buildComponent("path", { d: "M 425 1190 c -4 12 -7 12 -12 16 l -178 114 c -6 4 -9 8 -10 13 l -3 42 l 228.939 -50.035 l 52.22 0.038 l 228.841 50.997 l -4 -44 c -1 -6 -4.981 -9.032 -11 -13 l -175 -112 c -6 -5 -9 -7 -12 -17", fill: BoeingColors.darkGray, stroke: BoeingColors.cyan, "stroke-width": "5px" }),
            FSComponent.buildComponent("path", { d: "M 409 304 l 0 772 c 2 50 4 64 15 131 c 12 51 29 101 47.66 137.019 l 10.811 -0.019 c 18.529 -35 38.529 -88 49.637 -136.452 c 9.892 -60.548 12.892 -81.548 15.592 -131.548 l 0.3 -772 c -3 -90 -39 -192 -71 -192 c -28 0 -65 102 -68 192", fill: BoeingColors.darkGray, stroke: BoeingColors.cyan, "stroke-width": "5px" }),
            FSComponent.buildComponent("path", { d: "M 390 340 l -220 -190", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 390 450 l -220 0", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 390 930 l -220 0", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 390 1110 l -220 100", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 565 340 l 220 -190", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 565 395 l 220 -90", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 565 450 l 220 0", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 565 930 l 220 0", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 565 1000 l 220 60", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 565 1110 l 220 100", stroke: BoeingColors.cyan, "stroke-width": "4px" }),
            FSComponent.buildComponent("path", { d: "M 390 1065 l -220 20", stroke: BoeingColors.cyan, "stroke-width": "4px" })),
            FSComponent.buildComponent("div", { class: "doors-page-refuel-panel door-refuel-unlocked" }),
            FSComponent.buildComponent("div", { class: "doors-page-fd-ovhd square-sized-door other-door-closed" }),
            FSComponent.buildComponent("div", { class: "doors-page-fwd-ee-access square-sized-door other-door-closed" }),
            FSComponent.buildComponent("div", { class: "doors-page-entry-1L entry-door-closed entry-door-manual", ref: this.entry1LRef }),
FSComponent.buildComponent("div", { class: "doors-page-entry-1R entry-door-closed entry-door-manual", ref: this.entry1RRef }),
            FSComponent.buildComponent("div", { class: "doors-page-entry-2L entry-door-closed entry-door-manual", ref: this.entry2LRef }),
            FSComponent.buildComponent("div", { class: "doors-page-fwd-cargo other-door-closed", ref: this.fwdCargoRef }),
FSComponent.buildComponent("div", { class: "doors-page-entry-2R entry-door-closed entry-door-auto", ref: this.entry2RRef }),
            FSComponent.buildComponent("div", { class: "doors-page-refuel", ref: this.refuelDoorRef }),
            FSComponent.buildComponent("div", { class: "doors-page-aft-ee-access other-door-closed" }),
FSComponent.buildComponent("div", { class: "doors-page-entry-3L entry-door-closed entry-door-manual", ref: this.entry3LRef }),
            FSComponent.buildComponent("div", { class: "doors-page-entry-3R entry-door-closed entry-door-manual", ref: this.entry3RRef }),
            FSComponent.buildComponent("div", { class: "doors-page-aft-cargo other-door-closed", ref: this.aftCargoRef }),
            FSComponent.buildComponent("div", { class: "doors-page-bulk-cargo other-door-closed", ref: this.bulkCargoRef }),
FSComponent.buildComponent("div", { class: "doors-page-entry-4L entry-door-closed entry-door-manual", ref: this.entry4LRef }),
            FSComponent.buildComponent("div", { class: "doors-page-entry-4R entry-door-closed entry-door-manual", ref: this.entry4RRef })),
        FSComponent.buildComponent("div", { class: 'efb-left-side2' },
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 1), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "ENTRY 1L")),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blankL" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 3), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "ENTRY 2L")),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blankL" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blankL" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 5), isDisabled: true },
                FSComponent.buildComponent("span", null, "ENTRY 3L")),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 11), isDisabled: this.DoorButtonDisabled },
                    FSComponent.buildComponent("span", null, "BULK&thinsp;CARGO")),
                FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 7), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "ENTRY 4L"))),
        FSComponent.buildComponent("div", { class: 'efb-right-side2' },
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 2), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "ENTRY 1R")),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 9), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "FWD&thinsp;CARGO")),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 4), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "ENTRY 2R")),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blankR" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blankR" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 6), isDisabled: true },
                FSComponent.buildComponent("span", null, "ENTRY 3R")),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 10), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "AFT&thinsp;CARGO")),
            FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.SimVarDoorCommand.bind(this, 8), isDisabled: this.DoorButtonDisabled },
                FSComponent.buildComponent("span", null, "ENTRY 4R")))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
}

/** Sams Stuff */

/** A Boeing 787-10 EFB instrument.
*/
let  LastEFBPg = "MainMenu";
class WTB78xEfbInstrument extends WTB78xFsInstrument {
   /**
    * Constructor.
    * @param instrument This instrument's parent BaseInstrument.
    * @param config This instrument's avionics config
    */
   constructor(instrument, config) {
       super(instrument, config);
       this.instrument = instrument;
       this.containerRef = FSComponent.createRef();
       this.powerState = Subject.create(true);
       this.b787EfbLVarPublisher = new B787EfbLVarPublisher(this.bus);
       this.visiblePage = Subject.create(EfbPages.MainMenu);
       this.pageVisible = (page) => this.visiblePage.map((it) => it === page);
       this.store = new BoeingEfbStore();
       this.communicationsManager = new BoeingEfbCommunicationManager(this.bus);
       this.takeoffCalculator = new B787TakeoffCalculator(new B787VSpeedData());
       this.containerPointerEventsStyle = this.powerState.map((it) => it ? 'auto' : 'none');
       this.containerVisibilityStyle = this.powerState.map((it) => it ? 'inherit' : 'hidden');
       this.backplane.addPublisher('hEvent', this.hEventPublisher);
       this.backplane.addPublisher('b787EfbLVars', this.b787EfbLVarPublisher);
       this.doInit().catch(e => {
           console.error(e);
       });
   }
   /**
    * Performs initialization tasks.
    */
   async doInit() {
       FSComponent.render(this.renderComponents(), document.getElementById('Electricity'));
       this.bus.getSubscriber().on('hEvent').handle((event) => {
           if (event.startsWith('WT787_EFB')) {
               const eventSuffix = event.replace('WT787_EFB_plt_', '').replace('WT787_EFB_coplt_', '');
               switch (eventSuffix) {
                  
                   case 'MENU': this.visiblePage.set(EfbPages.MainMenu); 
                   LastEFBPg = "MainMenu";
                   break;
                   case 'BACK': this.visiblePage.set(EfbPages[LastEFBPg]); 
                   if   (LastEFBPg = "PilotUtilities"){
                       LastEFBPg = "MainMenu";
                   }
                   else if (LastEFBPg = "Performance") {
                       LastEFBPg = "MainMenu";
                   };
                   break;
                  // case 'ZOOM': this.visiblePage.set(EfbPages.ScratchpadPage); break;
                  

               }
           }
       });
       this.bus.getSubscriber().on('b787efb_power').whenChanged().handle((newState) => {
           const isOn = SimVar.GetSimVarValue('CIRCUIT SWITCH ON:100', SimVarValueType.Number) === 1;
           if (isOn !== newState) {
               SimVar.SetSimVarValue('K:ELECTRICAL_CIRCUIT_TOGGLE', SimVarValueType.Number, 100);
           }
       });
       this.bus.getSubscriber().on('elec_circuit_on_100').whenChanged().handle((circuitOn) => {
           if (circuitOn && !this.powerState.get()) {
               this.visiblePage.set(EfbPages.MainMenu);
               
           }
           this.powerState.set(circuitOn);
       });
       this.backplane.init();
   }
   /**
    * Renders this instrument's components.
    * @returns This instrument's rendered components, as a VNode.
    */
   renderComponents() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef, style: { 'pointer-events': this.containerPointerEventsStyle, 'visibility': this.containerVisibilityStyle } },
           FSComponent.buildComponent(B787PerformancePage, { bus: this.bus, visible: this.pageVisible(EfbPages.Performance), communicationsManager: this.communicationsManager,onPageSelect: (page) => this.visiblePage.set(page), store: this.store, activePerformancePlan: this.activeRoutePerformancePlan, engineDataProvider: this.engineDataProvider, speedDataProvider: this.speedData, takeoffCalculator: this.takeoffCalculator }),
           FSComponent.buildComponent(EfbMainMenuPage, { bus: this.bus, visible: this.pageVisible(EfbPages.MainMenu), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(PilotUtilitiesPage, { bus: this.bus, visible: this.pageVisible(EfbPages.PilotUtilities), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(IDENTPAGE, { bus: this.bus, visible: this.pageVisible(EfbPages.IdentPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(TERMINALCHARTPAGE, { bus: this.bus, visible: this.pageVisible(EfbPages.TerminalCharts), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(B787PerformancePageARPTINFO, { bus: this.bus, visible: this.pageVisible(EfbPages.PerformanceARPTINFO), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(B787LandingPerformancePG, { bus: this.bus, visible: this.pageVisible(EfbPages.LandingPerformancePG), communicationsManager: this.communicationsManager,onPageSelect: (page) => this.visiblePage.set(page), store: this.store, activePerformancePlan: this.activeRoutePerformancePlan, engineDataProvider: this.engineDataProvider, speedDataProvider: this.speedData, takeoffCalculator: this.takeoffCalculator }),
           FSComponent.buildComponent(B787PerformancePageMEL, { bus: this.bus, visible: this.pageVisible(EfbPages.PerformanceMEL), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),  
           
           FSComponent.buildComponent(B787DoorsPageE, { bus: this.bus, visible: this.pageVisible(EfbPages.Doors), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(ENROUTECHARTPAGE, { bus: this.bus, visible: this.pageVisible(EfbPages.EnrouteCharts), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
          // PILOT UTILITY PAGES
          
           FSComponent.buildComponent(EFBCALCULATORPAGE, { bus: this.bus, visible: this.pageVisible(EfbPages.CalculatorPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBTIMERPAGE, { bus: this.bus, visible: this.pageVisible(EfbPages.TimerPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBSCRATCHPAD, { bus: this.bus, visible: this.pageVisible(EfbPages.ScratchpadPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBFUELWEIGHTVOLUMEPG, { bus: this.bus, visible: this.pageVisible(EfbPages.FuelWeightVolPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBFUELVOLUMETOWEIGHTPG, { bus: this.bus, visible: this.pageVisible(EfbPages.FuelVolWeightPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBSPEEDCOVERSIONPG, { bus: this.bus, visible: this.pageVisible(EfbPages.SpeedConversionPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBLENGTHCOVERSIONPG, { bus: this.bus, visible: this.pageVisible(EfbPages.LengthConversionPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBWEIGHTCONVERSIONPG, { bus: this.bus, visible: this.pageVisible(EfbPages.WeightConversionPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBTEMPERATURECONVERSIONPG, { bus: this.bus, visible: this.pageVisible(EfbPages.TemperatureConversionPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBVOLUMECONVERSIONPG, { bus: this.bus, visible: this.pageVisible(EfbPages.VolumeConversionPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           FSComponent.buildComponent(EFBTIMEZONECONVERSIONPG, { bus: this.bus, visible: this.pageVisible(EfbPages.TimeZoneConversionPage), communicationsManager: this.communicationsManager, simvarpush: (index) => this.simvarpush.set(index) }),
           // Data Page
           FSComponent.buildComponent(EfbDataPage, { bus: this.bus, visible: this.pageVisible(EfbPages.dataLOAD), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           // Video Pages
           FSComponent.buildComponent(EfbVideoPage, { bus: this.bus, visible: this.pageVisible(EfbPages.Video), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           
          
          
           FSComponent.buildComponent(EfbVideoLeftPage, { bus: this.bus, visible: this.pageVisible(EfbVideoPages.Left), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbVideoRightPage, { bus: this.bus, visible: this.pageVisible(EfbVideoPages.Right), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbId0Page, { bus: this.bus, visible: this.pageVisible(EfbVideoPages.ShowMenu), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfblshowPage, { bus: this.bus, visible: this.pageVisible(EfbVideoLPages.ShowMenu), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbLeftbmPage, { bus: this.bus, visible: this.pageVisible(EfblshowPages.Bright30), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbLeftbpPage, { bus: this.bus, visible: this.pageVisible(EfblshowPages.Bright50), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbLeftcmPage, { bus: this.bus, visible: this.pageVisible(EfblshowPages.con1), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbLeftcpPage, { bus: this.bus, visible: this.pageVisible(EfblshowPages.con2), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbRightbmPage, { bus: this.bus, visible: this.pageVisible(EfbRshowPages.Bright30), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbRightbpPage, { bus: this.bus, visible: this.pageVisible(EfbRshowPages.Bright50), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbRightcmPage, { bus: this.bus, visible: this.pageVisible(EfbRshowPages.con1), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbRightcpPage, { bus: this.bus, visible: this.pageVisible(EfbRshowPages.con2), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbrshowPage, { bus: this.bus, visible: this.pageVisible(EfbVideoRPages.ShowMenu), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbId1Page, { bus: this.bus, visible: this.pageVisible(EfbIdPages.Bright30), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbId2Page, { bus: this.bus, visible: this.pageVisible(EfbIdPages.Bright50), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(EfbconPage, { bus: this.bus, visible: this.pageVisible(EfbIdPages.con1), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
           FSComponent.buildComponent(Efbcon2Page, { bus: this.bus, visible: this.pageVisible(EfbIdPages.con2), store: this.store, communicationsManager: this.communicationsManager, onPageSelect: (page) => this.visiblePage.set(page) }),
          
          ));
           
   }
   /** @inheritdoc */
   onGameStateChanged() {
       // noop
   }
   /** @inheritdoc */
   getSourceSelectSide() {
       return this.instrument.instrumentIndex === 2 ? 'right' : 'left';
   }
   /** @inheritdoc */
   onFlightStart() {
       // noop
   }
   /** @inheritdoc */
   onSoundEnd() {
       // noop
   }
   /** @inheritdoc */
   onInteractionEvent(hEvent) {
       this.hEventPublisher.dispatchHEvent(hEvent[0]);
   }
   /** @inheritdoc */
   Update() {
       this.backplane.onUpdate();
   }
}




/**
* EFB PilotUtilities page
*/
class PilotUtilitiesPage extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
     
      
       

   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
   render() {
           return (FSComponent.buildComponent("div", { ref: this.containerRef},
           FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
           FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
               
          // FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, onClick: () => this.props.onPageSelect(EfbPages.CalculatorPage),LastEFBPg: "PilotUtilities"},
           
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,isDisabled: true },

           FSComponent.buildComponent("span", null, "CALCULATOR")),

           
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,isDisabled: true },
        
           FSComponent.buildComponent("span", null, "TIMER"),
           FSComponent.buildComponent("span", null, "STOP WATCH")),
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,isDisabled: true },
           

           FSComponent.buildComponent("span", null, "SCRATCHPAD")),
           
           
           FSComponent.buildComponent("div", { class: "efb-main-menu-button-column efb-main-menu-button-column-right" },
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,onClick: () => {this.props.onPageSelect(EfbPages.SpeedConversionPage);LastEFBPg = "PilotUtilities"; }, },
           
        
           FSComponent.buildComponent("span", null, "SPEED"),
           FSComponent.buildComponent("span", null, "CONVERSION")),
          
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,onClick: () => {this.props.onPageSelect(EfbPages.LengthConversionPage);LastEFBPg = "PilotUtilities"; }, },
          
           FSComponent.buildComponent("span", null, "LENGTH"),
           FSComponent.buildComponent("span", null, "CONVERSION")),
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,onClick: () => {this.props.onPageSelect(EfbPages.WeightConversionPage);LastEFBPg = "PilotUtilities"; }, },
         

           FSComponent.buildComponent("span", null, "WEIGHT"),
           FSComponent.buildComponent("span", null, "CONVERSION")),
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,onClick: () => {this.props.onPageSelect(EfbPages.TemperatureConversionPage);LastEFBPg = "PilotUtilities"; }, },
          

           FSComponent.buildComponent("span", null, "TEMPERATURE"),
           FSComponent.buildComponent("span", null, "CONVERSION")),
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,onClick: () => {this.props.onPageSelect(EfbPages.VolumeConversionPage);LastEFBPg = "PilotUtilities"; }, },
          
        
           FSComponent.buildComponent("span", null, "VOLUME"),
           FSComponent.buildComponent("span", null, "CONVERSION")),
           FSComponent.buildComponent(BoeingEfbSideButton, {width: 300,height: 70,isDisabled: true },
           
          
           FSComponent.buildComponent("span", null, "TIME ZONE"),
           FSComponent.buildComponent("span", null, "CONVERSION")),
           ))));
}

   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}

/**
* EFB IDENT page
*/
class IDENTPAGE extends DisplayPaneView {
   
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
       this.datetimeSettingManager = DateTimeUserSettings.getManager(this.props.bus);
       this.timerPublisher = this.props.bus.getPublisher();
       this.timerSubscriber = this.props.bus.getSubscriber();
       this.timeSubject = ConsumerSubject.create(this.props.bus.getSubscriber().on('simTime').whenChangedBy(1000), 0);
       this.timeDisplayFormatSubject = Subject.create(TimeDisplayFormat.UTC);
       this.timeDisplayLocalOffsetSubject = Subject.create(0);
      
       

   }
   
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
  
  render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page2' }, "IDENT"),
       FSComponent.buildComponent("div", {class: "fullsize" },
       FSComponent.buildComponent("div", { class: 'AircraftModel' }, "A/C MODEL:  787-10"),
       FSComponent.buildComponent("div", { class: 'TAILID' }, `TAIL ID:  ${SimVar.GetSimVarValue('ATC ID', SimVarValueType.String)}`),
       
       FSComponent.buildComponent("div", { class: 'DATE' }, 
       "DATE: ", ),
       FSComponent.buildComponent("div", { class: 'DATEREAL' }, 
       FSComponent.buildComponent(DateDisplay, { time: this.timeSubject, localOffset: this.timeDisplayLocalOffsetSubject.get() })),
     
   
       FSComponent.buildComponent("div", { class: 'TIME' }, "TIME: ",),
        
       FSComponent.buildComponent("div", { class: 'TIMEREAL' }, 
       FSComponent.buildComponent(TimeDisplay, { time: this.timeSubject, format: this.timeDisplayFormatSubject, localOffset: this.timeDisplayLocalOffsetSubject,AltFormat: false, })),
       
       FSComponent.buildComponent("div", { class: 'EFBCONNECTIVTYTEXT' }, "EFB EFFECTIVITY CONFIGURATION"),

       
       )));
   } 





   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}

/**
* EFB TERMINALCHARTS page
*/
class TERMINALCHARTPAGE extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
     
      
       

   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "TERMINAL CHARTS"),
       FSComponent.buildComponent("div", {class: "doors-page-container" },
       )));
   }







   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}

/**
* EFB ENROUTECHARTS page
*/
class ENROUTECHARTPAGE extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
       
      
       

   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "ENROUTE CHARTS"),
       FSComponent.buildComponent("div", {class: "doors-page-container" },
       
       FSComponent.buildComponent("div", { class: 'efb-title-page2' }, "CHART CLIP"),
       )));
   }







   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}


/**
* EFB Calculator page
*/
class EFBCALCULATORPAGE extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "CALCULATOR"),
       FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
       )));
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}
/**
* EFB EFBTIMERPAGE page
*/
class EFBTIMERPAGE extends DisplayPaneView {
  
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
       this.Daylight = Subject.create(false);
       this.SelectedTime = Subject.create(null);

       this.InputCOUNTDOWN = Subject.create(true);
       this.InputCOUNTUP = Subject.create(false);
       this.InputAlert = Subject.create(false);
       this.InputHours = Subject.create(null);
       this.InputMinutes = Subject.create(null);
       this.InputSeconds = Subject.create(null);
       this.datetimeSettingManager = DateTimeUserSettings.getManager(this.props.bus);
       this.timerPublisher = this.props.bus.getPublisher();
       this.timerSubscriber = this.props.bus.getSubscriber();
       this.timeSubject = ConsumerSubject.create(this.props.bus.getSubscriber().on('simTime').whenChangedBy(1000), 0);
       this.timeDisplayFormatSubject = Subject.create(TimeDisplayFormat.UTC);
       this.timeDisplayLocalOffsetSubject = Subject.create(0);
       this.typedQnhUnit = Subject.create(UnitType.HPA);
       this.TimerText = FSComponent.createRef();
       this.CurrentInput = Subject.create('KT')
   }

   starttimer (){
if (this.InputHours != null && this.InputMinutes != null && this.InputSeconds != null ){


    }
   }
   handleInputDetection(inputType, newValue) {
       if (newValue) {
           this.CurrentInput.set(inputType);
           
           const inputs = {
               'CountDown': this.InputCOUNTDOWN, 'CountUp': this.InputCOUNTUP, 
           };
           for (const key in inputs) {
               if (key !== inputType) {
                   inputs[key].set(false);
               }
           }
       }
   }
   DetectInput(input, inputType) {
       return input.sub(this.handleInputDetection.bind(this, inputType), true);
   }




   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
       this.subscriptions = [
           
           this.DetectInput.call(this, this.InputCOUNTDOWN, 'CountDown'),
           this.DetectInput.call(this, this.InputCOUNTUP, 'CountUp'),
           

           
       ];
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "STOP WATCH"),


       
       
       FSComponent.buildComponent("div", { class: 'efb-Left-StopWatch-Box' },

       FSComponent.buildComponent(BoeingEfbTextField, { width: 55, height: 50, ref: this.TimerText, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.StopWatchParse, textFieldFormatter: EfbFormatters.TimerStopWatch, bottomTextFormatter: EfbFormatters.BottomTextPressureFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
           
           this.InputHours.set(unit);
          
       }, unitForTextField: this.typedQnhUnit.map((unit) => unit === UnitType.HPA ? '' : '') }),
       
       FSComponent.buildComponent("div", { class: 'efb-Left-StopWatch-Point' },":")) ,
//
       FSComponent.buildComponent("div", { class: 'efb-Middle-StopWatch-Box' },

       FSComponent.buildComponent(BoeingEfbTextField, { width: 55, height: 50, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.StopWatchParse, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
       this.InputMinutes.set(value);
       } }),
       FSComponent.buildComponent("div", { class: 'efb-Middle-StopWatch-Point' },":")),
//
       FSComponent.buildComponent("div", { class: 'efb-Right-StopWatch-Box' },

       FSComponent.buildComponent(BoeingEfbTextField, { width: 55, height: 50, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.StopWatchParse, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
       this.InputSeconds.set(value);
       } }),
       FSComponent.buildComponent("div", { class: 'efb-Center-stopWatch-Box2' },
       FSComponent.buildComponent("div", { class: 'efb-Center-stopwatch-title5' }, "STOP TIME: ")),
       FSComponent.buildComponent("div", { class: 'efb-Center-stopWatch-Box' },
       FSComponent.buildComponent("div", { class: 'efb-Center-stopwatch-title5' }, "CURRENT TIME: "),
       FSComponent.buildComponent("div", { class: 'efb-Center-TimeDisplay2-Box' },
       FSComponent.buildComponent(TimeDisplay, { time: this.timeSubject, format: this.timeDisplayFormatSubject, localOffset: this.timeDisplayLocalOffsetSubject,AltFormat: true, }))),

       FSComponent.buildComponent("div", { class: 'efb-Left-Stopwatch-Button' },
       FSComponent.buildComponent(BoeingEfbSideButton, {width: 124,height: 55,onClick: () => {  this.starttimer(); ; ;LastEFBPg = "PilotUtilities"; }, },
       FSComponent.buildComponent("span", null, "START"))),
       
       FSComponent.buildComponent("div", { class: 'efb-Right-Stopwatch-Button' },
       FSComponent.buildComponent(BoeingEfbSideButton, {width: 124,height: 55,onClick: () => {this.props.onPageSelect(EfbPages.TimeZoneConversionPage);LastEFBPg = "PilotUtilities"; }, },
       FSComponent.buildComponent("span", null, "RESET"))),

     ) ,
     FSComponent.buildComponent("div", { class: 'efb-Left-StopWatch-Box-medium' },
     FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "TIMER MODE"), 
     FSComponent.buildComponent("div", { class: 'efb-Left-TimeZone-Box' }),
     FSComponent.buildComponent("div", { class: 'efb-Leftt-ConversionOption-Box' },
     FSComponent.buildComponent(MenuCheckbox, { label: "COUNT DOWN", ConversionBtn: true, isChecked: this.InputCOUNTDOWN })),
     FSComponent.buildComponent("div", { class: 'efb-Center-ConversionOption-Box' },
     FSComponent.buildComponent(MenuCheckbox, { label: "COUNT UP", ConversionBtn: true, isChecked: this.InputCOUNTUP })),
     FSComponent.buildComponent("div", { class: 'efb-Right-ConversionOption-Box' },
     FSComponent.buildComponent(MenuCheckbox, {width: 30,height: 30, label: "ALERT ON COMPLETION", ConversionBtn: false, isChecked: this.InputAlert })),
     
   
   ),

     
      

   
   ));
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }

}
/**
* EFB SCRATCHPAD page
*/
class EFBSCRATCHPAD extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
           
       }, true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "SCRATCHPAD"),
      
       FSComponent.buildComponent("div", { class: 'efb-Center-ScratchpadPg-Box' },

           FSComponent.buildComponent(BoeingEfbTextBox, { width: 745, height: 400, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: false, onValueChanged: (value) => {
               this.InputValue.set(value);
           } }), 
     
     
       ) ,
       
       
  






    
       ));

       
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}
/**
* EFB EFBFUELWEIGHTVOLUMEPG page
*/
class EFBFUELWEIGHTVOLUMEPG extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "FUEL WEIGHT TO VOLUME CONVERSION"),
       FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
       )));
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}
/**
* EFB EFBFUELWEIGHTVOLUMEPG page
*/
class EFBFUELVOLUMETOWEIGHTPG extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "FUEL VOLUME TO WEIGHT CONVERSION"),
       FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
       )));
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}
/**
* EFB SPEEDCONVERSION page
*/
class EFBSPEEDCOVERSIONPG extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
       this.InputFT = Subject.create(false);this.InputKMH = Subject.create(false);this.InputKT = Subject.create(true);this.InputMPS = Subject.create(false);this.InputMPH = Subject.create(false);
       this.OutputFT = Subject.create(false);this.OutputKMH = Subject.create(false);this.OutputKT = Subject.create(false);this.OutputMPS = Subject.create(false);this.OutputMPH = Subject.create(true);

       this.InputValue = Subject.create(null)
       this.OutputValue = Subject.create(null)
       
       this.CurrentInput = Subject.create('KT')
       this.CurrentOutput = Subject.create('MPH')
       
       this.units = {
           'FT/M': 5468.0664917,
           'KM/H': 100,
           'KT': 53.9957,
           'MPS': 27.7778,
           'MPH': 62.1371,  
      };
   }
   //Output Detection
   handleOutputDetection(outputType, newValue) {
       if (newValue) {
           this.CurrentOutput.set(outputType);
           
           const outputs = {
               'FT/M': this.OutputFT, 'KM/H': this.OutputKMH, 'KT': this.OutputKT, 'MPS': this.OutputMPS, 'MPH': this.OutputMPH
           };
           for (const key in outputs) {
               if (key !== outputType) {
                   outputs[key].set(false);
               }
           }
       }
   }
   DetectOutput(output, outputType) {
       return output.sub(this.handleOutputDetection.bind(this, outputType), true);
   }
   //Input Detection
   handleInputDetection(inputType, newValue) {
       if (newValue) {
           this.CurrentInput.set(inputType);
           
           const inputs = {
               'FT/M': this.InputFT, 'KM/H': this.InputKMH, 'KT': this.InputKT, 'MPS': this.InputMPS, 'MPH': this.InputMPH
           };
           for (const key in inputs) {
               if (key !== inputType) {
                   inputs[key].set(false);
               }
           }
       }
   }
   DetectInput(input, inputType) {
       return input.sub(this.handleInputDetection.bind(this, inputType), true);
   }
   /** @inheritDoc */

   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
       this.subscriptions = [
           this.DetectOutput.call(this, this.OutputFT, 'FT/M'),
           this.DetectOutput.call(this, this.OutputKMH, 'KM/H'),
           this.DetectOutput.call(this, this.OutputKT, 'KT'),
           this.DetectOutput.call(this, this.OutputMPS, 'MPS'),
           this.DetectOutput.call(this, this.OutputMPH, 'MPH'),
           this.DetectInput.call(this, this.InputFT, 'FT/M'),
           this.DetectInput.call(this, this.InputKMH, 'KM/H'),
           this.DetectInput.call(this, this.InputKT, 'KT'),
           this.DetectInput.call(this, this.InputMPS, 'MPS'),
           this.DetectInput.call(this, this.InputMPH, 'MPH'),

           this.DetectInputBox(),
           this.ChangeInOption(),
           this.ChangeInOption2(),
       ];
   }
   calculateOutputValue(inputValue, currentInput, currentOutput, units) {
       if (typeof inputValue === 'number') {
           return (parseFloat(inputValue) / units[currentInput] * units[currentOutput]).toFixed(2);
       } else {
           return "- - - -";
       }
   }
   
   updateOutputValue() {
       const inputValue = this.InputValue.get();
       const currentInput = this.CurrentInput.get();
       const currentOutput = this.CurrentOutput.get();
       const units = this.units;
   
      
       const outputValue = this.calculateOutputValue(inputValue, currentInput, currentOutput, units);
   
      
       const outputWithUnit = `${outputValue} ${currentOutput}`;
   
       
       if (this.OutputValue != null ){
           this.OutputValue.set(outputWithUnit);
       }
       else{
           this.OutputValue.set(currentOutput);
       }
       
   }
   
   ChangeInOption() {
       return this.CurrentInput.sub(this.updateOutputValue.bind(this), true);
   }
   
   ChangeInOption2() {
       return this.CurrentOutput.sub(this.updateOutputValue.bind(this), true);
   }
   
   DetectInputBox() {
       return this.InputValue.sub(this.updateOutputValue.bind(this), true);
   }
   
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "SPEED CONVERSION"),
       FSComponent.buildComponent("div", { class: 'efb-Left-Conversion-Box' },
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "INPUT UNIT"), 
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
           FSComponent.buildComponent(MenuCheckbox, { label: "FT/M", ConversionBtn: true, isChecked: this.InputFT  })),
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
           FSComponent.buildComponent(MenuCheckbox, { label: "KM/H", ConversionBtn: true, isChecked: this.InputKMH })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box3' },
           FSComponent.buildComponent(MenuCheckbox, { label: "KT", ConversionBtn: true, isChecked: this.InputKT })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box4' },
           FSComponent.buildComponent(MenuCheckbox, { label: "MPS", ConversionBtn: true, isChecked: this.InputMPS })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box5' },
           FSComponent.buildComponent(MenuCheckbox, { label: "MPH", ConversionBtn: true, isChecked: this.InputMPH })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box6' },
           FSComponent.buildComponent(BoeingEfbTextField, { width: 245, height: 35, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
           this.InputValue.set(value);
       } })),), 
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box' }, 
        FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "OUTPUT UNIT"), 
           FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
           FSComponent.buildComponent(MenuCheckbox, { label: "FT/M", ConversionBtn: true, isChecked: this.OutputFT })),
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
           FSComponent.buildComponent(MenuCheckbox, { label: "KM/H", ConversionBtn: true, isChecked: this.OutputKMH })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box3' },
           FSComponent.buildComponent(MenuCheckbox, { label: "KT", ConversionBtn: true, isChecked: this.OutputKT })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box4' },
           FSComponent.buildComponent(MenuCheckbox, { label: "MPS", ConversionBtn: true, isChecked: this.OutputMPS })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box5' },
           FSComponent.buildComponent(MenuCheckbox, { label: "MPH", ConversionBtn: true, isChecked: this.OutputMPH })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box6' },
           FSComponent.buildComponent("div", { class: 'efb-middle-top-left3-title' }, this.OutputValue),) 
    )));
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}
/**
* EFB LENGTHCONVERSION page
*/
class EFBLENGTHCOVERSIONPG extends DisplayPaneView {
  
    /** @inheritDoc */
    constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
       this.InputFEET = Subject.create(true);this.InputKILO = Subject.create(false);this.InputMETER = Subject.create(false);this.InputNAUTICMILE = Subject.create(false);this.InputSTATUTEMILE = Subject.create(false);
       this.OutputFEET = Subject.create(false);this.OutputKILO = Subject.create(false);this.OutputMETER = Subject.create(true);this.OutputNAUTICMILE = Subject.create(false);this.OutputSTATUTEMILE = Subject.create(false);
       this.InputValue = Subject.create(null)
       this.OutputValue = Subject.create(null)
       this.CurrentInput = Subject.create('FT')
       this.CurrentOutput = Subject.create('M')
       this.units = {
           'FT': 3.28084,
           'KM': 0.001,
           'M': 1,
           'NM': 0.000539957,
           'MI': 0.000621371,  
      };
   }
       //Output Detection
       handleOutputDetection(outputType, newValue) {
           if (newValue) {
               this.CurrentOutput.set(outputType);
               
               const outputs = {
                   'FT': this.OutputFEET, 'KM': this.OutputKILO, 'M': this.OutputMETER, 'NM': this.OutputNAUTICMILE, 'MI': this.OutputSTATUTEMILE
               };
               for (const key in outputs) {
                   if (key !== outputType) {
                       outputs[key].set(false);
                   }
               }
           }
       }
       DetectOutput(output, outputType) {
           return output.sub(this.handleOutputDetection.bind(this, outputType), true);
       }
       //Input Detection
       handleInputDetection(inputType, newValue) {
           if (newValue) {
               this.CurrentInput.set(inputType);
               
               const inputs = {
                   'FT': this.InputFEET, 'KM': this.InputKILO, 'M': this.InputMETER, 'NM': this.InputNAUTICMILE, 'MI': this.InputSTATUTEMILE
               };
               for (const key in inputs) {
                   if (key !== inputType) {
                       inputs[key].set(false);
                   }
               }
           }
       }
       DetectInput(input, inputType) {
           return input.sub(this.handleInputDetection.bind(this, inputType), true);
       }



   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
       this.subscriptions = [
           this.DetectOutput.call(this, this.OutputFEET, 'FT'),
           this.DetectOutput.call(this, this.OutputKILO, 'KM'),
           this.DetectOutput.call(this, this.OutputMETER, 'M'),
           this.DetectOutput.call(this, this.OutputNAUTICMILE, 'NM'),
           this.DetectOutput.call(this, this.OutputSTATUTEMILE, 'MI'),
           this.DetectInput.call(this, this.InputFEET, 'FT'),
           this.DetectInput.call(this, this.InputKILO, 'KM'),
           this.DetectInput.call(this, this.InputMETER, 'M'),
           this.DetectInput.call(this, this.InputNAUTICMILE, 'NM'),
           this.DetectInput.call(this, this.InputSTATUTEMILE, 'MI'),

           this.DetectInputBox(),
           this.ChangeInOption(),
           this.ChangeInOption2(),
       ];
   }
   calculateOutputValue(inputValue, currentInput, currentOutput, units) {
       if (typeof inputValue === 'number') {
           return (parseFloat(inputValue) / units[currentInput] * units[currentOutput]).toFixed(3);
       } else {
           return "- - - -";
       }
   }
   
   updateOutputValue() {
       const inputValue = this.InputValue.get();
       const currentInput = this.CurrentInput.get();
       const currentOutput = this.CurrentOutput.get();
       const units = this.units;
   
      
       const outputValue = this.calculateOutputValue(inputValue, currentInput, currentOutput, units);
   
     
       const outputWithUnit = `${outputValue} ${currentOutput}`;
   
      
       if (this.OutputValue != null ){
           this.OutputValue.set(outputWithUnit);
       }
       else{
           this.OutputValue.set(currentOutput);
       }
       
   }
   
   ChangeInOption() {
       return this.CurrentInput.sub(this.updateOutputValue.bind(this), true);
   }
   
   ChangeInOption2() {
       return this.CurrentOutput.sub(this.updateOutputValue.bind(this), true);
   }
   
   DetectInputBox() {
       return this.InputValue.sub(this.updateOutputValue.bind(this), true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "LENGTH CONVERSION"),
       
       FSComponent.buildComponent("div", { class: 'efb-Left-Conversion-Box' },
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "INPUT UNIT"), 

       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
           FSComponent.buildComponent(MenuCheckbox, { label: "FEET", ConversionBtn: true, isChecked: this.InputFEET })),
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
           FSComponent.buildComponent(MenuCheckbox, { label: "KILOMETERS", ConversionBtn: true, isChecked: this.InputKILO })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box3' },
           FSComponent.buildComponent(MenuCheckbox, { label: "METERS", ConversionBtn: true, isChecked: this.InputMETER })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box4' },
           FSComponent.buildComponent(MenuCheckbox, { label: "NAUTICAL MILES", ConversionBtn: true, isChecked: this.InputNAUTICMILE })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box5' },
           FSComponent.buildComponent(MenuCheckbox, { label: "STATUTE MILES", ConversionBtn: true, isChecked: this.InputSTATUTEMILE })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box6' },
           FSComponent.buildComponent(BoeingEfbTextField, { width: 245, height: 35, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
           this.InputValue.set(value);
       } })),
       
       ), 
       
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box' }, 
           FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "OUTPUT UNIT"), 
           FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
           FSComponent.buildComponent(MenuCheckbox, { label: "FEET", ConversionBtn: true, isChecked: this.OutputFEET })),
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
           FSComponent.buildComponent(MenuCheckbox, { label: "KILOMETERS", ConversionBtn: true, isChecked: this.OutputKILO })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box3' },
           FSComponent.buildComponent(MenuCheckbox, { label: "METERS", ConversionBtn: true, isChecked: this.OutputMETER })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box4' },
           FSComponent.buildComponent(MenuCheckbox, { label: "NAUTICAL MILES", ConversionBtn: true, isChecked: this.OutputNAUTICMILE })) ,
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box5' },
           FSComponent.buildComponent(MenuCheckbox, { label: "STATUTE MILES", ConversionBtn: true, isChecked: this.OutputSTATUTEMILE })) ,
           FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box6' },
               FSComponent.buildComponent("div", { class: 'efb-middle-top-left3-title' }, this.OutputValue),)  

       )));
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}
/**
* EFB WEIGHTCONVERSION page
*/
class EFBWEIGHTCONVERSIONPG extends DisplayPaneView {
  
  /** @inheritDoc */
  constructor() {
   super(...arguments);
   this.containerRef = FSComponent.createRef();
   this.InputKILOGRAMS = Subject.create(false);this.InputPOUNDS = Subject.create(true);
   this.OutputKILOGRAMS = Subject.create(true);this.OutputPOUNDS= Subject.create(false);
   this.InputValue = Subject.create(null)
   this.OutputValue = Subject.create(null)
   this.CurrentInput = Subject.create('LBS')
   this.CurrentOutput = Subject.create('KG')
   this.units = {
       'KG': 1,
       'LBS': 2.20462,
        
  };
 
}
//Output Detection
handleOutputDetection(outputType, newValue) {
   if (newValue) {
       this.CurrentOutput.set(outputType);
       
       const outputs = {
           'KG': this.OutputKILOGRAMS, 'LBS': this.OutputPOUNDS, 
       };
       for (const key in outputs) {
           if (key !== outputType) {
               outputs[key].set(false);
           }
       }
   }
}
DetectOutput(output, outputType) {
   return output.sub(this.handleOutputDetection.bind(this, outputType), true);
}
//Input Detection
handleInputDetection(inputType, newValue) {
   if (newValue) {
       this.CurrentInput.set(inputType);
       
       const inputs = {
           'KG': this.InputKILOGRAMS, 'LBS': this.InputPOUNDS, 
       };
       for (const key in inputs) {
           if (key !== inputType) {
               inputs[key].set(false);
           }
       }
   }
}
DetectInput(input, inputType) {
   return input.sub(this.handleInputDetection.bind(this, inputType), true);
}


/** @inheritDoc */
onAfterRender(node) {
   super.onAfterRender(node);
   this.props.visible.sub((visible) => {
       this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
   }, true);
   this.subscriptions = [
       this.DetectOutput.call(this, this.OutputKILOGRAMS, 'KG'),
       this.DetectOutput.call(this, this.OutputPOUNDS, 'LBS'),
       
       this.DetectInput.call(this, this.InputKILOGRAMS, 'KG'),
       this.DetectInput.call(this, this.InputPOUNDS, 'LBS'),
       

       this.DetectInputBox(),
       this.ChangeInOption(),
       this.ChangeInOption2(),
   ];
}
calculateOutputValue(inputValue, currentInput, currentOutput, units) {
   if (typeof inputValue === 'number') {
       return (parseFloat(inputValue) / units[currentInput] * units[currentOutput]).toFixed(2);
   } else {
       return "- - - -";
   }
}

updateOutputValue() {
   const inputValue = this.InputValue.get();
   const currentInput = this.CurrentInput.get();
   const currentOutput = this.CurrentOutput.get();
   const units = this.units;

  
   const outputValue = this.calculateOutputValue(inputValue, currentInput, currentOutput, units);

  
   const outputWithUnit = `${outputValue} ${currentOutput}`;

   
   if (this.OutputValue != null ){
       this.OutputValue.set(outputWithUnit);
   }
   else{
       this.OutputValue.set(currentOutput);
   }
   
}

ChangeInOption() {
   return this.CurrentInput.sub(this.updateOutputValue.bind(this), true);
}

ChangeInOption2() {
   return this.CurrentOutput.sub(this.updateOutputValue.bind(this), true);
}

DetectInputBox() {
   return this.InputValue.sub(this.updateOutputValue.bind(this), true);
}


render() {
   return (FSComponent.buildComponent("div", { ref: this.containerRef},
   FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
   FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "WEIGHT CONVERSION"),
   
   FSComponent.buildComponent("div", { class: 'efb-Left-Conversion-Box-small' },
   FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "INPUT UNIT"), 

   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
       FSComponent.buildComponent(MenuCheckbox, { label: "KILOGRAMS", ConversionBtn: true, isChecked: this.InputKILOGRAMS })),
   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
       FSComponent.buildComponent(MenuCheckbox, { label: "POUNDS", ConversionBtn: true, isChecked: this.InputPOUNDS })) ,
  
   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box7' },
       FSComponent.buildComponent(BoeingEfbTextField, {  width: 245, height: 35,ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
       this.InputValue.set(value);
   } })),
   
   ), 
   
   FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-small' }, 
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "OUTPUT UNIT"), 
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
       FSComponent.buildComponent(MenuCheckbox, { label: "KILOGRAMS", ConversionBtn: true, isChecked: this.OutputKILOGRAMS })),
   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
       FSComponent.buildComponent(MenuCheckbox, { label: "POUNDS", ConversionBtn: true, isChecked: this.OutputPOUNDS })) ,
   
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box7' },
       FSComponent.buildComponent("div", { class: 'efb-middle-top-left3-title' }, this.OutputValue),)  

)));
}
/** @inheritdoc */
destroy() {
   this.subs.forEach(sub => sub.destroy());
}
}
/**
* EFB TEMPERATURECONVERSION page
*/
class EFBTEMPERATURECONVERSIONPG extends DisplayPaneView {
  
  /** @inheritDoc */
  constructor() {
   super(...arguments);
   this.containerRef = FSComponent.createRef();
   this.InputCELCIUS = Subject.create(false);this.InputFAHRENHEIT = Subject.create(true);
   this.OutputCELCIUS = Subject.create(true);this.OutputFAHRENHEIT= Subject.create(false);
   this.InputValue = Subject.create(null)
       this.OutputValue = Subject.create(null)
       this.CurrentInput = Subject.create('°F')
       this.CurrentOutput = Subject.create('°C')
       

 
}
//Output Detection
handleOutputDetection(outputType, newValue) {
   if (newValue) {
       this.CurrentOutput.set(outputType);
       
       const outputs = {
           '°F': this.OutputFAHRENHEIT, '°C': this.OutputCELCIUS
       };
       for (const key in outputs) {
           if (key !== outputType) {
               outputs[key].set(false);
           }
       }
   }
}
DetectOutput(output, outputType) {
   return output.sub(this.handleOutputDetection.bind(this, outputType), true);
}
//Input Detection
handleInputDetection(inputType, newValue) {
   if (newValue) {
       this.CurrentInput.set(inputType);
       
       const inputs = {
           '°F': this.InputFAHRENHEIT, '°C': this.InputCELCIUS, 
       };
       for (const key in inputs) {
           if (key !== inputType) {
               inputs[key].set(false);
           }
       }
   }
}
DetectInput(input, inputType) {
   return input.sub(this.handleInputDetection.bind(this, inputType), true);
}

/** @inheritDoc */
onAfterRender(node) {
   super.onAfterRender(node);
   this.props.visible.sub((visible) => {
       this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
   }, true);
   this.subscriptions = [
       this.DetectOutput.call(this, this.OutputFAHRENHEIT, '°F'),
       this.DetectOutput.call(this, this.OutputCELCIUS, '°C'),
      

       this.DetectInput.call(this, this.InputFAHRENHEIT, '°F'),
       this.DetectInput.call(this, this.InputCELCIUS, '°C'),
      

       this.DetectInputBox(),
       this.ChangeInOption(),
       this.ChangeInOption2(),
   ];
}
calculateOutputValue(inputValue, currentInput, currentOutput, units) {
   if (typeof inputValue === 'number') {
       if (currentInput === '°C' && currentOutput === '°F') {
         
           return ((inputValue * 9/5) + 32).toFixed(2);
       } else if (currentInput === '°F' && currentOutput === '°C') {
          
           return ((inputValue - 32) * 5/9).toFixed(2);
       } else {
           return inputValue
       }
   } else {
       return "- - - -";
   }
}


updateOutputValue() {
   const inputValue = this.InputValue.get();
   const currentInput = this.CurrentInput.get();
   const currentOutput = this.CurrentOutput.get();
   const units = this.units;

  
   const outputValue = this.calculateOutputValue(inputValue, currentInput, currentOutput, units);

  
   const outputWithUnit = `${outputValue} ${currentOutput}`;

   
   if (this.OutputValue != null ){
       this.OutputValue.set(outputWithUnit);
   }
   else{
       this.OutputValue.set(currentOutput);
   }
   
}

ChangeInOption() {
   return this.CurrentInput.sub(this.updateOutputValue.bind(this), true);
}

ChangeInOption2() {
   return this.CurrentOutput.sub(this.updateOutputValue.bind(this), true);
}

DetectInputBox() {
   return this.InputValue.sub(this.updateOutputValue.bind(this), true);
}


render() {
   return (FSComponent.buildComponent("div", { ref: this.containerRef},
   FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
   FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "TEMPERATURE CONVERSION"),
   
   FSComponent.buildComponent("div", { class: 'efb-Left-Conversion-Box-small' },
   FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "INPUT UNIT"), 

   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
       FSComponent.buildComponent(MenuCheckbox, { label: "CELCIUS (°C)", ConversionBtn: true, isChecked: this.InputCELCIUS })),
   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
       FSComponent.buildComponent(MenuCheckbox, { label: "FAHRENHEIT (°F)", ConversionBtn: true, isChecked: this.InputFAHRENHEIT })) ,
  
   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box7' },
       FSComponent.buildComponent(BoeingEfbTextField, { width: 245, height: 35, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
       this.InputValue.set(value);
   } })),
   
   ), 
   
   FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-small' }, 
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "OUTPUT UNIT"), 
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
       FSComponent.buildComponent(MenuCheckbox, { label: "CELCIUS (°C)", ConversionBtn: true, isChecked: this.OutputCELCIUS })),
   FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
       FSComponent.buildComponent(MenuCheckbox, { label: "FAHRENHEIT (°F)", ConversionBtn: true, isChecked: this.OutputFAHRENHEIT })) ,
   
       FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box7' },
       FSComponent.buildComponent("div", { class: 'efb-middle-top-left3-title' }, this.OutputValue),)   

   )));
}
/** @inheritdoc */
destroy() {
   this.subs.forEach(sub => sub.destroy());
}
}
/**
* EFB VOLUMECONVERSION page
*/
class EFBVOLUMECONVERSIONPG extends DisplayPaneView {
  
   /** @inheritDoc */
constructor() {
super(...arguments);
this.containerRef = FSComponent.createRef();
this.InputIMPALGALL = Subject.create(false);this.InputUSGALL = Subject.create(false);this.InputLITRES = Subject.create(true);
this.OutputIMPALGALL = Subject.create(false);this.OutputUSGALL= Subject.create(true);this.OutputLITRES = Subject.create(false);
this.InputValue = Subject.create(null)
this.OutputValue = Subject.create(null)
this.CurrentInput = Subject.create('L')
this.CurrentOutput = Subject.create('US GAL')
this.units = {
    'IMP GAL': 0.832674,
    'US GAL': 1,
    'L': 3.78541,
     
};
}
//Output Detection
handleOutputDetection(outputType, newValue) {
if (newValue) {
    this.CurrentOutput.set(outputType);
    
    const outputs = {
        'IMP GAL': this.OutputIMPALGALL, 'US GAL': this.OutputUSGALL, 'L': this.OutputLITRES,
    };
    for (const key in outputs) {
        if (key !== outputType) {
            outputs[key].set(false);
        }
    }
}
}
DetectOutput(output, outputType) {
return output.sub(this.handleOutputDetection.bind(this, outputType), true);
}
//Input Detection
handleInputDetection(inputType, newValue) {
if (newValue) {
    this.CurrentInput.set(inputType);
    
    const inputs = {
        'IMP GAL': this.InputIMPALGALL, 'US GAL': this.InputUSGALL, 'L': this.InputLITRES, 
    };
    for (const key in inputs) {
        if (key !== inputType) {
            inputs[key].set(false);
        }
    }
}
}
DetectInput(input, inputType) {
return input.sub(this.handleInputDetection.bind(this, inputType), true);
}

/** @inheritDoc */
onAfterRender(node) {
super.onAfterRender(node);
this.props.visible.sub((visible) => {
    this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
}, true);
this.subscriptions = [
    this.DetectOutput.call(this, this.OutputIMPALGALL, 'IMP GAL'),
    this.DetectOutput.call(this, this.OutputUSGALL, 'US GAL'),
    this.DetectOutput.call(this, this.OutputLITRES, 'L'),
    
    this.DetectInput.call(this, this.InputIMPALGALL, 'IMP GAL'),
    this.DetectInput.call(this, this.InputUSGALL, 'US GAL'),
    this.DetectInput.call(this, this.InputLITRES, 'L'),
    

    this.DetectInputBox(),
    this.ChangeInOption(),
    this.ChangeInOption2(),
];
}
calculateOutputValue(inputValue, currentInput, currentOutput, units) {
if (typeof inputValue === 'number') {
    return (parseFloat(inputValue) / units[currentInput] * units[currentOutput]).toFixed(2);
} else {
    return "- - - -";
}
}


updateOutputValue() {
   const inputValue = this.InputValue.get();
   const currentInput = this.CurrentInput.get();
   const currentOutput = this.CurrentOutput.get();
   const units = this.units;

   
   const outputValue = this.calculateOutputValue(inputValue, currentInput, currentOutput, units);

   
   const outputWithUnit = `${outputValue} ${currentOutput}`;

   
   if (this.OutputValue != null ){
       this.OutputValue.set(outputWithUnit);
   }
   else{
       this.OutputValue.set(currentOutput);
   }
   
}

ChangeInOption() {
   return this.CurrentInput.sub(this.updateOutputValue.bind(this), true);
}

ChangeInOption2() {
   return this.CurrentOutput.sub(this.updateOutputValue.bind(this), true);
}

DetectInputBox() {
   return this.InputValue.sub(this.updateOutputValue.bind(this), true);
}

render() {
return (FSComponent.buildComponent("div", { ref: this.containerRef},
FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "VOLUME CONVERSION"),

FSComponent.buildComponent("div", { class: 'efb-Left-Conversion-Box-medium' },
FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "INPUT UNIT"), 

FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
    FSComponent.buildComponent(MenuCheckbox, { label: "IMPERIAL GALLONS", ConversionBtn: true, isChecked: this.InputIMPALGALL })),
FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
    FSComponent.buildComponent(MenuCheckbox, { label: "US GALLONS", ConversionBtn: true, isChecked: this.InputUSGALL })) ,
FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box3' },
    FSComponent.buildComponent(MenuCheckbox, { label: "LITRES", ConversionBtn: true, isChecked: this.InputLITRES })) ,    

FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box8' },
    FSComponent.buildComponent(BoeingEfbTextField, { width: 245, height: 35, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
    this.InputValue.set(value);
} })),

), 

FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-medium' }, 
    FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "OUTPUT UNIT"), 
    FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box' },
    FSComponent.buildComponent(MenuCheckbox, { label: "IMPERIAL GALLONS", ConversionBtn: true, isChecked: this.OutputIMPALGALL })),
FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box2' },
    FSComponent.buildComponent(MenuCheckbox, { label: "US GALLONS", ConversionBtn: true, isChecked: this.OutputUSGALL })) ,
FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box3' },
    FSComponent.buildComponent(MenuCheckbox, { label: "LITRES", ConversionBtn: true, isChecked: this.OutputLITRES })) ,

    FSComponent.buildComponent("div", { class: 'efb-Left-ConversionOption-Box8' },
    FSComponent.buildComponent("div", { class: 'efb-middle-top-left3-title' }, this.OutputValue),)   

)));
}
/** @inheritdoc */
destroy() {
this.subs.forEach(sub => sub.destroy());
}
}
/**
* EFB TIMEZONECONVERSION page
*/
class EFBTIMEZONECONVERSIONPG extends DisplayPaneView {
  
   /** @inheritDoc */
   constructor() {
       super(...arguments);
       this.containerRef = FSComponent.createRef();
       this.Daylight = Subject.create(false);
       this.SelectedTime = Subject.create(null);
       this.ZonesList = ArraySubject.create([
           EFBTIMEZONES.UTC,
           EFBTIMEZONES.GMT,
           EFBTIMEZONES.GMT1,
           EFBTIMEZONES.GMT2,
           EFBTIMEZONES.GMT3,
          
       ]);
       this.datetimeSettingManager = DateTimeUserSettings.getManager(this.props.bus);
       this.timerPublisher = this.props.bus.getPublisher();
       this.timerSubscriber = this.props.bus.getSubscriber();
       this.timeSubject = ConsumerSubject.create(this.props.bus.getSubscriber().on('simTime').whenChangedBy(1000), 0);
       this.timeDisplayFormatSubject = Subject.create(TimeDisplayFormat.UTC);
       this.timeDisplayLocalOffsetSubject = Subject.create(0);
   }
   /** @inheritDoc */
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
  
   render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef},
       FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PILOT UTILITIES"),
       FSComponent.buildComponent("div", { class: 'efb-title-page3' }, "TIME ZONE CONVERSION"),

       FSComponent.buildComponent("div", { class: 'efb-Left-TimeZone-Box-medium' },
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title' }, "INPUT TIME"), 
       FSComponent.buildComponent("div", { class: 'efb-Left-TimeZone-Box' },

       FSComponent.buildComponent(BoeingEfbTextField, { width: 60, height: 45, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
       this.InputValue.set(value);
       } })),

       FSComponent.buildComponent("div", { class: 'efb-Center-Timezone-title' }, ":"), 
       FSComponent.buildComponent("div", { class: 'efb-Center-Timezone-title2' }, "HH:MMZ"), 
       FSComponent.buildComponent("div", { class: 'efb-Right-TimeZone-Box' },

       FSComponent.buildComponent(BoeingEfbTextField, { width: 60, height: 45, ref: this.atmTextFieldRef, buttonName: '', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
       this.InputValue.set(value);
        } })),
        FSComponent.buildComponent("div", { class: 'efb-Center-Timezone-Box' },
       FSComponent.buildComponent(MenuCheckbox, { label: "ADJUST TIME FOR DAYLIGHT", width: 36,height: 36,ConversionBtn: false, isChecked: this.Daylight })),
       FSComponent.buildComponent("div", { class: 'efb-Center-Timezone-title3' }, "CURRENT DATE/TIME: "),
       FSComponent.buildComponent("div", { class: 'efb-Center-TimeDisplay-Box' },
       FSComponent.buildComponent(TimeDisplay, { time: this.timeSubject, format: this.timeDisplayFormatSubject, localOffset: this.timeDisplayLocalOffsetSubject,AltFormat: true, })),

       FSComponent.buildComponent("div", { class: 'efb-Center-DateDisplay-Box' },
       FSComponent.buildComponent(DateDisplay, { time: this.timeSubject, localOffset: this.timeDisplayLocalOffsetSubject.get() }),
      
      
   ), 
       
      
      
       ),
       FSComponent.buildComponent("div", { class: 'efb-Left-TimeZone-Box-large' },
       FSComponent.buildComponent("div", { class: 'efb-Right-Conversion-Box-title2' }, "OUTPUT TIME"), 
       FSComponent.buildComponent("div", { class: 'efb-Center-Timezone-title4' }, "16:25"), 
       FSComponent.buildComponent("div", { class: 'efb-Center-Timezone-title5' }, "HH:MM"), 
       FSComponent.buildComponent("div", { class: 'efb-Center-Timezone-title6' }, "CURRENT CONVERTED TIME: "), 
       FSComponent.buildComponent("div", { class: 'efb-TimeZone-DropDown-Box' },
       FSComponent.buildComponent(BoeingEfbLargeDropdownButton, {  width: 580, height: 60,dropdownItems: this.ZonesList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: '', isNameOnLeftSide: false, dropDownDefaultName: '(UTC) Coordinated Universal Time', onItemSelected: (TimeZone) => this.SelectedTime.set(TimeZone) })),
       )));
   }
   /** @inheritdoc */
   destroy() {
       this.subs.forEach(sub => sub.destroy());
   }
}


class B787PerformancePageMEL extends DisplayComponent {
   constructor () {
       super(...arguments)
       this.containerRef = FSComponent.createRef()
   }
   onAfterRender(node) {
       super.onAfterRender(node);
       this.props.visible.sub((visible) => {
           this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
       }, true);
   }
   
    render() {
       return (FSComponent.buildComponent("div", { ref: this.containerRef },
           FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PERFORMANCE-MEL"),
           FSComponent.buildComponent("div", { class: 'efb-right-side' },
               FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                   FSComponent.buildComponent("span", null, "COMPLETE")),
               FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                   FSComponent.buildComponent("span", null, "CANCEL")),
               FSComponent.buildComponent(BoeingEfbSideButton, { onClick: ()=> this.props.onPageSelect()},
                   FSComponent.buildComponent("span", null, "MEL")),
                   FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                   FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                   FSComponent.buildComponent("div", { class: "efb-main-mel-blankR" }),
               FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                   FSComponent.buildComponent("span", null, "CLEAR")),),
           FSComponent.buildComponent("div", { class: 'efb-middle' },)))
}
}


class B787PerformancePageARPTINFO extends DisplayPaneView {
   
   
    /** @inheritDoc */
    constructor() {
        super(...arguments);
      
 
        this.containerRef = FSComponent.createRef();
        this.ARPTName = Subject.create('');
        this.RWYName = Subject.create('');
        this.RWyslope = Subject.create('');
        this.RWyLength = Subject.create('');
        this.RWyElev = Subject.create('');
        this.rwyident = Subject.create('');
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        this.props.visible.sub((visible) => {
            this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
        }, true);
     this.props.store.flightInitializationDataAcceptedEvent.on(this.UpdateData.bind(this));
     this.props.store.FlightDataUpdate.on(this.UpdateData.bind(this));
    }
  
    UpdateData() {
     
        
         this.ARPTName.set(this.props.store.airportOrigin.get().substring(6));
         const takeoffRunway = this.props.store.takeoffRunway.get();
         takeoffRunway !== null && this.RWYName.set(takeoffRunway);
         this.rwyident.set(RunwayUtils.getRunwayNameString(takeoffRunway.direction, takeoffRunway.runwayDesignator));
         this.RWyslope.set(parseFloat(takeoffRunway.gradient).toFixed(2))
         this.RWyLength.set(Math.round(parseFloat(takeoffRunway.length)*3.28084))
         this.RWyElev.set(Math.round(parseFloat(takeoffRunway.elevation)*3.28084))   
 }
 
 
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef},
        FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PERFORMANCE - AIRPORT DATA"),
       
        FSComponent.buildComponent("div", { class: 'efb-left-side' },
        FSComponent.buildComponent(BoeingEfbSideButton, {  isDisabled: false },
        FSComponent.buildComponent("span", null, "ARPT"),
        FSComponent.buildComponent("span", null, "INFO")),
        FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
            FSComponent.buildComponent("span", null, "ADD"),
            FSComponent.buildComponent("span", null, "ARPT")),
        FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
            FSComponent.buildComponent("span", null, "NOTAMS")),
        FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
            FSComponent.buildComponent("span", null, "SHOW"),
            FSComponent.buildComponent("span", null, "KYBD")),
        FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
            FSComponent.buildComponent("span", null, "WT AND"),
            FSComponent.buildComponent("span", null, "BALANCE")),
        FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
            FSComponent.buildComponent("span", null, "SHOW"),
            FSComponent.buildComponent("span", null, "LANDING")),
        FSComponent.buildComponent(BoeingEfbSideButton, {  isDisabled: true },
            FSComponent.buildComponent("span", null, "COPY"),
            FSComponent.buildComponent("span", null, "FMC DATA")),
        FSComponent.buildComponent(BoeingEfbSideButton, {  isDisabled: true },
            FSComponent.buildComponent("span", null, "SEND"),
            FSComponent.buildComponent("span", null, "OUTPUT"))),
 
        FSComponent.buildComponent("div", { class: 'efb-right-side' },
        
        FSComponent.buildComponent(BoeingEfbSideButton, {  onClick: () => this.props.onPageSelect(EfbPages.Performance) },
            FSComponent.buildComponent("span", null, "OK")),
        FSComponent.buildComponent(BoeingEfbSideButton, {  isDisabled: true },
            FSComponent.buildComponent("span", null, "ARPT"),    
            FSComponent.buildComponent("span", null, "COMMENT")),    
        FSComponent.buildComponent(BoeingEfbSideButton, {  isDisabled: true },
            FSComponent.buildComponent("span", null, "RWY"),    
            FSComponent.buildComponent("span", null, "COMMENT")),   
            FSComponent.buildComponent("div", { class: "efb-main-menu2-blank" }),
        FSComponent.buildComponent(BoeingEfbSideButton, {  isDisabled: true },
            FSComponent.buildComponent("span", null, "ACTIVE"),    
            FSComponent.buildComponent("span", null, "NOTAMS")),   
        FSComponent.buildComponent(BoeingEfbSideButton, {  isDisabled: true },
            FSComponent.buildComponent("span", null, "INTX"))),
 
        FSComponent.buildComponent("div", { class: 'efb-middleARPT' },
 
        FSComponent.buildComponent("div", { class: 'efb-Data-Airport' },
        FSComponent.buildComponent(BoeingEfbDynamicLabel, { Name: this.ARPTName,width: 70,Smaller: false  })),
        FSComponent.buildComponent("div", { class: 'efb-Data-Elevation' },
        FSComponent.buildComponent(BoeingEfbDynamicLabel, { Name: this.RWyElev , width: 200 ,SecondaryText: "Elevation:",Smaller: true,TertiaryText: "ft" })),
        
 
      ),
        
        
     FSComponent.buildComponent("div", { class: 'efb-middleRNW1' },   
     FSComponent.buildComponent("div", { class: 'efb-Data-Runway' },
         FSComponent.buildComponent(BoeingEfbDynamicLabel, { Name: this.rwyident, width: 130, SecondaryText: "Runway", Smaller: false })
     ),
     FSComponent.buildComponent("div", { class: 'efb-Data-TORA' },
     FSComponent.buildComponent(BoeingEfbDynamicLabel, { Name: this.RWyLength , width: 200 ,SecondaryText: "TORA:",Smaller: true,TertiaryText: "ft" }),
     ),
     FSComponent.buildComponent("div", { class: 'efb-Data-TODA' },
     FSComponent.buildComponent(BoeingEfbDynamicLabel, {  width: 200 ,SecondaryText: "TODA:",Smaller: true,}),
     ),
     FSComponent.buildComponent("div", { class: 'efb-Data-ASDA' },
     FSComponent.buildComponent(BoeingEfbDynamicLabel, {  Name: this.RWyLength , width: 200 ,SecondaryText: "ADSA:",Smaller: true,TertiaryText: "ft" }),
     ),
     FSComponent.buildComponent("div", { class: 'efb-Data-Slope' },
     FSComponent.buildComponent(BoeingEfbDynamicLabel, {  Name: this.RWyslope , width: 200 ,SecondaryText: "Slope:",Smaller: true,TertiaryText: "%" }),
     ),
     FSComponent.buildComponent("div", { class: 'efb-Data-LDA' },
     FSComponent.buildComponent(BoeingEfbDynamicLabel, {  Name: this.RWyLength , width: 200 ,SecondaryText: "LDA:",Smaller: true,TertiaryText: "ft" }),
     ),
    
  
 )));
    }
 
 
 
 
 
    
    /** @inheritdoc */
    destroy() {
        this.subs.forEach(sub => sub.destroy());
    }
 }




class B787LandingPerformancePG extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.gameUnitsMetric = ConsumerSubject.create(this.props.bus.getSubscriber().on('game_units_metric'), false);
        this.unit = this.gameUnitsMetric.map((isMetric) => {
            return isMetric ? UnitType.KILOGRAM : UnitType.POUND;
        });
        this.unitString = this.gameUnitsMetric.map((isMetric) => {
            return BoeingUnitUtils.getUnitString(isMetric ? UnitType.KILOGRAM : UnitType.POUND);
        });
        this.atmTextFieldRef = FSComponent.createRef();
        this.windTextFieldRef = FSComponent.createRef();
        this.rwyDropdownRef = FSComponent.createRef();
        this.oatFieldRef = FSComponent.createRef();
        this.progressBarRef = FSComponent.createRef();
        this.qnhFieldRef = FSComponent.createRef();
        this.towFieldRef = FSComponent.createRef();
        this.zfwFieldRef = FSComponent.createRef();
        this.cgFieldRef = FSComponent.createRef();
        this.sendOutputButtonRef = FSComponent.createRef();
        this.bus = new EventBus();
        this.takeoffCalculator = this.props.takeoffCalculator;
        this.runwayList = ArraySubject.create([]);
        this.arptList = ArraySubject.create([]);
        this.aprtName = Subject.create('');
        this.pickedRunway = Subject.create(null);
        this.pickedRunwayCondition = Subject.create(null);
        this.pickedOat = Subject.create(null);
        this.runwayCondition = Subject.create(null);
        /** QNH in hPa, or null if none. */
        this.pickedQnh = NumberUnitSubject.create(new NumberUnit(0, UnitType.HPA));
        this.typedQnhUnit = Subject.create(UnitType.HPA);
        this.pickedWind = Subject.create(null);
        this.pickedTow = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.pickedAtm = Subject.create(null);
        this.pickedZfwKg = Subject.create(null);
        this.pickedCg = Subject.create(null);
        this.pickedFlaps = Subject.create(null);
        this.pickedRtg = Subject.create(null);
        this.pickAiConfig = Subject.create(null);
        this.pickedImClb = Subject.create('NONE');
        this.atmResults = Subject.create(undefined);
        this.fullResults = Subject.create(undefined);
        this.rtgList = ArraySubject.create([
            EFBTakeoffThrustMode.OPTIMUM,
            EFBTakeoffThrustMode.TO,
            EFBTakeoffThrustMode.TO1,
            EFBTakeoffThrustMode.TO2,
            EFBTakeoffThrustMode.WINDSHEAR,
        ]);
        this.flapList = ArraySubject.create([OptimumRequest.OPTIMUM, 5, 10, 15, 17, 18, 20]);
        this.aiList = ArraySubject.create([EFBAntiIceSetting.OFF, EFBAntiIceSetting.ENGINE, EFBAntiIceSetting.ENGINE_AUTO]);
        this.imClbList = ArraySubject.create(['OPTIMUM', 'NONE', 'EXIT']);
        this.intxList = ArraySubject.create([]);
        this.flapsValue = Subject.create('0');
        this.accelHtValue = Subject.create('0');
        this.rwyValue = Subject.create('0');
        /** Takeoff weight value in the results area. */
        this.togwResultText = Subject.create('0');
        this.takeoffThrustValue = Subject.create('0');
        this.selTempValue = Subject.create('0');
        // FIXME rename (rename css class as well)
        /** Result not available message. */
        this.runwayInformationValue = Subject.create('');
        this.v1SpeedValue = Subject.create('0');
        this.v2SpeedValue = Subject.create('0');
        this.vrSpeedValue = Subject.create('0');
        this.vRefSpeedValue = Subject.create('0');
        this.efbThrustModeText = Subject.create(null);
        this.isResultPerfCalculation = Subject.create(false);
        this.isResultAvailable = Subject.create(false);
        this.condList = ArraySubject.create([
            EfbRunwayCondition.DRY,
            EfbRunwayCondition.WET,
            EfbRunwayCondition.STNDNG_WTR,
            EfbRunwayCondition.SLUSH,
            EfbRunwayCondition.CMPCT_SNOW,
            EfbRunwayCondition.DRY_SNOW,
            // EfbRunwayCondition.WET_SNOW,
            EfbRunwayCondition.ICE,
            EfbRunwayCondition.GOOD,
            EfbRunwayCondition.MEDIUM,
            EfbRunwayCondition.POOR,
        ]);
        this.selTempTextAreaRef = FSComponent.createRef();
        this.nameAndEngineRef = FSComponent.createRef();
        this.v1TextAreaValueRef = FSComponent.createRef();
        this.vrTextAreaValueRef = FSComponent.createRef();
        this.v2TextAreaValueRef = FSComponent.createRef();
        this.vrefTextAreaValueRef = FSComponent.createRef();
        this.activeSetting = Subject.create(textAreaSetting.Atm);
        this.isFullSettingActive = this.activeSetting.map(x => x === textAreaSetting.Full);
        this.isAtmSettingActive = this.activeSetting.map(x => x === textAreaSetting.Atm);
        this.isAtmSettingDisabled = this.atmResults.map(x => x === undefined);
        this.textAreaSettingRef = FSComponent.createRef();
        this.textAreaSettingButtonsRefs = FSComponent.createRef();
        this.textAreaSetting = this.activeSetting.map((method) => method === textAreaSetting.Atm ? 'ATM' : 'FULL');
        this.textAreaContentsRef = FSComponent.createRef();
        this.calculationAllowed = MappedSubject.create((inputs) => inputs.every((v) => v !== null), this.pickedQnh, this.pickedOat, this.pickedWind, this.pickedFlaps, this.pickedRtg, this.pickAiConfig, this.pickedRunway, this.pickedRunwayCondition, this.pickedImClb, this.pickedAtm);
                this.sendDataDisabled = Subject.create(true);
        // RTOW requirements are a subset of perf requirements so we can always calculate when RTOW is possible
        this.calcDataDisabled = this.calculationAllowed.map((v) => !v);
        this.arptListGreenOutline = Subject.create(true);
        this.rwyListGreenOutline = Subject.create(false);
        this.isProgressBarVisible = Subject.create(false);
        this.flightButtonDisabled = Subject.create(false);
        this.arptinfobuttondisabled = Subject.create(true);
        
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        this.props.visible.sub((visible) => {
            this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';
        }, true);
        this.props.store.flightInitializationDataAcceptedEvent.on(this.initializeData.bind(this));
        this.unit.sub(() => this.handleGameUnitsChanged());
        this.unitString.sub(() => this.handleGameUnitsChanged());
        this.isResultAvailable.sub(this.showDataInTextArea.bind(this));
        this.activeSetting.sub(this.showDataInTextArea.bind(this));
        // default ATM to MAX here. subject is a number so can't use valueOnStartup on the field
        this.atmTextFieldRef.instance.typeValue('MAX');
    }
    /**
     * Handles the user pressing the CALC button
     */
    handleCalculateButton() {
        if (this.calculationAllowed.get()) {
            // clear the textfield and show the text area if its possible
            this.runwayInformationValue.set('');
            this.hideDataInTextArea();
        const toRunway = this.pickedRunway.get();
        const toRunwayCondition = this.pickedRunwayCondition.get();
        const toWind = this.pickedWind.get();
        const toOat = this.pickedOat.get();
        const toQnh = this.pickedQnh.get().asUnit(UnitType.HPA);
        const toTow = this.pickedTow.get().asUnit(UnitType.POUND);
        const toAtm = this.pickedAtm.get();
        const toFlaps = this.pickedFlaps.get();
        const toRtg = this.pickedRtg.get();
        const toAi = this.pickAiConfig.get();
        const toImClb = this.pickedImClb.get();
        this.disableEverything(); // After reading the fields, because we need to fetch the field state for the tow field unaltered!
        // TODO ugggh annoying to validate these again
        if (toRunway === null || toRunwayCondition === null || toWind === null || toOat === null || toQnh === null
            || toAtm === null || toFlaps === null || toRtg === null || toAi === null || toImClb === null) {
            return;
        }
        const runwayMagneticCourse = MagVar.trueToMagnetic(toRunway.course, toRunway.latitude, toRunway.longitude);
        // Make the progress bar ready and call the calculation:
        this.progressBarRef.instance.resetProgressBar();
        this.isProgressBarVisible.set(true);
        this.simulateProgressBar().then(() => {
            const results = this.takeoffCalculator.getTakeoffPerformanceData(toRunway, toRunwayCondition, Number.isFinite(toWind.direction) ? toWind.direction : runwayMagneticCourse, toWind.speed, toOat, toQnh, toRtg, toAtm, toFlaps, toAi, toTow);
            const atmResult = results.find(result => result.resultMode === EFBTakeoffCalculationMode.ATM);
            const fullResult = results.find(result => result.resultMode === EFBTakeoffCalculationMode.FULL);
            this.atmResults.set(atmResult);
            this.fullResults.set(fullResult);
            if (atmResult !== undefined) {
            this.isResultPerfCalculation.set(true);
                            this.activeSetting.set(textAreaSetting.Atm);
                this.displayResults(atmResult);
            }
            else if (fullResult) {
                this.isResultPerfCalculation.set(true);
                this.activeSetting.set(textAreaSetting.Full);
                this.displayResults(fullResult);
            }
        else {
        // At this point, results should only contain a RTOW result:
                const rtowResult = results.find(result => result.resultMode === EFBTakeoffCalculationMode.RTOW);
                if (rtowResult !== undefined) {
                    this.isResultPerfCalculation.set(false);
                this.displayResults(rtowResult);
                }
            }
        });
    }
}
    /**
     * Displays calculation results in the bottom section
     *
     * @param calculatedData the calculated data
     */
    displayResults(calculatedData) {
        var _a;
        const toRunway = this.pickedRunway.get();
        const toRtg = this.pickedRtg.get();
        const toOat = this.pickedOat.get();
        if (toRunway === null || toRtg === null || toOat === null) {
            return;
        }
        const { isPossible, maxTakeoffWeightOut, thrustRatingOut, flapSettingOut, assumedTemperatureOut, v1Out, vrOut, v2Out, } = calculatedData;
        if (!isPossible) {
            // if the calc is not possible it will report it in the inforamtion field
            this.hideDataInTextArea();
            if (this.activeSetting.get() === textAreaSetting.Atm && calculatedData.resultMode !== EFBTakeoffCalculationMode.RTOW) {
                this.runwayInformationValue.set('No valid assumed temp found for these conditions. No assumed temp allowed.');
            }
            else {
                this.runwayInformationValue.set('No takeoff allowed. Planned weight exceeds max allowable weight of ' + Math.trunc(UnitType.POUND.convertTo(maxTakeoffWeightOut, this.unit.get())) + ' ' + this.unitString.get() + '.');
            }
            this.sendDataDisabled.set(true);
            this.textAreaSettingRef.instance.classList.remove('hidden');
        }
        else {
            this.runwayInformationValue.set('');
            this.sendDataDisabled.set(false);
            const accelAlt = UnitType.FOOT.convertFrom(toRunway.elevation, UnitType.METER) + this.props.activePerformancePlan.takeoffAccelerationHeight.get();
            this.accelHtValue.set(`${Math.round(accelAlt)} ft MSL`);
            this.props.activePerformancePlan.takeoffFlaps.get();
            if (this.pickedFlaps !== null) {
                if (this.pickedFlaps.get() === OptimumRequest.OPTIMUM) {
                    this.flapsValue.set(flapSettingOut + '');
                }
                else {
                    this.flapsValue.set(this.pickedFlaps.get() + '');
                }
            }
            // truncate so the RTOW calculation result can always get a result when entered back into the calculator
            this.togwResultText.set(`${Math.trunc(UnitType.POUND.convertTo(maxTakeoffWeightOut, this.unit.get()))} ${this.unitString.get()}`);
            // set the button on the right menu bar
            this.progressBarRef.instance.setBarInfo((_a = this.pickedRunway.get()) === null || _a === void 0 ? void 0 : _a.designation, this.togwResultText.get());
            this.v1SpeedValue.set(v1Out !== undefined ? (v1Out + ' KT') : '');
            this.v2SpeedValue.set(v2Out !== undefined ? (v2Out + ' KT') : '');
            this.vrSpeedValue.set(vrOut !== undefined ? (vrOut + ' KT') : '');
            if (assumedTemperatureOut !== 0) {
                this.selTempValue.set(assumedTemperatureOut + ' C');
            }
            //default value for the QNH if nothing is entered
            const qnh = this.pickedQnh.get().asUnit(UnitType.HPA);
            const qnhValue = Number.isFinite(qnh) ? qnh : 1013.25;
            const pressureAlt = UnitType.FOOT.convertFrom(toRunway.elevation + AeroMath.baroPressureAltitudeOffset(qnhValue), UnitType.METER);
            this.rwyValue.set(toRunway.designation);
            this.vRefSpeedValue.set(Math.round(this.props.speedDataProvider.getVrefSpeed(30, maxTakeoffWeightOut, pressureAlt)) + ' KT');
            let thrustRating;
            switch (thrustRatingOut) {
                default:
                case EFBTakeoffThrustMode.TO:
                    thrustRating = TakeoffThrustMode.TO;
                    break;
                case EFBTakeoffThrustMode.TO1:
                    thrustRating = TakeoffThrustMode.TO1;
                    break;
                case EFBTakeoffThrustMode.TO2:
                    thrustRating = TakeoffThrustMode.TO2;
                    break;
            }
            if (this.pickedRtg !== null) {
                switch (toRtg) {
                    case EFBTakeoffThrustMode.OPTIMUM:
                        this.setRtg(thrustRating, toOat, assumedTemperatureOut, toRunway);
                        break;
                    case EFBTakeoffThrustMode.TO:
                        this.setRtg(TakeoffThrustMode.TO, toOat, assumedTemperatureOut, toRunway);
                        break;
                    case EFBTakeoffThrustMode.TO1:
                        this.setRtg(TakeoffThrustMode.TO1, toOat, assumedTemperatureOut, toRunway);
                        break;
                    case EFBTakeoffThrustMode.TO2:
                        this.setRtg(TakeoffThrustMode.TO2, toOat, assumedTemperatureOut, toRunway);
                        break;
                }
            }
            this.isResultAvailable.set(true);
        }
    }
    /**
     * Simulates the progress bar filling up, and resolves when complete.
     */
    simulateProgressBar() {
        return new Promise((resolve) => {
            for (let i = 0; i <= 11; i++) {
                setTimeout(() => {
                    if (i <= 10) {
                        this.progressBarRef.instance.update(i * 10);
                    }
                    if (i === 11) {
                        resolve();
                    }
                }, 200 * i);
            }
        });
    }
    /**
     * Handles the user pressing the CALC button
     */
    sendPerfDataToFMC() {
    
        const togw = this.pickedTow.get().asUnit(UnitType.POUND);
        if (togw === null) {
            return;
        }
        const calculatedData = this.activeSetting.get() === textAreaSetting.Full ? this.fullResults.get() : this.atmResults.get();
        if (calculatedData === undefined) {
            return;
        }
        const { isPossible, thrustRatingOut, flapSettingOut, assumedTemperatureOut, v1Out, vrOut, v2Out } = calculatedData;
        let thrustRating;
        switch (thrustRatingOut) {
            default:
            case EFBTakeoffThrustMode.TO:
                thrustRating = TakeoffThrustMode.TO;
                break;
            case EFBTakeoffThrustMode.TO1:
                thrustRating = TakeoffThrustMode.TO1;
                break;
            case EFBTakeoffThrustMode.TO2:
                thrustRating = TakeoffThrustMode.TO2;
                break;
        }
        if (isPossible) {
            this.props.communicationsManager.sendTakeoffDataUplinkToFmc({
                v1: v1Out,
                vr: vrOut,
                v2: v2Out,
                togw,
                thrustRating,
                assumedTemperature: assumedTemperatureOut,
                flapSetting: flapSettingOut,
            });
        }
    }
    /**
     * Will disable eveything and take away green outline while the progess bar fills up.
     */
    disableEverything() {
        this.arptListGreenOutline.set(false);
        this.rwyListGreenOutline.set(false);
        this.windTextFieldRef.instance.setTextFieldToInactive();
        this.oatFieldRef.instance.setTextFieldToInactive();
        this.qnhFieldRef.instance.setTextFieldToInactive();
        this.towFieldRef.instance.setTextFieldToInactive();
        this.zfwFieldRef.instance.setTextFieldToInactive();
        this.cgFieldRef.instance.setTextFieldToInactive();
    }
    /**
     * Sets the RTG in the display area to the right settings
     * @param thrustRatingMode The mode
     * @param toOat The temp
     * @param assumedTemp Assumed temperature from the calculation or 0 if none.
     * @param toRunway The runway taking off from
     */
    setRtg(thrustRatingMode, toOat, assumedTemp, toRunway) {
        const useAssumedTemp = assumedTemp !== 0 && assumedTemp > toOat;
        const temperature = useAssumedTemp ? assumedTemp : toOat;
        const qnh = this.pickedQnh.get().asUnit(UnitType.HPA);
        const pressureAlt = Number.isFinite(qnh) ? UnitType.FOOT.convertFrom(toRunway.elevation - AeroMath.baroPressureAltitudeOffset(qnh), UnitType.METER) : null;
        const thrustModeText = useAssumedTemp ? `D-${thrustRatingMode}` : thrustRatingMode;
        if (thrustRatingMode === TakeoffThrustMode.TO) {
            this.efbThrustModeText.set(thrustModeText);
            if (pressureAlt !== null) {
                this.takeoffThrustValue.set(this.props.engineDataProvider.getToMaxTpr(pressureAlt, temperature).toFixed(1));
            }
        }
        else if (thrustRatingMode === TakeoffThrustMode.TO1) {
            this.efbThrustModeText.set(thrustModeText);
            if (pressureAlt !== null) {
                this.takeoffThrustValue.set(this.props.engineDataProvider.getTo1Tpr(pressureAlt, temperature).toFixed(1));
            }
        }
        else if (thrustRatingMode === TakeoffThrustMode.TO2) {
            this.efbThrustModeText.set(thrustModeText);
            if (pressureAlt !== null) {
                this.takeoffThrustValue.set(this.props.engineDataProvider.getTo2Tpr(pressureAlt, temperature).toFixed(1));
            }
        }
    }
    /** Shows data in the results area */
    showDataInTextArea() {
        const isResultAvailable = this.isResultAvailable.get();
        this.textAreaContentsRef.instance.classList.toggle('hidden', !isResultAvailable);
        this.nameAndEngineRef.instance.classList.toggle('hidden', !isResultAvailable);
        const isRtowCalc = !this.isResultPerfCalculation.get();
        this.selTempTextAreaRef.instance.classList.toggle('hidden', isRtowCalc || this.activeSetting.get() !== textAreaSetting.Atm);
        this.textAreaSettingRef.instance.classList.toggle('hidden', isRtowCalc);
        this.textAreaSettingButtonsRefs.instance.classList.toggle('hidden', isRtowCalc || this.atmResults.get() === null);
        this.v1TextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
        this.vrTextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
        this.v2TextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
        this.vrefTextAreaValueRef.instance.classList.toggle('hidden', isRtowCalc);
    }
    /**
     * Hides data in the results area
     */
    hideDataInTextArea() {
        this.isResultPerfCalculation.set(false);
        this.isResultAvailable.set(false);
        this.textAreaContentsRef.instance.classList.add('hidden');
        this.nameAndEngineRef.instance.classList.add('hidden');
        this.selTempTextAreaRef.instance.classList.add('hidden');
        this.v1TextAreaValueRef.instance.classList.add('hidden');
        this.vrTextAreaValueRef.instance.classList.add('hidden');
        this.v2TextAreaValueRef.instance.classList.add('hidden');
        this.vrefTextAreaValueRef.instance.classList.add('hidden');
        this.textAreaSettingRef.instance.classList.add('hidden');
        this.textAreaSettingButtonsRefs.instance.classList.add('hidden');
    }
    /**
     * Handles when a new airport is selected and runways change.
     */
    initializeData() {
        var _a;
        const unit = this.unit.get();
        //clear lists so no dupes show up
        this.runwayList.clear();
        this.arptList.clear();
        const listOfRunways = this.props.store.availableTakeoffRunways.get();
        this.runwayList.set(listOfRunways);
        if (this.props.store.airportOrigin.get() !== '') {
            this.aprtName.set(this.props.store.airportOrigin.get().substring(6));
            
        }
        else {
            this.aprtName.set('ARPT SEARCH');
        }
        const takeoffRunway = this.props.store.takeoffRunway.get();
        takeoffRunway !== null && this.rwyDropdownRef.instance.pickItem(takeoffRunway);
        const takeoffOat = this.props.store.takeoffOatCelsius.get();
        takeoffOat !== null && this.oatFieldRef.instance.typeValue(takeoffOat.toFixed(0));
        const takeoffWind = this.props.store.takeoffWind.get();
        if (takeoffWind) {
            const direction = (takeoffWind.direction.toFixed(0) === '0' ? '360' : takeoffWind.direction.toFixed(0)).padStart(3, '0');
            this.windTextFieldRef.instance.typeValue(direction + '/' + takeoffWind.speed.toFixed(0));
        }
        const takeoffQnh = this.props.store.takeoffQnhHpa.get();
        if (takeoffQnh !== null) {
            if (this.gameUnitsMetric.get()) {
                if (takeoffQnh < 1000) {
                    //show one deciml point
                    takeoffQnh !== null && this.qnhFieldRef.instance.typeValue(takeoffQnh.toFixed(1));
                }
                else {
                    //show none if above or equal to 1000
                    //this.qnhFieldRef.instance.typeValue(pickedQnh.number.toFixed(0).toString());
                    takeoffQnh !== null && this.qnhFieldRef.instance.typeValue(takeoffQnh.toFixed(0));
                }
            }
            else {
                takeoffQnh !== null && this.qnhFieldRef.instance.typeValue(UnitType.IN_HG.convertFrom(takeoffQnh, UnitType.HPA).toFixed(2));
            }
        }
        const takeoffWeightLbs = this.props.store.takeoffGwLbs.get();
        takeoffWeightLbs !== null && this.towFieldRef.instance.typeValue(unit.convertFrom(takeoffWeightLbs, UnitType.POUND).toFixed(0));
        const zeroFuelWeightKg = this.props.store.takeoffZfwKg.get();
        zeroFuelWeightKg !== null && this.zfwFieldRef.instance.typeValue(unit.convertFrom(zeroFuelWeightKg, UnitType.KILOGRAM).toFixed(0));
        const centerOfGravity = this.props.store.takeoffCg.get();
        centerOfGravity !== null && this.cgFieldRef.instance.typeValue(centerOfGravity.toFixed(0));
        this.runwayCondition.set(this.props.store.takeoffRunwayCondition.get());
        this.pickedQnh.set((_a = this.props.store.takeoffQnhHpa.get()) !== null && _a !== void 0 ? _a : NaN, UnitType.HPA);
        this.pickedTow.set(takeoffWeightLbs === null ? 0 : takeoffWeightLbs, UnitType.POUND);
        this.pickedZfwKg.set(zeroFuelWeightKg);
        this.pickedCg.set(centerOfGravity);
    }
    /** Updates fields when game units change. */
    handleGameUnitsChanged() {
        var _a;
        const weightUnit = this.unit.get();
        const pickedZfwKg = this.pickedZfwKg.get();
        pickedZfwKg !== null && this.zfwFieldRef.instance.typeValue(weightUnit.convertFrom(pickedZfwKg, UnitType.KILOGRAM).toFixed(0));
        const pickedTow = this.pickedTow.get();
        pickedTow !== null && this.towFieldRef.instance.typeValue(pickedTow.asUnit(weightUnit).toFixed(0));
        // Redisplay results
        const activeAtmFullSetting = this.activeSetting.get();
        const atmResults = this.atmResults.get();
        const fullResults = this.fullResults.get();
        if (activeAtmFullSetting === textAreaSetting.Atm && atmResults) {
            this.displayResults(atmResults);
        }
        else if (activeAtmFullSetting === textAreaSetting.Full && fullResults) {
            this.displayResults(fullResults);
        }
        //update the text in the progress bar
        this.progressBarRef.instance.setBarInfo((_a = this.pickedRunway.get()) === null || _a === void 0 ? void 0 : _a.designation, this.togwResultText.get());
    }
    /**
     * Handler when any top menu button is clicked.(NORMAL, RESET, NON-NORMAL)
     * @param menu The menu button that was clicked.
     */
    onMenuButtonClicked(menu) {
        if (menu === textAreaSetting.Atm) {
            const atmResults = this.atmResults.get();
            if (atmResults) {
            this.activeSetting.set(textAreaSetting.Atm);
                            this.displayResults(atmResults);
            }
        }
        if (menu === textAreaSetting.Full) {
                        const fullResults = this.fullResults.get();
            if (fullResults) {
                this.activeSetting.set(textAreaSetting.Full);
                this.displayResults(fullResults);
            }
        }
    }
   
    
    
    async CopyFMCDATA() {
        this.flightButtonDisabled.set(true);
       
        this.props.communicationsManager.requestFlightInitializationData().then((data) => {
            this.arptListGreenOutline.set(true);
            this.rwyListGreenOutline.set(true);

            this.flightButtonDisabled.set(false);
            this.arptinfobuttondisabled.set(false);
            this.props.store.acceptFlightInitializationData(data,true);
            
        }).catch(() => {
            
          this.flightButtonDisabled.set(false);
        });
    }
    async CloseFlight() {
       
       this.flightButtonDisabled.set(false);
       this.flightButtonText.set('INITIALIZE FLIGHT');
       this.props.store.acceptFlightInitializationData();
       
   }
   
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.containerRef },
            FSComponent.buildComponent("div", { class: 'efb-title-page' }, "PERFORMANCE-LANDING"),
            FSComponent.buildComponent("div", { class: 'efb-left-side' },
               
           //FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => this.onPageSelect(EfbPages.PerformanceARPTINFO),isDisabled: false},
                
           FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => {this.props.onPageSelect(EfbPages.PerformanceARPTINFO);LastEFBPg = "Performance"; },isDisabled: this.arptinfobuttondisabled },
                    
                    FSComponent.buildComponent("span", null, "ARPT"),
                    FSComponent.buildComponent("span", null, "INFO")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "ADD"),
                    FSComponent.buildComponent("span", null, "ARPT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "NOTAMS")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "SHOW"),
                    FSComponent.buildComponent("span", null, "KYBD")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "WT AND"),
                    FSComponent.buildComponent("span", null, "BALANCE")),
                FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => {this.props.onPageSelect(EfbPages.Performance);LastEFBPg = "Performance"; },},
                    FSComponent.buildComponent("span", null, "SHOW"),
                    FSComponent.buildComponent("span", null, "TAKEOFF")),
                FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.CopyFMCDATA.bind(this), isDisabled: this.flightButtonDisabled },
                    FSComponent.buildComponent("span", null, "COPY"),
                    FSComponent.buildComponent("span", null, "FMC DATA")),
                FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.sendPerfDataToFMC.bind(this), isDisabled: this.sendDataDisabled },
                    FSComponent.buildComponent("span", null, "SEND"),
                    FSComponent.buildComponent("span", null, "OUTPUT"))),
            FSComponent.buildComponent("div", { class: 'efb-right-side' },
                FSComponent.buildComponent(BoeingEfbSideButton, { onClick: this.handleCalculateButton.bind(this), isDisabled: this.calcDataDisabled },
                    FSComponent.buildComponent("span", null, "CALC")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "SHOW"),
                    FSComponent.buildComponent("span", null, "ALL ENGINE")),
             FSComponent.buildComponent(BoeingEfbSideButton, {onClick: () => {this.props.onPageSelect(EfbPages.PerformanceMEL);LastEFBPg = "Performance"; },isDisabled: this.arptinfobuttondisabled },
                    FSComponent.buildComponent("span", null, "MEL")),
                FSComponent.buildComponent(BoeingEfbSideButton, { isDisabled: true },
                    FSComponent.buildComponent("span", null, "CDL")),
                FSComponent.buildComponent(BoeingEfbProgressBar, { ref: this.progressBarRef, isHidden: this.isProgressBarVisible })),
            FSComponent.buildComponent("div", { class: 'efb-middle' },
                FSComponent.buildComponent("div", { class: 'efb-middle-top-left-title' }, "TRENT1000-D3"),
                FSComponent.buildComponent("div", { class: 'efb-middle-top-right-box' },
                    FSComponent.buildComponent("div", { class: 'right-side-dropdowns' },
                    FSComponent.buildComponent("div", { class: "efb-perf-blank" }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.atmTextFieldRef, buttonName: 'ATM', isNameOnLeftSide: false, hasBottomText: false, enableKeyboard: true, validator: EfbFormatters.AssumedTemperatureModeParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: false, onValueChanged: (value) => {
                                this.pickedAtm.set(value);
                            } }),
                        FSComponent.buildComponent("div", { class: 'right-side-making-space' }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { dropdownItems: this.flapList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'FLAP', isNameOnLeftSide: false, dropDownDefaultName: 'FLAP CONFIG', onItemSelected: (flap) => this.pickedFlaps.set(flap) }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { dropdownItems: this.aiList, dropdownItemFormatter: EfbFormatters.EngineAntiIceSettingFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'A/I', isNameOnLeftSide: false, dropDownDefaultName: 'A/I CONFIG', onItemSelected: (aiConfig) => this.pickAiConfig.set(aiConfig) }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { dropdownItems: this.imClbList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'ImCLB', isNameOnLeftSide: false, dropDownDefaultName: 'NONE', onItemSelected: (imClb) => this.pickedImClb.set(imClb), isDisabled: true, isDropDownDisabled: true }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-top-left-box' },
                    FSComponent.buildComponent("div", { class: 'left-side-dropdowns' },
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { dropdownItems: this.arptList, dropdownItemFormatter: RawFormatter, hasGreenOutline: this.arptListGreenOutline, hasArrow: false, dropdownButtonName: 'ARPT', isNameOnLeftSide: true, dropDownDefaultName: 'ARPT SEARCH', onFmcLoadedName: this.aprtName, isDropDownDisabled: true }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { ref: this.rwyDropdownRef, dropdownItems: this.runwayList, dropdownItemFormatter: EfbFormatters.RunwayFormatter, hasGreenOutline: this.rwyListGreenOutline, hasArrow: true, dropdownButtonName: 'RWY', isNameOnLeftSide: true, dropDownDefaultName: 'RUNWAYS', onItemSelected: (runway) => this.pickedRunway.set(runway) }),
                        FSComponent.buildComponent("div", { class: "efb-perf-blank" }),
                        FSComponent.buildComponent(BoeingEfbDropdownButton, { dropdownItems: this.condList, dropdownItemFormatter: RawFormatter, hasGreenOutline: false, hasArrow: true, dropdownButtonName: 'COND', isNameOnLeftSide: true, dropDownDefaultName: 'CONDITION', onItemSelected: (item) => {
                                this.pickedRunwayCondition.set(item);
                            }, onFmcLoadedName: this.pickedRunwayCondition }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.windTextFieldRef, buttonName: 'WIND', isNameOnLeftSide: true, hasBottomText: true, enableKeyboard: true, validator: EfbFormatters.WindParser, bottomTextFormatter: EfbFormatters.WindFormatter(this.props.store.takeoffRunway), onlyNumberEntry: true, onValueChanged: (value) => {
                                this.pickedWind.set(value);
                            }, unitForTextField: 'KT', allowTforWind: true }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.oatFieldRef, buttonName: 'OAT', isNameOnLeftSide: true, hasBottomText: true, enableKeyboard: true, valueOnStartUp: this.pickedOat, validator: EfbFormatters.NumberParser, bottomTextFormatter: EfbFormatters.FahrenheitTemperatureFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                this.pickedOat.set(value);
                            }, unitForTextField: 'C' }),
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.qnhFieldRef, buttonName: 'QNH', isNameOnLeftSide: true, hasBottomText: true, enableKeyboard: true, validator: EfbFormatters.PressureParser, textFieldFormatter: EfbFormatters.FieldPressureFormatter, bottomTextFormatter: EfbFormatters.BottomTextPressureFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                const unit = (value >= 28 && value <= 31) ? UnitType.IN_HG : UnitType.HPA;
                                this.typedQnhUnit.set(unit);
                                this.pickedQnh.set(value, unit);
                            }, unitForTextField: this.typedQnhUnit.map((unit) => unit === UnitType.HPA ? 'HPa' : 'IN HG') }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-1st-middle-box' },
                    FSComponent.buildComponent("div", { class: 'left-textfield-middle-Landing' },
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.towFieldRef, buttonName: 'LANDING WT:', isNameOnLeftSide: true, hasBottomText: false,width: 120,TextWidth: 100, enableKeyboard: true, validator: EfbFormatters.TowParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                if (this.gameUnitsMetric.get()) {
                                    this.pickedTow.set(value, UnitType.KILOGRAM);
                                }
                                else {
                                    this.pickedTow.set(value, UnitType.POUND);
                                }
                            }, unitForTextField: this.unitString })),
                    FSComponent.buildComponent("div", { class: 'right-textfield-middle-Landing' },
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.zfwFieldRef, buttonName: 'VREF ADD:', isNameOnLeftSide: true, hasBottomText: false, width: 60,enableKeyboard: true, validator: EfbFormatters.NumberParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                if (this.gameUnitsMetric.get()) {
                                    //if the game is in metric then keep the same
                                    this.pickedZfwKg.set(value);
                                }
                                else {
                                    //if in us system (LB) then convert to lb
                                    const data = Number(UnitType.POUND.convertTo(value, UnitType.KILOGRAM).toFixed());
                                    this.pickedZfwKg.set(data);
                                }
                            }, unitForTextField: this.unitString }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box' },
                    FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box-name-and-engine hidden', ref: this.nameAndEngineRef }, "787-9/TRENT1000-D3"),
                    FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box-setting-buttons hidden', ref: this.textAreaSettingButtonsRefs },
                        FSComponent.buildComponent(BoeingEfbButton, { selected: this.isFullSettingActive, onClick: () => this.onMenuButtonClicked(textAreaSetting.Full) },
                            FSComponent.buildComponent("span", null, "FULL")),
                        FSComponent.buildComponent(BoeingEfbButton, { selected: this.isAtmSettingActive, isDisabled: this.isAtmSettingDisabled, onClick: () => this.onMenuButtonClicked(textAreaSetting.Atm) },
                            FSComponent.buildComponent("span", null, "ATM"))),
                    FSComponent.buildComponent("div", { class: 'efb-middle-2st-middle-box-cg' },
                        FSComponent.buildComponent(BoeingEfbTextField, { ref: this.cgFieldRef, buttonName: 'CG(%): ', isNameOnLeftSide: true, hasBottomText: false, width: 60, enableKeyboard: true, validator: EfbFormatters.NumberParser, bottomTextFormatter: EfbFormatters.RawFormatter, onlyNumberEntry: true, onValueChanged: (value) => {
                                this.pickedCg.set(value);
                            } }))),
                FSComponent.buildComponent("div", { class: 'efb-middle-3st-middle-box' },
                    FSComponent.buildComponent("div", { class: 'efb-middle-3st-middle-box-contents hidden', ref: this.textAreaContentsRef },
                        FSComponent.buildComponent("div", { class: 'efb-text-area-flaps' },
                            "FLAP",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-flaps-value efb-result-value' }, this.flapsValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-accel-ht' },
                            "ACCEL HT",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-accel-ht-value efb-result-value' }, this.accelHtValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-rwy-intx' },
                            "RWY/INTX",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-rwy-intx-value efb-result-value' }, this.rwyValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-togw' },
                            "TOGW",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-togw-value efb-result-value' }, this.togwResultText)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-thrust-rating' },
                            this.efbThrustModeText,
                            FSComponent.buildComponent("div", { class: 'efb-text-area-thrust-rating-value efb-result-value' }, this.takeoffThrustValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-sel-temp', ref: this.selTempTextAreaRef },
                            "SEL TEMP",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-sel-temp-value efb-result-value' }, this.selTempValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-v1-speed' },
                            "V1",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-v-speed-value hidden efb-result-value', ref: this.v1TextAreaValueRef }, this.v1SpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-vr-speed' },
                            "VR",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-v-speed-value hidden efb-result-value', ref: this.vrTextAreaValueRef }, this.vrSpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-v2-speed' },
                            "V2",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-v-speed-value hidden efb-result-value', ref: this.v2TextAreaValueRef }, this.v2SpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-vref' },
                            "Vref30",
                            FSComponent.buildComponent("div", { class: 'efb-text-area-vref-speed-value hidden efb-result-value', ref: this.vrefTextAreaValueRef }, this.vRefSpeedValue)),
                        FSComponent.buildComponent("div", { class: 'efb-text-area-big-setting-text hidden', ref: this.textAreaSettingRef }, this.textAreaSetting)),
                    FSComponent.buildComponent("div", { class: 'efb-text-area-runway-information' },
                        FSComponent.buildComponent("div", { class: 'efb-text-area-runway-information-value' }, this.runwayInformationValue))))));
                    }












   
   
}
/**
 * Video Page Button
 */
/**Image-1*/
class BoeingEfbImageButton extends DisplayComponent {
    /**
     * The constructor of the BoeingMfdButton, used for formatting button text on creation.
     * @param props The props of the BoeingMfdButton.
     */
    constructor(props) {
        var _a;
        super(props);
        this.root = FSComponent.createRef();
        this.buttonText = [];
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable((_a = this.props.isDisabled) !== null && _a !== void 0 ? _a : false, true);
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => !this.isDisabled.get() && this.props.onClick && this.props.onClick());
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        return (FSComponent.buildComponent("span", { ref: this.root, style: style, class: Object.assign({ 'boeing-efb-button1': true, 'boeing-efb-button-selected1': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-efb-button-disabled1': this.isDisabled.map(x => x === true), 'boeing-efb-button-alerted1': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                previous[current] = true;
                return previous;
            }, {}))) }, ...this.buttonText));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}




/**Image-2*/
class BoeingEfbImage2Button extends DisplayComponent {
    /**
     * The constructor of the BoeingMfdButton, used for formatting button text on creation.
     * @param props The props of the BoeingMfdButton.
     */
    constructor(props) {
        var _a;
        super(props);
        this.root = FSComponent.createRef();
        this.buttonText = [];
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable((_a = this.props.isDisabled) !== null && _a !== void 0 ? _a : false, true);
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => !this.isDisabled.get() && this.props.onClick && this.props.onClick());
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        return (FSComponent.buildComponent("span", { ref: this.root, style: style, class: Object.assign({ 'boeing-efb-button2': true, 'boeing-efb-button-selected2': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-efb-button-disabled2': this.isDisabled.map(x => x === true), 'boeing-efb-button-alerted2': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                previous[current] = true;
                return previous;
            }, {}))) }, ...this.buttonText));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}


/**Image-3*/
class BoeingEfbImage3Button extends DisplayComponent {
    /**
     * The constructor of the BoeingMfdButton, used for formatting button text on creation.
     * @param props The props of the BoeingMfdButton.
     */
    constructor(props) {
        var _a;
        super(props);
        this.root = FSComponent.createRef();
        this.buttonText = [];
        this.isSelected = SubscribableUtils.toSubscribable(this.props.selected, true);
        this.isAlerted = SubscribableUtils.toSubscribable(this.props.isAlerted, true);
        this.isVisible = SubscribableUtils.toSubscribable(this.props.isVisible, true);
        this.isDisabled = SubscribableUtils.toSubscribable((_a = this.props.isDisabled) !== null && _a !== void 0 ? _a : false, true);
        if (this.props.children) {
            for (const child of this.props.children) {
                this.buttonText.push(typeof child === 'string' ? FSComponent.buildComponent("span", null, child) : child);
            }
        }
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.onClick) {
            this.root.instance.addEventListener('click', () => !this.isDisabled.get() && this.props.onClick && this.props.onClick());
        }
    }
    /** @inheritDoc */
    render() {
        var _a;
        const customWidthStyleString = this.props.width ? `width: ${this.props.width}px !important;` : '';
        const customHeightStyleString = this.props.height ? `height: ${this.props.height}px !important;` : '';
        const style = `${customWidthStyleString} ${customHeightStyleString}`;
        return (FSComponent.buildComponent("span", { ref: this.root, style: style, class: Object.assign({ 'boeing-efb-button3': true, 'boeing-efb-button-selected3': this.isSelected.map(x => x === undefined ? false : typeof x === 'boolean' ? x : this.props.name === x), 'boeing-efb-button-disabled3': this.isDisabled.map(x => x === true), 'boeing-efb-button-alerted3': this.isAlerted.map(x => x === true), 'hidden': this.isVisible.map(x => x === false) }, (((_a = this.props.class) !== null && _a !== void 0 ? _a : []).reduce((previous, current) => {
                previous[current] = true;
                return previous;
            }, {}))) }, ...this.buttonText));
    }
    /** @inheritDoc */
    destroy() {
        this.root.instance.removeEventListener('click', () => null);
    }
}
/**Video Page */
var EfbVideoPages;
(function (EfbVideoPages) {
    EfbVideoPages[EfbVideoPages["ShowMenu"] = 63] = "ShowMenu";  
    EfbVideoPages[EfbVideoPages["Center"] = 64] = "Center";  
    EfbVideoPages[EfbVideoPages["Right"] = 65] = "Right";
    EfbVideoPages[EfbVideoPages["Left"] = 66] = "Left";    
})(EfbVideoPages || (EfbVideoPages = {}));

class EfbVideoPage extends DisplayComponent {   
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/center_default.png';
    }    

    /** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';  
    }, true);
}
   
/**@inheritDoc */
 render(){ 
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
    FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"), 
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title8"}, "IDENTIFICATION"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title9"}, "IDENTIFICATION"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title10"}, "DOOR #1 LEFT"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title11"}, "DOOR #1 RIGHT"),
    FSComponent.buildComponent("div", { class: "efb-middle6"}),
    FSComponent.buildComponent("div", { class: "efb-middle7"}),
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
    FSComponent.buildComponent("span", null, "FREEZE"))),
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column7" },
    FSComponent.buildComponent(BoeingEfbImageButton, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbPages.Video) },)), /**center */
    FSComponent.buildComponent("div", { class: "efb-right-side6" },
    FSComponent.buildComponent(BoeingEfbImage2Button, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbVideoPages.Right) },)), /**right */
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column8" },
    FSComponent.buildComponent(BoeingEfbImage3Button, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) })), /**left */
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column9" },
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
    FSComponent.buildComponent("span", null, "SHOW MENU")),
    FSComponent.buildComponent("div", { class: "body" }),
        FSComponent.buildComponent("div", { class: "static-image" }),
        FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 59px; position: absolute; top: 70px;',}),
    )));
        }
}
/**Left*/
var EfbVideoLPages;
(function (EfbVideoLPages) {
    EfbVideoLPages[EfbVideoLPages["ShowMenu"] = 67] = "ShowMenu";  
    EfbVideoLPages[EfbVideoLPages["Center"] = 68] = "Center";  
    EfbVideoLPages[EfbVideoLPages["Right"] = 69] = "Right";
    EfbVideoLPages[EfbVideoLPages["Left"] = 70] = "Left";    
})(EfbVideoLPages || (EfbVideoLPages = {}));

class EfbVideoLeftPage extends DisplayComponent {   
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/left_side_default.jpg';
    }    

    /** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';  
    }, true);
}
   
/**@inheritDoc */
 render(){ 
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
    FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"), 
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title31"}, "DOOR #1 LEFT"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title9"}, "IDENTIFICATION"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title10"}, "DOOR #1 LEFT"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title11"}, "DOOR #1 RIGHT"),
    FSComponent.buildComponent("div", { class: "efb-middle6"}),
    FSComponent.buildComponent("div", { class: "efb-middle8"}),
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
    FSComponent.buildComponent("span", null, "FREEZE"))),
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column7" },
    FSComponent.buildComponent(BoeingEfbImageButton, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbPages.Video) },)), /**center */
    FSComponent.buildComponent("div", { class: "efb-right-side6" },
    FSComponent.buildComponent(BoeingEfbImage2Button, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbVideoPages.Right) },)), /**right */
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column8" },
    FSComponent.buildComponent(BoeingEfbImage3Button, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) })), /**left */
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column9" },
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu) },
    FSComponent.buildComponent("span", null, "SHOW MENU")),
    FSComponent.buildComponent("div", { class: "body" }),
        FSComponent.buildComponent("div", { class: "static-image" }),
        FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 59px; position: absolute; top: 70px;',}),
    )));
        }
}
/**Right*/
var EfbVideoRPages;
(function (EfbVideoRPages) {
    EfbVideoRPages[EfbVideoRPages["ShowMenu"] = 71] = "ShowMenu";  
    EfbVideoRPages[EfbVideoRPages["Center"] = 72] = "Center";  
    EfbVideoRPages[EfbVideoRPages["Right"] = 73] = "Right";
    EfbVideoRPages[EfbVideoRPages["Left"] = 74] = "Left";    
})(EfbVideoRPages || (EfbVideoRPages = {}));

class EfbVideoRightPage extends DisplayComponent {   
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/right_side_default.jpg';
    }    

    /** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden';  
    }, true);
}
   
/**@inheritDoc */
 render(){ 
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
    FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"), 
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title31"}, "DOOR #1 RIGHT"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title9"}, "IDENTIFICATION"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title10"}, "DOOR #1 LEFT"),
    FSComponent.buildComponent("div", { class: "efb-middle-top-left-title11"}, "DOOR #1 RIGHT"),
    FSComponent.buildComponent("div", { class: "efb-middle6"}),
    FSComponent.buildComponent("div", { class: "efb-middle9"}),
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
    FSComponent.buildComponent("span", null, "FREEZE"))),
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column7" },
    FSComponent.buildComponent(BoeingEfbImageButton, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbPages.Video) },)), /**center */
    FSComponent.buildComponent("div", { class: "efb-right-side6" },
    FSComponent.buildComponent(BoeingEfbImage2Button, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbVideoPages.Right) },)), /**right */
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column8" },
    FSComponent.buildComponent(BoeingEfbImage3Button, { width: 230, height: 195, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) })), /**left */
    FSComponent.buildComponent("div", { class: "efb-main-menu-button-column9" },
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
    FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
    FSComponent.buildComponent("span", null, "SHOW MENU")),
    FSComponent.buildComponent("div", { class: "body" }),
        FSComponent.buildComponent("div", { class: "static-image" }),
        FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 59px; position: absolute; top: 70px;',}),
    )));
        }
}
/**left*/
var EfblshowPages
(function (EfblshowPages) {
    EfblshowPages[EfblshowPages["Bright30"] = 75] = "Bright30";
    EfblshowPages[EfblshowPages["Bright50"] = 76] = "Bright50";
    EfblshowPages[EfblshowPages["con1"] = 77] = "con1";
    EfblshowPages[EfblshowPages["con2"] = 78] = "con2";
})(EfblshowPages || (EfblshowPages = {}));

class EfblshowPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/left_side_default.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 LEFT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfblshowPages.Bright50) },
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfblshowPages.Bright30) },
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLeftPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfblshowPages.con2) },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfblshowPages.con1) },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Left Bright -50 */
class EfbLeftbmPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/left_side-50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 LEFT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu)},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Left Bright +50 */
class EfbLeftbpPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/left_side+50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 LEFT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu)},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Left contrast -50 */
class EfbLeftcmPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/left_side_con-50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 LEFT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Left contrast +50 */
class EfbLeftcpPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/left_side_con+50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 LEFT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoLPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**right*/
var EfbRshowPages
(function (EfbRshowPages) {
    EfbRshowPages[EfbRshowPages["Bright30"] = 79] = "Bright30";
    EfbRshowPages[EfbRshowPages["Bright50"] = 80] = "Bright50";
    EfbRshowPages[EfbRshowPages["con1"] = 81] = "con1";
    EfbRshowPages[EfbRshowPages["con2"] = 82] = "con2";
})(EfbRshowPages || (EfbRshowPages = {}));
class EfbrshowPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/right_side_default.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 RIGHT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbRshowPages.Bright50) },
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbRshowPages.Bright30) },
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Right) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbRshowPages.con2) },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbRshowPages.con1) },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Right Bright -50 */
class EfbRightbmPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/right_side-50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 RIGHT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu)},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Right Bright +50 */
class EfbRightbpPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/right_side+50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 RIGHT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu)},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Left) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Right contrast -50 */
class EfbRightcmPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/right_side_con-50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 RIGHT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Right) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Right contrast +50 */
class EfbRightcpPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/right_side_con+50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title30"}, "DOOR #1 RIGHT"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.Right) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoRPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
var EfbIdPages
(function (EfbIdPages) {
    EfbIdPages[EfbIdPages["Bright30"] = 55] = "Bright30";
    EfbIdPages[EfbIdPages["Bright50"] = 56] = "Bright50";
    EfbIdPages[EfbIdPages["con1"] = 57] = "con1";
    EfbIdPages[EfbIdPages["con2"] = 58] = "con2";
})(EfbIdPages || (EfbIdPages = {}));

class EfbId0Page extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/center_default.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title8"}, "IDENTIFICATION"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbIdPages.Bright50) },
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbIdPages.Bright30) },
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbPages.Video) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbIdPages.con2) },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbIdPages.con1) },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Bright Center-50*/
class EfbId1Page extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/center-50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title8"}, "IDENTIFICATION"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbPages.Video) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Bright Center +50*/
class EfbId2Page extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/center+50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title8"}, "IDENTIFICATION"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu)},
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbPages.Video) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70,isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Contrast Center -50*/
class EfbconPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/center_con-50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title8"}, "IDENTIFICATION"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbPages.Video) }, 
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/**Contrast Center +50*/
class Efbcon2Page extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
        this.staticImagePath = '/Pages/VCockpit/Instruments/Airliners/HSB787_10/Assets/images/efb/center_con+50.jpg';
        
}


/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page6' }, "VIDEO SURVEILLANCE"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title8"}, "IDENTIFICATION"),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "FREEZE")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
            FSComponent.buildComponent("span", null, "BRIGHTNESS +")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
            FSComponent.buildComponent("span", null, "BRIGHTNESS -")),
            FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbPages.Video) },
            FSComponent.buildComponent("span", null, "HIDE MENU"))),
            FSComponent.buildComponent("div", { class: 'efb-main-menu-button-column1 efb-main-menu-button-column-right1' },
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
            FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu) },
                FSComponent.buildComponent("span", null, "DEFAULT")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: false },
                FSComponent.buildComponent("span", null, "CONTRAST +")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, onClick: () => this.props.onPageSelect(EfbVideoPages.ShowMenu)},
                FSComponent.buildComponent("span", null, "CONTRAST -")),
                FSComponent.buildComponent(BoeingEfbSideButton, { width: 160, height: 70, isDisabled: true },
                FSComponent.buildComponent("span", null, "MAINTAINCE"))),
            FSComponent.buildComponent("div", { class: "body" }),
            FSComponent.buildComponent("div", { class: "static-image" }),
            FSComponent.buildComponent("img", { src: this.staticImagePath,   alt: 'IDENTIFICATION1',style: 'height: 450px; width: 650px; margin-left: 60px; position: absolute; top: 70px;'}),   
            
    ));
}
}
/** Data load */
class EfbDataPage extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.containerRef = FSComponent.createRef();
}
/** @inheritDoc */
onAfterRender(node) {
    super.onAfterRender(node);
    this.props.visible.sub((visible) => {
        this.containerRef.instance.style.visibility = visible ? 'inherit' : 'hidden'; 
    }, true);
}
/** @inheritDoc */
render() {
    return (FSComponent.buildComponent("div", { ref: this.containerRef },
        FSComponent.buildComponent("div", { class: 'efb-title-page7' }, "DATA LOAD"),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title6"}, "No Application Data is Available to Load."),
        FSComponent.buildComponent("div", { class: "efb-middle-top-left-title7"}, "Select MENU button to return MAIN MENU."),
        FSComponent.buildComponent("div", { class: "efb-main-menu-button-column" },
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent("div", { class: "efb-main-menu-blank" }),
        FSComponent.buildComponent(BoeingEfbSideButton, { width: 300, height: 70, isDisabled: true },
            FSComponent.buildComponent("span", null, "LOAD")),
        
        )))
}
}


/**
 * A configuration object which defines options related to various aircraft sensors.
 */
class SensorsConfig {
// eslint-disable-next-line jsdoc/require-returns
    /** Whether this configuration defines a radar altimeter. */
    get hasRadarAltimeter() {
        return this.radarAltimeterDefinitions.length > 1;
    }
    /**
     * Creates a new SensorsConfig from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     */
    constructor(baseInstrument, element) {
        if (element === undefined) {
            this.adcCount = 1;
            this.ahrsCount = 1;
            this.radarAltimeterCount = 1;
            this.gpsCount = 1;
            this.adcDefinitions = [undefined, { altimeterIndex: 1, airspeedIndicatorIndex: 1 }];
            this.ahrsDefinitions = [undefined, { attitudeIndicatorIndex: 1, directionIndicatorIndex: 1 }];
            this.radarAltimeterDefinitions = [undefined, {}];
            this.gpsDefinitions = [undefined, {}];
        }
        else {
            if (element.tagName !== 'Sensors') {
                throw new Error(`Invalid SensorsConfig definition: expected tag name 'Sensors' but was '${element.tagName}'`);
            }
            const adcCount = Number(element.getAttribute('adc-count'));
            if (!Number.isInteger(adcCount) || adcCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC count (must be a positive integer)');
                this.adcCount = 1;
            }
            else {
                this.adcCount = adcCount;
            }
            const ahrsCount = Number(element.getAttribute('ahrs-count'));
            if (!Number.isInteger(ahrsCount) || ahrsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS count (must be a positive integer)');
                this.ahrsCount = 1;
            }
            else {
                this.ahrsCount = ahrsCount;
            }
            const radarAltimeterCount = Number(element.getAttribute('radar-altimeter-count'));
            if (!Number.isInteger(radarAltimeterCount) || radarAltimeterCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized RA count (must be a positive integer)');
                this.radarAltimeterCount = 1;
            }
            else {
                this.radarAltimeterCount = radarAltimeterCount;
            }
            const gpsCount = Number(element.getAttribute('gps-count'));
            if (!Number.isInteger(gpsCount) || gpsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS count (must be a positive integer)');
                this.gpsCount = 1;
            }
            else {
                this.gpsCount = gpsCount;
            }
            this.adcDefinitions = this.parseAdcDefinitions(baseInstrument, element);
            this.ahrsDefinitions = this.parseAhrsDefinitions(baseInstrument, element);
            this.radarAltimeterDefinitions = this.parseRadarAltimeterDefinitions(baseInstrument, element);
            this.gpsDefinitions = this.parseGpsDefinitions(baseInstrument, element);
        }
    }
        /**
     * Parses ADC definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of ADC definitions defined by the configuration document element.
     */
    parseAdcDefinitions(baseInstrument, element) {
        const adcElements = element.querySelectorAll(':scope>Adc');
        const defs = [];
        for (const adcElement of adcElements) {
            const index = Number(adcElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.adcCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC index (must be an integer between 1 and the number of supported ADCs)');
                continue;
            }
            const altimeterIndex = Number(adcElement.getAttribute('altimeter'));
            if (!Number.isInteger(altimeterIndex) || altimeterIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized altimeter index (must be a positive integer)');
                continue;
            }
            const airspeedIndicatorIndex = Number(adcElement.getAttribute('airspeed-indicator'));
            if (!Number.isInteger(airspeedIndicatorIndex) || airspeedIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized airspeed indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = adcElement.querySelector(':scope>Electric');
            defs[index] = {
                altimeterIndex,
                airspeedIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    altimeterIndex: i,
                    airspeedIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses AHRS definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of AHRS definitions defined by the configuration document element.
     */
    parseAhrsDefinitions(baseInstrument, element) {
        const ahrsElements = element.querySelectorAll(':scope>Ahrs');
        const defs = [];
        for (const ahrsElement of ahrsElements) {
            const index = Number(ahrsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.ahrsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const attitudeIndicatorIndex = Number(ahrsElement.getAttribute('attitude-indicator'));
            if (!Number.isInteger(attitudeIndicatorIndex) || attitudeIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized attitude indicator index (must be a positive integer)');
                continue;
            }
            const directionIndicatorIndex = Number(ahrsElement.getAttribute('direction-indicator'));
            if (!Number.isInteger(directionIndicatorIndex) || directionIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized direction indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = ahrsElement.querySelector(':scope>Electric');
            defs[index] = {
                attitudeIndicatorIndex,
                directionIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    attitudeIndicatorIndex: i,
                    directionIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses a radar altimeter definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of RA definitions defined by the configuration document element.
     */
    parseRadarAltimeterDefinitions(baseInstrument, element) {
        const radarAltimeterElements = element.querySelectorAll(':scope>RadarAltimeter');
        const defs = [];
        for (const radarAltimeterElement of radarAltimeterElements) {
            const index = Number(radarAltimeterElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.radarAltimeterCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const electricLogicElement = radarAltimeterElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.radarAltimeterCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
    /**
     * Parses a GPS receiver definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of GPS definitions defined by the configuration document element.
     */
    parseGpsDefinitions(baseInstrument, element) {
        const gpsElements = element.querySelectorAll(':scope>Gps');
        const defs = [];
        for (const gpsElement of gpsElements) {
            const index = Number(gpsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.gpsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS index (must be an integer between 1 and the number of supported GPS)');
                continue;
            }
            const electricLogicElement = gpsElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.gpsCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
}

/**
 * A configuration object which defines options for G3000/5000 avionics systems.
 */
class AvionicsConfig {
    /**
     * Creates an AvionicsConfig from an XML configuration document.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param xmlConfig An XML configuration document.
     */
    constructor(baseInstrument, xmlConfig) {
        const root = xmlConfig.getElementsByTagName('PlaneHTMLConfig')[0];
        this.sensors = this.parseSensorsConfig(baseInstrument, root.querySelector(':scope>Sensors'));
    }
    /**
     * Parses a sensors configuration object from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns The sensors configuration defined by the configuration document element.
     */
    parseSensorsConfig(baseInstrument, element) {
        if (element !== null) {
            try {
                return new SensorsConfig(baseInstrument, element);
            }
            catch (e) {
                console.warn(e);
            }
        }
        return new SensorsConfig(baseInstrument, undefined);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/// <reference types="@microsoft/msfs-types/Pages/VCockpit/Core/VCockpit" />
/// <reference types="@microsoft/msfs-types/Pages/VCockpit/Instruments/Shared/BaseInstrument" />
/// <reference types="@microsoft/msfs-types/js/simvar" />
/// <reference types="@microsoft/msfs-types/js/netbingmap" />
/**
 * A Boeing 787-10 EFB BaseInstrument.
 */
class HSB78X_EFB extends FsBaseInstrument {
    /** @inheritdoc */
    get isInteractive() {
        return true;
    }
    /** @inheritdoc */
    constructInstrument() {
        return new WTB78xEfbInstrument(this, new AvionicsConfig(this, this.xmlConfig));
    }
    /** @inheritdoc */
    get templateID() {
        return 'HSB78X_EFB';
    }
}
registerInstrument('wtb78x-efb', HSB78X_EFB);

//registerInstrument("b777-efb", B777_EFB);
//# sourceMappingURL=B777_EFB.js.map